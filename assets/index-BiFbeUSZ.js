function R8(e, t) {
    for (var n = 0; n < t.length; n++) {
        const r = t[n];
        if (typeof r != "string" && !Array.isArray(r)) {
            for (const i in r)
                if (i !== "default" && !(i in e)) {
                    const o = Object.getOwnPropertyDescriptor(r, i);
                    o && Object.defineProperty(e, i, o.get ? o : {
                        enumerable: !0,
                        get: () => r[i]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
    }))
}(function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload")) return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
    new MutationObserver(i => {
        for (const o of i)
            if (o.type === "childList")
                for (const a of o.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && r(a)
    }).observe(document, {
        childList: !0,
        subtree: !0
    });

    function n(i) {
        const o = {};
        return i.integrity && (o.integrity = i.integrity), i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? o.credentials = "include" : i.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o
    }

    function r(i) {
        if (i.ep) return;
        i.ep = !0;
        const o = n(i);
        fetch(i.href, o)
    }
})();
var sMe = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};

function Fe(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}

function uMe(e) {
    if (e.__esModule) return e;
    var t = e.default;
    if (typeof t == "function") {
        var n = function r() {
            return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments)
        };
        n.prototype = t.prototype
    } else n = {};
    return Object.defineProperty(n, "__esModule", {
        value: !0
    }), Object.keys(e).forEach(function(r) {
        var i = Object.getOwnPropertyDescriptor(e, r);
        Object.defineProperty(n, r, i.get ? i : {
            enumerable: !0,
            get: function() {
                return e[r]
            }
        })
    }), n
}
var xN = {
        exports: {}
    },
    Ny = {},
    AN = {
        exports: {}
    },
    Se = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var th = Symbol.for("react.element"),
    j8 = Symbol.for("react.portal"),
    B8 = Symbol.for("react.fragment"),
    D8 = Symbol.for("react.strict_mode"),
    $8 = Symbol.for("react.profiler"),
    L8 = Symbol.for("react.provider"),
    F8 = Symbol.for("react.context"),
    U8 = Symbol.for("react.forward_ref"),
    H8 = Symbol.for("react.suspense"),
    V8 = Symbol.for("react.memo"),
    z8 = Symbol.for("react.lazy"),
    MT = Symbol.iterator;

function W8(e) {
    return e === null || typeof e != "object" ? null : (e = MT && e[MT] || e["@@iterator"], typeof e == "function" ? e : null)
}
var EN = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    },
    SN = Object.assign,
    _N = {};

function Bl(e, t, n) {
    this.props = e, this.context = t, this.refs = _N, this.updater = n || EN
}
Bl.prototype.isReactComponent = {};
Bl.prototype.setState = function(e, t) {
    if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, e, t, "setState")
};
Bl.prototype.forceUpdate = function(e) {
    this.updater.enqueueForceUpdate(this, e, "forceUpdate")
};

function TN() {}
TN.prototype = Bl.prototype;

function LA(e, t, n) {
    this.props = e, this.context = t, this.refs = _N, this.updater = n || EN
}
var FA = LA.prototype = new TN;
FA.constructor = LA;
SN(FA, Bl.prototype);
FA.isPureReactComponent = !0;
var NT = Array.isArray,
    PN = Object.prototype.hasOwnProperty,
    UA = {
        current: null
    },
    ON = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };

function kN(e, t, n) {
    var r, i = {},
        o = null,
        a = null;
    if (t != null)
        for (r in t.ref !== void 0 && (a = t.ref), t.key !== void 0 && (o = "" + t.key), t) PN.call(t, r) && !ON.hasOwnProperty(r) && (i[r] = t[r]);
    var s = arguments.length - 2;
    if (s === 1) i.children = n;
    else if (1 < s) {
        for (var u = Array(s), l = 0; l < s; l++) u[l] = arguments[l + 2];
        i.children = u
    }
    if (e && e.defaultProps)
        for (r in s = e.defaultProps, s) i[r] === void 0 && (i[r] = s[r]);
    return {
        $$typeof: th,
        type: e,
        key: o,
        ref: a,
        props: i,
        _owner: UA.current
    }
}

function G8(e, t) {
    return {
        $$typeof: th,
        type: e.type,
        key: t,
        ref: e.ref,
        props: e.props,
        _owner: e._owner
    }
}

function HA(e) {
    return typeof e == "object" && e !== null && e.$$typeof === th
}

function q8(e) {
    var t = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + e.replace(/[=:]/g, function(n) {
        return t[n]
    })
}
var RT = /\/+/g;

function S0(e, t) {
    return typeof e == "object" && e !== null && e.key != null ? q8("" + e.key) : t.toString(36)
}

function Tp(e, t, n, r, i) {
    var o = typeof e;
    (o === "undefined" || o === "boolean") && (e = null);
    var a = !1;
    if (e === null) a = !0;
    else switch (o) {
        case "string":
        case "number":
            a = !0;
            break;
        case "object":
            switch (e.$$typeof) {
                case th:
                case j8:
                    a = !0
            }
    }
    if (a) return a = e, i = i(a), e = r === "" ? "." + S0(a, 0) : r, NT(i) ? (n = "", e != null && (n = e.replace(RT, "$&/") + "/"), Tp(i, t, n, "", function(l) {
        return l
    })) : i != null && (HA(i) && (i = G8(i, n + (!i.key || a && a.key === i.key ? "" : ("" + i.key).replace(RT, "$&/") + "/") + e)), t.push(i)), 1;
    if (a = 0, r = r === "" ? "." : r + ":", NT(e))
        for (var s = 0; s < e.length; s++) {
            o = e[s];
            var u = r + S0(o, s);
            a += Tp(o, t, n, u, i)
        } else if (u = W8(e), typeof u == "function")
            for (e = u.call(e), s = 0; !(o = e.next()).done;) o = o.value, u = r + S0(o, s++), a += Tp(o, t, n, u, i);
        else if (o === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
    return a
}

function Nh(e, t, n) {
    if (e == null) return e;
    var r = [],
        i = 0;
    return Tp(e, r, "", "", function(o) {
        return t.call(n, o, i++)
    }), r
}

function K8(e) {
    if (e._status === -1) {
        var t = e._result;
        t = t(), t.then(function(n) {
            (e._status === 0 || e._status === -1) && (e._status = 1, e._result = n)
        }, function(n) {
            (e._status === 0 || e._status === -1) && (e._status = 2, e._result = n)
        }), e._status === -1 && (e._status = 0, e._result = t)
    }
    if (e._status === 1) return e._result.default;
    throw e._result
}
var wn = {
        current: null
    },
    Pp = {
        transition: null
    },
    Q8 = {
        ReactCurrentDispatcher: wn,
        ReactCurrentBatchConfig: Pp,
        ReactCurrentOwner: UA
    };

function CN() {
    throw Error("act(...) is not supported in production builds of React.")
}
Se.Children = {
    map: Nh,
    forEach: function(e, t, n) {
        Nh(e, function() {
            t.apply(this, arguments)
        }, n)
    },
    count: function(e) {
        var t = 0;
        return Nh(e, function() {
            t++
        }), t
    },
    toArray: function(e) {
        return Nh(e, function(t) {
            return t
        }) || []
    },
    only: function(e) {
        if (!HA(e)) throw Error("React.Children.only expected to receive a single React element child.");
        return e
    }
};
Se.Component = Bl;
Se.Fragment = B8;
Se.Profiler = $8;
Se.PureComponent = LA;
Se.StrictMode = D8;
Se.Suspense = H8;
Se.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Q8;
Se.act = CN;
Se.cloneElement = function(e, t, n) {
    if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
    var r = SN({}, e.props),
        i = e.key,
        o = e.ref,
        a = e._owner;
    if (t != null) {
        if (t.ref !== void 0 && (o = t.ref, a = UA.current), t.key !== void 0 && (i = "" + t.key), e.type && e.type.defaultProps) var s = e.type.defaultProps;
        for (u in t) PN.call(t, u) && !ON.hasOwnProperty(u) && (r[u] = t[u] === void 0 && s !== void 0 ? s[u] : t[u])
    }
    var u = arguments.length - 2;
    if (u === 1) r.children = n;
    else if (1 < u) {
        s = Array(u);
        for (var l = 0; l < u; l++) s[l] = arguments[l + 2];
        r.children = s
    }
    return {
        $$typeof: th,
        type: e.type,
        key: i,
        ref: o,
        props: r,
        _owner: a
    }
};
Se.createContext = function(e) {
    return e = {
        $$typeof: F8,
        _currentValue: e,
        _currentValue2: e,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    }, e.Provider = {
        $$typeof: L8,
        _context: e
    }, e.Consumer = e
};
Se.createElement = kN;
Se.createFactory = function(e) {
    var t = kN.bind(null, e);
    return t.type = e, t
};
Se.createRef = function() {
    return {
        current: null
    }
};
Se.forwardRef = function(e) {
    return {
        $$typeof: U8,
        render: e
    }
};
Se.isValidElement = HA;
Se.lazy = function(e) {
    return {
        $$typeof: z8,
        _payload: {
            _status: -1,
            _result: e
        },
        _init: K8
    }
};
Se.memo = function(e, t) {
    return {
        $$typeof: V8,
        type: e,
        compare: t === void 0 ? null : t
    }
};
Se.startTransition = function(e) {
    var t = Pp.transition;
    Pp.transition = {};
    try {
        e()
    } finally {
        Pp.transition = t
    }
};
Se.unstable_act = CN;
Se.useCallback = function(e, t) {
    return wn.current.useCallback(e, t)
};
Se.useContext = function(e) {
    return wn.current.useContext(e)
};
Se.useDebugValue = function() {};
Se.useDeferredValue = function(e) {
    return wn.current.useDeferredValue(e)
};
Se.useEffect = function(e, t) {
    return wn.current.useEffect(e, t)
};
Se.useId = function() {
    return wn.current.useId()
};
Se.useImperativeHandle = function(e, t, n) {
    return wn.current.useImperativeHandle(e, t, n)
};
Se.useInsertionEffect = function(e, t) {
    return wn.current.useInsertionEffect(e, t)
};
Se.useLayoutEffect = function(e, t) {
    return wn.current.useLayoutEffect(e, t)
};
Se.useMemo = function(e, t) {
    return wn.current.useMemo(e, t)
};
Se.useReducer = function(e, t, n) {
    return wn.current.useReducer(e, t, n)
};
Se.useRef = function(e) {
    return wn.current.useRef(e)
};
Se.useState = function(e) {
    return wn.current.useState(e)
};
Se.useSyncExternalStore = function(e, t, n) {
    return wn.current.useSyncExternalStore(e, t, n)
};
Se.useTransition = function() {
    return wn.current.useTransition()
};
Se.version = "18.3.1";
AN.exports = Se;
var S = AN.exports;
const R = Fe(S),
    wf = R8({
        __proto__: null,
        default: R
    }, [S]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Y8 = S,
    X8 = Symbol.for("react.element"),
    Z8 = Symbol.for("react.fragment"),
    J8 = Object.prototype.hasOwnProperty,
    eF = Y8.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    tF = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };

function IN(e, t, n) {
    var r, i = {},
        o = null,
        a = null;
    n !== void 0 && (o = "" + n), t.key !== void 0 && (o = "" + t.key), t.ref !== void 0 && (a = t.ref);
    for (r in t) J8.call(t, r) && !tF.hasOwnProperty(r) && (i[r] = t[r]);
    if (e && e.defaultProps)
        for (r in t = e.defaultProps, t) i[r] === void 0 && (i[r] = t[r]);
    return {
        $$typeof: X8,
        type: e,
        key: o,
        ref: a,
        props: i,
        _owner: eF.current
    }
}
Ny.Fragment = Z8;
Ny.jsx = IN;
Ny.jsxs = IN;
xN.exports = Ny;
var E = xN.exports,
    lw = {},
    MN = {
        exports: {}
    },
    qn = {},
    NN = {
        exports: {}
    },
    RN = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(e) {
    function t(N, D) {
        var $ = N.length;
        N.push(D);
        e: for (; 0 < $;) {
            var V = $ - 1 >>> 1,
                H = N[V];
            if (0 < i(H, D)) N[V] = D, N[$] = H, $ = V;
            else break e
        }
    }

    function n(N) {
        return N.length === 0 ? null : N[0]
    }

    function r(N) {
        if (N.length === 0) return null;
        var D = N[0],
            $ = N.pop();
        if ($ !== D) {
            N[0] = $;
            e: for (var V = 0, H = N.length, Q = H >>> 1; V < Q;) {
                var X = 2 * (V + 1) - 1,
                    ve = N[X],
                    De = X + 1,
                    ot = N[De];
                if (0 > i(ve, $)) De < H && 0 > i(ot, ve) ? (N[V] = ot, N[De] = $, V = De) : (N[V] = ve, N[X] = $, V = X);
                else if (De < H && 0 > i(ot, $)) N[V] = ot, N[De] = $, V = De;
                else break e
            }
        }
        return D
    }

    function i(N, D) {
        var $ = N.sortIndex - D.sortIndex;
        return $ !== 0 ? $ : N.id - D.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var o = performance;
        e.unstable_now = function() {
            return o.now()
        }
    } else {
        var a = Date,
            s = a.now();
        e.unstable_now = function() {
            return a.now() - s
        }
    }
    var u = [],
        l = [],
        c = 1,
        f = null,
        d = 3,
        h = !1,
        m = !1,
        p = !1,
        y = typeof setTimeout == "function" ? setTimeout : null,
        g = typeof clearTimeout == "function" ? clearTimeout : null,
        b = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

    function v(N) {
        for (var D = n(l); D !== null;) {
            if (D.callback === null) r(l);
            else if (D.startTime <= N) r(l), D.sortIndex = D.expirationTime, t(u, D);
            else break;
            D = n(l)
        }
    }

    function A(N) {
        if (p = !1, v(N), !m)
            if (n(u) !== null) m = !0, C(w);
            else {
                var D = n(l);
                D !== null && j(A, D.startTime - N)
            }
    }

    function w(N, D) {
        m = !1, p && (p = !1, g(_), _ = -1), h = !0;
        var $ = d;
        try {
            for (v(D), f = n(u); f !== null && (!(f.expirationTime > D) || N && !I());) {
                var V = f.callback;
                if (typeof V == "function") {
                    f.callback = null, d = f.priorityLevel;
                    var H = V(f.expirationTime <= D);
                    D = e.unstable_now(), typeof H == "function" ? f.callback = H : f === n(u) && r(u), v(D)
                } else r(u);
                f = n(u)
            }
            if (f !== null) var Q = !0;
            else {
                var X = n(l);
                X !== null && j(A, X.startTime - D), Q = !1
            }
            return Q
        } finally {
            f = null, d = $, h = !1
        }
    }
    var x = !1,
        T = null,
        _ = -1,
        O = 5,
        k = -1;

    function I() {
        return !(e.unstable_now() - k < O)
    }

    function M() {
        if (T !== null) {
            var N = e.unstable_now();
            k = N;
            var D = !0;
            try {
                D = T(!0, N)
            } finally {
                D ? B() : (x = !1, T = null)
            }
        } else x = !1
    }
    var B;
    if (typeof b == "function") B = function() {
        b(M)
    };
    else if (typeof MessageChannel < "u") {
        var L = new MessageChannel,
            P = L.port2;
        L.port1.onmessage = M, B = function() {
            P.postMessage(null)
        }
    } else B = function() {
        y(M, 0)
    };

    function C(N) {
        T = N, x || (x = !0, B())
    }

    function j(N, D) {
        _ = y(function() {
            N(e.unstable_now())
        }, D)
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(N) {
        N.callback = null
    }, e.unstable_continueExecution = function() {
        m || h || (m = !0, C(w))
    }, e.unstable_forceFrameRate = function(N) {
        0 > N || 125 < N ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : O = 0 < N ? Math.floor(1e3 / N) : 5
    }, e.unstable_getCurrentPriorityLevel = function() {
        return d
    }, e.unstable_getFirstCallbackNode = function() {
        return n(u)
    }, e.unstable_next = function(N) {
        switch (d) {
            case 1:
            case 2:
            case 3:
                var D = 3;
                break;
            default:
                D = d
        }
        var $ = d;
        d = D;
        try {
            return N()
        } finally {
            d = $
        }
    }, e.unstable_pauseExecution = function() {}, e.unstable_requestPaint = function() {}, e.unstable_runWithPriority = function(N, D) {
        switch (N) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                N = 3
        }
        var $ = d;
        d = N;
        try {
            return D()
        } finally {
            d = $
        }
    }, e.unstable_scheduleCallback = function(N, D, $) {
        var V = e.unstable_now();
        switch (typeof $ == "object" && $ !== null ? ($ = $.delay, $ = typeof $ == "number" && 0 < $ ? V + $ : V) : $ = V, N) {
            case 1:
                var H = -1;
                break;
            case 2:
                H = 250;
                break;
            case 5:
                H = 1073741823;
                break;
            case 4:
                H = 1e4;
                break;
            default:
                H = 5e3
        }
        return H = $ + H, N = {
            id: c++,
            callback: D,
            priorityLevel: N,
            startTime: $,
            expirationTime: H,
            sortIndex: -1
        }, $ > V ? (N.sortIndex = $, t(l, N), n(u) === null && N === n(l) && (p ? (g(_), _ = -1) : p = !0, j(A, $ - V))) : (N.sortIndex = H, t(u, N), m || h || (m = !0, C(w))), N
    }, e.unstable_shouldYield = I, e.unstable_wrapCallback = function(N) {
        var D = d;
        return function() {
            var $ = d;
            d = D;
            try {
                return N.apply(this, arguments)
            } finally {
                d = $
            }
        }
    }
})(RN);
NN.exports = RN;
var nF = NN.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rF = S,
    Vn = nF;

function G(e) {
    for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++) t += "&args[]=" + encodeURIComponent(arguments[n]);
    return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var jN = new Set,
    xf = {};

function Ms(e, t) {
    Uu(e, t), Uu(e + "Capture", t)
}

function Uu(e, t) {
    for (xf[e] = t, e = 0; e < t.length; e++) jN.add(t[e])
}
var Qi = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
    cw = Object.prototype.hasOwnProperty,
    iF = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    jT = {},
    BT = {};

function oF(e) {
    return cw.call(BT, e) ? !0 : cw.call(jT, e) ? !1 : iF.test(e) ? BT[e] = !0 : (jT[e] = !0, !1)
}

function aF(e, t, n, r) {
    if (n !== null && n.type === 0) return !1;
    switch (typeof t) {
        case "function":
        case "symbol":
            return !0;
        case "boolean":
            return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-");
        default:
            return !1
    }
}

function sF(e, t, n, r) {
    if (t === null || typeof t > "u" || aF(e, t, n, r)) return !0;
    if (r) return !1;
    if (n !== null) switch (n.type) {
        case 3:
            return !t;
        case 4:
            return t === !1;
        case 5:
            return isNaN(t);
        case 6:
            return isNaN(t) || 1 > t
    }
    return !1
}

function xn(e, t, n, r, i, o, a) {
    this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = o, this.removeEmptyString = a
}
var Qt = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e) {
    Qt[e] = new xn(e, 0, !1, e, null, !1, !1)
});
[
    ["acceptCharset", "accept-charset"],
    ["className", "class"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"]
].forEach(function(e) {
    var t = e[0];
    Qt[t] = new xn(t, 1, !1, e[1], null, !1, !1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
    Qt[e] = new xn(e, 2, !1, e.toLowerCase(), null, !1, !1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
    Qt[e] = new xn(e, 2, !1, e, null, !1, !1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e) {
    Qt[e] = new xn(e, 3, !1, e.toLowerCase(), null, !1, !1)
});
["checked", "multiple", "muted", "selected"].forEach(function(e) {
    Qt[e] = new xn(e, 3, !0, e, null, !1, !1)
});
["capture", "download"].forEach(function(e) {
    Qt[e] = new xn(e, 4, !1, e, null, !1, !1)
});
["cols", "rows", "size", "span"].forEach(function(e) {
    Qt[e] = new xn(e, 6, !1, e, null, !1, !1)
});
["rowSpan", "start"].forEach(function(e) {
    Qt[e] = new xn(e, 5, !1, e.toLowerCase(), null, !1, !1)
});
var VA = /[\-:]([a-z])/g;

function zA(e) {
    return e[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e) {
    var t = e.replace(VA, zA);
    Qt[t] = new xn(t, 1, !1, e, null, !1, !1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e) {
    var t = e.replace(VA, zA);
    Qt[t] = new xn(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(e) {
    var t = e.replace(VA, zA);
    Qt[t] = new xn(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1)
});
["tabIndex", "crossOrigin"].forEach(function(e) {
    Qt[e] = new xn(e, 1, !1, e.toLowerCase(), null, !1, !1)
});
Qt.xlinkHref = new xn("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(e) {
    Qt[e] = new xn(e, 1, !1, e.toLowerCase(), null, !0, !0)
});

function WA(e, t, n, r) {
    var i = Qt.hasOwnProperty(t) ? Qt[t] : null;
    (i !== null ? i.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (sF(t, n, i, r) && (n = null), r || i === null ? oF(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = n === null ? i.type === 3 ? !1 : "" : n : (t = i.attributeName, r = i.attributeNamespace, n === null ? e.removeAttribute(t) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
}
var co = rF.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    Rh = Symbol.for("react.element"),
    iu = Symbol.for("react.portal"),
    ou = Symbol.for("react.fragment"),
    GA = Symbol.for("react.strict_mode"),
    fw = Symbol.for("react.profiler"),
    BN = Symbol.for("react.provider"),
    DN = Symbol.for("react.context"),
    qA = Symbol.for("react.forward_ref"),
    dw = Symbol.for("react.suspense"),
    hw = Symbol.for("react.suspense_list"),
    KA = Symbol.for("react.memo"),
    ko = Symbol.for("react.lazy"),
    $N = Symbol.for("react.offscreen"),
    DT = Symbol.iterator;

function cc(e) {
    return e === null || typeof e != "object" ? null : (e = DT && e[DT] || e["@@iterator"], typeof e == "function" ? e : null)
}
var dt = Object.assign,
    _0;

function Lc(e) {
    if (_0 === void 0) try {
        throw Error()
    } catch (n) {
        var t = n.stack.trim().match(/\n( *(at )?)/);
        _0 = t && t[1] || ""
    }
    return `
` + _0 + e
}
var T0 = !1;

function P0(e, t) {
    if (!e || T0) return "";
    T0 = !0;
    var n = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (t)
            if (t = function() {
                    throw Error()
                }, Object.defineProperty(t.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }), typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(t, [])
                } catch (l) {
                    var r = l
                }
                Reflect.construct(e, [], t)
            } else {
                try {
                    t.call()
                } catch (l) {
                    r = l
                }
                e.call(t.prototype)
            }
        else {
            try {
                throw Error()
            } catch (l) {
                r = l
            }
            e()
        }
    } catch (l) {
        if (l && r && typeof l.stack == "string") {
            for (var i = l.stack.split(`
`), o = r.stack.split(`
`), a = i.length - 1, s = o.length - 1; 1 <= a && 0 <= s && i[a] !== o[s];) s--;
            for (; 1 <= a && 0 <= s; a--, s--)
                if (i[a] !== o[s]) {
                    if (a !== 1 || s !== 1)
                        do
                            if (a--, s--, 0 > s || i[a] !== o[s]) {
                                var u = `
` + i[a].replace(" at new ", " at ");
                                return e.displayName && u.includes("<anonymous>") && (u = u.replace("<anonymous>", e.displayName)), u
                            }
                    while (1 <= a && 0 <= s);
                    break
                }
        }
    } finally {
        T0 = !1, Error.prepareStackTrace = n
    }
    return (e = e ? e.displayName || e.name : "") ? Lc(e) : ""
}

function uF(e) {
    switch (e.tag) {
        case 5:
            return Lc(e.type);
        case 16:
            return Lc("Lazy");
        case 13:
            return Lc("Suspense");
        case 19:
            return Lc("SuspenseList");
        case 0:
        case 2:
        case 15:
            return e = P0(e.type, !1), e;
        case 11:
            return e = P0(e.type.render, !1), e;
        case 1:
            return e = P0(e.type, !0), e;
        default:
            return ""
    }
}

function pw(e) {
    if (e == null) return null;
    if (typeof e == "function") return e.displayName || e.name || null;
    if (typeof e == "string") return e;
    switch (e) {
        case ou:
            return "Fragment";
        case iu:
            return "Portal";
        case fw:
            return "Profiler";
        case GA:
            return "StrictMode";
        case dw:
            return "Suspense";
        case hw:
            return "SuspenseList"
    }
    if (typeof e == "object") switch (e.$$typeof) {
        case DN:
            return (e.displayName || "Context") + ".Consumer";
        case BN:
            return (e._context.displayName || "Context") + ".Provider";
        case qA:
            var t = e.render;
            return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
        case KA:
            return t = e.displayName || null, t !== null ? t : pw(e.type) || "Memo";
        case ko:
            t = e._payload, e = e._init;
            try {
                return pw(e(t))
            } catch {}
    }
    return null
}

function lF(e) {
    var t = e.type;
    switch (e.tag) {
        case 24:
            return "Cache";
        case 9:
            return (t.displayName || "Context") + ".Consumer";
        case 10:
            return (t._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return t;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return pw(t);
        case 8:
            return t === GA ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof t == "function") return t.displayName || t.name || null;
            if (typeof t == "string") return t
    }
    return null
}

function ea(e) {
    switch (typeof e) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return e;
        case "object":
            return e;
        default:
            return ""
    }
}

function LN(e) {
    var t = e.type;
    return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio")
}

function cF(e) {
    var t = LN(e) ? "checked" : "value",
        n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
        r = "" + e[t];
    if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
        var i = n.get,
            o = n.set;
        return Object.defineProperty(e, t, {
            configurable: !0,
            get: function() {
                return i.call(this)
            },
            set: function(a) {
                r = "" + a, o.call(this, a)
            }
        }), Object.defineProperty(e, t, {
            enumerable: n.enumerable
        }), {
            getValue: function() {
                return r
            },
            setValue: function(a) {
                r = "" + a
            },
            stopTracking: function() {
                e._valueTracker = null, delete e[t]
            }
        }
    }
}

function jh(e) {
    e._valueTracker || (e._valueTracker = cF(e))
}

function FN(e) {
    if (!e) return !1;
    var t = e._valueTracker;
    if (!t) return !0;
    var n = t.getValue(),
        r = "";
    return e && (r = LN(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n ? (t.setValue(e), !0) : !1
}

function em(e) {
    if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null;
    try {
        return e.activeElement || e.body
    } catch {
        return e.body
    }
}

function mw(e, t) {
    var n = t.checked;
    return dt({}, t, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: n ? ? e._wrapperState.initialChecked
    })
}

function $T(e, t) {
    var n = t.defaultValue == null ? "" : t.defaultValue,
        r = t.checked != null ? t.checked : t.defaultChecked;
    n = ea(t.value != null ? t.value : n), e._wrapperState = {
        initialChecked: r,
        initialValue: n,
        controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null
    }
}

function UN(e, t) {
    t = t.checked, t != null && WA(e, "checked", t, !1)
}

function gw(e, t) {
    UN(e, t);
    var n = ea(t.value),
        r = t.type;
    if (n != null) r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n);
    else if (r === "submit" || r === "reset") {
        e.removeAttribute("value");
        return
    }
    t.hasOwnProperty("value") ? yw(e, t.type, n) : t.hasOwnProperty("defaultValue") && yw(e, t.type, ea(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked)
}

function LT(e, t, n) {
    if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
        var r = t.type;
        if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null)) return;
        t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t
    }
    n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n)
}

function yw(e, t, n) {
    (t !== "number" || em(e.ownerDocument) !== e) && (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n))
}
var Fc = Array.isArray;

function Pu(e, t, n, r) {
    if (e = e.options, t) {
        t = {};
        for (var i = 0; i < n.length; i++) t["$" + n[i]] = !0;
        for (n = 0; n < e.length; n++) i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0)
    } else {
        for (n = "" + ea(n), t = null, i = 0; i < e.length; i++) {
            if (e[i].value === n) {
                e[i].selected = !0, r && (e[i].defaultSelected = !0);
                return
            }
            t !== null || e[i].disabled || (t = e[i])
        }
        t !== null && (t.selected = !0)
    }
}

function vw(e, t) {
    if (t.dangerouslySetInnerHTML != null) throw Error(G(91));
    return dt({}, t, {
        value: void 0,
        defaultValue: void 0,
        children: "" + e._wrapperState.initialValue
    })
}

function FT(e, t) {
    var n = t.value;
    if (n == null) {
        if (n = t.children, t = t.defaultValue, n != null) {
            if (t != null) throw Error(G(92));
            if (Fc(n)) {
                if (1 < n.length) throw Error(G(93));
                n = n[0]
            }
            t = n
        }
        t == null && (t = ""), n = t
    }
    e._wrapperState = {
        initialValue: ea(n)
    }
}

function HN(e, t) {
    var n = ea(t.value),
        r = ea(t.defaultValue);
    n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), r != null && (e.defaultValue = "" + r)
}

function UT(e) {
    var t = e.textContent;
    t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t)
}

function VN(e) {
    switch (e) {
        case "svg":
            return "http://www.w3.org/2000/svg";
        case "math":
            return "http://www.w3.org/1998/Math/MathML";
        default:
            return "http://www.w3.org/1999/xhtml"
    }
}

function bw(e, t) {
    return e == null || e === "http://www.w3.org/1999/xhtml" ? VN(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e
}
var Bh, zN = function(e) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(t, n, r, i) {
        MSApp.execUnsafeLocalFunction(function() {
            return e(t, n, r, i)
        })
    } : e
}(function(e, t) {
    if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t;
    else {
        for (Bh = Bh || document.createElement("div"), Bh.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = Bh.firstChild; e.firstChild;) e.removeChild(e.firstChild);
        for (; t.firstChild;) e.appendChild(t.firstChild)
    }
});

function Af(e, t) {
    if (t) {
        var n = e.firstChild;
        if (n && n === e.lastChild && n.nodeType === 3) {
            n.nodeValue = t;
            return
        }
    }
    e.textContent = t
}
var Yc = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    },
    fF = ["Webkit", "ms", "Moz", "O"];
Object.keys(Yc).forEach(function(e) {
    fF.forEach(function(t) {
        t = t + e.charAt(0).toUpperCase() + e.substring(1), Yc[t] = Yc[e]
    })
});

function WN(e, t, n) {
    return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || Yc.hasOwnProperty(e) && Yc[e] ? ("" + t).trim() : t + "px"
}

function GN(e, t) {
    e = e.style;
    for (var n in t)
        if (t.hasOwnProperty(n)) {
            var r = n.indexOf("--") === 0,
                i = WN(n, t[n], r);
            n === "float" && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i
        }
}
var dF = dt({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});

function ww(e, t) {
    if (t) {
        if (dF[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(G(137, e));
        if (t.dangerouslySetInnerHTML != null) {
            if (t.children != null) throw Error(G(60));
            if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(G(61))
        }
        if (t.style != null && typeof t.style != "object") throw Error(G(62))
    }
}

function xw(e, t) {
    if (e.indexOf("-") === -1) return typeof t.is == "string";
    switch (e) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
    }
}
var Aw = null;

function QA(e) {
    return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e
}
var Ew = null,
    Ou = null,
    ku = null;

function HT(e) {
    if (e = ih(e)) {
        if (typeof Ew != "function") throw Error(G(280));
        var t = e.stateNode;
        t && (t = $y(t), Ew(e.stateNode, e.type, t))
    }
}

function qN(e) {
    Ou ? ku ? ku.push(e) : ku = [e] : Ou = e
}

function KN() {
    if (Ou) {
        var e = Ou,
            t = ku;
        if (ku = Ou = null, HT(e), t)
            for (e = 0; e < t.length; e++) HT(t[e])
    }
}

function QN(e, t) {
    return e(t)
}

function YN() {}
var O0 = !1;

function XN(e, t, n) {
    if (O0) return e(t, n);
    O0 = !0;
    try {
        return QN(e, t, n)
    } finally {
        O0 = !1, (Ou !== null || ku !== null) && (YN(), KN())
    }
}

function Ef(e, t) {
    var n = e.stateNode;
    if (n === null) return null;
    var r = $y(n);
    if (r === null) return null;
    n = r[t];
    e: switch (t) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r;
            break e;
        default:
            e = !1
    }
    if (e) return null;
    if (n && typeof n != "function") throw Error(G(231, t, typeof n));
    return n
}
var Sw = !1;
if (Qi) try {
    var fc = {};
    Object.defineProperty(fc, "passive", {
        get: function() {
            Sw = !0
        }
    }), window.addEventListener("test", fc, fc), window.removeEventListener("test", fc, fc)
} catch {
    Sw = !1
}

function hF(e, t, n, r, i, o, a, s, u) {
    var l = Array.prototype.slice.call(arguments, 3);
    try {
        t.apply(n, l)
    } catch (c) {
        this.onError(c)
    }
}
var Xc = !1,
    tm = null,
    nm = !1,
    _w = null,
    pF = {
        onError: function(e) {
            Xc = !0, tm = e
        }
    };

function mF(e, t, n, r, i, o, a, s, u) {
    Xc = !1, tm = null, hF.apply(pF, arguments)
}

function gF(e, t, n, r, i, o, a, s, u) {
    if (mF.apply(this, arguments), Xc) {
        if (Xc) {
            var l = tm;
            Xc = !1, tm = null
        } else throw Error(G(198));
        nm || (nm = !0, _w = l)
    }
}

function Ns(e) {
    var t = e,
        n = e;
    if (e.alternate)
        for (; t.return;) t = t.return;
    else {
        e = t;
        do t = e, t.flags & 4098 && (n = t.return), e = t.return; while (e)
    }
    return t.tag === 3 ? n : null
}

function ZN(e) {
    if (e.tag === 13) {
        var t = e.memoizedState;
        if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated
    }
    return null
}

function VT(e) {
    if (Ns(e) !== e) throw Error(G(188))
}

function yF(e) {
    var t = e.alternate;
    if (!t) {
        if (t = Ns(e), t === null) throw Error(G(188));
        return t !== e ? null : e
    }
    for (var n = e, r = t;;) {
        var i = n.return;
        if (i === null) break;
        var o = i.alternate;
        if (o === null) {
            if (r = i.return, r !== null) {
                n = r;
                continue
            }
            break
        }
        if (i.child === o.child) {
            for (o = i.child; o;) {
                if (o === n) return VT(i), e;
                if (o === r) return VT(i), t;
                o = o.sibling
            }
            throw Error(G(188))
        }
        if (n.return !== r.return) n = i, r = o;
        else {
            for (var a = !1, s = i.child; s;) {
                if (s === n) {
                    a = !0, n = i, r = o;
                    break
                }
                if (s === r) {
                    a = !0, r = i, n = o;
                    break
                }
                s = s.sibling
            }
            if (!a) {
                for (s = o.child; s;) {
                    if (s === n) {
                        a = !0, n = o, r = i;
                        break
                    }
                    if (s === r) {
                        a = !0, r = o, n = i;
                        break
                    }
                    s = s.sibling
                }
                if (!a) throw Error(G(189))
            }
        }
        if (n.alternate !== r) throw Error(G(190))
    }
    if (n.tag !== 3) throw Error(G(188));
    return n.stateNode.current === n ? e : t
}

function JN(e) {
    return e = yF(e), e !== null ? eR(e) : null
}

function eR(e) {
    if (e.tag === 5 || e.tag === 6) return e;
    for (e = e.child; e !== null;) {
        var t = eR(e);
        if (t !== null) return t;
        e = e.sibling
    }
    return null
}
var tR = Vn.unstable_scheduleCallback,
    zT = Vn.unstable_cancelCallback,
    vF = Vn.unstable_shouldYield,
    bF = Vn.unstable_requestPaint,
    xt = Vn.unstable_now,
    wF = Vn.unstable_getCurrentPriorityLevel,
    YA = Vn.unstable_ImmediatePriority,
    nR = Vn.unstable_UserBlockingPriority,
    rm = Vn.unstable_NormalPriority,
    xF = Vn.unstable_LowPriority,
    rR = Vn.unstable_IdlePriority,
    Ry = null,
    oi = null;

function AF(e) {
    if (oi && typeof oi.onCommitFiberRoot == "function") try {
        oi.onCommitFiberRoot(Ry, e, void 0, (e.current.flags & 128) === 128)
    } catch {}
}
var Nr = Math.clz32 ? Math.clz32 : _F,
    EF = Math.log,
    SF = Math.LN2;

function _F(e) {
    return e >>>= 0, e === 0 ? 32 : 31 - (EF(e) / SF | 0) | 0
}
var Dh = 64,
    $h = 4194304;

function Uc(e) {
    switch (e & -e) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return e & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return e & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return e
    }
}

function im(e, t) {
    var n = e.pendingLanes;
    if (n === 0) return 0;
    var r = 0,
        i = e.suspendedLanes,
        o = e.pingedLanes,
        a = n & 268435455;
    if (a !== 0) {
        var s = a & ~i;
        s !== 0 ? r = Uc(s) : (o &= a, o !== 0 && (r = Uc(o)))
    } else a = n & ~i, a !== 0 ? r = Uc(a) : o !== 0 && (r = Uc(o));
    if (r === 0) return 0;
    if (t !== 0 && t !== r && !(t & i) && (i = r & -r, o = t & -t, i >= o || i === 16 && (o & 4194240) !== 0)) return t;
    if (r & 4 && (r |= n & 16), t = e.entangledLanes, t !== 0)
        for (e = e.entanglements, t &= r; 0 < t;) n = 31 - Nr(t), i = 1 << n, r |= e[n], t &= ~i;
    return r
}

function TF(e, t) {
    switch (e) {
        case 1:
        case 2:
        case 4:
            return t + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return t + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
    }
}

function PF(e, t) {
    for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o;) {
        var a = 31 - Nr(o),
            s = 1 << a,
            u = i[a];
        u === -1 ? (!(s & n) || s & r) && (i[a] = TF(s, t)) : u <= t && (e.expiredLanes |= s), o &= ~s
    }
}

function Tw(e) {
    return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0
}

function iR() {
    var e = Dh;
    return Dh <<= 1, !(Dh & 4194240) && (Dh = 64), e
}

function k0(e) {
    for (var t = [], n = 0; 31 > n; n++) t.push(e);
    return t
}

function nh(e, t, n) {
    e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - Nr(t), e[t] = n
}

function OF(e, t) {
    var n = e.pendingLanes & ~t;
    e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements;
    var r = e.eventTimes;
    for (e = e.expirationTimes; 0 < n;) {
        var i = 31 - Nr(n),
            o = 1 << i;
        t[i] = 0, r[i] = -1, e[i] = -1, n &= ~o
    }
}

function XA(e, t) {
    var n = e.entangledLanes |= t;
    for (e = e.entanglements; n;) {
        var r = 31 - Nr(n),
            i = 1 << r;
        i & t | e[r] & t && (e[r] |= t), n &= ~i
    }
}
var Le = 0;

function oR(e) {
    return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1
}
var aR, ZA, sR, uR, lR, Pw = !1,
    Lh = [],
    Ho = null,
    Vo = null,
    zo = null,
    Sf = new Map,
    _f = new Map,
    Mo = [],
    kF = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

function WT(e, t) {
    switch (e) {
        case "focusin":
        case "focusout":
            Ho = null;
            break;
        case "dragenter":
        case "dragleave":
            Vo = null;
            break;
        case "mouseover":
        case "mouseout":
            zo = null;
            break;
        case "pointerover":
        case "pointerout":
            Sf.delete(t.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            _f.delete(t.pointerId)
    }
}

function dc(e, t, n, r, i, o) {
    return e === null || e.nativeEvent !== o ? (e = {
        blockedOn: t,
        domEventName: n,
        eventSystemFlags: r,
        nativeEvent: o,
        targetContainers: [i]
    }, t !== null && (t = ih(t), t !== null && ZA(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, i !== null && t.indexOf(i) === -1 && t.push(i), e)
}

function CF(e, t, n, r, i) {
    switch (t) {
        case "focusin":
            return Ho = dc(Ho, e, t, n, r, i), !0;
        case "dragenter":
            return Vo = dc(Vo, e, t, n, r, i), !0;
        case "mouseover":
            return zo = dc(zo, e, t, n, r, i), !0;
        case "pointerover":
            var o = i.pointerId;
            return Sf.set(o, dc(Sf.get(o) || null, e, t, n, r, i)), !0;
        case "gotpointercapture":
            return o = i.pointerId, _f.set(o, dc(_f.get(o) || null, e, t, n, r, i)), !0
    }
    return !1
}

function cR(e) {
    var t = Da(e.target);
    if (t !== null) {
        var n = Ns(t);
        if (n !== null) {
            if (t = n.tag, t === 13) {
                if (t = ZN(n), t !== null) {
                    e.blockedOn = t, lR(e.priority, function() {
                        sR(n)
                    });
                    return
                }
            } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
                e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
                return
            }
        }
    }
    e.blockedOn = null
}

function Op(e) {
    if (e.blockedOn !== null) return !1;
    for (var t = e.targetContainers; 0 < t.length;) {
        var n = Ow(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
        if (n === null) {
            n = e.nativeEvent;
            var r = new n.constructor(n.type, n);
            Aw = r, n.target.dispatchEvent(r), Aw = null
        } else return t = ih(n), t !== null && ZA(t), e.blockedOn = n, !1;
        t.shift()
    }
    return !0
}

function GT(e, t, n) {
    Op(e) && n.delete(t)
}

function IF() {
    Pw = !1, Ho !== null && Op(Ho) && (Ho = null), Vo !== null && Op(Vo) && (Vo = null), zo !== null && Op(zo) && (zo = null), Sf.forEach(GT), _f.forEach(GT)
}

function hc(e, t) {
    e.blockedOn === t && (e.blockedOn = null, Pw || (Pw = !0, Vn.unstable_scheduleCallback(Vn.unstable_NormalPriority, IF)))
}

function Tf(e) {
    function t(i) {
        return hc(i, e)
    }
    if (0 < Lh.length) {
        hc(Lh[0], e);
        for (var n = 1; n < Lh.length; n++) {
            var r = Lh[n];
            r.blockedOn === e && (r.blockedOn = null)
        }
    }
    for (Ho !== null && hc(Ho, e), Vo !== null && hc(Vo, e), zo !== null && hc(zo, e), Sf.forEach(t), _f.forEach(t), n = 0; n < Mo.length; n++) r = Mo[n], r.blockedOn === e && (r.blockedOn = null);
    for (; 0 < Mo.length && (n = Mo[0], n.blockedOn === null);) cR(n), n.blockedOn === null && Mo.shift()
}
var Cu = co.ReactCurrentBatchConfig,
    om = !0;

function MF(e, t, n, r) {
    var i = Le,
        o = Cu.transition;
    Cu.transition = null;
    try {
        Le = 1, JA(e, t, n, r)
    } finally {
        Le = i, Cu.transition = o
    }
}

function NF(e, t, n, r) {
    var i = Le,
        o = Cu.transition;
    Cu.transition = null;
    try {
        Le = 4, JA(e, t, n, r)
    } finally {
        Le = i, Cu.transition = o
    }
}

function JA(e, t, n, r) {
    if (om) {
        var i = Ow(e, t, n, r);
        if (i === null) L0(e, t, r, am, n), WT(e, r);
        else if (CF(i, e, t, n, r)) r.stopPropagation();
        else if (WT(e, r), t & 4 && -1 < kF.indexOf(e)) {
            for (; i !== null;) {
                var o = ih(i);
                if (o !== null && aR(o), o = Ow(e, t, n, r), o === null && L0(e, t, r, am, n), o === i) break;
                i = o
            }
            i !== null && r.stopPropagation()
        } else L0(e, t, r, null, n)
    }
}
var am = null;

function Ow(e, t, n, r) {
    if (am = null, e = QA(r), e = Da(e), e !== null)
        if (t = Ns(e), t === null) e = null;
        else if (n = t.tag, n === 13) {
        if (e = ZN(t), e !== null) return e;
        e = null
    } else if (n === 3) {
        if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null;
        e = null
    } else t !== e && (e = null);
    return am = e, null
}

function fR(e) {
    switch (e) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 4;
        case "message":
            switch (wF()) {
                case YA:
                    return 1;
                case nR:
                    return 4;
                case rm:
                case xF:
                    return 16;
                case rR:
                    return 536870912;
                default:
                    return 16
            }
        default:
            return 16
    }
}
var Bo = null,
    eE = null,
    kp = null;

function dR() {
    if (kp) return kp;
    var e, t = eE,
        n = t.length,
        r, i = "value" in Bo ? Bo.value : Bo.textContent,
        o = i.length;
    for (e = 0; e < n && t[e] === i[e]; e++);
    var a = n - e;
    for (r = 1; r <= a && t[n - r] === i[o - r]; r++);
    return kp = i.slice(e, 1 < r ? 1 - r : void 0)
}

function Cp(e) {
    var t = e.keyCode;
    return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0
}

function Fh() {
    return !0
}

function qT() {
    return !1
}

function Kn(e) {
    function t(n, r, i, o, a) {
        this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = o, this.target = a, this.currentTarget = null;
        for (var s in e) e.hasOwnProperty(s) && (n = e[s], this[s] = n ? n(o) : o[s]);
        return this.isDefaultPrevented = (o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1) ? Fh : qT, this.isPropagationStopped = qT, this
    }
    return dt(t.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var n = this.nativeEvent;
            n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = Fh)
        },
        stopPropagation: function() {
            var n = this.nativeEvent;
            n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = Fh)
        },
        persist: function() {},
        isPersistent: Fh
    }), t
}
var Dl = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(e) {
            return e.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    },
    tE = Kn(Dl),
    rh = dt({}, Dl, {
        view: 0,
        detail: 0
    }),
    RF = Kn(rh),
    C0, I0, pc, jy = dt({}, rh, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: nE,
        button: 0,
        buttons: 0,
        relatedTarget: function(e) {
            return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
        },
        movementX: function(e) {
            return "movementX" in e ? e.movementX : (e !== pc && (pc && e.type === "mousemove" ? (C0 = e.screenX - pc.screenX, I0 = e.screenY - pc.screenY) : I0 = C0 = 0, pc = e), C0)
        },
        movementY: function(e) {
            return "movementY" in e ? e.movementY : I0
        }
    }),
    KT = Kn(jy),
    jF = dt({}, jy, {
        dataTransfer: 0
    }),
    BF = Kn(jF),
    DF = dt({}, rh, {
        relatedTarget: 0
    }),
    M0 = Kn(DF),
    $F = dt({}, Dl, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }),
    LF = Kn($F),
    FF = dt({}, Dl, {
        clipboardData: function(e) {
            return "clipboardData" in e ? e.clipboardData : window.clipboardData
        }
    }),
    UF = Kn(FF),
    HF = dt({}, Dl, {
        data: 0
    }),
    QT = Kn(HF),
    VF = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    },
    zF = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    },
    WF = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };

function GF(e) {
    var t = this.nativeEvent;
    return t.getModifierState ? t.getModifierState(e) : (e = WF[e]) ? !!t[e] : !1
}

function nE() {
    return GF
}
var qF = dt({}, rh, {
        key: function(e) {
            if (e.key) {
                var t = VF[e.key] || e.key;
                if (t !== "Unidentified") return t
            }
            return e.type === "keypress" ? (e = Cp(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? zF[e.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: nE,
        charCode: function(e) {
            return e.type === "keypress" ? Cp(e) : 0
        },
        keyCode: function(e) {
            return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
        },
        which: function(e) {
            return e.type === "keypress" ? Cp(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
        }
    }),
    KF = Kn(qF),
    QF = dt({}, jy, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    }),
    YT = Kn(QF),
    YF = dt({}, rh, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: nE
    }),
    XF = Kn(YF),
    ZF = dt({}, Dl, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }),
    JF = Kn(ZF),
    eU = dt({}, jy, {
        deltaX: function(e) {
            return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0
        },
        deltaY: function(e) {
            return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    }),
    tU = Kn(eU),
    nU = [9, 13, 27, 32],
    rE = Qi && "CompositionEvent" in window,
    Zc = null;
Qi && "documentMode" in document && (Zc = document.documentMode);
var rU = Qi && "TextEvent" in window && !Zc,
    hR = Qi && (!rE || Zc && 8 < Zc && 11 >= Zc),
    XT = " ",
    ZT = !1;

function pR(e, t) {
    switch (e) {
        case "keyup":
            return nU.indexOf(t.keyCode) !== -1;
        case "keydown":
            return t.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
    }
}

function mR(e) {
    return e = e.detail, typeof e == "object" && "data" in e ? e.data : null
}
var au = !1;

function iU(e, t) {
    switch (e) {
        case "compositionend":
            return mR(t);
        case "keypress":
            return t.which !== 32 ? null : (ZT = !0, XT);
        case "textInput":
            return e = t.data, e === XT && ZT ? null : e;
        default:
            return null
    }
}

function oU(e, t) {
    if (au) return e === "compositionend" || !rE && pR(e, t) ? (e = dR(), kp = eE = Bo = null, au = !1, e) : null;
    switch (e) {
        case "paste":
            return null;
        case "keypress":
            if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
                if (t.char && 1 < t.char.length) return t.char;
                if (t.which) return String.fromCharCode(t.which)
            }
            return null;
        case "compositionend":
            return hR && t.locale !== "ko" ? null : t.data;
        default:
            return null
    }
}
var aU = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};

function JT(e) {
    var t = e && e.nodeName && e.nodeName.toLowerCase();
    return t === "input" ? !!aU[e.type] : t === "textarea"
}

function gR(e, t, n, r) {
    qN(r), t = sm(t, "onChange"), 0 < t.length && (n = new tE("onChange", "change", null, n, r), e.push({
        event: n,
        listeners: t
    }))
}
var Jc = null,
    Pf = null;

function sU(e) {
    PR(e, 0)
}

function By(e) {
    var t = lu(e);
    if (FN(t)) return e
}

function uU(e, t) {
    if (e === "change") return t
}
var yR = !1;
if (Qi) {
    var N0;
    if (Qi) {
        var R0 = "oninput" in document;
        if (!R0) {
            var eP = document.createElement("div");
            eP.setAttribute("oninput", "return;"), R0 = typeof eP.oninput == "function"
        }
        N0 = R0
    } else N0 = !1;
    yR = N0 && (!document.documentMode || 9 < document.documentMode)
}

function tP() {
    Jc && (Jc.detachEvent("onpropertychange", vR), Pf = Jc = null)
}

function vR(e) {
    if (e.propertyName === "value" && By(Pf)) {
        var t = [];
        gR(t, Pf, e, QA(e)), XN(sU, t)
    }
}

function lU(e, t, n) {
    e === "focusin" ? (tP(), Jc = t, Pf = n, Jc.attachEvent("onpropertychange", vR)) : e === "focusout" && tP()
}

function cU(e) {
    if (e === "selectionchange" || e === "keyup" || e === "keydown") return By(Pf)
}

function fU(e, t) {
    if (e === "click") return By(t)
}

function dU(e, t) {
    if (e === "input" || e === "change") return By(t)
}

function hU(e, t) {
    return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t
}
var $r = typeof Object.is == "function" ? Object.is : hU;

function Of(e, t) {
    if ($r(e, t)) return !0;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1;
    var n = Object.keys(e),
        r = Object.keys(t);
    if (n.length !== r.length) return !1;
    for (r = 0; r < n.length; r++) {
        var i = n[r];
        if (!cw.call(t, i) || !$r(e[i], t[i])) return !1
    }
    return !0
}

function nP(e) {
    for (; e && e.firstChild;) e = e.firstChild;
    return e
}

function rP(e, t) {
    var n = nP(e);
    e = 0;
    for (var r; n;) {
        if (n.nodeType === 3) {
            if (r = e + n.textContent.length, e <= t && r >= t) return {
                node: n,
                offset: t - e
            };
            e = r
        }
        e: {
            for (; n;) {
                if (n.nextSibling) {
                    n = n.nextSibling;
                    break e
                }
                n = n.parentNode
            }
            n = void 0
        }
        n = nP(n)
    }
}

function bR(e, t) {
    return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? bR(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1
}

function wR() {
    for (var e = window, t = em(); t instanceof e.HTMLIFrameElement;) {
        try {
            var n = typeof t.contentWindow.location.href == "string"
        } catch {
            n = !1
        }
        if (n) e = t.contentWindow;
        else break;
        t = em(e.document)
    }
    return t
}

function iE(e) {
    var t = e && e.nodeName && e.nodeName.toLowerCase();
    return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true")
}

function pU(e) {
    var t = wR(),
        n = e.focusedElem,
        r = e.selectionRange;
    if (t !== n && n && n.ownerDocument && bR(n.ownerDocument.documentElement, n)) {
        if (r !== null && iE(n)) {
            if (t = r.start, e = r.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length);
            else if (e = (t = n.ownerDocument || document) && t.defaultView || window, e.getSelection) {
                e = e.getSelection();
                var i = n.textContent.length,
                    o = Math.min(r.start, i);
                r = r.end === void 0 ? o : Math.min(r.end, i), !e.extend && o > r && (i = r, r = o, o = i), i = rP(n, o);
                var a = rP(n, r);
                i && a && (e.rangeCount !== 1 || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== a.node || e.focusOffset !== a.offset) && (t = t.createRange(), t.setStart(i.node, i.offset), e.removeAllRanges(), o > r ? (e.addRange(t), e.extend(a.node, a.offset)) : (t.setEnd(a.node, a.offset), e.addRange(t)))
            }
        }
        for (t = [], e = n; e = e.parentNode;) e.nodeType === 1 && t.push({
            element: e,
            left: e.scrollLeft,
            top: e.scrollTop
        });
        for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++) e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top
    }
}
var mU = Qi && "documentMode" in document && 11 >= document.documentMode,
    su = null,
    kw = null,
    ef = null,
    Cw = !1;

function iP(e, t, n) {
    var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
    Cw || su == null || su !== em(r) || (r = su, "selectionStart" in r && iE(r) ? r = {
        start: r.selectionStart,
        end: r.selectionEnd
    } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = {
        anchorNode: r.anchorNode,
        anchorOffset: r.anchorOffset,
        focusNode: r.focusNode,
        focusOffset: r.focusOffset
    }), ef && Of(ef, r) || (ef = r, r = sm(kw, "onSelect"), 0 < r.length && (t = new tE("onSelect", "select", null, t, n), e.push({
        event: t,
        listeners: r
    }), t.target = su)))
}

function Uh(e, t) {
    var n = {};
    return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n
}
var uu = {
        animationend: Uh("Animation", "AnimationEnd"),
        animationiteration: Uh("Animation", "AnimationIteration"),
        animationstart: Uh("Animation", "AnimationStart"),
        transitionend: Uh("Transition", "TransitionEnd")
    },
    j0 = {},
    xR = {};
Qi && (xR = document.createElement("div").style, "AnimationEvent" in window || (delete uu.animationend.animation, delete uu.animationiteration.animation, delete uu.animationstart.animation), "TransitionEvent" in window || delete uu.transitionend.transition);

function Dy(e) {
    if (j0[e]) return j0[e];
    if (!uu[e]) return e;
    var t = uu[e],
        n;
    for (n in t)
        if (t.hasOwnProperty(n) && n in xR) return j0[e] = t[n];
    return e
}
var AR = Dy("animationend"),
    ER = Dy("animationiteration"),
    SR = Dy("animationstart"),
    _R = Dy("transitionend"),
    TR = new Map,
    oP = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

function ca(e, t) {
    TR.set(e, t), Ms(t, [e])
}
for (var B0 = 0; B0 < oP.length; B0++) {
    var D0 = oP[B0],
        gU = D0.toLowerCase(),
        yU = D0[0].toUpperCase() + D0.slice(1);
    ca(gU, "on" + yU)
}
ca(AR, "onAnimationEnd");
ca(ER, "onAnimationIteration");
ca(SR, "onAnimationStart");
ca("dblclick", "onDoubleClick");
ca("focusin", "onFocus");
ca("focusout", "onBlur");
ca(_R, "onTransitionEnd");
Uu("onMouseEnter", ["mouseout", "mouseover"]);
Uu("onMouseLeave", ["mouseout", "mouseover"]);
Uu("onPointerEnter", ["pointerout", "pointerover"]);
Uu("onPointerLeave", ["pointerout", "pointerover"]);
Ms("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Ms("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Ms("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Ms("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Ms("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Ms("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Hc = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
    vU = new Set("cancel close invalid load scroll toggle".split(" ").concat(Hc));

function aP(e, t, n) {
    var r = e.type || "unknown-event";
    e.currentTarget = n, gF(r, t, void 0, e), e.currentTarget = null
}

function PR(e, t) {
    t = (t & 4) !== 0;
    for (var n = 0; n < e.length; n++) {
        var r = e[n],
            i = r.event;
        r = r.listeners;
        e: {
            var o = void 0;
            if (t)
                for (var a = r.length - 1; 0 <= a; a--) {
                    var s = r[a],
                        u = s.instance,
                        l = s.currentTarget;
                    if (s = s.listener, u !== o && i.isPropagationStopped()) break e;
                    aP(i, s, l), o = u
                } else
                    for (a = 0; a < r.length; a++) {
                        if (s = r[a], u = s.instance, l = s.currentTarget, s = s.listener, u !== o && i.isPropagationStopped()) break e;
                        aP(i, s, l), o = u
                    }
        }
    }
    if (nm) throw e = _w, nm = !1, _w = null, e
}

function Xe(e, t) {
    var n = t[jw];
    n === void 0 && (n = t[jw] = new Set);
    var r = e + "__bubble";
    n.has(r) || (OR(t, e, 2, !1), n.add(r))
}

function $0(e, t, n) {
    var r = 0;
    t && (r |= 4), OR(n, e, r, t)
}
var Hh = "_reactListening" + Math.random().toString(36).slice(2);

function kf(e) {
    if (!e[Hh]) {
        e[Hh] = !0, jN.forEach(function(n) {
            n !== "selectionchange" && (vU.has(n) || $0(n, !1, e), $0(n, !0, e))
        });
        var t = e.nodeType === 9 ? e : e.ownerDocument;
        t === null || t[Hh] || (t[Hh] = !0, $0("selectionchange", !1, t))
    }
}

function OR(e, t, n, r) {
    switch (fR(t)) {
        case 1:
            var i = MF;
            break;
        case 4:
            i = NF;
            break;
        default:
            i = JA
    }
    n = i.bind(null, t, n, e), i = void 0, !Sw || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (i = !0), r ? i !== void 0 ? e.addEventListener(t, n, {
        capture: !0,
        passive: i
    }) : e.addEventListener(t, n, !0) : i !== void 0 ? e.addEventListener(t, n, {
        passive: i
    }) : e.addEventListener(t, n, !1)
}

function L0(e, t, n, r, i) {
    var o = r;
    if (!(t & 1) && !(t & 2) && r !== null) e: for (;;) {
        if (r === null) return;
        var a = r.tag;
        if (a === 3 || a === 4) {
            var s = r.stateNode.containerInfo;
            if (s === i || s.nodeType === 8 && s.parentNode === i) break;
            if (a === 4)
                for (a = r.return; a !== null;) {
                    var u = a.tag;
                    if ((u === 3 || u === 4) && (u = a.stateNode.containerInfo, u === i || u.nodeType === 8 && u.parentNode === i)) return;
                    a = a.return
                }
            for (; s !== null;) {
                if (a = Da(s), a === null) return;
                if (u = a.tag, u === 5 || u === 6) {
                    r = o = a;
                    continue e
                }
                s = s.parentNode
            }
        }
        r = r.return
    }
    XN(function() {
        var l = o,
            c = QA(n),
            f = [];
        e: {
            var d = TR.get(e);
            if (d !== void 0) {
                var h = tE,
                    m = e;
                switch (e) {
                    case "keypress":
                        if (Cp(n) === 0) break e;
                    case "keydown":
                    case "keyup":
                        h = KF;
                        break;
                    case "focusin":
                        m = "focus", h = M0;
                        break;
                    case "focusout":
                        m = "blur", h = M0;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        h = M0;
                        break;
                    case "click":
                        if (n.button === 2) break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        h = KT;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        h = BF;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        h = XF;
                        break;
                    case AR:
                    case ER:
                    case SR:
                        h = LF;
                        break;
                    case _R:
                        h = JF;
                        break;
                    case "scroll":
                        h = RF;
                        break;
                    case "wheel":
                        h = tU;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        h = UF;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        h = YT
                }
                var p = (t & 4) !== 0,
                    y = !p && e === "scroll",
                    g = p ? d !== null ? d + "Capture" : null : d;
                p = [];
                for (var b = l, v; b !== null;) {
                    v = b;
                    var A = v.stateNode;
                    if (v.tag === 5 && A !== null && (v = A, g !== null && (A = Ef(b, g), A != null && p.push(Cf(b, A, v)))), y) break;
                    b = b.return
                }
                0 < p.length && (d = new h(d, m, null, n, c), f.push({
                    event: d,
                    listeners: p
                }))
            }
        }
        if (!(t & 7)) {
            e: {
                if (d = e === "mouseover" || e === "pointerover", h = e === "mouseout" || e === "pointerout", d && n !== Aw && (m = n.relatedTarget || n.fromElement) && (Da(m) || m[Yi])) break e;
                if ((h || d) && (d = c.window === c ? c : (d = c.ownerDocument) ? d.defaultView || d.parentWindow : window, h ? (m = n.relatedTarget || n.toElement, h = l, m = m ? Da(m) : null, m !== null && (y = Ns(m), m !== y || m.tag !== 5 && m.tag !== 6) && (m = null)) : (h = null, m = l), h !== m)) {
                    if (p = KT, A = "onMouseLeave", g = "onMouseEnter", b = "mouse", (e === "pointerout" || e === "pointerover") && (p = YT, A = "onPointerLeave", g = "onPointerEnter", b = "pointer"), y = h == null ? d : lu(h), v = m == null ? d : lu(m), d = new p(A, b + "leave", h, n, c), d.target = y, d.relatedTarget = v, A = null, Da(c) === l && (p = new p(g, b + "enter", m, n, c), p.target = v, p.relatedTarget = y, A = p), y = A, h && m) t: {
                        for (p = h, g = m, b = 0, v = p; v; v = Vs(v)) b++;
                        for (v = 0, A = g; A; A = Vs(A)) v++;
                        for (; 0 < b - v;) p = Vs(p),
                        b--;
                        for (; 0 < v - b;) g = Vs(g),
                        v--;
                        for (; b--;) {
                            if (p === g || g !== null && p === g.alternate) break t;
                            p = Vs(p), g = Vs(g)
                        }
                        p = null
                    }
                    else p = null;
                    h !== null && sP(f, d, h, p, !1), m !== null && y !== null && sP(f, y, m, p, !0)
                }
            }
            e: {
                if (d = l ? lu(l) : window, h = d.nodeName && d.nodeName.toLowerCase(), h === "select" || h === "input" && d.type === "file") var w = uU;
                else if (JT(d))
                    if (yR) w = dU;
                    else {
                        w = cU;
                        var x = lU
                    }
                else(h = d.nodeName) && h.toLowerCase() === "input" && (d.type === "checkbox" || d.type === "radio") && (w = fU);
                if (w && (w = w(e, l))) {
                    gR(f, w, n, c);
                    break e
                }
                x && x(e, d, l),
                e === "focusout" && (x = d._wrapperState) && x.controlled && d.type === "number" && yw(d, "number", d.value)
            }
            switch (x = l ? lu(l) : window, e) {
                case "focusin":
                    (JT(x) || x.contentEditable === "true") && (su = x, kw = l, ef = null);
                    break;
                case "focusout":
                    ef = kw = su = null;
                    break;
                case "mousedown":
                    Cw = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    Cw = !1, iP(f, n, c);
                    break;
                case "selectionchange":
                    if (mU) break;
                case "keydown":
                case "keyup":
                    iP(f, n, c)
            }
            var T;
            if (rE) e: {
                switch (e) {
                    case "compositionstart":
                        var _ = "onCompositionStart";
                        break e;
                    case "compositionend":
                        _ = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        _ = "onCompositionUpdate";
                        break e
                }
                _ = void 0
            }
            else au ? pR(e, n) && (_ = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (_ = "onCompositionStart");_ && (hR && n.locale !== "ko" && (au || _ !== "onCompositionStart" ? _ === "onCompositionEnd" && au && (T = dR()) : (Bo = c, eE = "value" in Bo ? Bo.value : Bo.textContent, au = !0)), x = sm(l, _), 0 < x.length && (_ = new QT(_, e, null, n, c), f.push({
                event: _,
                listeners: x
            }), T ? _.data = T : (T = mR(n), T !== null && (_.data = T)))),
            (T = rU ? iU(e, n) : oU(e, n)) && (l = sm(l, "onBeforeInput"), 0 < l.length && (c = new QT("onBeforeInput", "beforeinput", null, n, c), f.push({
                event: c,
                listeners: l
            }), c.data = T))
        }
        PR(f, t)
    })
}

function Cf(e, t, n) {
    return {
        instance: e,
        listener: t,
        currentTarget: n
    }
}

function sm(e, t) {
    for (var n = t + "Capture", r = []; e !== null;) {
        var i = e,
            o = i.stateNode;
        i.tag === 5 && o !== null && (i = o, o = Ef(e, n), o != null && r.unshift(Cf(e, o, i)), o = Ef(e, t), o != null && r.push(Cf(e, o, i))), e = e.return
    }
    return r
}

function Vs(e) {
    if (e === null) return null;
    do e = e.return; while (e && e.tag !== 5);
    return e || null
}

function sP(e, t, n, r, i) {
    for (var o = t._reactName, a = []; n !== null && n !== r;) {
        var s = n,
            u = s.alternate,
            l = s.stateNode;
        if (u !== null && u === r) break;
        s.tag === 5 && l !== null && (s = l, i ? (u = Ef(n, o), u != null && a.unshift(Cf(n, u, s))) : i || (u = Ef(n, o), u != null && a.push(Cf(n, u, s)))), n = n.return
    }
    a.length !== 0 && e.push({
        event: t,
        listeners: a
    })
}
var bU = /\r\n?/g,
    wU = /\u0000|\uFFFD/g;

function uP(e) {
    return (typeof e == "string" ? e : "" + e).replace(bU, `
`).replace(wU, "")
}

function Vh(e, t, n) {
    if (t = uP(t), uP(e) !== t && n) throw Error(G(425))
}

function um() {}
var Iw = null,
    Mw = null;

function Nw(e, t) {
    return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null
}
var Rw = typeof setTimeout == "function" ? setTimeout : void 0,
    xU = typeof clearTimeout == "function" ? clearTimeout : void 0,
    lP = typeof Promise == "function" ? Promise : void 0,
    AU = typeof queueMicrotask == "function" ? queueMicrotask : typeof lP < "u" ? function(e) {
        return lP.resolve(null).then(e).catch(EU)
    } : Rw;

function EU(e) {
    setTimeout(function() {
        throw e
    })
}

function F0(e, t) {
    var n = t,
        r = 0;
    do {
        var i = n.nextSibling;
        if (e.removeChild(n), i && i.nodeType === 8)
            if (n = i.data, n === "/$") {
                if (r === 0) {
                    e.removeChild(i), Tf(t);
                    return
                }
                r--
            } else n !== "$" && n !== "$?" && n !== "$!" || r++;
        n = i
    } while (n);
    Tf(t)
}

function Wo(e) {
    for (; e != null; e = e.nextSibling) {
        var t = e.nodeType;
        if (t === 1 || t === 3) break;
        if (t === 8) {
            if (t = e.data, t === "$" || t === "$!" || t === "$?") break;
            if (t === "/$") return null
        }
    }
    return e
}

function cP(e) {
    e = e.previousSibling;
    for (var t = 0; e;) {
        if (e.nodeType === 8) {
            var n = e.data;
            if (n === "$" || n === "$!" || n === "$?") {
                if (t === 0) return e;
                t--
            } else n === "/$" && t++
        }
        e = e.previousSibling
    }
    return null
}
var $l = Math.random().toString(36).slice(2),
    Zr = "__reactFiber$" + $l,
    If = "__reactProps$" + $l,
    Yi = "__reactContainer$" + $l,
    jw = "__reactEvents$" + $l,
    SU = "__reactListeners$" + $l,
    _U = "__reactHandles$" + $l;

function Da(e) {
    var t = e[Zr];
    if (t) return t;
    for (var n = e.parentNode; n;) {
        if (t = n[Yi] || n[Zr]) {
            if (n = t.alternate, t.child !== null || n !== null && n.child !== null)
                for (e = cP(e); e !== null;) {
                    if (n = e[Zr]) return n;
                    e = cP(e)
                }
            return t
        }
        e = n, n = e.parentNode
    }
    return null
}

function ih(e) {
    return e = e[Zr] || e[Yi], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e
}

function lu(e) {
    if (e.tag === 5 || e.tag === 6) return e.stateNode;
    throw Error(G(33))
}

function $y(e) {
    return e[If] || null
}
var Bw = [],
    cu = -1;

function fa(e) {
    return {
        current: e
    }
}

function et(e) {
    0 > cu || (e.current = Bw[cu], Bw[cu] = null, cu--)
}

function Qe(e, t) {
    cu++, Bw[cu] = e.current, e.current = t
}
var ta = {},
    sn = fa(ta),
    Cn = fa(!1),
    hs = ta;

function Hu(e, t) {
    var n = e.type.contextTypes;
    if (!n) return ta;
    var r = e.stateNode;
    if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext;
    var i = {},
        o;
    for (o in n) i[o] = t[o];
    return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = i), i
}

function In(e) {
    return e = e.childContextTypes, e != null
}

function lm() {
    et(Cn), et(sn)
}

function fP(e, t, n) {
    if (sn.current !== ta) throw Error(G(168));
    Qe(sn, t), Qe(Cn, n)
}

function kR(e, t, n) {
    var r = e.stateNode;
    if (t = t.childContextTypes, typeof r.getChildContext != "function") return n;
    r = r.getChildContext();
    for (var i in r)
        if (!(i in t)) throw Error(G(108, lF(e) || "Unknown", i));
    return dt({}, n, r)
}

function cm(e) {
    return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || ta, hs = sn.current, Qe(sn, e), Qe(Cn, Cn.current), !0
}

function dP(e, t, n) {
    var r = e.stateNode;
    if (!r) throw Error(G(169));
    n ? (e = kR(e, t, hs), r.__reactInternalMemoizedMergedChildContext = e, et(Cn), et(sn), Qe(sn, e)) : et(Cn), Qe(Cn, n)
}
var Ci = null,
    Ly = !1,
    U0 = !1;

function CR(e) {
    Ci === null ? Ci = [e] : Ci.push(e)
}

function TU(e) {
    Ly = !0, CR(e)
}

function da() {
    if (!U0 && Ci !== null) {
        U0 = !0;
        var e = 0,
            t = Le;
        try {
            var n = Ci;
            for (Le = 1; e < n.length; e++) {
                var r = n[e];
                do r = r(!0); while (r !== null)
            }
            Ci = null, Ly = !1
        } catch (i) {
            throw Ci !== null && (Ci = Ci.slice(e + 1)), tR(YA, da), i
        } finally {
            Le = t, U0 = !1
        }
    }
    return null
}
var fu = [],
    du = 0,
    fm = null,
    dm = 0,
    rr = [],
    ir = 0,
    ps = null,
    Ri = 1,
    ji = "";

function Oa(e, t) {
    fu[du++] = dm, fu[du++] = fm, fm = e, dm = t
}

function IR(e, t, n) {
    rr[ir++] = Ri, rr[ir++] = ji, rr[ir++] = ps, ps = e;
    var r = Ri;
    e = ji;
    var i = 32 - Nr(r) - 1;
    r &= ~(1 << i), n += 1;
    var o = 32 - Nr(t) + i;
    if (30 < o) {
        var a = i - i % 5;
        o = (r & (1 << a) - 1).toString(32), r >>= a, i -= a, Ri = 1 << 32 - Nr(t) + i | n << i | r, ji = o + e
    } else Ri = 1 << o | n << i | r, ji = e
}

function oE(e) {
    e.return !== null && (Oa(e, 1), IR(e, 1, 0))
}

function aE(e) {
    for (; e === fm;) fm = fu[--du], fu[du] = null, dm = fu[--du], fu[du] = null;
    for (; e === ps;) ps = rr[--ir], rr[ir] = null, ji = rr[--ir], rr[ir] = null, Ri = rr[--ir], rr[ir] = null
}
var Un = null,
    Fn = null,
    rt = !1,
    Or = null;

function MR(e, t) {
    var n = sr(5, null, null, 0);
    n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n)
}

function hP(e, t) {
    switch (e.tag) {
        case 5:
            var n = e.type;
            return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, Un = e, Fn = Wo(t.firstChild), !0) : !1;
        case 6:
            return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, Un = e, Fn = null, !0) : !1;
        case 13:
            return t = t.nodeType !== 8 ? null : t, t !== null ? (n = ps !== null ? {
                id: Ri,
                overflow: ji
            } : null, e.memoizedState = {
                dehydrated: t,
                treeContext: n,
                retryLane: 1073741824
            }, n = sr(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, Un = e, Fn = null, !0) : !1;
        default:
            return !1
    }
}

function Dw(e) {
    return (e.mode & 1) !== 0 && (e.flags & 128) === 0
}

function $w(e) {
    if (rt) {
        var t = Fn;
        if (t) {
            var n = t;
            if (!hP(e, t)) {
                if (Dw(e)) throw Error(G(418));
                t = Wo(n.nextSibling);
                var r = Un;
                t && hP(e, t) ? MR(r, n) : (e.flags = e.flags & -4097 | 2, rt = !1, Un = e)
            }
        } else {
            if (Dw(e)) throw Error(G(418));
            e.flags = e.flags & -4097 | 2, rt = !1, Un = e
        }
    }
}

function pP(e) {
    for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;) e = e.return;
    Un = e
}

function zh(e) {
    if (e !== Un) return !1;
    if (!rt) return pP(e), rt = !0, !1;
    var t;
    if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !Nw(e.type, e.memoizedProps)), t && (t = Fn)) {
        if (Dw(e)) throw NR(), Error(G(418));
        for (; t;) MR(e, t), t = Wo(t.nextSibling)
    }
    if (pP(e), e.tag === 13) {
        if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(G(317));
        e: {
            for (e = e.nextSibling, t = 0; e;) {
                if (e.nodeType === 8) {
                    var n = e.data;
                    if (n === "/$") {
                        if (t === 0) {
                            Fn = Wo(e.nextSibling);
                            break e
                        }
                        t--
                    } else n !== "$" && n !== "$!" && n !== "$?" || t++
                }
                e = e.nextSibling
            }
            Fn = null
        }
    } else Fn = Un ? Wo(e.stateNode.nextSibling) : null;
    return !0
}

function NR() {
    for (var e = Fn; e;) e = Wo(e.nextSibling)
}

function Vu() {
    Fn = Un = null, rt = !1
}

function sE(e) {
    Or === null ? Or = [e] : Or.push(e)
}
var PU = co.ReactCurrentBatchConfig;

function mc(e, t, n) {
    if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") {
        if (n._owner) {
            if (n = n._owner, n) {
                if (n.tag !== 1) throw Error(G(309));
                var r = n.stateNode
            }
            if (!r) throw Error(G(147, e));
            var i = r,
                o = "" + e;
            return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === o ? t.ref : (t = function(a) {
                var s = i.refs;
                a === null ? delete s[o] : s[o] = a
            }, t._stringRef = o, t)
        }
        if (typeof e != "string") throw Error(G(284));
        if (!n._owner) throw Error(G(290, e))
    }
    return e
}

function Wh(e, t) {
    throw e = Object.prototype.toString.call(t), Error(G(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
}

function mP(e) {
    var t = e._init;
    return t(e._payload)
}

function RR(e) {
    function t(g, b) {
        if (e) {
            var v = g.deletions;
            v === null ? (g.deletions = [b], g.flags |= 16) : v.push(b)
        }
    }

    function n(g, b) {
        if (!e) return null;
        for (; b !== null;) t(g, b), b = b.sibling;
        return null
    }

    function r(g, b) {
        for (g = new Map; b !== null;) b.key !== null ? g.set(b.key, b) : g.set(b.index, b), b = b.sibling;
        return g
    }

    function i(g, b) {
        return g = Qo(g, b), g.index = 0, g.sibling = null, g
    }

    function o(g, b, v) {
        return g.index = v, e ? (v = g.alternate, v !== null ? (v = v.index, v < b ? (g.flags |= 2, b) : v) : (g.flags |= 2, b)) : (g.flags |= 1048576, b)
    }

    function a(g) {
        return e && g.alternate === null && (g.flags |= 2), g
    }

    function s(g, b, v, A) {
        return b === null || b.tag !== 6 ? (b = K0(v, g.mode, A), b.return = g, b) : (b = i(b, v), b.return = g, b)
    }

    function u(g, b, v, A) {
        var w = v.type;
        return w === ou ? c(g, b, v.props.children, A, v.key) : b !== null && (b.elementType === w || typeof w == "object" && w !== null && w.$$typeof === ko && mP(w) === b.type) ? (A = i(b, v.props), A.ref = mc(g, b, v), A.return = g, A) : (A = Dp(v.type, v.key, v.props, null, g.mode, A), A.ref = mc(g, b, v), A.return = g, A)
    }

    function l(g, b, v, A) {
        return b === null || b.tag !== 4 || b.stateNode.containerInfo !== v.containerInfo || b.stateNode.implementation !== v.implementation ? (b = Q0(v, g.mode, A), b.return = g, b) : (b = i(b, v.children || []), b.return = g, b)
    }

    function c(g, b, v, A, w) {
        return b === null || b.tag !== 7 ? (b = es(v, g.mode, A, w), b.return = g, b) : (b = i(b, v), b.return = g, b)
    }

    function f(g, b, v) {
        if (typeof b == "string" && b !== "" || typeof b == "number") return b = K0("" + b, g.mode, v), b.return = g, b;
        if (typeof b == "object" && b !== null) {
            switch (b.$$typeof) {
                case Rh:
                    return v = Dp(b.type, b.key, b.props, null, g.mode, v), v.ref = mc(g, null, b), v.return = g, v;
                case iu:
                    return b = Q0(b, g.mode, v), b.return = g, b;
                case ko:
                    var A = b._init;
                    return f(g, A(b._payload), v)
            }
            if (Fc(b) || cc(b)) return b = es(b, g.mode, v, null), b.return = g, b;
            Wh(g, b)
        }
        return null
    }

    function d(g, b, v, A) {
        var w = b !== null ? b.key : null;
        if (typeof v == "string" && v !== "" || typeof v == "number") return w !== null ? null : s(g, b, "" + v, A);
        if (typeof v == "object" && v !== null) {
            switch (v.$$typeof) {
                case Rh:
                    return v.key === w ? u(g, b, v, A) : null;
                case iu:
                    return v.key === w ? l(g, b, v, A) : null;
                case ko:
                    return w = v._init, d(g, b, w(v._payload), A)
            }
            if (Fc(v) || cc(v)) return w !== null ? null : c(g, b, v, A, null);
            Wh(g, v)
        }
        return null
    }

    function h(g, b, v, A, w) {
        if (typeof A == "string" && A !== "" || typeof A == "number") return g = g.get(v) || null, s(b, g, "" + A, w);
        if (typeof A == "object" && A !== null) {
            switch (A.$$typeof) {
                case Rh:
                    return g = g.get(A.key === null ? v : A.key) || null, u(b, g, A, w);
                case iu:
                    return g = g.get(A.key === null ? v : A.key) || null, l(b, g, A, w);
                case ko:
                    var x = A._init;
                    return h(g, b, v, x(A._payload), w)
            }
            if (Fc(A) || cc(A)) return g = g.get(v) || null, c(b, g, A, w, null);
            Wh(b, A)
        }
        return null
    }

    function m(g, b, v, A) {
        for (var w = null, x = null, T = b, _ = b = 0, O = null; T !== null && _ < v.length; _++) {
            T.index > _ ? (O = T, T = null) : O = T.sibling;
            var k = d(g, T, v[_], A);
            if (k === null) {
                T === null && (T = O);
                break
            }
            e && T && k.alternate === null && t(g, T), b = o(k, b, _), x === null ? w = k : x.sibling = k, x = k, T = O
        }
        if (_ === v.length) return n(g, T), rt && Oa(g, _), w;
        if (T === null) {
            for (; _ < v.length; _++) T = f(g, v[_], A), T !== null && (b = o(T, b, _), x === null ? w = T : x.sibling = T, x = T);
            return rt && Oa(g, _), w
        }
        for (T = r(g, T); _ < v.length; _++) O = h(T, g, _, v[_], A), O !== null && (e && O.alternate !== null && T.delete(O.key === null ? _ : O.key), b = o(O, b, _), x === null ? w = O : x.sibling = O, x = O);
        return e && T.forEach(function(I) {
            return t(g, I)
        }), rt && Oa(g, _), w
    }

    function p(g, b, v, A) {
        var w = cc(v);
        if (typeof w != "function") throw Error(G(150));
        if (v = w.call(v), v == null) throw Error(G(151));
        for (var x = w = null, T = b, _ = b = 0, O = null, k = v.next(); T !== null && !k.done; _++, k = v.next()) {
            T.index > _ ? (O = T, T = null) : O = T.sibling;
            var I = d(g, T, k.value, A);
            if (I === null) {
                T === null && (T = O);
                break
            }
            e && T && I.alternate === null && t(g, T), b = o(I, b, _), x === null ? w = I : x.sibling = I, x = I, T = O
        }
        if (k.done) return n(g, T), rt && Oa(g, _), w;
        if (T === null) {
            for (; !k.done; _++, k = v.next()) k = f(g, k.value, A), k !== null && (b = o(k, b, _), x === null ? w = k : x.sibling = k, x = k);
            return rt && Oa(g, _), w
        }
        for (T = r(g, T); !k.done; _++, k = v.next()) k = h(T, g, _, k.value, A), k !== null && (e && k.alternate !== null && T.delete(k.key === null ? _ : k.key), b = o(k, b, _), x === null ? w = k : x.sibling = k, x = k);
        return e && T.forEach(function(M) {
            return t(g, M)
        }), rt && Oa(g, _), w
    }

    function y(g, b, v, A) {
        if (typeof v == "object" && v !== null && v.type === ou && v.key === null && (v = v.props.children), typeof v == "object" && v !== null) {
            switch (v.$$typeof) {
                case Rh:
                    e: {
                        for (var w = v.key, x = b; x !== null;) {
                            if (x.key === w) {
                                if (w = v.type, w === ou) {
                                    if (x.tag === 7) {
                                        n(g, x.sibling), b = i(x, v.props.children), b.return = g, g = b;
                                        break e
                                    }
                                } else if (x.elementType === w || typeof w == "object" && w !== null && w.$$typeof === ko && mP(w) === x.type) {
                                    n(g, x.sibling), b = i(x, v.props), b.ref = mc(g, x, v), b.return = g, g = b;
                                    break e
                                }
                                n(g, x);
                                break
                            } else t(g, x);
                            x = x.sibling
                        }
                        v.type === ou ? (b = es(v.props.children, g.mode, A, v.key), b.return = g, g = b) : (A = Dp(v.type, v.key, v.props, null, g.mode, A), A.ref = mc(g, b, v), A.return = g, g = A)
                    }
                    return a(g);
                case iu:
                    e: {
                        for (x = v.key; b !== null;) {
                            if (b.key === x)
                                if (b.tag === 4 && b.stateNode.containerInfo === v.containerInfo && b.stateNode.implementation === v.implementation) {
                                    n(g, b.sibling), b = i(b, v.children || []), b.return = g, g = b;
                                    break e
                                } else {
                                    n(g, b);
                                    break
                                }
                            else t(g, b);
                            b = b.sibling
                        }
                        b = Q0(v, g.mode, A),
                        b.return = g,
                        g = b
                    }
                    return a(g);
                case ko:
                    return x = v._init, y(g, b, x(v._payload), A)
            }
            if (Fc(v)) return m(g, b, v, A);
            if (cc(v)) return p(g, b, v, A);
            Wh(g, v)
        }
        return typeof v == "string" && v !== "" || typeof v == "number" ? (v = "" + v, b !== null && b.tag === 6 ? (n(g, b.sibling), b = i(b, v), b.return = g, g = b) : (n(g, b), b = K0(v, g.mode, A), b.return = g, g = b), a(g)) : n(g, b)
    }
    return y
}
var zu = RR(!0),
    jR = RR(!1),
    hm = fa(null),
    pm = null,
    hu = null,
    uE = null;

function lE() {
    uE = hu = pm = null
}

function cE(e) {
    var t = hm.current;
    et(hm), e._currentValue = t
}

function Lw(e, t, n) {
    for (; e !== null;) {
        var r = e.alternate;
        if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break;
        e = e.return
    }
}

function Iu(e, t) {
    pm = e, uE = hu = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (Pn = !0), e.firstContext = null)
}

function hr(e) {
    var t = e._currentValue;
    if (uE !== e)
        if (e = {
                context: e,
                memoizedValue: t,
                next: null
            }, hu === null) {
            if (pm === null) throw Error(G(308));
            hu = e, pm.dependencies = {
                lanes: 0,
                firstContext: e
            }
        } else hu = hu.next = e;
    return t
}
var $a = null;

function fE(e) {
    $a === null ? $a = [e] : $a.push(e)
}

function BR(e, t, n, r) {
    var i = t.interleaved;
    return i === null ? (n.next = n, fE(t)) : (n.next = i.next, i.next = n), t.interleaved = n, Xi(e, r)
}

function Xi(e, t) {
    e.lanes |= t;
    var n = e.alternate;
    for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null;) e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return;
    return n.tag === 3 ? n.stateNode : null
}
var Co = !1;

function dE(e) {
    e.updateQueue = {
        baseState: e.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}

function DR(e, t) {
    e = e.updateQueue, t.updateQueue === e && (t.updateQueue = {
        baseState: e.baseState,
        firstBaseUpdate: e.firstBaseUpdate,
        lastBaseUpdate: e.lastBaseUpdate,
        shared: e.shared,
        effects: e.effects
    })
}

function Fi(e, t) {
    return {
        eventTime: e,
        lane: t,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}

function Go(e, t, n) {
    var r = e.updateQueue;
    if (r === null) return null;
    if (r = r.shared, ke & 2) {
        var i = r.pending;
        return i === null ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, Xi(e, n)
    }
    return i = r.interleaved, i === null ? (t.next = t, fE(r)) : (t.next = i.next, i.next = t), r.interleaved = t, Xi(e, n)
}

function Ip(e, t, n) {
    if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194240) !== 0)) {
        var r = t.lanes;
        r &= e.pendingLanes, n |= r, t.lanes = n, XA(e, n)
    }
}

function gP(e, t) {
    var n = e.updateQueue,
        r = e.alternate;
    if (r !== null && (r = r.updateQueue, n === r)) {
        var i = null,
            o = null;
        if (n = n.firstBaseUpdate, n !== null) {
            do {
                var a = {
                    eventTime: n.eventTime,
                    lane: n.lane,
                    tag: n.tag,
                    payload: n.payload,
                    callback: n.callback,
                    next: null
                };
                o === null ? i = o = a : o = o.next = a, n = n.next
            } while (n !== null);
            o === null ? i = o = t : o = o.next = t
        } else i = o = t;
        n = {
            baseState: r.baseState,
            firstBaseUpdate: i,
            lastBaseUpdate: o,
            shared: r.shared,
            effects: r.effects
        }, e.updateQueue = n;
        return
    }
    e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t
}

function mm(e, t, n, r) {
    var i = e.updateQueue;
    Co = !1;
    var o = i.firstBaseUpdate,
        a = i.lastBaseUpdate,
        s = i.shared.pending;
    if (s !== null) {
        i.shared.pending = null;
        var u = s,
            l = u.next;
        u.next = null, a === null ? o = l : a.next = l, a = u;
        var c = e.alternate;
        c !== null && (c = c.updateQueue, s = c.lastBaseUpdate, s !== a && (s === null ? c.firstBaseUpdate = l : s.next = l, c.lastBaseUpdate = u))
    }
    if (o !== null) {
        var f = i.baseState;
        a = 0, c = l = u = null, s = o;
        do {
            var d = s.lane,
                h = s.eventTime;
            if ((r & d) === d) {
                c !== null && (c = c.next = {
                    eventTime: h,
                    lane: 0,
                    tag: s.tag,
                    payload: s.payload,
                    callback: s.callback,
                    next: null
                });
                e: {
                    var m = e,
                        p = s;
                    switch (d = t, h = n, p.tag) {
                        case 1:
                            if (m = p.payload, typeof m == "function") {
                                f = m.call(h, f, d);
                                break e
                            }
                            f = m;
                            break e;
                        case 3:
                            m.flags = m.flags & -65537 | 128;
                        case 0:
                            if (m = p.payload, d = typeof m == "function" ? m.call(h, f, d) : m, d == null) break e;
                            f = dt({}, f, d);
                            break e;
                        case 2:
                            Co = !0
                    }
                }
                s.callback !== null && s.lane !== 0 && (e.flags |= 64, d = i.effects, d === null ? i.effects = [s] : d.push(s))
            } else h = {
                eventTime: h,
                lane: d,
                tag: s.tag,
                payload: s.payload,
                callback: s.callback,
                next: null
            }, c === null ? (l = c = h, u = f) : c = c.next = h, a |= d;
            if (s = s.next, s === null) {
                if (s = i.shared.pending, s === null) break;
                d = s, s = d.next, d.next = null, i.lastBaseUpdate = d, i.shared.pending = null
            }
        } while (!0);
        if (c === null && (u = f), i.baseState = u, i.firstBaseUpdate = l, i.lastBaseUpdate = c, t = i.shared.interleaved, t !== null) {
            i = t;
            do a |= i.lane, i = i.next; while (i !== t)
        } else o === null && (i.shared.lanes = 0);
        gs |= a, e.lanes = a, e.memoizedState = f
    }
}

function yP(e, t, n) {
    if (e = t.effects, t.effects = null, e !== null)
        for (t = 0; t < e.length; t++) {
            var r = e[t],
                i = r.callback;
            if (i !== null) {
                if (r.callback = null, r = n, typeof i != "function") throw Error(G(191, i));
                i.call(r)
            }
        }
}
var oh = {},
    ai = fa(oh),
    Mf = fa(oh),
    Nf = fa(oh);

function La(e) {
    if (e === oh) throw Error(G(174));
    return e
}

function hE(e, t) {
    switch (Qe(Nf, t), Qe(Mf, e), Qe(ai, oh), e = t.nodeType, e) {
        case 9:
        case 11:
            t = (t = t.documentElement) ? t.namespaceURI : bw(null, "");
            break;
        default:
            e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = bw(t, e)
    }
    et(ai), Qe(ai, t)
}

function Wu() {
    et(ai), et(Mf), et(Nf)
}

function $R(e) {
    La(Nf.current);
    var t = La(ai.current),
        n = bw(t, e.type);
    t !== n && (Qe(Mf, e), Qe(ai, n))
}

function pE(e) {
    Mf.current === e && (et(ai), et(Mf))
}
var st = fa(0);

function gm(e) {
    for (var t = e; t !== null;) {
        if (t.tag === 13) {
            var n = t.memoizedState;
            if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t
        } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
            if (t.flags & 128) return t
        } else if (t.child !== null) {
            t.child.return = t, t = t.child;
            continue
        }
        if (t === e) break;
        for (; t.sibling === null;) {
            if (t.return === null || t.return === e) return null;
            t = t.return
        }
        t.sibling.return = t.return, t = t.sibling
    }
    return null
}
var H0 = [];

function mE() {
    for (var e = 0; e < H0.length; e++) H0[e]._workInProgressVersionPrimary = null;
    H0.length = 0
}
var Mp = co.ReactCurrentDispatcher,
    V0 = co.ReactCurrentBatchConfig,
    ms = 0,
    ct = null,
    It = null,
    $t = null,
    ym = !1,
    tf = !1,
    Rf = 0,
    OU = 0;

function Yt() {
    throw Error(G(321))
}

function gE(e, t) {
    if (t === null) return !1;
    for (var n = 0; n < t.length && n < e.length; n++)
        if (!$r(e[n], t[n])) return !1;
    return !0
}

function yE(e, t, n, r, i, o) {
    if (ms = o, ct = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, Mp.current = e === null || e.memoizedState === null ? MU : NU, e = n(r, i), tf) {
        o = 0;
        do {
            if (tf = !1, Rf = 0, 25 <= o) throw Error(G(301));
            o += 1, $t = It = null, t.updateQueue = null, Mp.current = RU, e = n(r, i)
        } while (tf)
    }
    if (Mp.current = vm, t = It !== null && It.next !== null, ms = 0, $t = It = ct = null, ym = !1, t) throw Error(G(300));
    return e
}

function vE() {
    var e = Rf !== 0;
    return Rf = 0, e
}

function Gr() {
    var e = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return $t === null ? ct.memoizedState = $t = e : $t = $t.next = e, $t
}

function pr() {
    if (It === null) {
        var e = ct.alternate;
        e = e !== null ? e.memoizedState : null
    } else e = It.next;
    var t = $t === null ? ct.memoizedState : $t.next;
    if (t !== null) $t = t, It = e;
    else {
        if (e === null) throw Error(G(310));
        It = e, e = {
            memoizedState: It.memoizedState,
            baseState: It.baseState,
            baseQueue: It.baseQueue,
            queue: It.queue,
            next: null
        }, $t === null ? ct.memoizedState = $t = e : $t = $t.next = e
    }
    return $t
}

function jf(e, t) {
    return typeof t == "function" ? t(e) : t
}

function z0(e) {
    var t = pr(),
        n = t.queue;
    if (n === null) throw Error(G(311));
    n.lastRenderedReducer = e;
    var r = It,
        i = r.baseQueue,
        o = n.pending;
    if (o !== null) {
        if (i !== null) {
            var a = i.next;
            i.next = o.next, o.next = a
        }
        r.baseQueue = i = o, n.pending = null
    }
    if (i !== null) {
        o = i.next, r = r.baseState;
        var s = a = null,
            u = null,
            l = o;
        do {
            var c = l.lane;
            if ((ms & c) === c) u !== null && (u = u.next = {
                lane: 0,
                action: l.action,
                hasEagerState: l.hasEagerState,
                eagerState: l.eagerState,
                next: null
            }), r = l.hasEagerState ? l.eagerState : e(r, l.action);
            else {
                var f = {
                    lane: c,
                    action: l.action,
                    hasEagerState: l.hasEagerState,
                    eagerState: l.eagerState,
                    next: null
                };
                u === null ? (s = u = f, a = r) : u = u.next = f, ct.lanes |= c, gs |= c
            }
            l = l.next
        } while (l !== null && l !== o);
        u === null ? a = r : u.next = s, $r(r, t.memoizedState) || (Pn = !0), t.memoizedState = r, t.baseState = a, t.baseQueue = u, n.lastRenderedState = r
    }
    if (e = n.interleaved, e !== null) {
        i = e;
        do o = i.lane, ct.lanes |= o, gs |= o, i = i.next; while (i !== e)
    } else i === null && (n.lanes = 0);
    return [t.memoizedState, n.dispatch]
}

function W0(e) {
    var t = pr(),
        n = t.queue;
    if (n === null) throw Error(G(311));
    n.lastRenderedReducer = e;
    var r = n.dispatch,
        i = n.pending,
        o = t.memoizedState;
    if (i !== null) {
        n.pending = null;
        var a = i = i.next;
        do o = e(o, a.action), a = a.next; while (a !== i);
        $r(o, t.memoizedState) || (Pn = !0), t.memoizedState = o, t.baseQueue === null && (t.baseState = o), n.lastRenderedState = o
    }
    return [o, r]
}

function LR() {}

function FR(e, t) {
    var n = ct,
        r = pr(),
        i = t(),
        o = !$r(r.memoizedState, i);
    if (o && (r.memoizedState = i, Pn = !0), r = r.queue, bE(VR.bind(null, n, r, e), [e]), r.getSnapshot !== t || o || $t !== null && $t.memoizedState.tag & 1) {
        if (n.flags |= 2048, Bf(9, HR.bind(null, n, r, i, t), void 0, null), Ft === null) throw Error(G(349));
        ms & 30 || UR(n, t, i)
    }
    return i
}

function UR(e, t, n) {
    e.flags |= 16384, e = {
        getSnapshot: t,
        value: n
    }, t = ct.updateQueue, t === null ? (t = {
        lastEffect: null,
        stores: null
    }, ct.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e))
}

function HR(e, t, n, r) {
    t.value = n, t.getSnapshot = r, zR(t) && WR(e)
}

function VR(e, t, n) {
    return n(function() {
        zR(t) && WR(e)
    })
}

function zR(e) {
    var t = e.getSnapshot;
    e = e.value;
    try {
        var n = t();
        return !$r(e, n)
    } catch {
        return !0
    }
}

function WR(e) {
    var t = Xi(e, 1);
    t !== null && Rr(t, e, 1, -1)
}

function vP(e) {
    var t = Gr();
    return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: jf,
        lastRenderedState: e
    }, t.queue = e, e = e.dispatch = IU.bind(null, ct, e), [t.memoizedState, e]
}

function Bf(e, t, n, r) {
    return e = {
        tag: e,
        create: t,
        destroy: n,
        deps: r,
        next: null
    }, t = ct.updateQueue, t === null ? (t = {
        lastEffect: null,
        stores: null
    }, ct.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e)), e
}

function GR() {
    return pr().memoizedState
}

function Np(e, t, n, r) {
    var i = Gr();
    ct.flags |= e, i.memoizedState = Bf(1 | t, n, void 0, r === void 0 ? null : r)
}

function Fy(e, t, n, r) {
    var i = pr();
    r = r === void 0 ? null : r;
    var o = void 0;
    if (It !== null) {
        var a = It.memoizedState;
        if (o = a.destroy, r !== null && gE(r, a.deps)) {
            i.memoizedState = Bf(t, n, o, r);
            return
        }
    }
    ct.flags |= e, i.memoizedState = Bf(1 | t, n, o, r)
}

function bP(e, t) {
    return Np(8390656, 8, e, t)
}

function bE(e, t) {
    return Fy(2048, 8, e, t)
}

function qR(e, t) {
    return Fy(4, 2, e, t)
}

function KR(e, t) {
    return Fy(4, 4, e, t)
}

function QR(e, t) {
    if (typeof t == "function") return e = e(), t(e),
        function() {
            t(null)
        };
    if (t != null) return e = e(), t.current = e,
        function() {
            t.current = null
        }
}

function YR(e, t, n) {
    return n = n != null ? n.concat([e]) : null, Fy(4, 4, QR.bind(null, t, e), n)
}

function wE() {}

function XR(e, t) {
    var n = pr();
    t = t === void 0 ? null : t;
    var r = n.memoizedState;
    return r !== null && t !== null && gE(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e)
}

function ZR(e, t) {
    var n = pr();
    t = t === void 0 ? null : t;
    var r = n.memoizedState;
    return r !== null && t !== null && gE(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e)
}

function JR(e, t, n) {
    return ms & 21 ? ($r(n, t) || (n = iR(), ct.lanes |= n, gs |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, Pn = !0), e.memoizedState = n)
}

function kU(e, t) {
    var n = Le;
    Le = n !== 0 && 4 > n ? n : 4, e(!0);
    var r = V0.transition;
    V0.transition = {};
    try {
        e(!1), t()
    } finally {
        Le = n, V0.transition = r
    }
}

function ej() {
    return pr().memoizedState
}

function CU(e, t, n) {
    var r = Ko(e);
    if (n = {
            lane: r,
            action: n,
            hasEagerState: !1,
            eagerState: null,
            next: null
        }, tj(e)) nj(t, n);
    else if (n = BR(e, t, n, r), n !== null) {
        var i = pn();
        Rr(n, e, r, i), rj(n, t, r)
    }
}

function IU(e, t, n) {
    var r = Ko(e),
        i = {
            lane: r,
            action: n,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
    if (tj(e)) nj(t, i);
    else {
        var o = e.alternate;
        if (e.lanes === 0 && (o === null || o.lanes === 0) && (o = t.lastRenderedReducer, o !== null)) try {
            var a = t.lastRenderedState,
                s = o(a, n);
            if (i.hasEagerState = !0, i.eagerState = s, $r(s, a)) {
                var u = t.interleaved;
                u === null ? (i.next = i, fE(t)) : (i.next = u.next, u.next = i), t.interleaved = i;
                return
            }
        } catch {} finally {}
        n = BR(e, t, i, r), n !== null && (i = pn(), Rr(n, e, r, i), rj(n, t, r))
    }
}

function tj(e) {
    var t = e.alternate;
    return e === ct || t !== null && t === ct
}

function nj(e, t) {
    tf = ym = !0;
    var n = e.pending;
    n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t
}

function rj(e, t, n) {
    if (n & 4194240) {
        var r = t.lanes;
        r &= e.pendingLanes, n |= r, t.lanes = n, XA(e, n)
    }
}
var vm = {
        readContext: hr,
        useCallback: Yt,
        useContext: Yt,
        useEffect: Yt,
        useImperativeHandle: Yt,
        useInsertionEffect: Yt,
        useLayoutEffect: Yt,
        useMemo: Yt,
        useReducer: Yt,
        useRef: Yt,
        useState: Yt,
        useDebugValue: Yt,
        useDeferredValue: Yt,
        useTransition: Yt,
        useMutableSource: Yt,
        useSyncExternalStore: Yt,
        useId: Yt,
        unstable_isNewReconciler: !1
    },
    MU = {
        readContext: hr,
        useCallback: function(e, t) {
            return Gr().memoizedState = [e, t === void 0 ? null : t], e
        },
        useContext: hr,
        useEffect: bP,
        useImperativeHandle: function(e, t, n) {
            return n = n != null ? n.concat([e]) : null, Np(4194308, 4, QR.bind(null, t, e), n)
        },
        useLayoutEffect: function(e, t) {
            return Np(4194308, 4, e, t)
        },
        useInsertionEffect: function(e, t) {
            return Np(4, 2, e, t)
        },
        useMemo: function(e, t) {
            var n = Gr();
            return t = t === void 0 ? null : t, e = e(), n.memoizedState = [e, t], e
        },
        useReducer: function(e, t, n) {
            var r = Gr();
            return t = n !== void 0 ? n(t) : t, r.memoizedState = r.baseState = t, e = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: e,
                lastRenderedState: t
            }, r.queue = e, e = e.dispatch = CU.bind(null, ct, e), [r.memoizedState, e]
        },
        useRef: function(e) {
            var t = Gr();
            return e = {
                current: e
            }, t.memoizedState = e
        },
        useState: vP,
        useDebugValue: wE,
        useDeferredValue: function(e) {
            return Gr().memoizedState = e
        },
        useTransition: function() {
            var e = vP(!1),
                t = e[0];
            return e = kU.bind(null, e[1]), Gr().memoizedState = e, [t, e]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(e, t, n) {
            var r = ct,
                i = Gr();
            if (rt) {
                if (n === void 0) throw Error(G(407));
                n = n()
            } else {
                if (n = t(), Ft === null) throw Error(G(349));
                ms & 30 || UR(r, t, n)
            }
            i.memoizedState = n;
            var o = {
                value: n,
                getSnapshot: t
            };
            return i.queue = o, bP(VR.bind(null, r, o, e), [e]), r.flags |= 2048, Bf(9, HR.bind(null, r, o, n, t), void 0, null), n
        },
        useId: function() {
            var e = Gr(),
                t = Ft.identifierPrefix;
            if (rt) {
                var n = ji,
                    r = Ri;
                n = (r & ~(1 << 32 - Nr(r) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = Rf++, 0 < n && (t += "H" + n.toString(32)), t += ":"
            } else n = OU++, t = ":" + t + "r" + n.toString(32) + ":";
            return e.memoizedState = t
        },
        unstable_isNewReconciler: !1
    },
    NU = {
        readContext: hr,
        useCallback: XR,
        useContext: hr,
        useEffect: bE,
        useImperativeHandle: YR,
        useInsertionEffect: qR,
        useLayoutEffect: KR,
        useMemo: ZR,
        useReducer: z0,
        useRef: GR,
        useState: function() {
            return z0(jf)
        },
        useDebugValue: wE,
        useDeferredValue: function(e) {
            var t = pr();
            return JR(t, It.memoizedState, e)
        },
        useTransition: function() {
            var e = z0(jf)[0],
                t = pr().memoizedState;
            return [e, t]
        },
        useMutableSource: LR,
        useSyncExternalStore: FR,
        useId: ej,
        unstable_isNewReconciler: !1
    },
    RU = {
        readContext: hr,
        useCallback: XR,
        useContext: hr,
        useEffect: bE,
        useImperativeHandle: YR,
        useInsertionEffect: qR,
        useLayoutEffect: KR,
        useMemo: ZR,
        useReducer: W0,
        useRef: GR,
        useState: function() {
            return W0(jf)
        },
        useDebugValue: wE,
        useDeferredValue: function(e) {
            var t = pr();
            return It === null ? t.memoizedState = e : JR(t, It.memoizedState, e)
        },
        useTransition: function() {
            var e = W0(jf)[0],
                t = pr().memoizedState;
            return [e, t]
        },
        useMutableSource: LR,
        useSyncExternalStore: FR,
        useId: ej,
        unstable_isNewReconciler: !1
    };

function Sr(e, t) {
    if (e && e.defaultProps) {
        t = dt({}, t), e = e.defaultProps;
        for (var n in e) t[n] === void 0 && (t[n] = e[n]);
        return t
    }
    return t
}

function Fw(e, t, n, r) {
    t = e.memoizedState, n = n(r, t), n = n == null ? t : dt({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n)
}
var Uy = {
    isMounted: function(e) {
        return (e = e._reactInternals) ? Ns(e) === e : !1
    },
    enqueueSetState: function(e, t, n) {
        e = e._reactInternals;
        var r = pn(),
            i = Ko(e),
            o = Fi(r, i);
        o.payload = t, n != null && (o.callback = n), t = Go(e, o, i), t !== null && (Rr(t, e, i, r), Ip(t, e, i))
    },
    enqueueReplaceState: function(e, t, n) {
        e = e._reactInternals;
        var r = pn(),
            i = Ko(e),
            o = Fi(r, i);
        o.tag = 1, o.payload = t, n != null && (o.callback = n), t = Go(e, o, i), t !== null && (Rr(t, e, i, r), Ip(t, e, i))
    },
    enqueueForceUpdate: function(e, t) {
        e = e._reactInternals;
        var n = pn(),
            r = Ko(e),
            i = Fi(n, r);
        i.tag = 2, t != null && (i.callback = t), t = Go(e, i, r), t !== null && (Rr(t, e, r, n), Ip(t, e, r))
    }
};

function wP(e, t, n, r, i, o, a) {
    return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, o, a) : t.prototype && t.prototype.isPureReactComponent ? !Of(n, r) || !Of(i, o) : !0
}

function ij(e, t, n) {
    var r = !1,
        i = ta,
        o = t.contextType;
    return typeof o == "object" && o !== null ? o = hr(o) : (i = In(t) ? hs : sn.current, r = t.contextTypes, o = (r = r != null) ? Hu(e, i) : ta), t = new t(n, o), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = Uy, e.stateNode = t, t._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = o), t
}

function xP(e, t, n, r) {
    e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Uy.enqueueReplaceState(t, t.state, null)
}

function Uw(e, t, n, r) {
    var i = e.stateNode;
    i.props = n, i.state = e.memoizedState, i.refs = {}, dE(e);
    var o = t.contextType;
    typeof o == "object" && o !== null ? i.context = hr(o) : (o = In(t) ? hs : sn.current, i.context = Hu(e, o)), i.state = e.memoizedState, o = t.getDerivedStateFromProps, typeof o == "function" && (Fw(e, t, o, n), i.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (t = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), t !== i.state && Uy.enqueueReplaceState(i, i.state, null), mm(e, n, i, r), i.state = e.memoizedState), typeof i.componentDidMount == "function" && (e.flags |= 4194308)
}

function Gu(e, t) {
    try {
        var n = "",
            r = t;
        do n += uF(r), r = r.return; while (r);
        var i = n
    } catch (o) {
        i = `
Error generating stack: ` + o.message + `
` + o.stack
    }
    return {
        value: e,
        source: t,
        stack: i,
        digest: null
    }
}

function G0(e, t, n) {
    return {
        value: e,
        source: null,
        stack: n ? ? null,
        digest: t ? ? null
    }
}

function Hw(e, t) {
    try {
        console.error(t.value)
    } catch (n) {
        setTimeout(function() {
            throw n
        })
    }
}
var jU = typeof WeakMap == "function" ? WeakMap : Map;

function oj(e, t, n) {
    n = Fi(-1, n), n.tag = 3, n.payload = {
        element: null
    };
    var r = t.value;
    return n.callback = function() {
        wm || (wm = !0, Zw = r), Hw(e, t)
    }, n
}

function aj(e, t, n) {
    n = Fi(-1, n), n.tag = 3;
    var r = e.type.getDerivedStateFromError;
    if (typeof r == "function") {
        var i = t.value;
        n.payload = function() {
            return r(i)
        }, n.callback = function() {
            Hw(e, t)
        }
    }
    var o = e.stateNode;
    return o !== null && typeof o.componentDidCatch == "function" && (n.callback = function() {
        Hw(e, t), typeof r != "function" && (qo === null ? qo = new Set([this]) : qo.add(this));
        var a = t.stack;
        this.componentDidCatch(t.value, {
            componentStack: a !== null ? a : ""
        })
    }), n
}

function AP(e, t, n) {
    var r = e.pingCache;
    if (r === null) {
        r = e.pingCache = new jU;
        var i = new Set;
        r.set(t, i)
    } else i = r.get(t), i === void 0 && (i = new Set, r.set(t, i));
    i.has(n) || (i.add(n), e = QU.bind(null, e, t, n), t.then(e, e))
}

function EP(e) {
    do {
        var t;
        if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e;
        e = e.return
    } while (e !== null);
    return null
}

function SP(e, t, n, r, i) {
    return e.mode & 1 ? (e.flags |= 65536, e.lanes = i, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = Fi(-1, 1), t.tag = 2, Go(n, t, 1))), n.lanes |= 1), e)
}
var BU = co.ReactCurrentOwner,
    Pn = !1;

function cn(e, t, n, r) {
    t.child = e === null ? jR(t, null, n, r) : zu(t, e.child, n, r)
}

function _P(e, t, n, r, i) {
    n = n.render;
    var o = t.ref;
    return Iu(t, i), r = yE(e, t, n, r, o, i), n = vE(), e !== null && !Pn ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Zi(e, t, i)) : (rt && n && oE(t), t.flags |= 1, cn(e, t, r, i), t.child)
}

function TP(e, t, n, r, i) {
    if (e === null) {
        var o = n.type;
        return typeof o == "function" && !OE(o) && o.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = o, sj(e, t, o, r, i)) : (e = Dp(n.type, null, r, t, t.mode, i), e.ref = t.ref, e.return = t, t.child = e)
    }
    if (o = e.child, !(e.lanes & i)) {
        var a = o.memoizedProps;
        if (n = n.compare, n = n !== null ? n : Of, n(a, r) && e.ref === t.ref) return Zi(e, t, i)
    }
    return t.flags |= 1, e = Qo(o, r), e.ref = t.ref, e.return = t, t.child = e
}

function sj(e, t, n, r, i) {
    if (e !== null) {
        var o = e.memoizedProps;
        if (Of(o, r) && e.ref === t.ref)
            if (Pn = !1, t.pendingProps = r = o, (e.lanes & i) !== 0) e.flags & 131072 && (Pn = !0);
            else return t.lanes = e.lanes, Zi(e, t, i)
    }
    return Vw(e, t, n, r, i)
}

function uj(e, t, n) {
    var r = t.pendingProps,
        i = r.children,
        o = e !== null ? e.memoizedState : null;
    if (r.mode === "hidden")
        if (!(t.mode & 1)) t.memoizedState = {
            baseLanes: 0,
            cachePool: null,
            transitions: null
        }, Qe(mu, Bn), Bn |= n;
        else {
            if (!(n & 1073741824)) return e = o !== null ? o.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = {
                baseLanes: e,
                cachePool: null,
                transitions: null
            }, t.updateQueue = null, Qe(mu, Bn), Bn |= e, null;
            t.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            }, r = o !== null ? o.baseLanes : n, Qe(mu, Bn), Bn |= r
        }
    else o !== null ? (r = o.baseLanes | n, t.memoizedState = null) : r = n, Qe(mu, Bn), Bn |= r;
    return cn(e, t, i, n), t.child
}

function lj(e, t) {
    var n = t.ref;
    (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152)
}

function Vw(e, t, n, r, i) {
    var o = In(n) ? hs : sn.current;
    return o = Hu(t, o), Iu(t, i), n = yE(e, t, n, r, o, i), r = vE(), e !== null && !Pn ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Zi(e, t, i)) : (rt && r && oE(t), t.flags |= 1, cn(e, t, n, i), t.child)
}

function PP(e, t, n, r, i) {
    if (In(n)) {
        var o = !0;
        cm(t)
    } else o = !1;
    if (Iu(t, i), t.stateNode === null) Rp(e, t), ij(t, n, r), Uw(t, n, r, i), r = !0;
    else if (e === null) {
        var a = t.stateNode,
            s = t.memoizedProps;
        a.props = s;
        var u = a.context,
            l = n.contextType;
        typeof l == "object" && l !== null ? l = hr(l) : (l = In(n) ? hs : sn.current, l = Hu(t, l));
        var c = n.getDerivedStateFromProps,
            f = typeof c == "function" || typeof a.getSnapshotBeforeUpdate == "function";
        f || typeof a.UNSAFE_componentWillReceiveProps != "function" && typeof a.componentWillReceiveProps != "function" || (s !== r || u !== l) && xP(t, a, r, l), Co = !1;
        var d = t.memoizedState;
        a.state = d, mm(t, r, a, i), u = t.memoizedState, s !== r || d !== u || Cn.current || Co ? (typeof c == "function" && (Fw(t, n, c, r), u = t.memoizedState), (s = Co || wP(t, n, s, r, d, u, l)) ? (f || typeof a.UNSAFE_componentWillMount != "function" && typeof a.componentWillMount != "function" || (typeof a.componentWillMount == "function" && a.componentWillMount(), typeof a.UNSAFE_componentWillMount == "function" && a.UNSAFE_componentWillMount()), typeof a.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof a.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = u), a.props = r, a.state = u, a.context = l, r = s) : (typeof a.componentDidMount == "function" && (t.flags |= 4194308), r = !1)
    } else {
        a = t.stateNode, DR(e, t), s = t.memoizedProps, l = t.type === t.elementType ? s : Sr(t.type, s), a.props = l, f = t.pendingProps, d = a.context, u = n.contextType, typeof u == "object" && u !== null ? u = hr(u) : (u = In(n) ? hs : sn.current, u = Hu(t, u));
        var h = n.getDerivedStateFromProps;
        (c = typeof h == "function" || typeof a.getSnapshotBeforeUpdate == "function") || typeof a.UNSAFE_componentWillReceiveProps != "function" && typeof a.componentWillReceiveProps != "function" || (s !== f || d !== u) && xP(t, a, r, u), Co = !1, d = t.memoizedState, a.state = d, mm(t, r, a, i);
        var m = t.memoizedState;
        s !== f || d !== m || Cn.current || Co ? (typeof h == "function" && (Fw(t, n, h, r), m = t.memoizedState), (l = Co || wP(t, n, l, r, d, m, u) || !1) ? (c || typeof a.UNSAFE_componentWillUpdate != "function" && typeof a.componentWillUpdate != "function" || (typeof a.componentWillUpdate == "function" && a.componentWillUpdate(r, m, u), typeof a.UNSAFE_componentWillUpdate == "function" && a.UNSAFE_componentWillUpdate(r, m, u)), typeof a.componentDidUpdate == "function" && (t.flags |= 4), typeof a.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof a.componentDidUpdate != "function" || s === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), typeof a.getSnapshotBeforeUpdate != "function" || s === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = m), a.props = r, a.state = m, a.context = u, r = l) : (typeof a.componentDidUpdate != "function" || s === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), typeof a.getSnapshotBeforeUpdate != "function" || s === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), r = !1)
    }
    return zw(e, t, n, r, o, i)
}

function zw(e, t, n, r, i, o) {
    lj(e, t);
    var a = (t.flags & 128) !== 0;
    if (!r && !a) return i && dP(t, n, !1), Zi(e, t, o);
    r = t.stateNode, BU.current = t;
    var s = a && typeof n.getDerivedStateFromError != "function" ? null : r.render();
    return t.flags |= 1, e !== null && a ? (t.child = zu(t, e.child, null, o), t.child = zu(t, null, s, o)) : cn(e, t, s, o), t.memoizedState = r.state, i && dP(t, n, !0), t.child
}

function cj(e) {
    var t = e.stateNode;
    t.pendingContext ? fP(e, t.pendingContext, t.pendingContext !== t.context) : t.context && fP(e, t.context, !1), hE(e, t.containerInfo)
}

function OP(e, t, n, r, i) {
    return Vu(), sE(i), t.flags |= 256, cn(e, t, n, r), t.child
}
var Ww = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};

function Gw(e) {
    return {
        baseLanes: e,
        cachePool: null,
        transitions: null
    }
}

function fj(e, t, n) {
    var r = t.pendingProps,
        i = st.current,
        o = !1,
        a = (t.flags & 128) !== 0,
        s;
    if ((s = a) || (s = e !== null && e.memoizedState === null ? !1 : (i & 2) !== 0), s ? (o = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (i |= 1), Qe(st, i & 1), e === null) return $w(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (a = r.children, e = r.fallback, o ? (r = t.mode, o = t.child, a = {
        mode: "hidden",
        children: a
    }, !(r & 1) && o !== null ? (o.childLanes = 0, o.pendingProps = a) : o = zy(a, r, 0, null), e = es(e, r, n, null), o.return = t, e.return = t, o.sibling = e, t.child = o, t.child.memoizedState = Gw(n), t.memoizedState = Ww, e) : xE(t, a));
    if (i = e.memoizedState, i !== null && (s = i.dehydrated, s !== null)) return DU(e, t, a, r, s, i, n);
    if (o) {
        o = r.fallback, a = t.mode, i = e.child, s = i.sibling;
        var u = {
            mode: "hidden",
            children: r.children
        };
        return !(a & 1) && t.child !== i ? (r = t.child, r.childLanes = 0, r.pendingProps = u, t.deletions = null) : (r = Qo(i, u), r.subtreeFlags = i.subtreeFlags & 14680064), s !== null ? o = Qo(s, o) : (o = es(o, a, n, null), o.flags |= 2), o.return = t, r.return = t, r.sibling = o, t.child = r, r = o, o = t.child, a = e.child.memoizedState, a = a === null ? Gw(n) : {
            baseLanes: a.baseLanes | n,
            cachePool: null,
            transitions: a.transitions
        }, o.memoizedState = a, o.childLanes = e.childLanes & ~n, t.memoizedState = Ww, r
    }
    return o = e.child, e = o.sibling, r = Qo(o, {
        mode: "visible",
        children: r.children
    }), !(t.mode & 1) && (r.lanes = n), r.return = t, r.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = r, t.memoizedState = null, r
}

function xE(e, t) {
    return t = zy({
        mode: "visible",
        children: t
    }, e.mode, 0, null), t.return = e, e.child = t
}

function Gh(e, t, n, r) {
    return r !== null && sE(r), zu(t, e.child, null, n), e = xE(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e
}

function DU(e, t, n, r, i, o, a) {
    if (n) return t.flags & 256 ? (t.flags &= -257, r = G0(Error(G(422))), Gh(e, t, a, r)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (o = r.fallback, i = t.mode, r = zy({
        mode: "visible",
        children: r.children
    }, i, 0, null), o = es(o, i, a, null), o.flags |= 2, r.return = t, o.return = t, r.sibling = o, t.child = r, t.mode & 1 && zu(t, e.child, null, a), t.child.memoizedState = Gw(a), t.memoizedState = Ww, o);
    if (!(t.mode & 1)) return Gh(e, t, a, null);
    if (i.data === "$!") {
        if (r = i.nextSibling && i.nextSibling.dataset, r) var s = r.dgst;
        return r = s, o = Error(G(419)), r = G0(o, r, void 0), Gh(e, t, a, r)
    }
    if (s = (a & e.childLanes) !== 0, Pn || s) {
        if (r = Ft, r !== null) {
            switch (a & -a) {
                case 4:
                    i = 2;
                    break;
                case 16:
                    i = 8;
                    break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                    i = 32;
                    break;
                case 536870912:
                    i = 268435456;
                    break;
                default:
                    i = 0
            }
            i = i & (r.suspendedLanes | a) ? 0 : i, i !== 0 && i !== o.retryLane && (o.retryLane = i, Xi(e, i), Rr(r, e, i, -1))
        }
        return PE(), r = G0(Error(G(421))), Gh(e, t, a, r)
    }
    return i.data === "$?" ? (t.flags |= 128, t.child = e.child, t = YU.bind(null, e), i._reactRetry = t, null) : (e = o.treeContext, Fn = Wo(i.nextSibling), Un = t, rt = !0, Or = null, e !== null && (rr[ir++] = Ri, rr[ir++] = ji, rr[ir++] = ps, Ri = e.id, ji = e.overflow, ps = t), t = xE(t, r.children), t.flags |= 4096, t)
}

function kP(e, t, n) {
    e.lanes |= t;
    var r = e.alternate;
    r !== null && (r.lanes |= t), Lw(e.return, t, n)
}

function q0(e, t, n, r, i) {
    var o = e.memoizedState;
    o === null ? e.memoizedState = {
        isBackwards: t,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: n,
        tailMode: i
    } : (o.isBackwards = t, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i)
}

function dj(e, t, n) {
    var r = t.pendingProps,
        i = r.revealOrder,
        o = r.tail;
    if (cn(e, t, r.children, n), r = st.current, r & 2) r = r & 1 | 2, t.flags |= 128;
    else {
        if (e !== null && e.flags & 128) e: for (e = t.child; e !== null;) {
            if (e.tag === 13) e.memoizedState !== null && kP(e, n, t);
            else if (e.tag === 19) kP(e, n, t);
            else if (e.child !== null) {
                e.child.return = e, e = e.child;
                continue
            }
            if (e === t) break e;
            for (; e.sibling === null;) {
                if (e.return === null || e.return === t) break e;
                e = e.return
            }
            e.sibling.return = e.return, e = e.sibling
        }
        r &= 1
    }
    if (Qe(st, r), !(t.mode & 1)) t.memoizedState = null;
    else switch (i) {
        case "forwards":
            for (n = t.child, i = null; n !== null;) e = n.alternate, e !== null && gm(e) === null && (i = n), n = n.sibling;
            n = i, n === null ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), q0(t, !1, i, n, o);
            break;
        case "backwards":
            for (n = null, i = t.child, t.child = null; i !== null;) {
                if (e = i.alternate, e !== null && gm(e) === null) {
                    t.child = i;
                    break
                }
                e = i.sibling, i.sibling = n, n = i, i = e
            }
            q0(t, !0, n, null, o);
            break;
        case "together":
            q0(t, !1, null, null, void 0);
            break;
        default:
            t.memoizedState = null
    }
    return t.child
}

function Rp(e, t) {
    !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2)
}

function Zi(e, t, n) {
    if (e !== null && (t.dependencies = e.dependencies), gs |= t.lanes, !(n & t.childLanes)) return null;
    if (e !== null && t.child !== e.child) throw Error(G(153));
    if (t.child !== null) {
        for (e = t.child, n = Qo(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;) e = e.sibling, n = n.sibling = Qo(e, e.pendingProps), n.return = t;
        n.sibling = null
    }
    return t.child
}

function $U(e, t, n) {
    switch (t.tag) {
        case 3:
            cj(t), Vu();
            break;
        case 5:
            $R(t);
            break;
        case 1:
            In(t.type) && cm(t);
            break;
        case 4:
            hE(t, t.stateNode.containerInfo);
            break;
        case 10:
            var r = t.type._context,
                i = t.memoizedProps.value;
            Qe(hm, r._currentValue), r._currentValue = i;
            break;
        case 13:
            if (r = t.memoizedState, r !== null) return r.dehydrated !== null ? (Qe(st, st.current & 1), t.flags |= 128, null) : n & t.child.childLanes ? fj(e, t, n) : (Qe(st, st.current & 1), e = Zi(e, t, n), e !== null ? e.sibling : null);
            Qe(st, st.current & 1);
            break;
        case 19:
            if (r = (n & t.childLanes) !== 0, e.flags & 128) {
                if (r) return dj(e, t, n);
                t.flags |= 128
            }
            if (i = t.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), Qe(st, st.current), r) break;
            return null;
        case 22:
        case 23:
            return t.lanes = 0, uj(e, t, n)
    }
    return Zi(e, t, n)
}
var hj, qw, pj, mj;
hj = function(e, t) {
    for (var n = t.child; n !== null;) {
        if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode);
        else if (n.tag !== 4 && n.child !== null) {
            n.child.return = n, n = n.child;
            continue
        }
        if (n === t) break;
        for (; n.sibling === null;) {
            if (n.return === null || n.return === t) return;
            n = n.return
        }
        n.sibling.return = n.return, n = n.sibling
    }
};
qw = function() {};
pj = function(e, t, n, r) {
    var i = e.memoizedProps;
    if (i !== r) {
        e = t.stateNode, La(ai.current);
        var o = null;
        switch (n) {
            case "input":
                i = mw(e, i), r = mw(e, r), o = [];
                break;
            case "select":
                i = dt({}, i, {
                    value: void 0
                }), r = dt({}, r, {
                    value: void 0
                }), o = [];
                break;
            case "textarea":
                i = vw(e, i), r = vw(e, r), o = [];
                break;
            default:
                typeof i.onClick != "function" && typeof r.onClick == "function" && (e.onclick = um)
        }
        ww(n, r);
        var a;
        n = null;
        for (l in i)
            if (!r.hasOwnProperty(l) && i.hasOwnProperty(l) && i[l] != null)
                if (l === "style") {
                    var s = i[l];
                    for (a in s) s.hasOwnProperty(a) && (n || (n = {}), n[a] = "")
                } else l !== "dangerouslySetInnerHTML" && l !== "children" && l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && l !== "autoFocus" && (xf.hasOwnProperty(l) ? o || (o = []) : (o = o || []).push(l, null));
        for (l in r) {
            var u = r[l];
            if (s = i != null ? i[l] : void 0, r.hasOwnProperty(l) && u !== s && (u != null || s != null))
                if (l === "style")
                    if (s) {
                        for (a in s) !s.hasOwnProperty(a) || u && u.hasOwnProperty(a) || (n || (n = {}), n[a] = "");
                        for (a in u) u.hasOwnProperty(a) && s[a] !== u[a] && (n || (n = {}), n[a] = u[a])
                    } else n || (o || (o = []), o.push(l, n)), n = u;
            else l === "dangerouslySetInnerHTML" ? (u = u ? u.__html : void 0, s = s ? s.__html : void 0, u != null && s !== u && (o = o || []).push(l, u)) : l === "children" ? typeof u != "string" && typeof u != "number" || (o = o || []).push(l, "" + u) : l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && (xf.hasOwnProperty(l) ? (u != null && l === "onScroll" && Xe("scroll", e), o || s === u || (o = [])) : (o = o || []).push(l, u))
        }
        n && (o = o || []).push("style", n);
        var l = o;
        (t.updateQueue = l) && (t.flags |= 4)
    }
};
mj = function(e, t, n, r) {
    n !== r && (t.flags |= 4)
};

function gc(e, t) {
    if (!rt) switch (e.tailMode) {
        case "hidden":
            t = e.tail;
            for (var n = null; t !== null;) t.alternate !== null && (n = t), t = t.sibling;
            n === null ? e.tail = null : n.sibling = null;
            break;
        case "collapsed":
            n = e.tail;
            for (var r = null; n !== null;) n.alternate !== null && (r = n), n = n.sibling;
            r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null
    }
}

function Xt(e) {
    var t = e.alternate !== null && e.alternate.child === e.child,
        n = 0,
        r = 0;
    if (t)
        for (var i = e.child; i !== null;) n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = e, i = i.sibling;
    else
        for (i = e.child; i !== null;) n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling;
    return e.subtreeFlags |= r, e.childLanes = n, t
}

function LU(e, t, n) {
    var r = t.pendingProps;
    switch (aE(t), t.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return Xt(t), null;
        case 1:
            return In(t.type) && lm(), Xt(t), null;
        case 3:
            return r = t.stateNode, Wu(), et(Cn), et(sn), mE(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (e === null || e.child === null) && (zh(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, Or !== null && (tx(Or), Or = null))), qw(e, t), Xt(t), null;
        case 5:
            pE(t);
            var i = La(Nf.current);
            if (n = t.type, e !== null && t.stateNode != null) pj(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152);
            else {
                if (!r) {
                    if (t.stateNode === null) throw Error(G(166));
                    return Xt(t), null
                }
                if (e = La(ai.current), zh(t)) {
                    r = t.stateNode, n = t.type;
                    var o = t.memoizedProps;
                    switch (r[Zr] = t, r[If] = o, e = (t.mode & 1) !== 0, n) {
                        case "dialog":
                            Xe("cancel", r), Xe("close", r);
                            break;
                        case "iframe":
                        case "object":
                        case "embed":
                            Xe("load", r);
                            break;
                        case "video":
                        case "audio":
                            for (i = 0; i < Hc.length; i++) Xe(Hc[i], r);
                            break;
                        case "source":
                            Xe("error", r);
                            break;
                        case "img":
                        case "image":
                        case "link":
                            Xe("error", r), Xe("load", r);
                            break;
                        case "details":
                            Xe("toggle", r);
                            break;
                        case "input":
                            $T(r, o), Xe("invalid", r);
                            break;
                        case "select":
                            r._wrapperState = {
                                wasMultiple: !!o.multiple
                            }, Xe("invalid", r);
                            break;
                        case "textarea":
                            FT(r, o), Xe("invalid", r)
                    }
                    ww(n, o), i = null;
                    for (var a in o)
                        if (o.hasOwnProperty(a)) {
                            var s = o[a];
                            a === "children" ? typeof s == "string" ? r.textContent !== s && (o.suppressHydrationWarning !== !0 && Vh(r.textContent, s, e), i = ["children", s]) : typeof s == "number" && r.textContent !== "" + s && (o.suppressHydrationWarning !== !0 && Vh(r.textContent, s, e), i = ["children", "" + s]) : xf.hasOwnProperty(a) && s != null && a === "onScroll" && Xe("scroll", r)
                        }
                    switch (n) {
                        case "input":
                            jh(r), LT(r, o, !0);
                            break;
                        case "textarea":
                            jh(r), UT(r);
                            break;
                        case "select":
                        case "option":
                            break;
                        default:
                            typeof o.onClick == "function" && (r.onclick = um)
                    }
                    r = i, t.updateQueue = r, r !== null && (t.flags |= 4)
                } else {
                    a = i.nodeType === 9 ? i : i.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = VN(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = a.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = a.createElement(n, {
                        is: r.is
                    }) : (e = a.createElement(n), n === "select" && (a = e, r.multiple ? a.multiple = !0 : r.size && (a.size = r.size))) : e = a.createElementNS(e, n), e[Zr] = t, e[If] = r, hj(e, t, !1, !1), t.stateNode = e;
                    e: {
                        switch (a = xw(n, r), n) {
                            case "dialog":
                                Xe("cancel", e), Xe("close", e), i = r;
                                break;
                            case "iframe":
                            case "object":
                            case "embed":
                                Xe("load", e), i = r;
                                break;
                            case "video":
                            case "audio":
                                for (i = 0; i < Hc.length; i++) Xe(Hc[i], e);
                                i = r;
                                break;
                            case "source":
                                Xe("error", e), i = r;
                                break;
                            case "img":
                            case "image":
                            case "link":
                                Xe("error", e), Xe("load", e), i = r;
                                break;
                            case "details":
                                Xe("toggle", e), i = r;
                                break;
                            case "input":
                                $T(e, r), i = mw(e, r), Xe("invalid", e);
                                break;
                            case "option":
                                i = r;
                                break;
                            case "select":
                                e._wrapperState = {
                                    wasMultiple: !!r.multiple
                                }, i = dt({}, r, {
                                    value: void 0
                                }), Xe("invalid", e);
                                break;
                            case "textarea":
                                FT(e, r), i = vw(e, r), Xe("invalid", e);
                                break;
                            default:
                                i = r
                        }
                        ww(n, i),
                        s = i;
                        for (o in s)
                            if (s.hasOwnProperty(o)) {
                                var u = s[o];
                                o === "style" ? GN(e, u) : o === "dangerouslySetInnerHTML" ? (u = u ? u.__html : void 0, u != null && zN(e, u)) : o === "children" ? typeof u == "string" ? (n !== "textarea" || u !== "") && Af(e, u) : typeof u == "number" && Af(e, "" + u) : o !== "suppressContentEditableWarning" && o !== "suppressHydrationWarning" && o !== "autoFocus" && (xf.hasOwnProperty(o) ? u != null && o === "onScroll" && Xe("scroll", e) : u != null && WA(e, o, u, a))
                            }
                        switch (n) {
                            case "input":
                                jh(e), LT(e, r, !1);
                                break;
                            case "textarea":
                                jh(e), UT(e);
                                break;
                            case "option":
                                r.value != null && e.setAttribute("value", "" + ea(r.value));
                                break;
                            case "select":
                                e.multiple = !!r.multiple, o = r.value, o != null ? Pu(e, !!r.multiple, o, !1) : r.defaultValue != null && Pu(e, !!r.multiple, r.defaultValue, !0);
                                break;
                            default:
                                typeof i.onClick == "function" && (e.onclick = um)
                        }
                        switch (n) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                r = !!r.autoFocus;
                                break e;
                            case "img":
                                r = !0;
                                break e;
                            default:
                                r = !1
                        }
                    }
                    r && (t.flags |= 4)
                }
                t.ref !== null && (t.flags |= 512, t.flags |= 2097152)
            }
            return Xt(t), null;
        case 6:
            if (e && t.stateNode != null) mj(e, t, e.memoizedProps, r);
            else {
                if (typeof r != "string" && t.stateNode === null) throw Error(G(166));
                if (n = La(Nf.current), La(ai.current), zh(t)) {
                    if (r = t.stateNode, n = t.memoizedProps, r[Zr] = t, (o = r.nodeValue !== n) && (e = Un, e !== null)) switch (e.tag) {
                        case 3:
                            Vh(r.nodeValue, n, (e.mode & 1) !== 0);
                            break;
                        case 5:
                            e.memoizedProps.suppressHydrationWarning !== !0 && Vh(r.nodeValue, n, (e.mode & 1) !== 0)
                    }
                    o && (t.flags |= 4)
                } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[Zr] = t, t.stateNode = r
            }
            return Xt(t), null;
        case 13:
            if (et(st), r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
                if (rt && Fn !== null && t.mode & 1 && !(t.flags & 128)) NR(), Vu(), t.flags |= 98560, o = !1;
                else if (o = zh(t), r !== null && r.dehydrated !== null) {
                    if (e === null) {
                        if (!o) throw Error(G(318));
                        if (o = t.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(G(317));
                        o[Zr] = t
                    } else Vu(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4;
                    Xt(t), o = !1
                } else Or !== null && (tx(Or), Or = null), o = !0;
                if (!o) return t.flags & 65536 ? t : null
            }
            return t.flags & 128 ? (t.lanes = n, t) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192, t.mode & 1 && (e === null || st.current & 1 ? Mt === 0 && (Mt = 3) : PE())), t.updateQueue !== null && (t.flags |= 4), Xt(t), null);
        case 4:
            return Wu(), qw(e, t), e === null && kf(t.stateNode.containerInfo), Xt(t), null;
        case 10:
            return cE(t.type._context), Xt(t), null;
        case 17:
            return In(t.type) && lm(), Xt(t), null;
        case 19:
            if (et(st), o = t.memoizedState, o === null) return Xt(t), null;
            if (r = (t.flags & 128) !== 0, a = o.rendering, a === null)
                if (r) gc(o, !1);
                else {
                    if (Mt !== 0 || e !== null && e.flags & 128)
                        for (e = t.child; e !== null;) {
                            if (a = gm(e), a !== null) {
                                for (t.flags |= 128, gc(o, !1), r = a.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; n !== null;) o = n, e = r, o.flags &= 14680066, a = o.alternate, a === null ? (o.childLanes = 0, o.lanes = e, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = a.childLanes, o.lanes = a.lanes, o.child = a.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = a.memoizedProps, o.memoizedState = a.memoizedState, o.updateQueue = a.updateQueue, o.type = a.type, e = a.dependencies, o.dependencies = e === null ? null : {
                                    lanes: e.lanes,
                                    firstContext: e.firstContext
                                }), n = n.sibling;
                                return Qe(st, st.current & 1 | 2), t.child
                            }
                            e = e.sibling
                        }
                    o.tail !== null && xt() > qu && (t.flags |= 128, r = !0, gc(o, !1), t.lanes = 4194304)
                }
            else {
                if (!r)
                    if (e = gm(a), e !== null) {
                        if (t.flags |= 128, r = !0, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), gc(o, !0), o.tail === null && o.tailMode === "hidden" && !a.alternate && !rt) return Xt(t), null
                    } else 2 * xt() - o.renderingStartTime > qu && n !== 1073741824 && (t.flags |= 128, r = !0, gc(o, !1), t.lanes = 4194304);
                o.isBackwards ? (a.sibling = t.child, t.child = a) : (n = o.last, n !== null ? n.sibling = a : t.child = a, o.last = a)
            }
            return o.tail !== null ? (t = o.tail, o.rendering = t, o.tail = t.sibling, o.renderingStartTime = xt(), t.sibling = null, n = st.current, Qe(st, r ? n & 1 | 2 : n & 1), t) : (Xt(t), null);
        case 22:
        case 23:
            return TE(), r = t.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (t.flags |= 8192), r && t.mode & 1 ? Bn & 1073741824 && (Xt(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : Xt(t), null;
        case 24:
            return null;
        case 25:
            return null
    }
    throw Error(G(156, t.tag))
}

function FU(e, t) {
    switch (aE(t), t.tag) {
        case 1:
            return In(t.type) && lm(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
        case 3:
            return Wu(), et(Cn), et(sn), mE(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null;
        case 5:
            return pE(t), null;
        case 13:
            if (et(st), e = t.memoizedState, e !== null && e.dehydrated !== null) {
                if (t.alternate === null) throw Error(G(340));
                Vu()
            }
            return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
        case 19:
            return et(st), null;
        case 4:
            return Wu(), null;
        case 10:
            return cE(t.type._context), null;
        case 22:
        case 23:
            return TE(), null;
        case 24:
            return null;
        default:
            return null
    }
}
var qh = !1,
    tn = !1,
    UU = typeof WeakSet == "function" ? WeakSet : Set,
    te = null;

function pu(e, t) {
    var n = e.ref;
    if (n !== null)
        if (typeof n == "function") try {
            n(null)
        } catch (r) {
            yt(e, t, r)
        } else n.current = null
}

function Kw(e, t, n) {
    try {
        n()
    } catch (r) {
        yt(e, t, r)
    }
}
var CP = !1;

function HU(e, t) {
    if (Iw = om, e = wR(), iE(e)) {
        if ("selectionStart" in e) var n = {
            start: e.selectionStart,
            end: e.selectionEnd
        };
        else e: {
            n = (n = e.ownerDocument) && n.defaultView || window;
            var r = n.getSelection && n.getSelection();
            if (r && r.rangeCount !== 0) {
                n = r.anchorNode;
                var i = r.anchorOffset,
                    o = r.focusNode;
                r = r.focusOffset;
                try {
                    n.nodeType, o.nodeType
                } catch {
                    n = null;
                    break e
                }
                var a = 0,
                    s = -1,
                    u = -1,
                    l = 0,
                    c = 0,
                    f = e,
                    d = null;
                t: for (;;) {
                    for (var h; f !== n || i !== 0 && f.nodeType !== 3 || (s = a + i), f !== o || r !== 0 && f.nodeType !== 3 || (u = a + r), f.nodeType === 3 && (a += f.nodeValue.length), (h = f.firstChild) !== null;) d = f, f = h;
                    for (;;) {
                        if (f === e) break t;
                        if (d === n && ++l === i && (s = a), d === o && ++c === r && (u = a), (h = f.nextSibling) !== null) break;
                        f = d, d = f.parentNode
                    }
                    f = h
                }
                n = s === -1 || u === -1 ? null : {
                    start: s,
                    end: u
                }
            } else n = null
        }
        n = n || {
            start: 0,
            end: 0
        }
    } else n = null;
    for (Mw = {
            focusedElem: e,
            selectionRange: n
        }, om = !1, te = t; te !== null;)
        if (t = te, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, te = e;
        else
            for (; te !== null;) {
                t = te;
                try {
                    var m = t.alternate;
                    if (t.flags & 1024) switch (t.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (m !== null) {
                                var p = m.memoizedProps,
                                    y = m.memoizedState,
                                    g = t.stateNode,
                                    b = g.getSnapshotBeforeUpdate(t.elementType === t.type ? p : Sr(t.type, p), y);
                                g.__reactInternalSnapshotBeforeUpdate = b
                            }
                            break;
                        case 3:
                            var v = t.stateNode.containerInfo;
                            v.nodeType === 1 ? v.textContent = "" : v.nodeType === 9 && v.documentElement && v.removeChild(v.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(G(163))
                    }
                } catch (A) {
                    yt(t, t.return, A)
                }
                if (e = t.sibling, e !== null) {
                    e.return = t.return, te = e;
                    break
                }
                te = t.return
            }
    return m = CP, CP = !1, m
}

function nf(e, t, n) {
    var r = t.updateQueue;
    if (r = r !== null ? r.lastEffect : null, r !== null) {
        var i = r = r.next;
        do {
            if ((i.tag & e) === e) {
                var o = i.destroy;
                i.destroy = void 0, o !== void 0 && Kw(t, n, o)
            }
            i = i.next
        } while (i !== r)
    }
}

function Hy(e, t) {
    if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) {
        var n = t = t.next;
        do {
            if ((n.tag & e) === e) {
                var r = n.create;
                n.destroy = r()
            }
            n = n.next
        } while (n !== t)
    }
}

function Qw(e) {
    var t = e.ref;
    if (t !== null) {
        var n = e.stateNode;
        switch (e.tag) {
            case 5:
                e = n;
                break;
            default:
                e = n
        }
        typeof t == "function" ? t(e) : t.current = e
    }
}

function gj(e) {
    var t = e.alternate;
    t !== null && (e.alternate = null, gj(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[Zr], delete t[If], delete t[jw], delete t[SU], delete t[_U])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null
}

function yj(e) {
    return e.tag === 5 || e.tag === 3 || e.tag === 4
}

function IP(e) {
    e: for (;;) {
        for (; e.sibling === null;) {
            if (e.return === null || yj(e.return)) return null;
            e = e.return
        }
        for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) {
            if (e.flags & 2 || e.child === null || e.tag === 4) continue e;
            e.child.return = e, e = e.child
        }
        if (!(e.flags & 2)) return e.stateNode
    }
}

function Yw(e, t, n) {
    var r = e.tag;
    if (r === 5 || r === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = um));
    else if (r !== 4 && (e = e.child, e !== null))
        for (Yw(e, t, n), e = e.sibling; e !== null;) Yw(e, t, n), e = e.sibling
}

function Xw(e, t, n) {
    var r = e.tag;
    if (r === 5 || r === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e);
    else if (r !== 4 && (e = e.child, e !== null))
        for (Xw(e, t, n), e = e.sibling; e !== null;) Xw(e, t, n), e = e.sibling
}
var zt = null,
    Tr = !1;

function Eo(e, t, n) {
    for (n = n.child; n !== null;) vj(e, t, n), n = n.sibling
}

function vj(e, t, n) {
    if (oi && typeof oi.onCommitFiberUnmount == "function") try {
        oi.onCommitFiberUnmount(Ry, n)
    } catch {}
    switch (n.tag) {
        case 5:
            tn || pu(n, t);
        case 6:
            var r = zt,
                i = Tr;
            zt = null, Eo(e, t, n), zt = r, Tr = i, zt !== null && (Tr ? (e = zt, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : zt.removeChild(n.stateNode));
            break;
        case 18:
            zt !== null && (Tr ? (e = zt, n = n.stateNode, e.nodeType === 8 ? F0(e.parentNode, n) : e.nodeType === 1 && F0(e, n), Tf(e)) : F0(zt, n.stateNode));
            break;
        case 4:
            r = zt, i = Tr, zt = n.stateNode.containerInfo, Tr = !0, Eo(e, t, n), zt = r, Tr = i;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            if (!tn && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) {
                i = r = r.next;
                do {
                    var o = i,
                        a = o.destroy;
                    o = o.tag, a !== void 0 && (o & 2 || o & 4) && Kw(n, t, a), i = i.next
                } while (i !== r)
            }
            Eo(e, t, n);
            break;
        case 1:
            if (!tn && (pu(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function")) try {
                r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount()
            } catch (s) {
                yt(n, t, s)
            }
            Eo(e, t, n);
            break;
        case 21:
            Eo(e, t, n);
            break;
        case 22:
            n.mode & 1 ? (tn = (r = tn) || n.memoizedState !== null, Eo(e, t, n), tn = r) : Eo(e, t, n);
            break;
        default:
            Eo(e, t, n)
    }
}

function MP(e) {
    var t = e.updateQueue;
    if (t !== null) {
        e.updateQueue = null;
        var n = e.stateNode;
        n === null && (n = e.stateNode = new UU), t.forEach(function(r) {
            var i = XU.bind(null, e, r);
            n.has(r) || (n.add(r), r.then(i, i))
        })
    }
}

function br(e, t) {
    var n = t.deletions;
    if (n !== null)
        for (var r = 0; r < n.length; r++) {
            var i = n[r];
            try {
                var o = e,
                    a = t,
                    s = a;
                e: for (; s !== null;) {
                    switch (s.tag) {
                        case 5:
                            zt = s.stateNode, Tr = !1;
                            break e;
                        case 3:
                            zt = s.stateNode.containerInfo, Tr = !0;
                            break e;
                        case 4:
                            zt = s.stateNode.containerInfo, Tr = !0;
                            break e
                    }
                    s = s.return
                }
                if (zt === null) throw Error(G(160));
                vj(o, a, i), zt = null, Tr = !1;
                var u = i.alternate;
                u !== null && (u.return = null), i.return = null
            } catch (l) {
                yt(i, t, l)
            }
        }
    if (t.subtreeFlags & 12854)
        for (t = t.child; t !== null;) bj(t, e), t = t.sibling
}

function bj(e, t) {
    var n = e.alternate,
        r = e.flags;
    switch (e.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (br(t, e), Hr(e), r & 4) {
                try {
                    nf(3, e, e.return), Hy(3, e)
                } catch (p) {
                    yt(e, e.return, p)
                }
                try {
                    nf(5, e, e.return)
                } catch (p) {
                    yt(e, e.return, p)
                }
            }
            break;
        case 1:
            br(t, e), Hr(e), r & 512 && n !== null && pu(n, n.return);
            break;
        case 5:
            if (br(t, e), Hr(e), r & 512 && n !== null && pu(n, n.return), e.flags & 32) {
                var i = e.stateNode;
                try {
                    Af(i, "")
                } catch (p) {
                    yt(e, e.return, p)
                }
            }
            if (r & 4 && (i = e.stateNode, i != null)) {
                var o = e.memoizedProps,
                    a = n !== null ? n.memoizedProps : o,
                    s = e.type,
                    u = e.updateQueue;
                if (e.updateQueue = null, u !== null) try {
                    s === "input" && o.type === "radio" && o.name != null && UN(i, o), xw(s, a);
                    var l = xw(s, o);
                    for (a = 0; a < u.length; a += 2) {
                        var c = u[a],
                            f = u[a + 1];
                        c === "style" ? GN(i, f) : c === "dangerouslySetInnerHTML" ? zN(i, f) : c === "children" ? Af(i, f) : WA(i, c, f, l)
                    }
                    switch (s) {
                        case "input":
                            gw(i, o);
                            break;
                        case "textarea":
                            HN(i, o);
                            break;
                        case "select":
                            var d = i._wrapperState.wasMultiple;
                            i._wrapperState.wasMultiple = !!o.multiple;
                            var h = o.value;
                            h != null ? Pu(i, !!o.multiple, h, !1) : d !== !!o.multiple && (o.defaultValue != null ? Pu(i, !!o.multiple, o.defaultValue, !0) : Pu(i, !!o.multiple, o.multiple ? [] : "", !1))
                    }
                    i[If] = o
                } catch (p) {
                    yt(e, e.return, p)
                }
            }
            break;
        case 6:
            if (br(t, e), Hr(e), r & 4) {
                if (e.stateNode === null) throw Error(G(162));
                i = e.stateNode, o = e.memoizedProps;
                try {
                    i.nodeValue = o
                } catch (p) {
                    yt(e, e.return, p)
                }
            }
            break;
        case 3:
            if (br(t, e), Hr(e), r & 4 && n !== null && n.memoizedState.isDehydrated) try {
                Tf(t.containerInfo)
            } catch (p) {
                yt(e, e.return, p)
            }
            break;
        case 4:
            br(t, e), Hr(e);
            break;
        case 13:
            br(t, e), Hr(e), i = e.child, i.flags & 8192 && (o = i.memoizedState !== null, i.stateNode.isHidden = o, !o || i.alternate !== null && i.alternate.memoizedState !== null || (SE = xt())), r & 4 && MP(e);
            break;
        case 22:
            if (c = n !== null && n.memoizedState !== null, e.mode & 1 ? (tn = (l = tn) || c, br(t, e), tn = l) : br(t, e), Hr(e), r & 8192) {
                if (l = e.memoizedState !== null, (e.stateNode.isHidden = l) && !c && e.mode & 1)
                    for (te = e, c = e.child; c !== null;) {
                        for (f = te = c; te !== null;) {
                            switch (d = te, h = d.child, d.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    nf(4, d, d.return);
                                    break;
                                case 1:
                                    pu(d, d.return);
                                    var m = d.stateNode;
                                    if (typeof m.componentWillUnmount == "function") {
                                        r = d, n = d.return;
                                        try {
                                            t = r, m.props = t.memoizedProps, m.state = t.memoizedState, m.componentWillUnmount()
                                        } catch (p) {
                                            yt(r, n, p)
                                        }
                                    }
                                    break;
                                case 5:
                                    pu(d, d.return);
                                    break;
                                case 22:
                                    if (d.memoizedState !== null) {
                                        RP(f);
                                        continue
                                    }
                            }
                            h !== null ? (h.return = d, te = h) : RP(f)
                        }
                        c = c.sibling
                    }
                e: for (c = null, f = e;;) {
                    if (f.tag === 5) {
                        if (c === null) {
                            c = f;
                            try {
                                i = f.stateNode, l ? (o = i.style, typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none") : (s = f.stateNode, u = f.memoizedProps.style, a = u != null && u.hasOwnProperty("display") ? u.display : null, s.style.display = WN("display", a))
                            } catch (p) {
                                yt(e, e.return, p)
                            }
                        }
                    } else if (f.tag === 6) {
                        if (c === null) try {
                            f.stateNode.nodeValue = l ? "" : f.memoizedProps
                        } catch (p) {
                            yt(e, e.return, p)
                        }
                    } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === e) && f.child !== null) {
                        f.child.return = f, f = f.child;
                        continue
                    }
                    if (f === e) break e;
                    for (; f.sibling === null;) {
                        if (f.return === null || f.return === e) break e;
                        c === f && (c = null), f = f.return
                    }
                    c === f && (c = null), f.sibling.return = f.return, f = f.sibling
                }
            }
            break;
        case 19:
            br(t, e), Hr(e), r & 4 && MP(e);
            break;
        case 21:
            break;
        default:
            br(t, e), Hr(e)
    }
}

function Hr(e) {
    var t = e.flags;
    if (t & 2) {
        try {
            e: {
                for (var n = e.return; n !== null;) {
                    if (yj(n)) {
                        var r = n;
                        break e
                    }
                    n = n.return
                }
                throw Error(G(160))
            }
            switch (r.tag) {
                case 5:
                    var i = r.stateNode;
                    r.flags & 32 && (Af(i, ""), r.flags &= -33);
                    var o = IP(e);
                    Xw(e, o, i);
                    break;
                case 3:
                case 4:
                    var a = r.stateNode.containerInfo,
                        s = IP(e);
                    Yw(e, s, a);
                    break;
                default:
                    throw Error(G(161))
            }
        }
        catch (u) {
            yt(e, e.return, u)
        }
        e.flags &= -3
    }
    t & 4096 && (e.flags &= -4097)
}

function VU(e, t, n) {
    te = e, wj(e)
}

function wj(e, t, n) {
    for (var r = (e.mode & 1) !== 0; te !== null;) {
        var i = te,
            o = i.child;
        if (i.tag === 22 && r) {
            var a = i.memoizedState !== null || qh;
            if (!a) {
                var s = i.alternate,
                    u = s !== null && s.memoizedState !== null || tn;
                s = qh;
                var l = tn;
                if (qh = a, (tn = u) && !l)
                    for (te = i; te !== null;) a = te, u = a.child, a.tag === 22 && a.memoizedState !== null ? jP(i) : u !== null ? (u.return = a, te = u) : jP(i);
                for (; o !== null;) te = o, wj(o), o = o.sibling;
                te = i, qh = s, tn = l
            }
            NP(e)
        } else i.subtreeFlags & 8772 && o !== null ? (o.return = i, te = o) : NP(e)
    }
}

function NP(e) {
    for (; te !== null;) {
        var t = te;
        if (t.flags & 8772) {
            var n = t.alternate;
            try {
                if (t.flags & 8772) switch (t.tag) {
                    case 0:
                    case 11:
                    case 15:
                        tn || Hy(5, t);
                        break;
                    case 1:
                        var r = t.stateNode;
                        if (t.flags & 4 && !tn)
                            if (n === null) r.componentDidMount();
                            else {
                                var i = t.elementType === t.type ? n.memoizedProps : Sr(t.type, n.memoizedProps);
                                r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                            }
                        var o = t.updateQueue;
                        o !== null && yP(t, o, r);
                        break;
                    case 3:
                        var a = t.updateQueue;
                        if (a !== null) {
                            if (n = null, t.child !== null) switch (t.child.tag) {
                                case 5:
                                    n = t.child.stateNode;
                                    break;
                                case 1:
                                    n = t.child.stateNode
                            }
                            yP(t, a, n)
                        }
                        break;
                    case 5:
                        var s = t.stateNode;
                        if (n === null && t.flags & 4) {
                            n = s;
                            var u = t.memoizedProps;
                            switch (t.type) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    u.autoFocus && n.focus();
                                    break;
                                case "img":
                                    u.src && (n.src = u.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (t.memoizedState === null) {
                            var l = t.alternate;
                            if (l !== null) {
                                var c = l.memoizedState;
                                if (c !== null) {
                                    var f = c.dehydrated;
                                    f !== null && Tf(f)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(G(163))
                }
                tn || t.flags & 512 && Qw(t)
            } catch (d) {
                yt(t, t.return, d)
            }
        }
        if (t === e) {
            te = null;
            break
        }
        if (n = t.sibling, n !== null) {
            n.return = t.return, te = n;
            break
        }
        te = t.return
    }
}

function RP(e) {
    for (; te !== null;) {
        var t = te;
        if (t === e) {
            te = null;
            break
        }
        var n = t.sibling;
        if (n !== null) {
            n.return = t.return, te = n;
            break
        }
        te = t.return
    }
}

function jP(e) {
    for (; te !== null;) {
        var t = te;
        try {
            switch (t.tag) {
                case 0:
                case 11:
                case 15:
                    var n = t.return;
                    try {
                        Hy(4, t)
                    } catch (u) {
                        yt(t, n, u)
                    }
                    break;
                case 1:
                    var r = t.stateNode;
                    if (typeof r.componentDidMount == "function") {
                        var i = t.return;
                        try {
                            r.componentDidMount()
                        } catch (u) {
                            yt(t, i, u)
                        }
                    }
                    var o = t.return;
                    try {
                        Qw(t)
                    } catch (u) {
                        yt(t, o, u)
                    }
                    break;
                case 5:
                    var a = t.return;
                    try {
                        Qw(t)
                    } catch (u) {
                        yt(t, a, u)
                    }
            }
        } catch (u) {
            yt(t, t.return, u)
        }
        if (t === e) {
            te = null;
            break
        }
        var s = t.sibling;
        if (s !== null) {
            s.return = t.return, te = s;
            break
        }
        te = t.return
    }
}
var zU = Math.ceil,
    bm = co.ReactCurrentDispatcher,
    AE = co.ReactCurrentOwner,
    fr = co.ReactCurrentBatchConfig,
    ke = 0,
    Ft = null,
    Pt = null,
    qt = 0,
    Bn = 0,
    mu = fa(0),
    Mt = 0,
    Df = null,
    gs = 0,
    Vy = 0,
    EE = 0,
    rf = null,
    Sn = null,
    SE = 0,
    qu = 1 / 0,
    Oi = null,
    wm = !1,
    Zw = null,
    qo = null,
    Kh = !1,
    Do = null,
    xm = 0,
    of = 0,
    Jw = null,
    jp = -1,
    Bp = 0;

function pn() {
    return ke & 6 ? xt() : jp !== -1 ? jp : jp = xt()
}

function Ko(e) {
    return e.mode & 1 ? ke & 2 && qt !== 0 ? qt & -qt : PU.transition !== null ? (Bp === 0 && (Bp = iR()), Bp) : (e = Le, e !== 0 || (e = window.event, e = e === void 0 ? 16 : fR(e.type)), e) : 1
}

function Rr(e, t, n, r) {
    if (50 < of ) throw of = 0, Jw = null, Error(G(185));
    nh(e, n, r), (!(ke & 2) || e !== Ft) && (e === Ft && (!(ke & 2) && (Vy |= n), Mt === 4 && No(e, qt)), Mn(e, r), n === 1 && ke === 0 && !(t.mode & 1) && (qu = xt() + 500, Ly && da()))
}

function Mn(e, t) {
    var n = e.callbackNode;
    PF(e, t);
    var r = im(e, e === Ft ? qt : 0);
    if (r === 0) n !== null && zT(n), e.callbackNode = null, e.callbackPriority = 0;
    else if (t = r & -r, e.callbackPriority !== t) {
        if (n != null && zT(n), t === 1) e.tag === 0 ? TU(BP.bind(null, e)) : CR(BP.bind(null, e)), AU(function() {
            !(ke & 6) && da()
        }), n = null;
        else {
            switch (oR(r)) {
                case 1:
                    n = YA;
                    break;
                case 4:
                    n = nR;
                    break;
                case 16:
                    n = rm;
                    break;
                case 536870912:
                    n = rR;
                    break;
                default:
                    n = rm
            }
            n = Oj(n, xj.bind(null, e))
        }
        e.callbackPriority = t, e.callbackNode = n
    }
}

function xj(e, t) {
    if (jp = -1, Bp = 0, ke & 6) throw Error(G(327));
    var n = e.callbackNode;
    if (Mu() && e.callbackNode !== n) return null;
    var r = im(e, e === Ft ? qt : 0);
    if (r === 0) return null;
    if (r & 30 || r & e.expiredLanes || t) t = Am(e, r);
    else {
        t = r;
        var i = ke;
        ke |= 2;
        var o = Ej();
        (Ft !== e || qt !== t) && (Oi = null, qu = xt() + 500, Ja(e, t));
        do try {
            qU();
            break
        } catch (s) {
            Aj(e, s)
        }
        while (!0);
        lE(), bm.current = o, ke = i, Pt !== null ? t = 0 : (Ft = null, qt = 0, t = Mt)
    }
    if (t !== 0) {
        if (t === 2 && (i = Tw(e), i !== 0 && (r = i, t = ex(e, i))), t === 1) throw n = Df, Ja(e, 0), No(e, r), Mn(e, xt()), n;
        if (t === 6) No(e, r);
        else {
            if (i = e.current.alternate, !(r & 30) && !WU(i) && (t = Am(e, r), t === 2 && (o = Tw(e), o !== 0 && (r = o, t = ex(e, o))), t === 1)) throw n = Df, Ja(e, 0), No(e, r), Mn(e, xt()), n;
            switch (e.finishedWork = i, e.finishedLanes = r, t) {
                case 0:
                case 1:
                    throw Error(G(345));
                case 2:
                    ka(e, Sn, Oi);
                    break;
                case 3:
                    if (No(e, r), (r & 130023424) === r && (t = SE + 500 - xt(), 10 < t)) {
                        if (im(e, 0) !== 0) break;
                        if (i = e.suspendedLanes, (i & r) !== r) {
                            pn(), e.pingedLanes |= e.suspendedLanes & i;
                            break
                        }
                        e.timeoutHandle = Rw(ka.bind(null, e, Sn, Oi), t);
                        break
                    }
                    ka(e, Sn, Oi);
                    break;
                case 4:
                    if (No(e, r), (r & 4194240) === r) break;
                    for (t = e.eventTimes, i = -1; 0 < r;) {
                        var a = 31 - Nr(r);
                        o = 1 << a, a = t[a], a > i && (i = a), r &= ~o
                    }
                    if (r = i, r = xt() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * zU(r / 1960)) - r, 10 < r) {
                        e.timeoutHandle = Rw(ka.bind(null, e, Sn, Oi), r);
                        break
                    }
                    ka(e, Sn, Oi);
                    break;
                case 5:
                    ka(e, Sn, Oi);
                    break;
                default:
                    throw Error(G(329))
            }
        }
    }
    return Mn(e, xt()), e.callbackNode === n ? xj.bind(null, e) : null
}

function ex(e, t) {
    var n = rf;
    return e.current.memoizedState.isDehydrated && (Ja(e, t).flags |= 256), e = Am(e, t), e !== 2 && (t = Sn, Sn = n, t !== null && tx(t)), e
}

function tx(e) {
    Sn === null ? Sn = e : Sn.push.apply(Sn, e)
}

function WU(e) {
    for (var t = e;;) {
        if (t.flags & 16384) {
            var n = t.updateQueue;
            if (n !== null && (n = n.stores, n !== null))
                for (var r = 0; r < n.length; r++) {
                    var i = n[r],
                        o = i.getSnapshot;
                    i = i.value;
                    try {
                        if (!$r(o(), i)) return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n;
        else {
            if (t === e) break;
            for (; t.sibling === null;) {
                if (t.return === null || t.return === e) return !0;
                t = t.return
            }
            t.sibling.return = t.return, t = t.sibling
        }
    }
    return !0
}

function No(e, t) {
    for (t &= ~EE, t &= ~Vy, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) {
        var n = 31 - Nr(t),
            r = 1 << n;
        e[n] = -1, t &= ~r
    }
}

function BP(e) {
    if (ke & 6) throw Error(G(327));
    Mu();
    var t = im(e, 0);
    if (!(t & 1)) return Mn(e, xt()), null;
    var n = Am(e, t);
    if (e.tag !== 0 && n === 2) {
        var r = Tw(e);
        r !== 0 && (t = r, n = ex(e, r))
    }
    if (n === 1) throw n = Df, Ja(e, 0), No(e, t), Mn(e, xt()), n;
    if (n === 6) throw Error(G(345));
    return e.finishedWork = e.current.alternate, e.finishedLanes = t, ka(e, Sn, Oi), Mn(e, xt()), null
}

function _E(e, t) {
    var n = ke;
    ke |= 1;
    try {
        return e(t)
    } finally {
        ke = n, ke === 0 && (qu = xt() + 500, Ly && da())
    }
}

function ys(e) {
    Do !== null && Do.tag === 0 && !(ke & 6) && Mu();
    var t = ke;
    ke |= 1;
    var n = fr.transition,
        r = Le;
    try {
        if (fr.transition = null, Le = 1, e) return e()
    } finally {
        Le = r, fr.transition = n, ke = t, !(ke & 6) && da()
    }
}

function TE() {
    Bn = mu.current, et(mu)
}

function Ja(e, t) {
    e.finishedWork = null, e.finishedLanes = 0;
    var n = e.timeoutHandle;
    if (n !== -1 && (e.timeoutHandle = -1, xU(n)), Pt !== null)
        for (n = Pt.return; n !== null;) {
            var r = n;
            switch (aE(r), r.tag) {
                case 1:
                    r = r.type.childContextTypes, r != null && lm();
                    break;
                case 3:
                    Wu(), et(Cn), et(sn), mE();
                    break;
                case 5:
                    pE(r);
                    break;
                case 4:
                    Wu();
                    break;
                case 13:
                    et(st);
                    break;
                case 19:
                    et(st);
                    break;
                case 10:
                    cE(r.type._context);
                    break;
                case 22:
                case 23:
                    TE()
            }
            n = n.return
        }
    if (Ft = e, Pt = e = Qo(e.current, null), qt = Bn = t, Mt = 0, Df = null, EE = Vy = gs = 0, Sn = rf = null, $a !== null) {
        for (t = 0; t < $a.length; t++)
            if (n = $a[t], r = n.interleaved, r !== null) {
                n.interleaved = null;
                var i = r.next,
                    o = n.pending;
                if (o !== null) {
                    var a = o.next;
                    o.next = i, r.next = a
                }
                n.pending = r
            }
        $a = null
    }
    return e
}

function Aj(e, t) {
    do {
        var n = Pt;
        try {
            if (lE(), Mp.current = vm, ym) {
                for (var r = ct.memoizedState; r !== null;) {
                    var i = r.queue;
                    i !== null && (i.pending = null), r = r.next
                }
                ym = !1
            }
            if (ms = 0, $t = It = ct = null, tf = !1, Rf = 0, AE.current = null, n === null || n.return === null) {
                Mt = 1, Df = t, Pt = null;
                break
            }
            e: {
                var o = e,
                    a = n.return,
                    s = n,
                    u = t;
                if (t = qt, s.flags |= 32768, u !== null && typeof u == "object" && typeof u.then == "function") {
                    var l = u,
                        c = s,
                        f = c.tag;
                    if (!(c.mode & 1) && (f === 0 || f === 11 || f === 15)) {
                        var d = c.alternate;
                        d ? (c.updateQueue = d.updateQueue, c.memoizedState = d.memoizedState, c.lanes = d.lanes) : (c.updateQueue = null, c.memoizedState = null)
                    }
                    var h = EP(a);
                    if (h !== null) {
                        h.flags &= -257, SP(h, a, s, o, t), h.mode & 1 && AP(o, l, t), t = h, u = l;
                        var m = t.updateQueue;
                        if (m === null) {
                            var p = new Set;
                            p.add(u), t.updateQueue = p
                        } else m.add(u);
                        break e
                    } else {
                        if (!(t & 1)) {
                            AP(o, l, t), PE();
                            break e
                        }
                        u = Error(G(426))
                    }
                } else if (rt && s.mode & 1) {
                    var y = EP(a);
                    if (y !== null) {
                        !(y.flags & 65536) && (y.flags |= 256), SP(y, a, s, o, t), sE(Gu(u, s));
                        break e
                    }
                }
                o = u = Gu(u, s),
                Mt !== 4 && (Mt = 2),
                rf === null ? rf = [o] : rf.push(o),
                o = a;do {
                    switch (o.tag) {
                        case 3:
                            o.flags |= 65536, t &= -t, o.lanes |= t;
                            var g = oj(o, u, t);
                            gP(o, g);
                            break e;
                        case 1:
                            s = u;
                            var b = o.type,
                                v = o.stateNode;
                            if (!(o.flags & 128) && (typeof b.getDerivedStateFromError == "function" || v !== null && typeof v.componentDidCatch == "function" && (qo === null || !qo.has(v)))) {
                                o.flags |= 65536, t &= -t, o.lanes |= t;
                                var A = aj(o, s, t);
                                gP(o, A);
                                break e
                            }
                    }
                    o = o.return
                } while (o !== null)
            }
            _j(n)
        } catch (w) {
            t = w, Pt === n && n !== null && (Pt = n = n.return);
            continue
        }
        break
    } while (!0)
}

function Ej() {
    var e = bm.current;
    return bm.current = vm, e === null ? vm : e
}

function PE() {
    (Mt === 0 || Mt === 3 || Mt === 2) && (Mt = 4), Ft === null || !(gs & 268435455) && !(Vy & 268435455) || No(Ft, qt)
}

function Am(e, t) {
    var n = ke;
    ke |= 2;
    var r = Ej();
    (Ft !== e || qt !== t) && (Oi = null, Ja(e, t));
    do try {
        GU();
        break
    } catch (i) {
        Aj(e, i)
    }
    while (!0);
    if (lE(), ke = n, bm.current = r, Pt !== null) throw Error(G(261));
    return Ft = null, qt = 0, Mt
}

function GU() {
    for (; Pt !== null;) Sj(Pt)
}

function qU() {
    for (; Pt !== null && !vF();) Sj(Pt)
}

function Sj(e) {
    var t = Pj(e.alternate, e, Bn);
    e.memoizedProps = e.pendingProps, t === null ? _j(e) : Pt = t, AE.current = null
}

function _j(e) {
    var t = e;
    do {
        var n = t.alternate;
        if (e = t.return, t.flags & 32768) {
            if (n = FU(n, t), n !== null) {
                n.flags &= 32767, Pt = n;
                return
            }
            if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null;
            else {
                Mt = 6, Pt = null;
                return
            }
        } else if (n = LU(n, t, Bn), n !== null) {
            Pt = n;
            return
        }
        if (t = t.sibling, t !== null) {
            Pt = t;
            return
        }
        Pt = t = e
    } while (t !== null);
    Mt === 0 && (Mt = 5)
}

function ka(e, t, n) {
    var r = Le,
        i = fr.transition;
    try {
        fr.transition = null, Le = 1, KU(e, t, n, r)
    } finally {
        fr.transition = i, Le = r
    }
    return null
}

function KU(e, t, n, r) {
    do Mu(); while (Do !== null);
    if (ke & 6) throw Error(G(327));
    n = e.finishedWork;
    var i = e.finishedLanes;
    if (n === null) return null;
    if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(G(177));
    e.callbackNode = null, e.callbackPriority = 0;
    var o = n.lanes | n.childLanes;
    if (OF(e, o), e === Ft && (Pt = Ft = null, qt = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || Kh || (Kh = !0, Oj(rm, function() {
            return Mu(), null
        })), o = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || o) {
        o = fr.transition, fr.transition = null;
        var a = Le;
        Le = 1;
        var s = ke;
        ke |= 4, AE.current = null, HU(e, n), bj(n, e), pU(Mw), om = !!Iw, Mw = Iw = null, e.current = n, VU(n), bF(), ke = s, Le = a, fr.transition = o
    } else e.current = n;
    if (Kh && (Kh = !1, Do = e, xm = i), o = e.pendingLanes, o === 0 && (qo = null), AF(n.stateNode), Mn(e, xt()), t !== null)
        for (r = e.onRecoverableError, n = 0; n < t.length; n++) i = t[n], r(i.value, {
            componentStack: i.stack,
            digest: i.digest
        });
    if (wm) throw wm = !1, e = Zw, Zw = null, e;
    return xm & 1 && e.tag !== 0 && Mu(), o = e.pendingLanes, o & 1 ? e === Jw ? of ++ : ( of = 0, Jw = e) : of = 0, da(), null
}

function Mu() {
    if (Do !== null) {
        var e = oR(xm),
            t = fr.transition,
            n = Le;
        try {
            if (fr.transition = null, Le = 16 > e ? 16 : e, Do === null) var r = !1;
            else {
                if (e = Do, Do = null, xm = 0, ke & 6) throw Error(G(331));
                var i = ke;
                for (ke |= 4, te = e.current; te !== null;) {
                    var o = te,
                        a = o.child;
                    if (te.flags & 16) {
                        var s = o.deletions;
                        if (s !== null) {
                            for (var u = 0; u < s.length; u++) {
                                var l = s[u];
                                for (te = l; te !== null;) {
                                    var c = te;
                                    switch (c.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            nf(8, c, o)
                                    }
                                    var f = c.child;
                                    if (f !== null) f.return = c, te = f;
                                    else
                                        for (; te !== null;) {
                                            c = te;
                                            var d = c.sibling,
                                                h = c.return;
                                            if (gj(c), c === l) {
                                                te = null;
                                                break
                                            }
                                            if (d !== null) {
                                                d.return = h, te = d;
                                                break
                                            }
                                            te = h
                                        }
                                }
                            }
                            var m = o.alternate;
                            if (m !== null) {
                                var p = m.child;
                                if (p !== null) {
                                    m.child = null;
                                    do {
                                        var y = p.sibling;
                                        p.sibling = null, p = y
                                    } while (p !== null)
                                }
                            }
                            te = o
                        }
                    }
                    if (o.subtreeFlags & 2064 && a !== null) a.return = o, te = a;
                    else e: for (; te !== null;) {
                        if (o = te, o.flags & 2048) switch (o.tag) {
                            case 0:
                            case 11:
                            case 15:
                                nf(9, o, o.return)
                        }
                        var g = o.sibling;
                        if (g !== null) {
                            g.return = o.return, te = g;
                            break e
                        }
                        te = o.return
                    }
                }
                var b = e.current;
                for (te = b; te !== null;) {
                    a = te;
                    var v = a.child;
                    if (a.subtreeFlags & 2064 && v !== null) v.return = a, te = v;
                    else e: for (a = b; te !== null;) {
                        if (s = te, s.flags & 2048) try {
                            switch (s.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Hy(9, s)
                            }
                        } catch (w) {
                            yt(s, s.return, w)
                        }
                        if (s === a) {
                            te = null;
                            break e
                        }
                        var A = s.sibling;
                        if (A !== null) {
                            A.return = s.return, te = A;
                            break e
                        }
                        te = s.return
                    }
                }
                if (ke = i, da(), oi && typeof oi.onPostCommitFiberRoot == "function") try {
                    oi.onPostCommitFiberRoot(Ry, e)
                } catch {}
                r = !0
            }
            return r
        } finally {
            Le = n, fr.transition = t
        }
    }
    return !1
}

function DP(e, t, n) {
    t = Gu(n, t), t = oj(e, t, 1), e = Go(e, t, 1), t = pn(), e !== null && (nh(e, 1, t), Mn(e, t))
}

function yt(e, t, n) {
    if (e.tag === 3) DP(e, e, n);
    else
        for (; t !== null;) {
            if (t.tag === 3) {
                DP(t, e, n);
                break
            } else if (t.tag === 1) {
                var r = t.stateNode;
                if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (qo === null || !qo.has(r))) {
                    e = Gu(n, e), e = aj(t, e, 1), t = Go(t, e, 1), e = pn(), t !== null && (nh(t, 1, e), Mn(t, e));
                    break
                }
            }
            t = t.return
        }
}

function QU(e, t, n) {
    var r = e.pingCache;
    r !== null && r.delete(t), t = pn(), e.pingedLanes |= e.suspendedLanes & n, Ft === e && (qt & n) === n && (Mt === 4 || Mt === 3 && (qt & 130023424) === qt && 500 > xt() - SE ? Ja(e, 0) : EE |= n), Mn(e, t)
}

function Tj(e, t) {
    t === 0 && (e.mode & 1 ? (t = $h, $h <<= 1, !($h & 130023424) && ($h = 4194304)) : t = 1);
    var n = pn();
    e = Xi(e, t), e !== null && (nh(e, t, n), Mn(e, n))
}

function YU(e) {
    var t = e.memoizedState,
        n = 0;
    t !== null && (n = t.retryLane), Tj(e, n)
}

function XU(e, t) {
    var n = 0;
    switch (e.tag) {
        case 13:
            var r = e.stateNode,
                i = e.memoizedState;
            i !== null && (n = i.retryLane);
            break;
        case 19:
            r = e.stateNode;
            break;
        default:
            throw Error(G(314))
    }
    r !== null && r.delete(t), Tj(e, n)
}
var Pj;
Pj = function(e, t, n) {
    if (e !== null)
        if (e.memoizedProps !== t.pendingProps || Cn.current) Pn = !0;
        else {
            if (!(e.lanes & n) && !(t.flags & 128)) return Pn = !1, $U(e, t, n);
            Pn = !!(e.flags & 131072)
        }
    else Pn = !1, rt && t.flags & 1048576 && IR(t, dm, t.index);
    switch (t.lanes = 0, t.tag) {
        case 2:
            var r = t.type;
            Rp(e, t), e = t.pendingProps;
            var i = Hu(t, sn.current);
            Iu(t, n), i = yE(null, t, r, e, i, n);
            var o = vE();
            return t.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, In(r) ? (o = !0, cm(t)) : o = !1, t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, dE(t), i.updater = Uy, t.stateNode = i, i._reactInternals = t, Uw(t, r, e, n), t = zw(null, t, r, !0, o, n)) : (t.tag = 0, rt && o && oE(t), cn(null, t, i, n), t = t.child), t;
        case 16:
            r = t.elementType;
            e: {
                switch (Rp(e, t), e = t.pendingProps, i = r._init, r = i(r._payload), t.type = r, i = t.tag = JU(r), e = Sr(r, e), i) {
                    case 0:
                        t = Vw(null, t, r, e, n);
                        break e;
                    case 1:
                        t = PP(null, t, r, e, n);
                        break e;
                    case 11:
                        t = _P(null, t, r, e, n);
                        break e;
                    case 14:
                        t = TP(null, t, r, Sr(r.type, e), n);
                        break e
                }
                throw Error(G(306, r, ""))
            }
            return t;
        case 0:
            return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Sr(r, i), Vw(e, t, r, i, n);
        case 1:
            return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Sr(r, i), PP(e, t, r, i, n);
        case 3:
            e: {
                if (cj(t), e === null) throw Error(G(387));r = t.pendingProps,
                o = t.memoizedState,
                i = o.element,
                DR(e, t),
                mm(t, r, null, n);
                var a = t.memoizedState;
                if (r = a.element, o.isDehydrated)
                    if (o = {
                            element: r,
                            isDehydrated: !1,
                            cache: a.cache,
                            pendingSuspenseBoundaries: a.pendingSuspenseBoundaries,
                            transitions: a.transitions
                        }, t.updateQueue.baseState = o, t.memoizedState = o, t.flags & 256) {
                        i = Gu(Error(G(423)), t), t = OP(e, t, r, n, i);
                        break e
                    } else if (r !== i) {
                    i = Gu(Error(G(424)), t), t = OP(e, t, r, n, i);
                    break e
                } else
                    for (Fn = Wo(t.stateNode.containerInfo.firstChild), Un = t, rt = !0, Or = null, n = jR(t, null, r, n), t.child = n; n;) n.flags = n.flags & -3 | 4096, n = n.sibling;
                else {
                    if (Vu(), r === i) {
                        t = Zi(e, t, n);
                        break e
                    }
                    cn(e, t, r, n)
                }
                t = t.child
            }
            return t;
        case 5:
            return $R(t), e === null && $w(t), r = t.type, i = t.pendingProps, o = e !== null ? e.memoizedProps : null, a = i.children, Nw(r, i) ? a = null : o !== null && Nw(r, o) && (t.flags |= 32), lj(e, t), cn(e, t, a, n), t.child;
        case 6:
            return e === null && $w(t), null;
        case 13:
            return fj(e, t, n);
        case 4:
            return hE(t, t.stateNode.containerInfo), r = t.pendingProps, e === null ? t.child = zu(t, null, r, n) : cn(e, t, r, n), t.child;
        case 11:
            return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Sr(r, i), _P(e, t, r, i, n);
        case 7:
            return cn(e, t, t.pendingProps, n), t.child;
        case 8:
            return cn(e, t, t.pendingProps.children, n), t.child;
        case 12:
            return cn(e, t, t.pendingProps.children, n), t.child;
        case 10:
            e: {
                if (r = t.type._context, i = t.pendingProps, o = t.memoizedProps, a = i.value, Qe(hm, r._currentValue), r._currentValue = a, o !== null)
                    if ($r(o.value, a)) {
                        if (o.children === i.children && !Cn.current) {
                            t = Zi(e, t, n);
                            break e
                        }
                    } else
                        for (o = t.child, o !== null && (o.return = t); o !== null;) {
                            var s = o.dependencies;
                            if (s !== null) {
                                a = o.child;
                                for (var u = s.firstContext; u !== null;) {
                                    if (u.context === r) {
                                        if (o.tag === 1) {
                                            u = Fi(-1, n & -n), u.tag = 2;
                                            var l = o.updateQueue;
                                            if (l !== null) {
                                                l = l.shared;
                                                var c = l.pending;
                                                c === null ? u.next = u : (u.next = c.next, c.next = u), l.pending = u
                                            }
                                        }
                                        o.lanes |= n, u = o.alternate, u !== null && (u.lanes |= n), Lw(o.return, n, t), s.lanes |= n;
                                        break
                                    }
                                    u = u.next
                                }
                            } else if (o.tag === 10) a = o.type === t.type ? null : o.child;
                            else if (o.tag === 18) {
                                if (a = o.return, a === null) throw Error(G(341));
                                a.lanes |= n, s = a.alternate, s !== null && (s.lanes |= n), Lw(a, n, t), a = o.sibling
                            } else a = o.child;
                            if (a !== null) a.return = o;
                            else
                                for (a = o; a !== null;) {
                                    if (a === t) {
                                        a = null;
                                        break
                                    }
                                    if (o = a.sibling, o !== null) {
                                        o.return = a.return, a = o;
                                        break
                                    }
                                    a = a.return
                                }
                            o = a
                        }
                cn(e, t, i.children, n),
                t = t.child
            }
            return t;
        case 9:
            return i = t.type, r = t.pendingProps.children, Iu(t, n), i = hr(i), r = r(i), t.flags |= 1, cn(e, t, r, n), t.child;
        case 14:
            return r = t.type, i = Sr(r, t.pendingProps), i = Sr(r.type, i), TP(e, t, r, i, n);
        case 15:
            return sj(e, t, t.type, t.pendingProps, n);
        case 17:
            return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Sr(r, i), Rp(e, t), t.tag = 1, In(r) ? (e = !0, cm(t)) : e = !1, Iu(t, n), ij(t, r, i), Uw(t, r, i, n), zw(null, t, r, !0, e, n);
        case 19:
            return dj(e, t, n);
        case 22:
            return uj(e, t, n)
    }
    throw Error(G(156, t.tag))
};

function Oj(e, t) {
    return tR(e, t)
}

function ZU(e, t, n, r) {
    this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
}

function sr(e, t, n, r) {
    return new ZU(e, t, n, r)
}

function OE(e) {
    return e = e.prototype, !(!e || !e.isReactComponent)
}

function JU(e) {
    if (typeof e == "function") return OE(e) ? 1 : 0;
    if (e != null) {
        if (e = e.$$typeof, e === qA) return 11;
        if (e === KA) return 14
    }
    return 2
}

function Qo(e, t) {
    var n = e.alternate;
    return n === null ? (n = sr(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 14680064, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : {
        lanes: t.lanes,
        firstContext: t.firstContext
    }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n
}

function Dp(e, t, n, r, i, o) {
    var a = 2;
    if (r = e, typeof e == "function") OE(e) && (a = 1);
    else if (typeof e == "string") a = 5;
    else e: switch (e) {
        case ou:
            return es(n.children, i, o, t);
        case GA:
            a = 8, i |= 8;
            break;
        case fw:
            return e = sr(12, n, t, i | 2), e.elementType = fw, e.lanes = o, e;
        case dw:
            return e = sr(13, n, t, i), e.elementType = dw, e.lanes = o, e;
        case hw:
            return e = sr(19, n, t, i), e.elementType = hw, e.lanes = o, e;
        case $N:
            return zy(n, i, o, t);
        default:
            if (typeof e == "object" && e !== null) switch (e.$$typeof) {
                case BN:
                    a = 10;
                    break e;
                case DN:
                    a = 9;
                    break e;
                case qA:
                    a = 11;
                    break e;
                case KA:
                    a = 14;
                    break e;
                case ko:
                    a = 16, r = null;
                    break e
            }
            throw Error(G(130, e == null ? e : typeof e, ""))
    }
    return t = sr(a, n, t, i), t.elementType = e, t.type = r, t.lanes = o, t
}

function es(e, t, n, r) {
    return e = sr(7, e, r, t), e.lanes = n, e
}

function zy(e, t, n, r) {
    return e = sr(22, e, r, t), e.elementType = $N, e.lanes = n, e.stateNode = {
        isHidden: !1
    }, e
}

function K0(e, t, n) {
    return e = sr(6, e, null, t), e.lanes = n, e
}

function Q0(e, t, n) {
    return t = sr(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = {
        containerInfo: e.containerInfo,
        pendingChildren: null,
        implementation: e.implementation
    }, t
}

function eH(e, t, n, r, i) {
    this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = k0(0), this.expirationTimes = k0(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = k0(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null
}

function kE(e, t, n, r, i, o, a, s, u) {
    return e = new eH(e, t, n, s, u), t === 1 ? (t = 1, o === !0 && (t |= 8)) : t = 0, o = sr(3, null, null, t), e.current = o, o.stateNode = e, o.memoizedState = {
        element: r,
        isDehydrated: n,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    }, dE(o), e
}

function tH(e, t, n) {
    var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: iu,
        key: r == null ? null : "" + r,
        children: e,
        containerInfo: t,
        implementation: n
    }
}

function kj(e) {
    if (!e) return ta;
    e = e._reactInternals;
    e: {
        if (Ns(e) !== e || e.tag !== 1) throw Error(G(170));
        var t = e;do {
            switch (t.tag) {
                case 3:
                    t = t.stateNode.context;
                    break e;
                case 1:
                    if (In(t.type)) {
                        t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
            }
            t = t.return
        } while (t !== null);
        throw Error(G(171))
    }
    if (e.tag === 1) {
        var n = e.type;
        if (In(n)) return kR(e, n, t)
    }
    return t
}

function Cj(e, t, n, r, i, o, a, s, u) {
    return e = kE(n, r, !0, e, i, o, a, s, u), e.context = kj(null), n = e.current, r = pn(), i = Ko(n), o = Fi(r, i), o.callback = t ? ? null, Go(n, o, i), e.current.lanes = i, nh(e, i, r), Mn(e, r), e
}

function Wy(e, t, n, r) {
    var i = t.current,
        o = pn(),
        a = Ko(i);
    return n = kj(n), t.context === null ? t.context = n : t.pendingContext = n, t = Fi(o, a), t.payload = {
        element: e
    }, r = r === void 0 ? null : r, r !== null && (t.callback = r), e = Go(i, t, a), e !== null && (Rr(e, i, a, o), Ip(e, i, a)), a
}

function Em(e) {
    if (e = e.current, !e.child) return null;
    switch (e.child.tag) {
        case 5:
            return e.child.stateNode;
        default:
            return e.child.stateNode
    }
}

function $P(e, t) {
    if (e = e.memoizedState, e !== null && e.dehydrated !== null) {
        var n = e.retryLane;
        e.retryLane = n !== 0 && n < t ? n : t
    }
}

function CE(e, t) {
    $P(e, t), (e = e.alternate) && $P(e, t)
}

function nH() {
    return null
}
var Ij = typeof reportError == "function" ? reportError : function(e) {
    console.error(e)
};

function IE(e) {
    this._internalRoot = e
}
Gy.prototype.render = IE.prototype.render = function(e) {
    var t = this._internalRoot;
    if (t === null) throw Error(G(409));
    Wy(e, t, null, null)
};
Gy.prototype.unmount = IE.prototype.unmount = function() {
    var e = this._internalRoot;
    if (e !== null) {
        this._internalRoot = null;
        var t = e.containerInfo;
        ys(function() {
            Wy(null, e, null, null)
        }), t[Yi] = null
    }
};

function Gy(e) {
    this._internalRoot = e
}
Gy.prototype.unstable_scheduleHydration = function(e) {
    if (e) {
        var t = uR();
        e = {
            blockedOn: null,
            target: e,
            priority: t
        };
        for (var n = 0; n < Mo.length && t !== 0 && t < Mo[n].priority; n++);
        Mo.splice(n, 0, e), n === 0 && cR(e)
    }
};

function ME(e) {
    return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11)
}

function qy(e) {
    return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "))
}

function LP() {}

function rH(e, t, n, r, i) {
    if (i) {
        if (typeof r == "function") {
            var o = r;
            r = function() {
                var l = Em(a);
                o.call(l)
            }
        }
        var a = Cj(t, r, e, 0, null, !1, !1, "", LP);
        return e._reactRootContainer = a, e[Yi] = a.current, kf(e.nodeType === 8 ? e.parentNode : e), ys(), a
    }
    for (; i = e.lastChild;) e.removeChild(i);
    if (typeof r == "function") {
        var s = r;
        r = function() {
            var l = Em(u);
            s.call(l)
        }
    }
    var u = kE(e, 0, !1, null, null, !1, !1, "", LP);
    return e._reactRootContainer = u, e[Yi] = u.current, kf(e.nodeType === 8 ? e.parentNode : e), ys(function() {
        Wy(t, u, n, r)
    }), u
}

function Ky(e, t, n, r, i) {
    var o = n._reactRootContainer;
    if (o) {
        var a = o;
        if (typeof i == "function") {
            var s = i;
            i = function() {
                var u = Em(a);
                s.call(u)
            }
        }
        Wy(t, a, e, i)
    } else a = rH(n, t, e, i, r);
    return Em(a)
}
aR = function(e) {
    switch (e.tag) {
        case 3:
            var t = e.stateNode;
            if (t.current.memoizedState.isDehydrated) {
                var n = Uc(t.pendingLanes);
                n !== 0 && (XA(t, n | 1), Mn(t, xt()), !(ke & 6) && (qu = xt() + 500, da()))
            }
            break;
        case 13:
            ys(function() {
                var r = Xi(e, 1);
                if (r !== null) {
                    var i = pn();
                    Rr(r, e, 1, i)
                }
            }), CE(e, 1)
    }
};
ZA = function(e) {
    if (e.tag === 13) {
        var t = Xi(e, 134217728);
        if (t !== null) {
            var n = pn();
            Rr(t, e, 134217728, n)
        }
        CE(e, 134217728)
    }
};
sR = function(e) {
    if (e.tag === 13) {
        var t = Ko(e),
            n = Xi(e, t);
        if (n !== null) {
            var r = pn();
            Rr(n, e, t, r)
        }
        CE(e, t)
    }
};
uR = function() {
    return Le
};
lR = function(e, t) {
    var n = Le;
    try {
        return Le = e, t()
    } finally {
        Le = n
    }
};
Ew = function(e, t, n) {
    switch (t) {
        case "input":
            if (gw(e, n), t = n.name, n.type === "radio" && t != null) {
                for (n = e; n.parentNode;) n = n.parentNode;
                for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) {
                    var r = n[t];
                    if (r !== e && r.form === e.form) {
                        var i = $y(r);
                        if (!i) throw Error(G(90));
                        FN(r), gw(r, i)
                    }
                }
            }
            break;
        case "textarea":
            HN(e, n);
            break;
        case "select":
            t = n.value, t != null && Pu(e, !!n.multiple, t, !1)
    }
};
QN = _E;
YN = ys;
var iH = {
        usingClientEntryPoint: !1,
        Events: [ih, lu, $y, qN, KN, _E]
    },
    yc = {
        findFiberByHostInstance: Da,
        bundleType: 0,
        version: "18.3.1",
        rendererPackageName: "react-dom"
    },
    oH = {
        bundleType: yc.bundleType,
        version: yc.version,
        rendererPackageName: yc.rendererPackageName,
        rendererConfig: yc.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setErrorHandler: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: co.ReactCurrentDispatcher,
        findHostInstanceByFiber: function(e) {
            return e = JN(e), e === null ? null : e.stateNode
        },
        findFiberByHostInstance: yc.findFiberByHostInstance || nH,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null,
        reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
    };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Qh = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Qh.isDisabled && Qh.supportsFiber) try {
        Ry = Qh.inject(oH), oi = Qh
    } catch {}
}
qn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = iH;
qn.createPortal = function(e, t) {
    var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!ME(t)) throw Error(G(200));
    return tH(e, t, null, n)
};
qn.createRoot = function(e, t) {
    if (!ME(e)) throw Error(G(299));
    var n = !1,
        r = "",
        i = Ij;
    return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onRecoverableError !== void 0 && (i = t.onRecoverableError)), t = kE(e, 1, !1, null, null, n, !1, r, i), e[Yi] = t.current, kf(e.nodeType === 8 ? e.parentNode : e), new IE(t)
};
qn.findDOMNode = function(e) {
    if (e == null) return null;
    if (e.nodeType === 1) return e;
    var t = e._reactInternals;
    if (t === void 0) throw typeof e.render == "function" ? Error(G(188)) : (e = Object.keys(e).join(","), Error(G(268, e)));
    return e = JN(t), e = e === null ? null : e.stateNode, e
};
qn.flushSync = function(e) {
    return ys(e)
};
qn.hydrate = function(e, t, n) {
    if (!qy(t)) throw Error(G(200));
    return Ky(null, e, t, !0, n)
};
qn.hydrateRoot = function(e, t, n) {
    if (!ME(e)) throw Error(G(405));
    var r = n != null && n.hydratedSources || null,
        i = !1,
        o = "",
        a = Ij;
    if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (o = n.identifierPrefix), n.onRecoverableError !== void 0 && (a = n.onRecoverableError)), t = Cj(t, null, e, 1, n ? ? null, i, !1, o, a), e[Yi] = t.current, kf(e), r)
        for (e = 0; e < r.length; e++) n = r[e], i = n._getVersion, i = i(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i);
    return new Gy(t)
};
qn.render = function(e, t, n) {
    if (!qy(t)) throw Error(G(200));
    return Ky(null, e, t, !1, n)
};
qn.unmountComponentAtNode = function(e) {
    if (!qy(e)) throw Error(G(40));
    return e._reactRootContainer ? (ys(function() {
        Ky(null, null, e, !1, function() {
            e._reactRootContainer = null, e[Yi] = null
        })
    }), !0) : !1
};
qn.unstable_batchedUpdates = _E;
qn.unstable_renderSubtreeIntoContainer = function(e, t, n, r) {
    if (!qy(n)) throw Error(G(200));
    if (e == null || e._reactInternals === void 0) throw Error(G(38));
    return Ky(e, t, n, !1, r)
};
qn.version = "18.3.1-next-f1338f8080-20240426";

function Mj() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Mj)
    } catch (e) {
        console.error(e)
    }
}
Mj(), MN.exports = qn;
var Nj = MN.exports,
    FP = Nj;
lw.createRoot = FP.createRoot, lw.hydrateRoot = FP.hydrateRoot;
var NE = {};
Object.defineProperty(NE, "__esModule", {
    value: !0
});
NE.parse = dH;
NE.serialize = hH;
const aH = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/,
    sH = /^[\u0021-\u003A\u003C-\u007E]*$/,
    uH = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    lH = /^[\u0020-\u003A\u003D-\u007E]*$/,
    cH = Object.prototype.toString,
    fH = (() => {
        const e = function() {};
        return e.prototype = Object.create(null), e
    })();

function dH(e, t) {
    const n = new fH,
        r = e.length;
    if (r < 2) return n;
    const i = (t == null ? void 0 : t.decode) || pH;
    let o = 0;
    do {
        const a = e.indexOf("=", o);
        if (a === -1) break;
        const s = e.indexOf(";", o),
            u = s === -1 ? r : s;
        if (a > u) {
            o = e.lastIndexOf(";", a - 1) + 1;
            continue
        }
        const l = UP(e, o, a),
            c = HP(e, a, l),
            f = e.slice(l, c);
        if (n[f] === void 0) {
            let d = UP(e, a + 1, u),
                h = HP(e, u, d);
            const m = i(e.slice(d, h));
            n[f] = m
        }
        o = u + 1
    } while (o < r);
    return n
}

function UP(e, t, n) {
    do {
        const r = e.charCodeAt(t);
        if (r !== 32 && r !== 9) return t
    } while (++t < n);
    return n
}

function HP(e, t, n) {
    for (; t > n;) {
        const r = e.charCodeAt(--t);
        if (r !== 32 && r !== 9) return t + 1
    }
    return n
}

function hH(e, t, n) {
    const r = (n == null ? void 0 : n.encode) || encodeURIComponent;
    if (!aH.test(e)) throw new TypeError(`argument name is invalid: ${e}`);
    const i = r(t);
    if (!sH.test(i)) throw new TypeError(`argument val is invalid: ${t}`);
    let o = e + "=" + i;
    if (!n) return o;
    if (n.maxAge !== void 0) {
        if (!Number.isInteger(n.maxAge)) throw new TypeError(`option maxAge is invalid: ${n.maxAge}`);
        o += "; Max-Age=" + n.maxAge
    }
    if (n.domain) {
        if (!uH.test(n.domain)) throw new TypeError(`option domain is invalid: ${n.domain}`);
        o += "; Domain=" + n.domain
    }
    if (n.path) {
        if (!lH.test(n.path)) throw new TypeError(`option path is invalid: ${n.path}`);
        o += "; Path=" + n.path
    }
    if (n.expires) {
        if (!mH(n.expires) || !Number.isFinite(n.expires.valueOf())) throw new TypeError(`option expires is invalid: ${n.expires}`);
        o += "; Expires=" + n.expires.toUTCString()
    }
    if (n.httpOnly && (o += "; HttpOnly"), n.secure && (o += "; Secure"), n.partitioned && (o += "; Partitioned"), n.priority) switch (typeof n.priority == "string" ? n.priority.toLowerCase() : void 0) {
        case "low":
            o += "; Priority=Low";
            break;
        case "medium":
            o += "; Priority=Medium";
            break;
        case "high":
            o += "; Priority=High";
            break;
        default:
            throw new TypeError(`option priority is invalid: ${n.priority}`)
    }
    if (n.sameSite) switch (typeof n.sameSite == "string" ? n.sameSite.toLowerCase() : n.sameSite) {
        case !0:
        case "strict":
            o += "; SameSite=Strict";
            break;
        case "lax":
            o += "; SameSite=Lax";
            break;
        case "none":
            o += "; SameSite=None";
            break;
        default:
            throw new TypeError(`option sameSite is invalid: ${n.sameSite}`)
    }
    return o
}

function pH(e) {
    if (e.indexOf("%") === -1) return e;
    try {
        return decodeURIComponent(e)
    } catch {
        return e
    }
}

function mH(e) {
    return cH.call(e) === "[object Date]"
}
/**
 * react-router v7.2.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
var VP = "popstate";

function gH(e = {}) {
    function t(r, i) {
        let {
            pathname: o,
            search: a,
            hash: s
        } = r.location;
        return nx("", {
            pathname: o,
            search: a,
            hash: s
        }, i.state && i.state.usr || null, i.state && i.state.key || "default")
    }

    function n(r, i) {
        return typeof i == "string" ? i : $f(i)
    }
    return vH(t, n, null, e)
}

function ft(e, t) {
    if (e === !1 || e === null || typeof e > "u") throw new Error(t)
}

function di(e, t) {
    if (!e) {
        typeof console < "u" && console.warn(t);
        try {
            throw new Error(t)
        } catch {}
    }
}

function yH() {
    return Math.random().toString(36).substring(2, 10)
}

function zP(e, t) {
    return {
        usr: e.state,
        key: e.key,
        idx: t
    }
}

function nx(e, t, n = null, r) {
    return {
        pathname: typeof e == "string" ? e : e.pathname,
        search: "",
        hash: "",
        ...typeof t == "string" ? Ll(t) : t,
        state: n,
        key: t && t.key || r || yH()
    }
}

function $f({
    pathname: e = "/",
    search: t = "",
    hash: n = ""
}) {
    return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), n && n !== "#" && (e += n.charAt(0) === "#" ? n : "#" + n), e
}

function Ll(e) {
    let t = {};
    if (e) {
        let n = e.indexOf("#");
        n >= 0 && (t.hash = e.substring(n), e = e.substring(0, n));
        let r = e.indexOf("?");
        r >= 0 && (t.search = e.substring(r), e = e.substring(0, r)), e && (t.pathname = e)
    }
    return t
}

function vH(e, t, n, r = {}) {
    let {
        window: i = document.defaultView,
        v5Compat: o = !1
    } = r, a = i.history, s = "POP", u = null, l = c();
    l == null && (l = 0, a.replaceState({ ...a.state,
        idx: l
    }, ""));

    function c() {
        return (a.state || {
            idx: null
        }).idx
    }

    function f() {
        s = "POP";
        let y = c(),
            g = y == null ? null : y - l;
        l = y, u && u({
            action: s,
            location: p.location,
            delta: g
        })
    }

    function d(y, g) {
        s = "PUSH";
        let b = nx(p.location, y, g);
        l = c() + 1;
        let v = zP(b, l),
            A = p.createHref(b);
        try {
            a.pushState(v, "", A)
        } catch (w) {
            if (w instanceof DOMException && w.name === "DataCloneError") throw w;
            i.location.assign(A)
        }
        o && u && u({
            action: s,
            location: p.location,
            delta: 1
        })
    }

    function h(y, g) {
        s = "REPLACE";
        let b = nx(p.location, y, g);
        l = c();
        let v = zP(b, l),
            A = p.createHref(b);
        a.replaceState(v, "", A), o && u && u({
            action: s,
            location: p.location,
            delta: 0
        })
    }

    function m(y) {
        let g = i.location.origin !== "null" ? i.location.origin : i.location.href,
            b = typeof y == "string" ? y : $f(y);
        return b = b.replace(/ $/, "%20"), ft(g, `No window.location.(origin|href) available to create URL for href: ${b}`), new URL(b, g)
    }
    let p = {
        get action() {
            return s
        },
        get location() {
            return e(i, a)
        },
        listen(y) {
            if (u) throw new Error("A history only accepts one active listener");
            return i.addEventListener(VP, f), u = y, () => {
                i.removeEventListener(VP, f), u = null
            }
        },
        createHref(y) {
            return t(i, y)
        },
        createURL: m,
        encodeLocation(y) {
            let g = m(y);
            return {
                pathname: g.pathname,
                search: g.search,
                hash: g.hash
            }
        },
        push: d,
        replace: h,
        go(y) {
            return a.go(y)
        }
    };
    return p
}

function Rj(e, t, n = "/") {
    return bH(e, t, n, !1)
}

function bH(e, t, n, r) {
    let i = typeof t == "string" ? Ll(t) : t,
        o = na(i.pathname || "/", n);
    if (o == null) return null;
    let a = jj(e);
    wH(a);
    let s = null;
    for (let u = 0; s == null && u < a.length; ++u) {
        let l = IH(o);
        s = kH(a[u], l, r)
    }
    return s
}

function jj(e, t = [], n = [], r = "") {
    let i = (o, a, s) => {
        let u = {
            relativePath: s === void 0 ? o.path || "" : s,
            caseSensitive: o.caseSensitive === !0,
            childrenIndex: a,
            route: o
        };
        u.relativePath.startsWith("/") && (ft(u.relativePath.startsWith(r), `Absolute route path "${u.relativePath}" nested under path "${r}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`), u.relativePath = u.relativePath.slice(r.length));
        let l = Ui([r, u.relativePath]),
            c = n.concat(u);
        o.children && o.children.length > 0 && (ft(o.index !== !0, `Index routes must not have child routes. Please remove all child routes from route path "${l}".`), jj(o.children, t, c, l)), !(o.path == null && !o.index) && t.push({
            path: l,
            score: PH(l, o.index),
            routesMeta: c
        })
    };
    return e.forEach((o, a) => {
        var s;
        if (o.path === "" || !((s = o.path) != null && s.includes("?"))) i(o, a);
        else
            for (let u of Bj(o.path)) i(o, a, u)
    }), t
}

function Bj(e) {
    let t = e.split("/");
    if (t.length === 0) return [];
    let [n, ...r] = t, i = n.endsWith("?"), o = n.replace(/\?$/, "");
    if (r.length === 0) return i ? [o, ""] : [o];
    let a = Bj(r.join("/")),
        s = [];
    return s.push(...a.map(u => u === "" ? o : [o, u].join("/"))), i && s.push(...a), s.map(u => e.startsWith("/") && u === "" ? "/" : u)
}

function wH(e) {
    e.sort((t, n) => t.score !== n.score ? n.score - t.score : OH(t.routesMeta.map(r => r.childrenIndex), n.routesMeta.map(r => r.childrenIndex)))
}
var xH = /^:[\w-]+$/,
    AH = 3,
    EH = 2,
    SH = 1,
    _H = 10,
    TH = -2,
    WP = e => e === "*";

function PH(e, t) {
    let n = e.split("/"),
        r = n.length;
    return n.some(WP) && (r += TH), t && (r += EH), n.filter(i => !WP(i)).reduce((i, o) => i + (xH.test(o) ? AH : o === "" ? SH : _H), r)
}

function OH(e, t) {
    return e.length === t.length && e.slice(0, -1).every((r, i) => r === t[i]) ? e[e.length - 1] - t[t.length - 1] : 0
}

function kH(e, t, n = !1) {
    let {
        routesMeta: r
    } = e, i = {}, o = "/", a = [];
    for (let s = 0; s < r.length; ++s) {
        let u = r[s],
            l = s === r.length - 1,
            c = o === "/" ? t : t.slice(o.length) || "/",
            f = Sm({
                path: u.relativePath,
                caseSensitive: u.caseSensitive,
                end: l
            }, c),
            d = u.route;
        if (!f && l && n && !r[r.length - 1].route.index && (f = Sm({
                path: u.relativePath,
                caseSensitive: u.caseSensitive,
                end: !1
            }, c)), !f) return null;
        Object.assign(i, f.params), a.push({
            params: i,
            pathname: Ui([o, f.pathname]),
            pathnameBase: jH(Ui([o, f.pathnameBase])),
            route: d
        }), f.pathnameBase !== "/" && (o = Ui([o, f.pathnameBase]))
    }
    return a
}

function Sm(e, t) {
    typeof e == "string" && (e = {
        path: e,
        caseSensitive: !1,
        end: !0
    });
    let [n, r] = CH(e.path, e.caseSensitive, e.end), i = t.match(n);
    if (!i) return null;
    let o = i[0],
        a = o.replace(/(.)\/+$/, "$1"),
        s = i.slice(1);
    return {
        params: r.reduce((l, {
            paramName: c,
            isOptional: f
        }, d) => {
            if (c === "*") {
                let m = s[d] || "";
                a = o.slice(0, o.length - m.length).replace(/(.)\/+$/, "$1")
            }
            const h = s[d];
            return f && !h ? l[c] = void 0 : l[c] = (h || "").replace(/%2F/g, "/"), l
        }, {}),
        pathname: o,
        pathnameBase: a,
        pattern: e
    }
}

function CH(e, t = !1, n = !0) {
    di(e === "*" || !e.endsWith("*") || e.endsWith("/*"), `Route path "${e}" will be treated as if it were "${e.replace(/\*$/,"/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/,"/*")}".`);
    let r = [],
        i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (a, s, u) => (r.push({
            paramName: s,
            isOptional: u != null
        }), u ? "/?([^\\/]+)?" : "/([^\\/]+)"));
    return e.endsWith("*") ? (r.push({
        paramName: "*"
    }), i += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : e !== "" && e !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, t ? void 0 : "i"), r]
}

function IH(e) {
    try {
        return e.split("/").map(t => decodeURIComponent(t).replace(/\//g, "%2F")).join("/")
    } catch (t) {
        return di(!1, `The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`), e
    }
}

function na(e, t) {
    if (t === "/") return e;
    if (!e.toLowerCase().startsWith(t.toLowerCase())) return null;
    let n = t.endsWith("/") ? t.length - 1 : t.length,
        r = e.charAt(n);
    return r && r !== "/" ? null : e.slice(n) || "/"
}

function MH(e, t = "/") {
    let {
        pathname: n,
        search: r = "",
        hash: i = ""
    } = typeof e == "string" ? Ll(e) : e;
    return {
        pathname: n ? n.startsWith("/") ? n : NH(n, t) : t,
        search: BH(r),
        hash: DH(i)
    }
}

function NH(e, t) {
    let n = t.replace(/\/+$/, "").split("/");
    return e.split("/").forEach(i => {
        i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i)
    }), n.length > 1 ? n.join("/") : "/"
}

function Y0(e, t, n, r) {
    return `Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(r)}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`
}

function RH(e) {
    return e.filter((t, n) => n === 0 || t.route.path && t.route.path.length > 0)
}

function Dj(e) {
    let t = RH(e);
    return t.map((n, r) => r === t.length - 1 ? n.pathname : n.pathnameBase)
}

function $j(e, t, n, r = !1) {
    let i;
    typeof e == "string" ? i = Ll(e) : (i = { ...e
    }, ft(!i.pathname || !i.pathname.includes("?"), Y0("?", "pathname", "search", i)), ft(!i.pathname || !i.pathname.includes("#"), Y0("#", "pathname", "hash", i)), ft(!i.search || !i.search.includes("#"), Y0("#", "search", "hash", i)));
    let o = e === "" || i.pathname === "",
        a = o ? "/" : i.pathname,
        s;
    if (a == null) s = n;
    else {
        let f = t.length - 1;
        if (!r && a.startsWith("..")) {
            let d = a.split("/");
            for (; d[0] === "..";) d.shift(), f -= 1;
            i.pathname = d.join("/")
        }
        s = f >= 0 ? t[f] : "/"
    }
    let u = MH(i, s),
        l = a && a !== "/" && a.endsWith("/"),
        c = (o || a === ".") && n.endsWith("/");
    return !u.pathname.endsWith("/") && (l || c) && (u.pathname += "/"), u
}
var Ui = e => e.join("/").replace(/\/\/+/g, "/"),
    jH = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"),
    BH = e => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e,
    DH = e => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e;

function $H(e) {
    return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e
}
var Lj = ["POST", "PUT", "PATCH", "DELETE"];
new Set(Lj);
var LH = ["GET", ...Lj];
new Set(LH);
var Fl = S.createContext(null);
Fl.displayName = "DataRouter";
var Qy = S.createContext(null);
Qy.displayName = "DataRouterState";
var Fj = S.createContext({
    isTransitioning: !1
});
Fj.displayName = "ViewTransition";
var FH = S.createContext(new Map);
FH.displayName = "Fetchers";
var UH = S.createContext(null);
UH.displayName = "Await";
var yi = S.createContext(null);
yi.displayName = "Navigation";
var ah = S.createContext(null);
ah.displayName = "Location";
var fo = S.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
});
fo.displayName = "Route";
var RE = S.createContext(null);
RE.displayName = "RouteError";

function HH(e, {
    relative: t
} = {}) {
    ft(sh(), "useHref() may be used only in the context of a <Router> component.");
    let {
        basename: n,
        navigator: r
    } = S.useContext(yi), {
        hash: i,
        pathname: o,
        search: a
    } = uh(e, {
        relative: t
    }), s = o;
    return n !== "/" && (s = o === "/" ? n : Ui([n, o])), r.createHref({
        pathname: s,
        search: a,
        hash: i
    })
}

function sh() {
    return S.useContext(ah) != null
}

function Rs() {
    return ft(sh(), "useLocation() may be used only in the context of a <Router> component."), S.useContext(ah).location
}
var Uj = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";

function Hj(e) {
    S.useContext(yi).static || S.useLayoutEffect(e)
}

function VH() {
    let {
        isDataRoute: e
    } = S.useContext(fo);
    return e ? n9() : zH()
}

function zH() {
    ft(sh(), "useNavigate() may be used only in the context of a <Router> component.");
    let e = S.useContext(Fl),
        {
            basename: t,
            navigator: n
        } = S.useContext(yi),
        {
            matches: r
        } = S.useContext(fo),
        {
            pathname: i
        } = Rs(),
        o = JSON.stringify(Dj(r)),
        a = S.useRef(!1);
    return Hj(() => {
        a.current = !0
    }), S.useCallback((u, l = {}) => {
        if (di(a.current, Uj), !a.current) return;
        if (typeof u == "number") {
            n.go(u);
            return
        }
        let c = $j(u, JSON.parse(o), i, l.relative === "path");
        e == null && t !== "/" && (c.pathname = c.pathname === "/" ? t : Ui([t, c.pathname])), (l.replace ? n.replace : n.push)(c, l.state, l)
    }, [t, n, o, i, e])
}
S.createContext(null);

function uh(e, {
    relative: t
} = {}) {
    let {
        matches: n
    } = S.useContext(fo), {
        pathname: r
    } = Rs(), i = JSON.stringify(Dj(n));
    return S.useMemo(() => $j(e, JSON.parse(i), r, t === "path"), [e, i, r, t])
}

function WH(e, t) {
    return Vj(e, t)
}

function Vj(e, t, n, r) {
    var b;
    ft(sh(), "useRoutes() may be used only in the context of a <Router> component.");
    let {
        navigator: i,
        static: o
    } = S.useContext(yi), {
        matches: a
    } = S.useContext(fo), s = a[a.length - 1], u = s ? s.params : {}, l = s ? s.pathname : "/", c = s ? s.pathnameBase : "/", f = s && s.route; {
        let v = f && f.path || "";
        zj(l, !f || v.endsWith("*") || v.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${l}" (under <Route path="${v}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${v}"> to <Route path="${v==="/"?"*":`${v}/*`}">.`)
    }
    let d = Rs(),
        h;
    if (t) {
        let v = typeof t == "string" ? Ll(t) : t;
        ft(c === "/" || ((b = v.pathname) == null ? void 0 : b.startsWith(c)), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${c}" but pathname "${v.pathname}" was given in the \`location\` prop.`), h = v
    } else h = d;
    let m = h.pathname || "/",
        p = m;
    if (c !== "/") {
        let v = c.replace(/^\//, "").split("/");
        p = "/" + m.replace(/^\//, "").split("/").slice(v.length).join("/")
    }
    let y = !o && n && n.matches && n.matches.length > 0 ? n.matches : Rj(e, {
        pathname: p
    });
    di(f || y != null, `No routes matched location "${h.pathname}${h.search}${h.hash}" `), di(y == null || y[y.length - 1].route.element !== void 0 || y[y.length - 1].route.Component !== void 0 || y[y.length - 1].route.lazy !== void 0, `Matched leaf route at location "${h.pathname}${h.search}${h.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);
    let g = YH(y && y.map(v => Object.assign({}, v, {
        params: Object.assign({}, u, v.params),
        pathname: Ui([c, i.encodeLocation ? i.encodeLocation(v.pathname).pathname : v.pathname]),
        pathnameBase: v.pathnameBase === "/" ? c : Ui([c, i.encodeLocation ? i.encodeLocation(v.pathnameBase).pathname : v.pathnameBase])
    })), a, n, r);
    return t && g ? S.createElement(ah.Provider, {
        value: {
            location: {
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default",
                ...h
            },
            navigationType: "POP"
        }
    }, g) : g
}

function GH() {
    let e = t9(),
        t = $H(e) ? `${e.status} ${e.statusText}` : e instanceof Error ? e.message : JSON.stringify(e),
        n = e instanceof Error ? e.stack : null,
        r = "rgba(200,200,200, 0.5)",
        i = {
            padding: "0.5rem",
            backgroundColor: r
        },
        o = {
            padding: "2px 4px",
            backgroundColor: r
        },
        a = null;
    return console.error("Error handled by React Router default ErrorBoundary:", e), a = S.createElement(S.Fragment, null, S.createElement("p", null, "💿 Hey developer 👋"), S.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", S.createElement("code", {
        style: o
    }, "ErrorBoundary"), " or", " ", S.createElement("code", {
        style: o
    }, "errorElement"), " prop on your route.")), S.createElement(S.Fragment, null, S.createElement("h2", null, "Unexpected Application Error!"), S.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, t), n ? S.createElement("pre", {
        style: i
    }, n) : null, a)
}
var qH = S.createElement(GH, null),
    KH = class extends S.Component {
        constructor(e) {
            super(e), this.state = {
                location: e.location,
                revalidation: e.revalidation,
                error: e.error
            }
        }
        static getDerivedStateFromError(e) {
            return {
                error: e
            }
        }
        static getDerivedStateFromProps(e, t) {
            return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? {
                error: e.error,
                location: e.location,
                revalidation: e.revalidation
            } : {
                error: e.error !== void 0 ? e.error : t.error,
                location: t.location,
                revalidation: e.revalidation || t.revalidation
            }
        }
        componentDidCatch(e, t) {
            console.error("React Router caught the following error during render", e, t)
        }
        render() {
            return this.state.error !== void 0 ? S.createElement(fo.Provider, {
                value: this.props.routeContext
            }, S.createElement(RE.Provider, {
                value: this.state.error,
                children: this.props.component
            })) : this.props.children
        }
    };

function QH({
    routeContext: e,
    match: t,
    children: n
}) {
    let r = S.useContext(Fl);
    return r && r.static && r.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (r.staticContext._deepestRenderedBoundaryId = t.route.id), S.createElement(fo.Provider, {
        value: e
    }, n)
}

function YH(e, t = [], n = null, r = null) {
    if (e == null) {
        if (!n) return null;
        if (n.errors) e = n.matches;
        else if (t.length === 0 && !n.initialized && n.matches.length > 0) e = n.matches;
        else return null
    }
    let i = e,
        o = n == null ? void 0 : n.errors;
    if (o != null) {
        let u = i.findIndex(l => l.route.id && (o == null ? void 0 : o[l.route.id]) !== void 0);
        ft(u >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(o).join(",")}`), i = i.slice(0, Math.min(i.length, u + 1))
    }
    let a = !1,
        s = -1;
    if (n)
        for (let u = 0; u < i.length; u++) {
            let l = i[u];
            if ((l.route.HydrateFallback || l.route.hydrateFallbackElement) && (s = u), l.route.id) {
                let {
                    loaderData: c,
                    errors: f
                } = n, d = l.route.loader && !c.hasOwnProperty(l.route.id) && (!f || f[l.route.id] === void 0);
                if (l.route.lazy || d) {
                    a = !0, s >= 0 ? i = i.slice(0, s + 1) : i = [i[0]];
                    break
                }
            }
        }
    return i.reduceRight((u, l, c) => {
        let f, d = !1,
            h = null,
            m = null;
        n && (f = o && l.route.id ? o[l.route.id] : void 0, h = l.route.errorElement || qH, a && (s < 0 && c === 0 ? (zj("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), d = !0, m = null) : s === c && (d = !0, m = l.route.hydrateFallbackElement || null)));
        let p = t.concat(i.slice(0, c + 1)),
            y = () => {
                let g;
                return f ? g = h : d ? g = m : l.route.Component ? g = S.createElement(l.route.Component, null) : l.route.element ? g = l.route.element : g = u, S.createElement(QH, {
                    match: l,
                    routeContext: {
                        outlet: u,
                        matches: p,
                        isDataRoute: n != null
                    },
                    children: g
                })
            };
        return n && (l.route.ErrorBoundary || l.route.errorElement || c === 0) ? S.createElement(KH, {
            location: n.location,
            revalidation: n.revalidation,
            component: h,
            error: f,
            children: y(),
            routeContext: {
                outlet: null,
                matches: p,
                isDataRoute: !0
            }
        }) : y()
    }, null)
}

function jE(e) {
    return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}

function XH(e) {
    let t = S.useContext(Fl);
    return ft(t, jE(e)), t
}

function ZH(e) {
    let t = S.useContext(Qy);
    return ft(t, jE(e)), t
}

function JH(e) {
    let t = S.useContext(fo);
    return ft(t, jE(e)), t
}

function BE(e) {
    let t = JH(e),
        n = t.matches[t.matches.length - 1];
    return ft(n.route.id, `${e} can only be used on routes that contain a unique "id"`), n.route.id
}

function e9() {
    return BE("useRouteId")
}

function t9() {
    var r;
    let e = S.useContext(RE),
        t = ZH("useRouteError"),
        n = BE("useRouteError");
    return e !== void 0 ? e : (r = t.errors) == null ? void 0 : r[n]
}

function n9() {
    let {
        router: e
    } = XH("useNavigate"), t = BE("useNavigate"), n = S.useRef(!1);
    return Hj(() => {
        n.current = !0
    }), S.useCallback(async (i, o = {}) => {
        di(n.current, Uj), n.current && (typeof i == "number" ? e.navigate(i) : await e.navigate(i, {
            fromRouteId: t,
            ...o
        }))
    }, [e, t])
}
var GP = {};

function zj(e, t, n) {
    !t && !GP[e] && (GP[e] = !0, di(!1, n))
}
S.memo(r9);

function r9({
    routes: e,
    future: t,
    state: n
}) {
    return Vj(e, void 0, n, t)
}

function Zs(e) {
    ft(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")
}

function i9({
    basename: e = "/",
    children: t = null,
    location: n,
    navigationType: r = "POP",
    navigator: i,
    static: o = !1
}) {
    ft(!sh(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");
    let a = e.replace(/^\/*/, "/"),
        s = S.useMemo(() => ({
            basename: a,
            navigator: i,
            static: o,
            future: {}
        }), [a, i, o]);
    typeof n == "string" && (n = Ll(n));
    let {
        pathname: u = "/",
        search: l = "",
        hash: c = "",
        state: f = null,
        key: d = "default"
    } = n, h = S.useMemo(() => {
        let m = na(u, a);
        return m == null ? null : {
            location: {
                pathname: m,
                search: l,
                hash: c,
                state: f,
                key: d
            },
            navigationType: r
        }
    }, [a, u, l, c, f, d, r]);
    return di(h != null, `<Router basename="${a}"> is not able to match the URL "${u}${l}${c}" because it does not start with the basename, so the <Router> won't render anything.`), h == null ? null : S.createElement(yi.Provider, {
        value: s
    }, S.createElement(ah.Provider, {
        children: t,
        value: h
    }))
}

function o9({
    children: e,
    location: t
}) {
    return WH(rx(e), t)
}

function rx(e, t = []) {
    let n = [];
    return S.Children.forEach(e, (r, i) => {
        if (!S.isValidElement(r)) return;
        let o = [...t, i];
        if (r.type === S.Fragment) {
            n.push.apply(n, rx(r.props.children, o));
            return
        }
        ft(r.type === Zs, `[${typeof r.type=="string"?r.type:r.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`), ft(!r.props.index || !r.props.children, "An index route cannot have child routes.");
        let a = {
            id: r.props.id || o.join("-"),
            caseSensitive: r.props.caseSensitive,
            element: r.props.element,
            Component: r.props.Component,
            index: r.props.index,
            path: r.props.path,
            loader: r.props.loader,
            action: r.props.action,
            hydrateFallbackElement: r.props.hydrateFallbackElement,
            HydrateFallback: r.props.HydrateFallback,
            errorElement: r.props.errorElement,
            ErrorBoundary: r.props.ErrorBoundary,
            hasErrorBoundary: r.props.hasErrorBoundary === !0 || r.props.ErrorBoundary != null || r.props.errorElement != null,
            shouldRevalidate: r.props.shouldRevalidate,
            handle: r.props.handle,
            lazy: r.props.lazy
        };
        r.props.children && (a.children = rx(r.props.children, o)), n.push(a)
    }), n
}
var $p = "get",
    Lp = "application/x-www-form-urlencoded";

function Yy(e) {
    return e != null && typeof e.tagName == "string"
}

function a9(e) {
    return Yy(e) && e.tagName.toLowerCase() === "button"
}

function s9(e) {
    return Yy(e) && e.tagName.toLowerCase() === "form"
}

function u9(e) {
    return Yy(e) && e.tagName.toLowerCase() === "input"
}

function l9(e) {
    return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
}

function c9(e, t) {
    return e.button === 0 && (!t || t === "_self") && !l9(e)
}
var Yh = null;

function f9() {
    if (Yh === null) try {
        new FormData(document.createElement("form"), 0), Yh = !1
    } catch {
        Yh = !0
    }
    return Yh
}
var d9 = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);

function X0(e) {
    return e != null && !d9.has(e) ? (di(!1, `"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${Lp}"`), null) : e
}

function h9(e, t) {
    let n, r, i, o, a;
    if (s9(e)) {
        let s = e.getAttribute("action");
        r = s ? na(s, t) : null, n = e.getAttribute("method") || $p, i = X0(e.getAttribute("enctype")) || Lp, o = new FormData(e)
    } else if (a9(e) || u9(e) && (e.type === "submit" || e.type === "image")) {
        let s = e.form;
        if (s == null) throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
        let u = e.getAttribute("formaction") || s.getAttribute("action");
        if (r = u ? na(u, t) : null, n = e.getAttribute("formmethod") || s.getAttribute("method") || $p, i = X0(e.getAttribute("formenctype")) || X0(s.getAttribute("enctype")) || Lp, o = new FormData(s, e), !f9()) {
            let {
                name: l,
                type: c,
                value: f
            } = e;
            if (c === "image") {
                let d = l ? `${l}.` : "";
                o.append(`${d}x`, "0"), o.append(`${d}y`, "0")
            } else l && o.append(l, f)
        }
    } else {
        if (Yy(e)) throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
        n = $p, r = null, i = Lp, a = e
    }
    return o && i === "text/plain" && (a = o, o = void 0), {
        action: r,
        method: n.toLowerCase(),
        encType: i,
        formData: o,
        body: a
    }
}

function DE(e, t) {
    if (e === !1 || e === null || typeof e > "u") throw new Error(t)
}
async function p9(e, t) {
    if (e.id in t) return t[e.id];
    try {
        let n = await
        import (e.module);
        return t[e.id] = n, n
    } catch (n) {
        return console.error(`Error loading route module \`${e.module}\`, reloading page...`), console.error(n), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => {})
    }
}

function m9(e) {
    return e == null ? !1 : e.href == null ? e.rel === "preload" && typeof e.imageSrcSet == "string" && typeof e.imageSizes == "string" : typeof e.rel == "string" && typeof e.href == "string"
}
async function g9(e, t, n) {
    let r = await Promise.all(e.map(async i => {
        let o = t.routes[i.route.id];
        if (o) {
            let a = await p9(o, n);
            return a.links ? a.links() : []
        }
        return []
    }));
    return w9(r.flat(1).filter(m9).filter(i => i.rel === "stylesheet" || i.rel === "preload").map(i => i.rel === "stylesheet" ? { ...i,
        rel: "prefetch",
        as: "style"
    } : { ...i,
        rel: "prefetch"
    }))
}

function qP(e, t, n, r, i, o) {
    let a = (u, l) => n[l] ? u.route.id !== n[l].route.id : !0,
        s = (u, l) => {
            var c;
            return n[l].pathname !== u.pathname || ((c = n[l].route.path) == null ? void 0 : c.endsWith("*")) && n[l].params["*"] !== u.params["*"]
        };
    return o === "assets" ? t.filter((u, l) => a(u, l) || s(u, l)) : o === "data" ? t.filter((u, l) => {
        var f;
        let c = r.routes[u.route.id];
        if (!c || !c.hasLoader) return !1;
        if (a(u, l) || s(u, l)) return !0;
        if (u.route.shouldRevalidate) {
            let d = u.route.shouldRevalidate({
                currentUrl: new URL(i.pathname + i.search + i.hash, window.origin),
                currentParams: ((f = n[0]) == null ? void 0 : f.params) || {},
                nextUrl: new URL(e, window.origin),
                nextParams: u.params,
                defaultShouldRevalidate: !0
            });
            if (typeof d == "boolean") return d
        }
        return !0
    }) : []
}

function y9(e, t, {
    includeHydrateFallback: n
} = {}) {
    return v9(e.map(r => {
        let i = t.routes[r.route.id];
        if (!i) return [];
        let o = [i.module];
        return i.clientActionModule && (o = o.concat(i.clientActionModule)), i.clientLoaderModule && (o = o.concat(i.clientLoaderModule)), n && i.hydrateFallbackModule && (o = o.concat(i.hydrateFallbackModule)), i.imports && (o = o.concat(i.imports)), o
    }).flat(1))
}

function v9(e) {
    return [...new Set(e)]
}

function b9(e) {
    let t = {},
        n = Object.keys(e).sort();
    for (let r of n) t[r] = e[r];
    return t
}

function w9(e, t) {
    let n = new Set;
    return new Set(t), e.reduce((r, i) => {
        let o = JSON.stringify(b9(i));
        return n.has(o) || (n.add(o), r.push({
            key: o,
            link: i
        })), r
    }, [])
}

function x9(e) {
    let t = typeof e == "string" ? new URL(e, typeof window > "u" ? "server://singlefetch/" : window.location.origin) : e;
    return t.pathname === "/" ? t.pathname = "_root.data" : t.pathname = `${t.pathname.replace(/\/$/,"")}.data`, t
}

function A9() {
    let e = S.useContext(Fl);
    return DE(e, "You must render this element inside a <DataRouterContext.Provider> element"), e
}

function E9() {
    let e = S.useContext(Qy);
    return DE(e, "You must render this element inside a <DataRouterStateContext.Provider> element"), e
}
var $E = S.createContext(void 0);
$E.displayName = "FrameworkContext";

function Wj() {
    let e = S.useContext($E);
    return DE(e, "You must render this element inside a <HydratedRouter> element"), e
}

function S9(e, t) {
    let n = S.useContext($E),
        [r, i] = S.useState(!1),
        [o, a] = S.useState(!1),
        {
            onFocus: s,
            onBlur: u,
            onMouseEnter: l,
            onMouseLeave: c,
            onTouchStart: f
        } = t,
        d = S.useRef(null);
    S.useEffect(() => {
        if (e === "render" && a(!0), e === "viewport") {
            let p = g => {
                    g.forEach(b => {
                        a(b.isIntersecting)
                    })
                },
                y = new IntersectionObserver(p, {
                    threshold: .5
                });
            return d.current && y.observe(d.current), () => {
                y.disconnect()
            }
        }
    }, [e]), S.useEffect(() => {
        if (r) {
            let p = setTimeout(() => {
                a(!0)
            }, 100);
            return () => {
                clearTimeout(p)
            }
        }
    }, [r]);
    let h = () => {
            i(!0)
        },
        m = () => {
            i(!1), a(!1)
        };
    return n ? e !== "intent" ? [o, d, {}] : [o, d, {
        onFocus: vc(s, h),
        onBlur: vc(u, m),
        onMouseEnter: vc(l, h),
        onMouseLeave: vc(c, m),
        onTouchStart: vc(f, h)
    }] : [!1, d, {}]
}

function vc(e, t) {
    return n => {
        e && e(n), n.defaultPrevented || t(n)
    }
}

function _9({
    page: e,
    ...t
}) {
    let {
        router: n
    } = A9(), r = S.useMemo(() => Rj(n.routes, e, n.basename), [n.routes, e, n.basename]);
    return r ? S.createElement(P9, {
        page: e,
        matches: r,
        ...t
    }) : null
}

function T9(e) {
    let {
        manifest: t,
        routeModules: n
    } = Wj(), [r, i] = S.useState([]);
    return S.useEffect(() => {
        let o = !1;
        return g9(e, t, n).then(a => {
            o || i(a)
        }), () => {
            o = !0
        }
    }, [e, t, n]), r
}

function P9({
    page: e,
    matches: t,
    ...n
}) {
    let r = Rs(),
        {
            manifest: i,
            routeModules: o
        } = Wj(),
        {
            loaderData: a,
            matches: s
        } = E9(),
        u = S.useMemo(() => qP(e, t, s, i, r, "data"), [e, t, s, i, r]),
        l = S.useMemo(() => qP(e, t, s, i, r, "assets"), [e, t, s, i, r]),
        c = S.useMemo(() => {
            if (e === r.pathname + r.search + r.hash) return [];
            let h = new Set,
                m = !1;
            if (t.forEach(y => {
                    var b;
                    let g = i.routes[y.route.id];
                    !g || !g.hasLoader || (!u.some(v => v.route.id === y.route.id) && y.route.id in a && ((b = o[y.route.id]) != null && b.shouldRevalidate) || g.hasClientLoader ? m = !0 : h.add(y.route.id))
                }), h.size === 0) return [];
            let p = x9(e);
            return m && h.size > 0 && p.searchParams.set("_routes", t.filter(y => h.has(y.route.id)).map(y => y.route.id).join(",")), [p.pathname + p.search]
        }, [a, r, i, u, t, e, o]),
        f = S.useMemo(() => y9(l, i), [l, i]),
        d = T9(l);
    return S.createElement(S.Fragment, null, c.map(h => S.createElement("link", {
        key: h,
        rel: "prefetch",
        as: "fetch",
        href: h,
        ...n
    })), f.map(h => S.createElement("link", {
        key: h,
        rel: "modulepreload",
        href: h,
        ...n
    })), d.map(({
        key: h,
        link: m
    }) => S.createElement("link", {
        key: h,
        ...m
    })))
}

function O9(...e) {
    return t => {
        e.forEach(n => {
            typeof n == "function" ? n(t) : n != null && (n.current = t)
        })
    }
}
var Gj = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
    Gj && (window.__reactRouterVersion = "7.2.0")
} catch {}

function k9({
    basename: e,
    children: t,
    window: n
}) {
    let r = S.useRef();
    r.current == null && (r.current = gH({
        window: n,
        v5Compat: !0
    }));
    let i = r.current,
        [o, a] = S.useState({
            action: i.action,
            location: i.location
        }),
        s = S.useCallback(u => {
            S.startTransition(() => a(u))
        }, [a]);
    return S.useLayoutEffect(() => i.listen(s), [i, s]), S.createElement(i9, {
        basename: e,
        children: t,
        location: o.location,
        navigationType: o.action,
        navigator: i
    })
}
var qj = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
    mt = S.forwardRef(function({
        onClick: t,
        discover: n = "render",
        prefetch: r = "none",
        relative: i,
        reloadDocument: o,
        replace: a,
        state: s,
        target: u,
        to: l,
        preventScrollReset: c,
        viewTransition: f,
        ...d
    }, h) {
        let {
            basename: m
        } = S.useContext(yi), p = typeof l == "string" && qj.test(l), y, g = !1;
        if (typeof l == "string" && p && (y = l, Gj)) try {
            let O = new URL(window.location.href),
                k = l.startsWith("//") ? new URL(O.protocol + l) : new URL(l),
                I = na(k.pathname, m);
            k.origin === O.origin && I != null ? l = I + k.search + k.hash : g = !0
        } catch {
            di(!1, `<Link to="${l}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)
        }
        let b = HH(l, {
                relative: i
            }),
            [v, A, w] = S9(r, d),
            x = N9(l, {
                replace: a,
                state: s,
                target: u,
                preventScrollReset: c,
                relative: i,
                viewTransition: f
            });

        function T(O) {
            t && t(O), O.defaultPrevented || x(O)
        }
        let _ = S.createElement("a", { ...d,
            ...w,
            href: y || b,
            onClick: g || o ? t : T,
            ref: O9(h, A),
            target: u,
            "data-discover": !p && n === "render" ? "true" : void 0
        });
        return v && !p ? S.createElement(S.Fragment, null, _, S.createElement(_9, {
            page: b
        })) : _
    });
mt.displayName = "Link";
var C9 = S.forwardRef(function({
    "aria-current": t = "page",
    caseSensitive: n = !1,
    className: r = "",
    end: i = !1,
    style: o,
    to: a,
    viewTransition: s,
    children: u,
    ...l
}, c) {
    let f = uh(a, {
            relative: l.relative
        }),
        d = Rs(),
        h = S.useContext(Qy),
        {
            navigator: m,
            basename: p
        } = S.useContext(yi),
        y = h != null && $9(f) && s === !0,
        g = m.encodeLocation ? m.encodeLocation(f).pathname : f.pathname,
        b = d.pathname,
        v = h && h.navigation && h.navigation.location ? h.navigation.location.pathname : null;
    n || (b = b.toLowerCase(), v = v ? v.toLowerCase() : null, g = g.toLowerCase()), v && p && (v = na(v, p) || v);
    const A = g !== "/" && g.endsWith("/") ? g.length - 1 : g.length;
    let w = b === g || !i && b.startsWith(g) && b.charAt(A) === "/",
        x = v != null && (v === g || !i && v.startsWith(g) && v.charAt(g.length) === "/"),
        T = {
            isActive: w,
            isPending: x,
            isTransitioning: y
        },
        _ = w ? t : void 0,
        O;
    typeof r == "function" ? O = r(T) : O = [r, w ? "active" : null, x ? "pending" : null, y ? "transitioning" : null].filter(Boolean).join(" ");
    let k = typeof o == "function" ? o(T) : o;
    return S.createElement(mt, { ...l,
        "aria-current": _,
        className: O,
        ref: c,
        style: k,
        to: a,
        viewTransition: s
    }, typeof u == "function" ? u(T) : u)
});
C9.displayName = "NavLink";
var I9 = S.forwardRef(({
    discover: e = "render",
    fetcherKey: t,
    navigate: n,
    reloadDocument: r,
    replace: i,
    state: o,
    method: a = $p,
    action: s,
    onSubmit: u,
    relative: l,
    preventScrollReset: c,
    viewTransition: f,
    ...d
}, h) => {
    let m = B9(),
        p = D9(s, {
            relative: l
        }),
        y = a.toLowerCase() === "get" ? "get" : "post",
        g = typeof s == "string" && qj.test(s),
        b = v => {
            if (u && u(v), v.defaultPrevented) return;
            v.preventDefault();
            let A = v.nativeEvent.submitter,
                w = (A == null ? void 0 : A.getAttribute("formmethod")) || a;
            m(A || v.currentTarget, {
                fetcherKey: t,
                method: w,
                navigate: n,
                replace: i,
                state: o,
                relative: l,
                preventScrollReset: c,
                viewTransition: f
            })
        };
    return S.createElement("form", {
        ref: h,
        method: y,
        action: p,
        onSubmit: r ? u : b,
        ...d,
        "data-discover": !g && e === "render" ? "true" : void 0
    })
});
I9.displayName = "Form";

function M9(e) {
    return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}

function Kj(e) {
    let t = S.useContext(Fl);
    return ft(t, M9(e)), t
}

function N9(e, {
    target: t,
    replace: n,
    state: r,
    preventScrollReset: i,
    relative: o,
    viewTransition: a
} = {}) {
    let s = VH(),
        u = Rs(),
        l = uh(e, {
            relative: o
        });
    return S.useCallback(c => {
        if (c9(c, t)) {
            c.preventDefault();
            let f = n !== void 0 ? n : $f(u) === $f(l);
            s(e, {
                replace: f,
                state: r,
                preventScrollReset: i,
                relative: o,
                viewTransition: a
            })
        }
    }, [u, s, l, n, r, t, e, i, o, a])
}
var R9 = 0,
    j9 = () => `__${String(++R9)}__`;

function B9() {
    let {
        router: e
    } = Kj("useSubmit"), {
        basename: t
    } = S.useContext(yi), n = e9();
    return S.useCallback(async (r, i = {}) => {
        let {
            action: o,
            method: a,
            encType: s,
            formData: u,
            body: l
        } = h9(r, t);
        if (i.navigate === !1) {
            let c = i.fetcherKey || j9();
            await e.fetch(c, n, i.action || o, {
                preventScrollReset: i.preventScrollReset,
                formData: u,
                body: l,
                formMethod: i.method || a,
                formEncType: i.encType || s,
                flushSync: i.flushSync
            })
        } else await e.navigate(i.action || o, {
            preventScrollReset: i.preventScrollReset,
            formData: u,
            body: l,
            formMethod: i.method || a,
            formEncType: i.encType || s,
            replace: i.replace,
            state: i.state,
            fromRouteId: n,
            flushSync: i.flushSync,
            viewTransition: i.viewTransition
        })
    }, [e, t, n])
}

function D9(e, {
    relative: t
} = {}) {
    let {
        basename: n
    } = S.useContext(yi), r = S.useContext(fo);
    ft(r, "useFormAction must be used inside a RouteContext");
    let [i] = r.matches.slice(-1), o = { ...uh(e || ".", {
            relative: t
        })
    }, a = Rs();
    if (e == null) {
        o.search = a.search;
        let s = new URLSearchParams(o.search),
            u = s.getAll("index");
        if (u.some(c => c === "")) {
            s.delete("index"), u.filter(f => f).forEach(f => s.append("index", f));
            let c = s.toString();
            o.search = c ? `?${c}` : ""
        }
    }
    return (!e || e === ".") && i.route.index && (o.search = o.search ? o.search.replace(/^\?/, "?index&") : "?index"), n !== "/" && (o.pathname = o.pathname === "/" ? n : Ui([n, o.pathname])), $f(o)
}

function $9(e, t = {}) {
    let n = S.useContext(Fj);
    ft(n != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
    let {
        basename: r
    } = Kj("useViewTransitionState"), i = uh(e, {
        relative: t.relative
    });
    if (!n.isTransitioning) return !1;
    let o = na(n.currentLocation.pathname, r) || n.currentLocation.pathname,
        a = na(n.nextLocation.pathname, r) || n.nextLocation.pathname;
    return Sm(i.pathname, a) != null || Sm(i.pathname, o) != null
}
new TextEncoder;
const LE = S.createContext({});

function FE(e) {
    const t = S.useRef(null);
    return t.current === null && (t.current = e()), t.current
}
const Xy = S.createContext(null),
    UE = S.createContext({
        transformPagePoint: e => e,
        isStatic: !1,
        reducedMotion: "never"
    });
class L9 extends S.Component {
    getSnapshotBeforeUpdate(t) {
        const n = this.props.childRef.current;
        if (n && t.isPresent && !this.props.isPresent) {
            const r = n.offsetParent,
                i = r instanceof HTMLElement && r.offsetWidth || 0,
                o = this.props.sizeRef.current;
            o.height = n.offsetHeight || 0, o.width = n.offsetWidth || 0, o.top = n.offsetTop, o.left = n.offsetLeft, o.right = i - o.width - o.left
        }
        return null
    }
    componentDidUpdate() {}
    render() {
        return this.props.children
    }
}

function F9({
    children: e,
    isPresent: t,
    anchorX: n
}) {
    const r = S.useId(),
        i = S.useRef(null),
        o = S.useRef({
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            right: 0
        }),
        {
            nonce: a
        } = S.useContext(UE);
    return S.useInsertionEffect(() => {
        const {
            width: s,
            height: u,
            top: l,
            left: c,
            right: f
        } = o.current;
        if (t || !i.current || !s || !u) return;
        const d = n === "left" ? `left: ${c}` : `right: ${f}`;
        i.current.dataset.motionPopId = r;
        const h = document.createElement("style");
        return a && (h.nonce = a), document.head.appendChild(h), h.sheet && h.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${s}px !important;
            height: ${u}px !important;
            ${d}px !important;
            top: ${l}px !important;
          }
        `), () => {
            document.head.removeChild(h)
        }
    }, [t]), E.jsx(L9, {
        isPresent: t,
        childRef: i,
        sizeRef: o,
        children: S.cloneElement(e, {
            ref: i
        })
    })
}
const U9 = ({
    children: e,
    initial: t,
    isPresent: n,
    onExitComplete: r,
    custom: i,
    presenceAffectsLayout: o,
    mode: a,
    anchorX: s
}) => {
    const u = FE(H9),
        l = S.useId(),
        c = S.useCallback(d => {
            u.set(d, !0);
            for (const h of u.values())
                if (!h) return;
            r && r()
        }, [u, r]),
        f = S.useMemo(() => ({
            id: l,
            initial: t,
            isPresent: n,
            custom: i,
            onExitComplete: c,
            register: d => (u.set(d, !1), () => u.delete(d))
        }), o ? [Math.random(), c] : [n, c]);
    return S.useMemo(() => {
        u.forEach((d, h) => u.set(h, !1))
    }, [n]), S.useEffect(() => {
        !n && !u.size && r && r()
    }, [n]), a === "popLayout" && (e = E.jsx(F9, {
        isPresent: n,
        anchorX: s,
        children: e
    })), E.jsx(Xy.Provider, {
        value: f,
        children: e
    })
};

function H9() {
    return new Map
}

function Qj(e = !0) {
    const t = S.useContext(Xy);
    if (t === null) return [!0, null];
    const {
        isPresent: n,
        onExitComplete: r,
        register: i
    } = t, o = S.useId();
    S.useEffect(() => {
        if (e) return i(o)
    }, [e]);
    const a = S.useCallback(() => e && r && r(o), [o, r, e]);
    return !n && r ? [!1, a] : [!0]
}
const Xh = e => e.key || "";

function KP(e) {
    const t = [];
    return S.Children.forEach(e, n => {
        S.isValidElement(n) && t.push(n)
    }), t
}
const HE = typeof window < "u",
    Yj = HE ? S.useLayoutEffect : S.useEffect,
    V9 = ({
        children: e,
        custom: t,
        initial: n = !0,
        onExitComplete: r,
        presenceAffectsLayout: i = !0,
        mode: o = "sync",
        propagate: a = !1,
        anchorX: s = "left"
    }) => {
        const [u, l] = Qj(a), c = S.useMemo(() => KP(e), [e]), f = a && !u ? [] : c.map(Xh), d = S.useRef(!0), h = S.useRef(c), m = FE(() => new Map), [p, y] = S.useState(c), [g, b] = S.useState(c);
        Yj(() => {
            d.current = !1, h.current = c;
            for (let w = 0; w < g.length; w++) {
                const x = Xh(g[w]);
                f.includes(x) ? m.delete(x) : m.get(x) !== !0 && m.set(x, !1)
            }
        }, [g, f.length, f.join("-")]);
        const v = [];
        if (c !== p) {
            let w = [...c];
            for (let x = 0; x < g.length; x++) {
                const T = g[x],
                    _ = Xh(T);
                f.includes(_) || (w.splice(x, 0, T), v.push(T))
            }
            return o === "wait" && v.length && (w = v), b(KP(w)), y(c), null
        }
        const {
            forceRender: A
        } = S.useContext(LE);
        return E.jsx(E.Fragment, {
            children: g.map(w => {
                const x = Xh(w),
                    T = a && !u ? !1 : c === g || f.includes(x),
                    _ = () => {
                        if (m.has(x)) m.set(x, !0);
                        else return;
                        let O = !0;
                        m.forEach(k => {
                            k || (O = !1)
                        }), O && (A == null || A(), b(h.current), a && (l == null || l()), r && r())
                    };
                return E.jsx(U9, {
                    isPresent: T,
                    initial: !d.current || n ? void 0 : !1,
                    custom: t,
                    presenceAffectsLayout: i,
                    mode: o,
                    onExitComplete: T ? void 0 : _,
                    anchorX: s,
                    children: w
                }, x)
            })
        })
    },
    Hn = e => e;
let Xj = Hn;

function VE(e) {
    let t;
    return () => (t === void 0 && (t = e()), t)
}
const Ku = (e, t, n) => {
        const r = t - e;
        return r === 0 ? 1 : (n - e) / r
    },
    Hi = e => e * 1e3,
    Vi = e => e / 1e3,
    z9 = {
        useManualTiming: !1
    },
    Zh = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"],
    QP = {
        value: null
    };

function W9(e, t) {
    let n = new Set,
        r = new Set,
        i = !1,
        o = !1;
    const a = new WeakSet;
    let s = {
            delta: 0,
            timestamp: 0,
            isProcessing: !1
        },
        u = 0;

    function l(f) {
        a.has(f) && (c.schedule(f), e()), u++, f(s)
    }
    const c = {
        schedule: (f, d = !1, h = !1) => {
            const p = h && i ? n : r;
            return d && a.add(f), p.has(f) || p.add(f), f
        },
        cancel: f => {
            r.delete(f), a.delete(f)
        },
        process: f => {
            if (s = f, i) {
                o = !0;
                return
            }
            i = !0, [n, r] = [r, n], n.forEach(l), t && QP.value && QP.value.frameloop[t].push(u), u = 0, n.clear(), i = !1, o && (o = !1, c.process(f))
        }
    };
    return c
}
const G9 = 40;

function Zj(e, t) {
    let n = !1,
        r = !0;
    const i = {
            delta: 0,
            timestamp: 0,
            isProcessing: !1
        },
        o = () => n = !0,
        a = Zh.reduce((g, b) => (g[b] = W9(o, t ? b : void 0), g), {}),
        {
            read: s,
            resolveKeyframes: u,
            update: l,
            preRender: c,
            render: f,
            postRender: d
        } = a,
        h = () => {
            const g = performance.now();
            n = !1, i.delta = r ? 1e3 / 60 : Math.max(Math.min(g - i.timestamp, G9), 1), i.timestamp = g, i.isProcessing = !0, s.process(i), u.process(i), l.process(i), c.process(i), f.process(i), d.process(i), i.isProcessing = !1, n && t && (r = !1, e(h))
        },
        m = () => {
            n = !0, r = !0, i.isProcessing || e(h)
        };
    return {
        schedule: Zh.reduce((g, b) => {
            const v = a[b];
            return g[b] = (A, w = !1, x = !1) => (n || m(), v.schedule(A, w, x)), g
        }, {}),
        cancel: g => {
            for (let b = 0; b < Zh.length; b++) a[Zh[b]].cancel(g)
        },
        state: i,
        steps: a
    }
}
const {
    schedule: Ye,
    cancel: ra,
    state: Wt,
    steps: Z0
} = Zj(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Hn, !0), Jj = S.createContext({
    strict: !1
}), YP = {
    animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
}, Qu = {};
for (const e in YP) Qu[e] = {
    isEnabled: t => YP[e].some(n => !!t[n])
};

function q9(e) {
    for (const t in e) Qu[t] = { ...Qu[t],
        ...e[t]
    }
}
const K9 = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);

function _m(e) {
    return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || K9.has(e)
}
let eB = e => !_m(e);

function Q9(e) {
    e && (eB = t => t.startsWith("on") ? !_m(t) : e(t))
}
try {
    Q9(require("@emotion/is-prop-valid").default)
} catch {}

function Y9(e, t, n) {
    const r = {};
    for (const i in e) i === "values" && typeof e.values == "object" || (eB(i) || n === !0 && _m(i) || !t && !_m(i) || e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]);
    return r
}

function X9(e) {
    if (typeof Proxy > "u") return e;
    const t = new Map,
        n = (...r) => e(...r);
    return new Proxy(n, {
        get: (r, i) => i === "create" ? e : (t.has(i) || t.set(i, e(i)), t.get(i))
    })
}
const Zy = S.createContext({});

function Jy(e) {
    return e !== null && typeof e == "object" && typeof e.start == "function"
}

function Lf(e) {
    return typeof e == "string" || Array.isArray(e)
}
const zE = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"],
    WE = ["initial", ...zE];

function ev(e) {
    return Jy(e.animate) || WE.some(t => Lf(e[t]))
}

function tB(e) {
    return !!(ev(e) || e.variants)
}

function Z9(e, t) {
    if (ev(e)) {
        const {
            initial: n,
            animate: r
        } = e;
        return {
            initial: n === !1 || Lf(n) ? n : void 0,
            animate: Lf(r) ? r : void 0
        }
    }
    return e.inherit !== !1 ? t : {}
}

function J9(e) {
    const {
        initial: t,
        animate: n
    } = Z9(e, S.useContext(Zy));
    return S.useMemo(() => ({
        initial: t,
        animate: n
    }), [XP(t), XP(n)])
}

function XP(e) {
    return Array.isArray(e) ? e.join(" ") : e
}
const eV = Symbol.for("motionComponentSymbol");

function gu(e) {
    return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current")
}

function tV(e, t, n) {
    return S.useCallback(r => {
        r && e.onMount && e.onMount(r), t && (r ? t.mount(r) : t.unmount()), n && (typeof n == "function" ? n(r) : gu(n) && (n.current = r))
    }, [t])
}
const GE = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
    nV = "framerAppearId",
    nB = "data-" + GE(nV),
    {
        schedule: qE
    } = Zj(queueMicrotask, !1),
    rB = S.createContext({});

function rV(e, t, n, r, i) {
    var o, a;
    const {
        visualElement: s
    } = S.useContext(Zy), u = S.useContext(Jj), l = S.useContext(Xy), c = S.useContext(UE).reducedMotion, f = S.useRef(null);
    r = r || u.renderer, !f.current && r && (f.current = r(e, {
        visualState: t,
        parent: s,
        props: n,
        presenceContext: l,
        blockInitialAnimation: l ? l.initial === !1 : !1,
        reducedMotionConfig: c
    }));
    const d = f.current,
        h = S.useContext(rB);
    d && !d.projection && i && (d.type === "html" || d.type === "svg") && iV(f.current, n, i, h);
    const m = S.useRef(!1);
    S.useInsertionEffect(() => {
        d && m.current && d.update(n, l)
    });
    const p = n[nB],
        y = S.useRef(!!p && !(!((o = window.MotionHandoffIsComplete) === null || o === void 0) && o.call(window, p)) && ((a = window.MotionHasOptimisedAnimation) === null || a === void 0 ? void 0 : a.call(window, p)));
    return Yj(() => {
        d && (m.current = !0, window.MotionIsMounted = !0, d.updateFeatures(), qE.render(d.render), y.current && d.animationState && d.animationState.animateChanges())
    }), S.useEffect(() => {
        d && (!y.current && d.animationState && d.animationState.animateChanges(), y.current && (queueMicrotask(() => {
            var g;
            (g = window.MotionHandoffMarkAsComplete) === null || g === void 0 || g.call(window, p)
        }), y.current = !1))
    }), d
}

function iV(e, t, n, r) {
    const {
        layoutId: i,
        layout: o,
        drag: a,
        dragConstraints: s,
        layoutScroll: u,
        layoutRoot: l
    } = t;
    e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : iB(e.parent)), e.projection.setOptions({
        layoutId: i,
        layout: o,
        alwaysMeasureLayout: !!a || s && gu(s),
        visualElement: e,
        animationType: typeof o == "string" ? o : "both",
        initialPromotionConfig: r,
        layoutScroll: u,
        layoutRoot: l
    })
}

function iB(e) {
    if (e) return e.options.allowProjection !== !1 ? e.projection : iB(e.parent)
}

function oV({
    preloadedFeatures: e,
    createVisualElement: t,
    useRender: n,
    useVisualState: r,
    Component: i
}) {
    var o, a;
    e && q9(e);

    function s(l, c) {
        let f;
        const d = { ...S.useContext(UE),
                ...l,
                layoutId: aV(l)
            },
            {
                isStatic: h
            } = d,
            m = J9(l),
            p = r(l, h);
        if (!h && HE) {
            sV();
            const y = uV(d);
            f = y.MeasureLayout, m.visualElement = rV(i, p, d, t, y.ProjectionNode)
        }
        return E.jsxs(Zy.Provider, {
            value: m,
            children: [f && m.visualElement ? E.jsx(f, {
                visualElement: m.visualElement,
                ...d
            }) : null, n(i, l, tV(p, m.visualElement, c), p, h, m.visualElement)]
        })
    }
    s.displayName = `motion.${typeof i=="string"?i:`create(${(a=(o=i.displayName)!==null&&o!==void 0?o:i.name)!==null&&a!==void 0?a:""})`}`;
    const u = S.forwardRef(s);
    return u[eV] = i, u
}

function aV({
    layoutId: e
}) {
    const t = S.useContext(LE).id;
    return t && e !== void 0 ? t + "-" + e : e
}

function sV(e, t) {
    S.useContext(Jj).strict
}

function uV(e) {
    const {
        drag: t,
        layout: n
    } = Qu;
    if (!t && !n) return {};
    const r = { ...t,
        ...n
    };
    return {
        MeasureLayout: t != null && t.isEnabled(e) || n != null && n.isEnabled(e) ? r.MeasureLayout : void 0,
        ProjectionNode: r.ProjectionNode
    }
}
const oB = e => t => typeof t == "string" && t.startsWith(e),
    KE = oB("--"),
    lV = oB("var(--"),
    QE = e => lV(e) ? cV.test(e.split("/*")[0].trim()) : !1,
    cV = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
    Ff = {};

function fV(e) {
    for (const t in e) Ff[t] = e[t], KE(t) && (Ff[t].isCSSVariable = !0)
}
const Ul = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"],
    js = new Set(Ul);

function aB(e, {
    layout: t,
    layoutId: n
}) {
    return js.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!Ff[e] || e === "opacity")
}
const rn = e => !!(e && e.getVelocity),
    sB = (e, t) => t && typeof e == "number" ? t.transform(e) : e,
    Ji = (e, t, n) => n > t ? t : n < e ? e : n,
    Hl = {
        test: e => typeof e == "number",
        parse: parseFloat,
        transform: e => e
    },
    Uf = { ...Hl,
        transform: e => Ji(0, 1, e)
    },
    Jh = { ...Hl,
        default: 1
    },
    lh = e => ({
        test: t => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
        parse: parseFloat,
        transform: t => `${t}${e}`
    }),
    Po = lh("deg"),
    si = lh("%"),
    ue = lh("px"),
    dV = lh("vh"),
    hV = lh("vw"),
    ZP = { ...si,
        parse: e => si.parse(e) / 100,
        transform: e => si.transform(e * 100)
    },
    pV = {
        borderWidth: ue,
        borderTopWidth: ue,
        borderRightWidth: ue,
        borderBottomWidth: ue,
        borderLeftWidth: ue,
        borderRadius: ue,
        radius: ue,
        borderTopLeftRadius: ue,
        borderTopRightRadius: ue,
        borderBottomRightRadius: ue,
        borderBottomLeftRadius: ue,
        width: ue,
        maxWidth: ue,
        height: ue,
        maxHeight: ue,
        top: ue,
        right: ue,
        bottom: ue,
        left: ue,
        padding: ue,
        paddingTop: ue,
        paddingRight: ue,
        paddingBottom: ue,
        paddingLeft: ue,
        margin: ue,
        marginTop: ue,
        marginRight: ue,
        marginBottom: ue,
        marginLeft: ue,
        backgroundPositionX: ue,
        backgroundPositionY: ue
    },
    mV = {
        rotate: Po,
        rotateX: Po,
        rotateY: Po,
        rotateZ: Po,
        scale: Jh,
        scaleX: Jh,
        scaleY: Jh,
        scaleZ: Jh,
        skew: Po,
        skewX: Po,
        skewY: Po,
        distance: ue,
        translateX: ue,
        translateY: ue,
        translateZ: ue,
        x: ue,
        y: ue,
        z: ue,
        perspective: ue,
        transformPerspective: ue,
        opacity: Uf,
        originX: ZP,
        originY: ZP,
        originZ: ue
    },
    JP = { ...Hl,
        transform: Math.round
    },
    YE = { ...pV,
        ...mV,
        zIndex: JP,
        size: ue,
        fillOpacity: Uf,
        strokeOpacity: Uf,
        numOctaves: JP
    },
    gV = {
        x: "translateX",
        y: "translateY",
        z: "translateZ",
        transformPerspective: "perspective"
    },
    yV = Ul.length;

function vV(e, t, n) {
    let r = "",
        i = !0;
    for (let o = 0; o < yV; o++) {
        const a = Ul[o],
            s = e[a];
        if (s === void 0) continue;
        let u = !0;
        if (typeof s == "number" ? u = s === (a.startsWith("scale") ? 1 : 0) : u = parseFloat(s) === 0, !u || n) {
            const l = sB(s, YE[a]);
            if (!u) {
                i = !1;
                const c = gV[a] || a;
                r += `${c}(${l}) `
            }
            n && (t[a] = l)
        }
    }
    return r = r.trim(), n ? r = n(t, i ? "" : r) : i && (r = "none"), r
}

function XE(e, t, n) {
    const {
        style: r,
        vars: i,
        transformOrigin: o
    } = e;
    let a = !1,
        s = !1;
    for (const u in t) {
        const l = t[u];
        if (js.has(u)) {
            a = !0;
            continue
        } else if (KE(u)) {
            i[u] = l;
            continue
        } else {
            const c = sB(l, YE[u]);
            u.startsWith("origin") ? (s = !0, o[u] = c) : r[u] = c
        }
    }
    if (t.transform || (a || n ? r.transform = vV(t, e.transform, n) : r.transform && (r.transform = "none")), s) {
        const {
            originX: u = "50%",
            originY: l = "50%",
            originZ: c = 0
        } = o;
        r.transformOrigin = `${u} ${l} ${c}`
    }
}
const ZE = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
});

function uB(e, t, n) {
    for (const r in t) !rn(t[r]) && !aB(r, n) && (e[r] = t[r])
}

function bV({
    transformTemplate: e
}, t) {
    return S.useMemo(() => {
        const n = ZE();
        return XE(n, t, e), Object.assign({}, n.vars, n.style)
    }, [t])
}

function wV(e, t) {
    const n = e.style || {},
        r = {};
    return uB(r, n, e), Object.assign(r, bV(e, t)), r
}

function xV(e, t) {
    const n = {},
        r = wV(e, t);
    return e.drag && e.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag==="x"?"y":"x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n
}
const AV = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];

function JE(e) {
    return typeof e != "string" || e.includes("-") ? !1 : !!(AV.indexOf(e) > -1 || /[A-Z]/u.test(e))
}
const EV = {
        offset: "stroke-dashoffset",
        array: "stroke-dasharray"
    },
    SV = {
        offset: "strokeDashoffset",
        array: "strokeDasharray"
    };

function _V(e, t, n = 1, r = 0, i = !0) {
    e.pathLength = 1;
    const o = i ? EV : SV;
    e[o.offset] = ue.transform(-r);
    const a = ue.transform(t),
        s = ue.transform(n);
    e[o.array] = `${a} ${s}`
}

function e2(e, t, n) {
    return typeof e == "string" ? e : ue.transform(t + n * e)
}

function TV(e, t, n) {
    const r = e2(t, e.x, e.width),
        i = e2(n, e.y, e.height);
    return `${r} ${i}`
}

function eS(e, {
    attrX: t,
    attrY: n,
    attrScale: r,
    originX: i,
    originY: o,
    pathLength: a,
    pathSpacing: s = 1,
    pathOffset: u = 0,
    ...l
}, c, f) {
    if (XE(e, l, f), c) {
        e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
        return
    }
    e.attrs = e.style, e.style = {};
    const {
        attrs: d,
        style: h,
        dimensions: m
    } = e;
    d.transform && (m && (h.transform = d.transform), delete d.transform), m && (i !== void 0 || o !== void 0 || h.transform) && (h.transformOrigin = TV(m, i !== void 0 ? i : .5, o !== void 0 ? o : .5)), t !== void 0 && (d.x = t), n !== void 0 && (d.y = n), r !== void 0 && (d.scale = r), a !== void 0 && _V(d, a, s, u, !1)
}
const lB = () => ({ ...ZE(),
        attrs: {}
    }),
    tS = e => typeof e == "string" && e.toLowerCase() === "svg";

function PV(e, t, n, r) {
    const i = S.useMemo(() => {
        const o = lB();
        return eS(o, t, tS(r), e.transformTemplate), { ...o.attrs,
            style: { ...o.style
            }
        }
    }, [t]);
    if (e.style) {
        const o = {};
        uB(o, e.style, e), i.style = { ...o,
            ...i.style
        }
    }
    return i
}

function OV(e = !1) {
    return (n, r, i, {
        latestValues: o
    }, a) => {
        const u = (JE(n) ? PV : xV)(r, o, a, n),
            l = Y9(r, typeof n == "string", e),
            c = n !== S.Fragment ? { ...l,
                ...u,
                ref: i
            } : {},
            {
                children: f
            } = r,
            d = S.useMemo(() => rn(f) ? f.get() : f, [f]);
        return S.createElement(n, { ...c,
            children: d
        })
    }
}

function t2(e) {
    const t = [{}, {}];
    return e == null || e.values.forEach((n, r) => {
        t[0][r] = n.get(), t[1][r] = n.getVelocity()
    }), t
}

function nS(e, t, n, r) {
    if (typeof t == "function") {
        const [i, o] = t2(r);
        t = t(n !== void 0 ? n : e.custom, i, o)
    }
    if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") {
        const [i, o] = t2(r);
        t = t(n !== void 0 ? n : e.custom, i, o)
    }
    return t
}
const ix = e => Array.isArray(e),
    kV = e => !!(e && typeof e == "object" && e.mix && e.toValue),
    CV = e => ix(e) ? e[e.length - 1] || 0 : e;

function Fp(e) {
    const t = rn(e) ? e.get() : e;
    return kV(t) ? t.toValue() : t
}

function IV({
    scrapeMotionValuesFromProps: e,
    createRenderState: t,
    onUpdate: n
}, r, i, o) {
    const a = {
        latestValues: MV(r, i, o, e),
        renderState: t()
    };
    return n && (a.onMount = s => n({
        props: r,
        current: s,
        ...a
    }), a.onUpdate = s => n(s)), a
}
const cB = e => (t, n) => {
    const r = S.useContext(Zy),
        i = S.useContext(Xy),
        o = () => IV(e, t, r, i);
    return n ? o() : FE(o)
};

function MV(e, t, n, r) {
    const i = {},
        o = r(e, {});
    for (const d in o) i[d] = Fp(o[d]);
    let {
        initial: a,
        animate: s
    } = e;
    const u = ev(e),
        l = tB(e);
    t && l && !u && e.inherit !== !1 && (a === void 0 && (a = t.initial), s === void 0 && (s = t.animate));
    let c = n ? n.initial === !1 : !1;
    c = c || a === !1;
    const f = c ? s : a;
    if (f && typeof f != "boolean" && !Jy(f)) {
        const d = Array.isArray(f) ? f : [f];
        for (let h = 0; h < d.length; h++) {
            const m = nS(e, d[h]);
            if (m) {
                const {
                    transitionEnd: p,
                    transition: y,
                    ...g
                } = m;
                for (const b in g) {
                    let v = g[b];
                    if (Array.isArray(v)) {
                        const A = c ? v.length - 1 : 0;
                        v = v[A]
                    }
                    v !== null && (i[b] = v)
                }
                for (const b in p) i[b] = p[b]
            }
        }
    }
    return i
}

function rS(e, t, n) {
    var r;
    const {
        style: i
    } = e, o = {};
    for (const a in i)(rn(i[a]) || t.style && rn(t.style[a]) || aB(a, e) || ((r = n == null ? void 0 : n.getValue(a)) === null || r === void 0 ? void 0 : r.liveStyle) !== void 0) && (o[a] = i[a]);
    return o
}
const NV = {
    useVisualState: cB({
        scrapeMotionValuesFromProps: rS,
        createRenderState: ZE
    })
};

function fB(e, t) {
    try {
        t.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect()
    } catch {
        t.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }
    }
}

function dB(e, {
    style: t,
    vars: n
}, r, i) {
    Object.assign(e.style, t, i && i.getProjectionStyles(r));
    for (const o in n) e.style.setProperty(o, n[o])
}
const hB = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);

function pB(e, t, n, r) {
    dB(e, t, void 0, r);
    for (const i in t.attrs) e.setAttribute(hB.has(i) ? i : GE(i), t.attrs[i])
}

function mB(e, t, n) {
    const r = rS(e, t, n);
    for (const i in e)
        if (rn(e[i]) || rn(t[i])) {
            const o = Ul.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
            r[o] = e[i]
        }
    return r
}
const n2 = ["x", "y", "width", "height", "cx", "cy", "r"],
    RV = {
        useVisualState: cB({
            scrapeMotionValuesFromProps: mB,
            createRenderState: lB,
            onUpdate: ({
                props: e,
                prevProps: t,
                current: n,
                renderState: r,
                latestValues: i
            }) => {
                if (!n) return;
                let o = !!e.drag;
                if (!o) {
                    for (const s in i)
                        if (js.has(s)) {
                            o = !0;
                            break
                        }
                }
                if (!o) return;
                let a = !t;
                if (t)
                    for (let s = 0; s < n2.length; s++) {
                        const u = n2[s];
                        e[u] !== t[u] && (a = !0)
                    }
                a && Ye.read(() => {
                    fB(n, r), Ye.render(() => {
                        eS(r, i, tS(n.tagName), e.transformTemplate), pB(n, r)
                    })
                })
            }
        })
    };

function jV(e, t) {
    return function(r, {
        forwardMotionProps: i
    } = {
        forwardMotionProps: !1
    }) {
        const a = { ...JE(r) ? RV : NV,
            preloadedFeatures: e,
            useRender: OV(i),
            createVisualElement: t,
            Component: r
        };
        return oV(a)
    }
}

function Hf(e, t, n) {
    const r = e.getProps();
    return nS(r, t, n !== void 0 ? n : r.custom, e)
}
const BV = VE(() => window.ScrollTimeline !== void 0);
class DV {
    constructor(t) {
        this.stop = () => this.runAll("stop"), this.animations = t.filter(Boolean)
    }
    get finished() {
        return Promise.all(this.animations.map(t => "finished" in t ? t.finished : t))
    }
    getAll(t) {
        return this.animations[0][t]
    }
    setAll(t, n) {
        for (let r = 0; r < this.animations.length; r++) this.animations[r][t] = n
    }
    attachTimeline(t, n) {
        const r = this.animations.map(i => {
            if (BV() && i.attachTimeline) return i.attachTimeline(t);
            if (typeof n == "function") return n(i)
        });
        return () => {
            r.forEach((i, o) => {
                i && i(), this.animations[o].stop()
            })
        }
    }
    get time() {
        return this.getAll("time")
    }
    set time(t) {
        this.setAll("time", t)
    }
    get speed() {
        return this.getAll("speed")
    }
    set speed(t) {
        this.setAll("speed", t)
    }
    get startTime() {
        return this.getAll("startTime")
    }
    get duration() {
        let t = 0;
        for (let n = 0; n < this.animations.length; n++) t = Math.max(t, this.animations[n].duration);
        return t
    }
    runAll(t) {
        this.animations.forEach(n => n[t]())
    }
    flatten() {
        this.runAll("flatten")
    }
    play() {
        this.runAll("play")
    }
    pause() {
        this.runAll("pause")
    }
    cancel() {
        this.runAll("cancel")
    }
    complete() {
        this.runAll("complete")
    }
}
class $V extends DV {
    then(t, n) {
        return Promise.all(this.animations).then(t).catch(n)
    }
}

function iS(e, t) {
    return e ? e[t] || e.default || e : void 0
}
const ox = 2e4;

function gB(e) {
    let t = 0;
    const n = 50;
    let r = e.next(t);
    for (; !r.done && t < ox;) t += n, r = e.next(t);
    return t >= ox ? 1 / 0 : t
}

function oS(e) {
    return typeof e == "function"
}

function r2(e, t) {
    e.timeline = t, e.onfinish = null
}
const aS = e => Array.isArray(e) && typeof e[0] == "number",
    LV = {
        linearEasing: void 0
    };

function FV(e, t) {
    const n = VE(e);
    return () => {
        var r;
        return (r = LV[t]) !== null && r !== void 0 ? r : n()
    }
}
const Tm = FV(() => {
        try {
            document.createElement("div").animate({
                opacity: 0
            }, {
                easing: "linear(0, 1)"
            })
        } catch {
            return !1
        }
        return !0
    }, "linearEasing"),
    yB = (e, t, n = 10) => {
        let r = "";
        const i = Math.max(Math.round(t / n), 2);
        for (let o = 0; o < i; o++) r += e(Ku(0, i - 1, o)) + ", ";
        return `linear(${r.substring(0,r.length-2)})`
    };

function vB(e) {
    return !!(typeof e == "function" && Tm() || !e || typeof e == "string" && (e in ax || Tm()) || aS(e) || Array.isArray(e) && e.every(vB))
}
const Vc = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`,
    ax = {
        linear: "linear",
        ease: "ease",
        easeIn: "ease-in",
        easeOut: "ease-out",
        easeInOut: "ease-in-out",
        circIn: Vc([0, .65, .55, 1]),
        circOut: Vc([.55, 0, 1, .45]),
        backIn: Vc([.31, .01, .66, -.59]),
        backOut: Vc([.33, 1.53, .69, .99])
    };

function bB(e, t) {
    if (e) return typeof e == "function" && Tm() ? yB(e, t) : aS(e) ? Vc(e) : Array.isArray(e) ? e.map(n => bB(n, t) || ax.easeOut) : ax[e]
}
const Er = {
    x: !1,
    y: !1
};

function wB() {
    return Er.x || Er.y
}

function UV(e, t, n) {
    var r;
    if (e instanceof EventTarget) return [e];
    if (typeof e == "string") {
        let i = document;
        const o = (r = void 0) !== null && r !== void 0 ? r : i.querySelectorAll(e);
        return o ? Array.from(o) : []
    }
    return Array.from(e)
}

function xB(e, t) {
    const n = UV(e),
        r = new AbortController,
        i = {
            passive: !0,
            ...t,
            signal: r.signal
        };
    return [n, i, () => r.abort()]
}

function i2(e) {
    return !(e.pointerType === "touch" || wB())
}

function HV(e, t, n = {}) {
    const [r, i, o] = xB(e, n), a = s => {
        if (!i2(s)) return;
        const {
            target: u
        } = s, l = t(u, s);
        if (typeof l != "function" || !u) return;
        const c = f => {
            i2(f) && (l(f), u.removeEventListener("pointerleave", c))
        };
        u.addEventListener("pointerleave", c, i)
    };
    return r.forEach(s => {
        s.addEventListener("pointerenter", a, i)
    }), o
}

function Pm(e, t) {
    const n = `${t}PointerCapture`;
    if (e.target instanceof Element && n in e.target && e.pointerId !== void 0) try {
        e.target[n](e.pointerId)
    } catch {}
}
const AB = (e, t) => t ? e === t ? !0 : AB(e, t.parentElement) : !1,
    sS = e => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1,
    VV = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);

function zV(e) {
    return VV.has(e.tagName) || e.tabIndex !== -1
}
const zc = new WeakSet;

function o2(e) {
    return t => {
        t.key === "Enter" && e(t)
    }
}

function J0(e, t) {
    e.dispatchEvent(new PointerEvent("pointer" + t, {
        isPrimary: !0,
        bubbles: !0
    }))
}
const WV = (e, t) => {
    const n = e.currentTarget;
    if (!n) return;
    const r = o2(() => {
        if (zc.has(n)) return;
        J0(n, "down");
        const i = o2(() => {
                J0(n, "up")
            }),
            o = () => J0(n, "cancel");
        n.addEventListener("keyup", i, t), n.addEventListener("blur", o, t)
    });
    n.addEventListener("keydown", r, t), n.addEventListener("blur", () => n.removeEventListener("keydown", r), t)
};

function a2(e) {
    return sS(e) && !wB()
}

function GV(e, t, n = {}) {
    const [r, i, o] = xB(e, n), a = s => {
        const u = s.currentTarget;
        if (!u || !a2(s) || zc.has(u)) return;
        zc.add(u), Pm(s, "set");
        const l = t(u, s),
            c = (h, m) => {
                u.removeEventListener("pointerup", f), u.removeEventListener("pointercancel", d), Pm(h, "release"), !(!a2(h) || !zc.has(u)) && (zc.delete(u), typeof l == "function" && l(h, {
                    success: m
                }))
            },
            f = h => {
                (h.isTrusted ? qV(h, u instanceof Element ? u.getBoundingClientRect() : {
                    left: 0,
                    top: 0,
                    right: window.innerWidth,
                    bottom: window.innerHeight
                }) : !1) ? c(h, !1): c(h, !(u instanceof Element) || AB(u, h.target))
            },
            d = h => {
                c(h, !1)
            };
        u.addEventListener("pointerup", f, i), u.addEventListener("pointercancel", d, i), u.addEventListener("lostpointercapture", d, i)
    };
    return r.forEach(s => {
        s = n.useGlobalTarget ? window : s;
        let u = !1;
        s instanceof HTMLElement && (u = !0, !zV(s) && s.getAttribute("tabindex") === null && (s.tabIndex = 0)), s.addEventListener("pointerdown", a, i), u && s.addEventListener("focus", l => WV(l, i), i)
    }), o
}

function qV(e, t) {
    return e.clientX < t.left || e.clientX > t.right || e.clientY < t.top || e.clientY > t.bottom
}

function KV(e) {
    return e === "x" || e === "y" ? Er[e] ? null : (Er[e] = !0, () => {
        Er[e] = !1
    }) : Er.x || Er.y ? null : (Er.x = Er.y = !0, () => {
        Er.x = Er.y = !1
    })
}
const EB = new Set(["width", "height", "top", "left", "right", "bottom", ...Ul]);
let Up;

function QV() {
    Up = void 0
}
const ui = {
    now: () => (Up === void 0 && ui.set(Wt.isProcessing || z9.useManualTiming ? Wt.timestamp : performance.now()), Up),
    set: e => {
        Up = e, queueMicrotask(QV)
    }
};

function uS(e, t) {
    e.indexOf(t) === -1 && e.push(t)
}

function lS(e, t) {
    const n = e.indexOf(t);
    n > -1 && e.splice(n, 1)
}
class cS {
    constructor() {
        this.subscriptions = []
    }
    add(t) {
        return uS(this.subscriptions, t), () => lS(this.subscriptions, t)
    }
    notify(t, n, r) {
        const i = this.subscriptions.length;
        if (i)
            if (i === 1) this.subscriptions[0](t, n, r);
            else
                for (let o = 0; o < i; o++) {
                    const a = this.subscriptions[o];
                    a && a(t, n, r)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}

function SB(e, t) {
    return t ? e * (1e3 / t) : 0
}
const s2 = 30,
    YV = e => !isNaN(parseFloat(e));
class XV {
    constructor(t, n = {}) {
        this.version = "12.4.7", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r, i = !0) => {
            const o = ui.now();
            this.updatedAt !== o && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), i && this.events.renderRequest && this.events.renderRequest.notify(this.current)
        }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner
    }
    setCurrent(t) {
        this.current = t, this.updatedAt = ui.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = YV(this.current))
    }
    setPrevFrameValue(t = this.current) {
        this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt
    }
    onChange(t) {
        return this.on("change", t)
    }
    on(t, n) {
        this.events[t] || (this.events[t] = new cS);
        const r = this.events[t].add(n);
        return t === "change" ? () => {
            r(), Ye.read(() => {
                this.events.change.getSize() || this.stop()
            })
        } : r
    }
    clearListeners() {
        for (const t in this.events) this.events[t].clear()
    }
    attach(t, n) {
        this.passiveEffect = t, this.stopPassiveEffect = n
    }
    set(t, n = !0) {
        !n || !this.passiveEffect ? this.updateAndNotify(t, n) : this.passiveEffect(t, this.updateAndNotify)
    }
    setWithVelocity(t, n, r) {
        this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r
    }
    jump(t, n = !0) {
        this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
    }
    get() {
        return this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        const t = ui.now();
        if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > s2) return 0;
        const n = Math.min(this.updatedAt - this.prevUpdatedAt, s2);
        return SB(parseFloat(this.current) - parseFloat(this.prevFrameValue), n)
    }
    start(t) {
        return this.stop(), new Promise(n => {
            this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify()
        }).then(() => {
            this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation()
        })
    }
    stop() {
        this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        delete this.animation
    }
    destroy() {
        this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
    }
}

function Vf(e, t) {
    return new XV(e, t)
}

function ZV(e, t, n) {
    e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Vf(n))
}

function JV(e, t) {
    const n = Hf(e, t);
    let {
        transitionEnd: r = {},
        transition: i = {},
        ...o
    } = n || {};
    o = { ...o,
        ...r
    };
    for (const a in o) {
        const s = CV(o[a]);
        ZV(e, a, s)
    }
}

function e7(e) {
    return !!(rn(e) && e.add)
}

function sx(e, t) {
    const n = e.getValue("willChange");
    if (e7(n)) return n.add(t)
}

function _B(e) {
    return e.props[nB]
}
const TB = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e,
    t7 = 1e-7,
    n7 = 12;

function r7(e, t, n, r, i) {
    let o, a, s = 0;
    do a = t + (n - t) / 2, o = TB(a, r, i) - e, o > 0 ? n = a : t = a; while (Math.abs(o) > t7 && ++s < n7);
    return a
}

function ch(e, t, n, r) {
    if (e === t && n === r) return Hn;
    const i = o => r7(o, 0, 1, e, n);
    return o => o === 0 || o === 1 ? o : TB(i(o), t, r)
}
const PB = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2,
    OB = e => t => 1 - e(1 - t),
    kB = ch(.33, 1.53, .69, .99),
    fS = OB(kB),
    CB = PB(fS),
    IB = e => (e *= 2) < 1 ? .5 * fS(e) : .5 * (2 - Math.pow(2, -10 * (e - 1))),
    dS = e => 1 - Math.sin(Math.acos(e)),
    MB = OB(dS),
    NB = PB(dS),
    RB = e => /^0[^.\s]+$/u.test(e);

function i7(e) {
    return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || RB(e) : !0
}
const af = e => Math.round(e * 1e5) / 1e5,
    hS = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;

function o7(e) {
    return e == null
}
const a7 = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
    pS = (e, t) => n => !!(typeof n == "string" && a7.test(n) && n.startsWith(e) || t && !o7(n) && Object.prototype.hasOwnProperty.call(n, t)),
    jB = (e, t, n) => r => {
        if (typeof r != "string") return r;
        const [i, o, a, s] = r.match(hS);
        return {
            [e]: parseFloat(i),
            [t]: parseFloat(o),
            [n]: parseFloat(a),
            alpha: s !== void 0 ? parseFloat(s) : 1
        }
    },
    s7 = e => Ji(0, 255, e),
    eb = { ...Hl,
        transform: e => Math.round(s7(e))
    },
    Fa = {
        test: pS("rgb", "red"),
        parse: jB("red", "green", "blue"),
        transform: ({
            red: e,
            green: t,
            blue: n,
            alpha: r = 1
        }) => "rgba(" + eb.transform(e) + ", " + eb.transform(t) + ", " + eb.transform(n) + ", " + af(Uf.transform(r)) + ")"
    };

function u7(e) {
    let t = "",
        n = "",
        r = "",
        i = "";
    return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, r += r, i += i), {
        red: parseInt(t, 16),
        green: parseInt(n, 16),
        blue: parseInt(r, 16),
        alpha: i ? parseInt(i, 16) / 255 : 1
    }
}
const ux = {
        test: pS("#"),
        parse: u7,
        transform: Fa.transform
    },
    yu = {
        test: pS("hsl", "hue"),
        parse: jB("hue", "saturation", "lightness"),
        transform: ({
            hue: e,
            saturation: t,
            lightness: n,
            alpha: r = 1
        }) => "hsla(" + Math.round(e) + ", " + si.transform(af(t)) + ", " + si.transform(af(n)) + ", " + af(Uf.transform(r)) + ")"
    },
    Jt = {
        test: e => Fa.test(e) || ux.test(e) || yu.test(e),
        parse: e => Fa.test(e) ? Fa.parse(e) : yu.test(e) ? yu.parse(e) : ux.parse(e),
        transform: e => typeof e == "string" ? e : e.hasOwnProperty("red") ? Fa.transform(e) : yu.transform(e)
    },
    l7 = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;

function c7(e) {
    var t, n;
    return isNaN(e) && typeof e == "string" && (((t = e.match(hS)) === null || t === void 0 ? void 0 : t.length) || 0) + (((n = e.match(l7)) === null || n === void 0 ? void 0 : n.length) || 0) > 0
}
const BB = "number",
    DB = "color",
    f7 = "var",
    d7 = "var(",
    u2 = "${}",
    h7 = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;

function zf(e) {
    const t = e.toString(),
        n = [],
        r = {
            color: [],
            number: [],
            var: []
        },
        i = [];
    let o = 0;
    const s = t.replace(h7, u => (Jt.test(u) ? (r.color.push(o), i.push(DB), n.push(Jt.parse(u))) : u.startsWith(d7) ? (r.var.push(o), i.push(f7), n.push(u)) : (r.number.push(o), i.push(BB), n.push(parseFloat(u))), ++o, u2)).split(u2);
    return {
        values: n,
        split: s,
        indexes: r,
        types: i
    }
}

function $B(e) {
    return zf(e).values
}

function LB(e) {
    const {
        split: t,
        types: n
    } = zf(e), r = t.length;
    return i => {
        let o = "";
        for (let a = 0; a < r; a++)
            if (o += t[a], i[a] !== void 0) {
                const s = n[a];
                s === BB ? o += af(i[a]) : s === DB ? o += Jt.transform(i[a]) : o += i[a]
            }
        return o
    }
}
const p7 = e => typeof e == "number" ? 0 : e;

function m7(e) {
    const t = $B(e);
    return LB(e)(t.map(p7))
}
const ia = {
        test: c7,
        parse: $B,
        createTransformer: LB,
        getAnimatableNone: m7
    },
    g7 = new Set(["brightness", "contrast", "saturate", "opacity"]);

function y7(e) {
    const [t, n] = e.slice(0, -1).split("(");
    if (t === "drop-shadow") return e;
    const [r] = n.match(hS) || [];
    if (!r) return e;
    const i = n.replace(r, "");
    let o = g7.has(t) ? 1 : 0;
    return r !== n && (o *= 100), t + "(" + o + i + ")"
}
const v7 = /\b([a-z-]*)\(.*?\)/gu,
    lx = { ...ia,
        getAnimatableNone: e => {
            const t = e.match(v7);
            return t ? t.map(y7).join(" ") : e
        }
    },
    b7 = { ...YE,
        color: Jt,
        backgroundColor: Jt,
        outlineColor: Jt,
        fill: Jt,
        stroke: Jt,
        borderColor: Jt,
        borderTopColor: Jt,
        borderRightColor: Jt,
        borderBottomColor: Jt,
        borderLeftColor: Jt,
        filter: lx,
        WebkitFilter: lx
    },
    mS = e => b7[e];

function FB(e, t) {
    let n = mS(e);
    return n !== lx && (n = ia), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0
}
const w7 = new Set(["auto", "none", "0"]);

function x7(e, t, n) {
    let r = 0,
        i;
    for (; r < e.length && !i;) {
        const o = e[r];
        typeof o == "string" && !w7.has(o) && zf(o).values.length && (i = e[r]), r++
    }
    if (i && n)
        for (const o of t) e[o] = FB(n, i)
}
const l2 = e => e === Hl || e === ue,
    c2 = (e, t) => parseFloat(e.split(", ")[t]),
    f2 = (e, t) => (n, {
        transform: r
    }) => {
        if (r === "none" || !r) return 0;
        const i = r.match(/^matrix3d\((.+)\)$/u);
        if (i) return c2(i[1], t); {
            const o = r.match(/^matrix\((.+)\)$/u);
            return o ? c2(o[1], e) : 0
        }
    },
    A7 = new Set(["x", "y", "z"]),
    E7 = Ul.filter(e => !A7.has(e));

function S7(e) {
    const t = [];
    return E7.forEach(n => {
        const r = e.getValue(n);
        r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0))
    }), t
}
const Yu = {
    width: ({
        x: e
    }, {
        paddingLeft: t = "0",
        paddingRight: n = "0"
    }) => e.max - e.min - parseFloat(t) - parseFloat(n),
    height: ({
        y: e
    }, {
        paddingTop: t = "0",
        paddingBottom: n = "0"
    }) => e.max - e.min - parseFloat(t) - parseFloat(n),
    top: (e, {
        top: t
    }) => parseFloat(t),
    left: (e, {
        left: t
    }) => parseFloat(t),
    bottom: ({
        y: e
    }, {
        top: t
    }) => parseFloat(t) + (e.max - e.min),
    right: ({
        x: e
    }, {
        left: t
    }) => parseFloat(t) + (e.max - e.min),
    x: f2(4, 13),
    y: f2(5, 14)
};
Yu.translateX = Yu.x;
Yu.translateY = Yu.y;
const ts = new Set;
let cx = !1,
    fx = !1;

function UB() {
    if (fx) {
        const e = Array.from(ts).filter(r => r.needsMeasurement),
            t = new Set(e.map(r => r.element)),
            n = new Map;
        t.forEach(r => {
            const i = S7(r);
            i.length && (n.set(r, i), r.render())
        }), e.forEach(r => r.measureInitialState()), t.forEach(r => {
            r.render();
            const i = n.get(r);
            i && i.forEach(([o, a]) => {
                var s;
                (s = r.getValue(o)) === null || s === void 0 || s.set(a)
            })
        }), e.forEach(r => r.measureEndState()), e.forEach(r => {
            r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY)
        })
    }
    fx = !1, cx = !1, ts.forEach(e => e.complete()), ts.clear()
}

function HB() {
    ts.forEach(e => {
        e.readKeyframes(), e.needsMeasurement && (fx = !0)
    })
}

function _7() {
    HB(), UB()
}
class gS {
    constructor(t, n, r, i, o, a = !1) {
        this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = r, this.motionValue = i, this.element = o, this.isAsync = a
    }
    scheduleResolve() {
        this.isScheduled = !0, this.isAsync ? (ts.add(this), cx || (cx = !0, Ye.read(HB), Ye.resolveKeyframes(UB))) : (this.readKeyframes(), this.complete())
    }
    readKeyframes() {
        const {
            unresolvedKeyframes: t,
            name: n,
            element: r,
            motionValue: i
        } = this;
        for (let o = 0; o < t.length; o++)
            if (t[o] === null)
                if (o === 0) {
                    const a = i == null ? void 0 : i.get(),
                        s = t[t.length - 1];
                    if (a !== void 0) t[0] = a;
                    else if (r && n) {
                        const u = r.readValue(n, s);
                        u != null && (t[0] = u)
                    }
                    t[0] === void 0 && (t[0] = s), i && a === void 0 && i.set(t[0])
                } else t[o] = t[o - 1]
    }
    setFinalKeyframe() {}
    measureInitialState() {}
    renderEndStyles() {}
    measureEndState() {}
    complete() {
        this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), ts.delete(this)
    }
    cancel() {
        this.isComplete || (this.isScheduled = !1, ts.delete(this))
    }
    resume() {
        this.isComplete || this.scheduleResolve()
    }
}
const VB = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e),
    T7 = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;

function P7(e) {
    const t = T7.exec(e);
    if (!t) return [, ];
    const [, n, r, i] = t;
    return [`--${n??r}`, i]
}

function zB(e, t, n = 1) {
    const [r, i] = P7(e);
    if (!r) return;
    const o = window.getComputedStyle(t).getPropertyValue(r);
    if (o) {
        const a = o.trim();
        return VB(a) ? parseFloat(a) : a
    }
    return QE(i) ? zB(i, t, n + 1) : i
}
const WB = e => t => t.test(e),
    O7 = {
        test: e => e === "auto",
        parse: e => e
    },
    GB = [Hl, ue, si, Po, hV, dV, O7],
    d2 = e => GB.find(WB(e));
class qB extends gS {
    constructor(t, n, r, i, o) {
        super(t, n, r, i, o, !0)
    }
    readKeyframes() {
        const {
            unresolvedKeyframes: t,
            element: n,
            name: r
        } = this;
        if (!n || !n.current) return;
        super.readKeyframes();
        for (let u = 0; u < t.length; u++) {
            let l = t[u];
            if (typeof l == "string" && (l = l.trim(), QE(l))) {
                const c = zB(l, n.current);
                c !== void 0 && (t[u] = c), u === t.length - 1 && (this.finalKeyframe = l)
            }
        }
        if (this.resolveNoneKeyframes(), !EB.has(r) || t.length !== 2) return;
        const [i, o] = t, a = d2(i), s = d2(o);
        if (a !== s)
            if (l2(a) && l2(s))
                for (let u = 0; u < t.length; u++) {
                    const l = t[u];
                    typeof l == "string" && (t[u] = parseFloat(l))
                } else this.needsMeasurement = !0
    }
    resolveNoneKeyframes() {
        const {
            unresolvedKeyframes: t,
            name: n
        } = this, r = [];
        for (let i = 0; i < t.length; i++) i7(t[i]) && r.push(i);
        r.length && x7(t, r, n)
    }
    measureInitialState() {
        const {
            element: t,
            unresolvedKeyframes: n,
            name: r
        } = this;
        if (!t || !t.current) return;
        r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Yu[r](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin;
        const i = n[n.length - 1];
        i !== void 0 && t.getValue(r, i).jump(i, !1)
    }
    measureEndState() {
        var t;
        const {
            element: n,
            name: r,
            unresolvedKeyframes: i
        } = this;
        if (!n || !n.current) return;
        const o = n.getValue(r);
        o && o.jump(this.measuredOrigin, !1);
        const a = i.length - 1,
            s = i[a];
        i[a] = Yu[r](n.measureViewportBox(), window.getComputedStyle(n.current)), s !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = s), !((t = this.removedTransforms) === null || t === void 0) && t.length && this.removedTransforms.forEach(([u, l]) => {
            n.getValue(u).set(l)
        }), this.resolveNoneKeyframes()
    }
}
const h2 = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (ia.test(e) || e === "0") && !e.startsWith("url("));

function k7(e) {
    const t = e[0];
    if (e.length === 1) return !0;
    for (let n = 0; n < e.length; n++)
        if (e[n] !== t) return !0
}

function C7(e, t, n, r) {
    const i = e[0];
    if (i === null) return !1;
    if (t === "display" || t === "visibility") return !0;
    const o = e[e.length - 1],
        a = h2(i, t),
        s = h2(o, t);
    return !a || !s ? !1 : k7(e) || (n === "spring" || oS(n)) && r
}
const I7 = e => e !== null;

function tv(e, {
    repeat: t,
    repeatType: n = "loop"
}, r) {
    const i = e.filter(I7),
        o = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1;
    return !o || r === void 0 ? i[o] : r
}
const M7 = 40;
class KB {
    constructor({
        autoplay: t = !0,
        delay: n = 0,
        type: r = "keyframes",
        repeat: i = 0,
        repeatDelay: o = 0,
        repeatType: a = "loop",
        ...s
    }) {
        this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = ui.now(), this.options = {
            autoplay: t,
            delay: n,
            type: r,
            repeat: i,
            repeatDelay: o,
            repeatType: a,
            ...s
        }, this.updateFinishedPromise()
    }
    calcStartTime() {
        return this.resolvedAt ? this.resolvedAt - this.createdAt > M7 ? this.resolvedAt : this.createdAt : this.createdAt
    }
    get resolved() {
        return !this._resolved && !this.hasAttemptedResolve && _7(), this._resolved
    }
    onKeyframesResolved(t, n) {
        this.resolvedAt = ui.now(), this.hasAttemptedResolve = !0;
        const {
            name: r,
            type: i,
            velocity: o,
            delay: a,
            onComplete: s,
            onUpdate: u,
            isGenerator: l
        } = this.options;
        if (!l && !C7(t, r, i, o))
            if (a) this.options.duration = 0;
            else {
                u && u(tv(t, this.options, n)), s && s(), this.resolveFinishedPromise();
                return
            }
        const c = this.initPlayback(t, n);
        c !== !1 && (this._resolved = {
            keyframes: t,
            finalKeyframe: n,
            ...c
        }, this.onPostResolved())
    }
    onPostResolved() {}
    then(t, n) {
        return this.currentFinishedPromise.then(t, n)
    }
    flatten() {
        this.options.type = "keyframes", this.options.ease = "linear"
    }
    updateFinishedPromise() {
        this.currentFinishedPromise = new Promise(t => {
            this.resolveFinishedPromise = t
        })
    }
}
const ut = (e, t, n) => e + (t - e) * n;

function tb(e, t, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
}

function N7({
    hue: e,
    saturation: t,
    lightness: n,
    alpha: r
}) {
    e /= 360, t /= 100, n /= 100;
    let i = 0,
        o = 0,
        a = 0;
    if (!t) i = o = a = n;
    else {
        const s = n < .5 ? n * (1 + t) : n + t - n * t,
            u = 2 * n - s;
        i = tb(u, s, e + 1 / 3), o = tb(u, s, e), a = tb(u, s, e - 1 / 3)
    }
    return {
        red: Math.round(i * 255),
        green: Math.round(o * 255),
        blue: Math.round(a * 255),
        alpha: r
    }
}

function Om(e, t) {
    return n => n > 0 ? t : e
}
const nb = (e, t, n) => {
        const r = e * e,
            i = n * (t * t - r) + r;
        return i < 0 ? 0 : Math.sqrt(i)
    },
    R7 = [ux, Fa, yu],
    j7 = e => R7.find(t => t.test(e));

function p2(e) {
    const t = j7(e);
    if (!t) return !1;
    let n = t.parse(e);
    return t === yu && (n = N7(n)), n
}
const m2 = (e, t) => {
        const n = p2(e),
            r = p2(t);
        if (!n || !r) return Om(e, t);
        const i = { ...n
        };
        return o => (i.red = nb(n.red, r.red, o), i.green = nb(n.green, r.green, o), i.blue = nb(n.blue, r.blue, o), i.alpha = ut(n.alpha, r.alpha, o), Fa.transform(i))
    },
    B7 = (e, t) => n => t(e(n)),
    fh = (...e) => e.reduce(B7),
    dx = new Set(["none", "hidden"]);

function D7(e, t) {
    return dx.has(e) ? n => n <= 0 ? e : t : n => n >= 1 ? t : e
}

function $7(e, t) {
    return n => ut(e, t, n)
}

function yS(e) {
    return typeof e == "number" ? $7 : typeof e == "string" ? QE(e) ? Om : Jt.test(e) ? m2 : U7 : Array.isArray(e) ? QB : typeof e == "object" ? Jt.test(e) ? m2 : L7 : Om
}

function QB(e, t) {
    const n = [...e],
        r = n.length,
        i = e.map((o, a) => yS(o)(o, t[a]));
    return o => {
        for (let a = 0; a < r; a++) n[a] = i[a](o);
        return n
    }
}

function L7(e, t) {
    const n = { ...e,
            ...t
        },
        r = {};
    for (const i in n) e[i] !== void 0 && t[i] !== void 0 && (r[i] = yS(e[i])(e[i], t[i]));
    return i => {
        for (const o in r) n[o] = r[o](i);
        return n
    }
}

function F7(e, t) {
    var n;
    const r = [],
        i = {
            color: 0,
            var: 0,
            number: 0
        };
    for (let o = 0; o < t.values.length; o++) {
        const a = t.types[o],
            s = e.indexes[a][i[a]],
            u = (n = e.values[s]) !== null && n !== void 0 ? n : 0;
        r[o] = u, i[a]++
    }
    return r
}
const U7 = (e, t) => {
    const n = ia.createTransformer(t),
        r = zf(e),
        i = zf(t);
    return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? dx.has(e) && !i.values.length || dx.has(t) && !r.values.length ? D7(e, t) : fh(QB(F7(r, i), i.values), n) : Om(e, t)
};

function YB(e, t, n) {
    return typeof e == "number" && typeof t == "number" && typeof n == "number" ? ut(e, t, n) : yS(e)(e, t)
}
const H7 = 5;

function XB(e, t, n) {
    const r = Math.max(t - H7, 0);
    return SB(n - e(r), t - r)
}
const gt = {
        stiffness: 100,
        damping: 10,
        mass: 1,
        velocity: 0,
        duration: 800,
        bounce: .3,
        visualDuration: .3,
        restSpeed: {
            granular: .01,
            default: 2
        },
        restDelta: {
            granular: .005,
            default: .5
        },
        minDuration: .01,
        maxDuration: 10,
        minDamping: .05,
        maxDamping: 1
    },
    g2 = .001;

function V7({
    duration: e = gt.duration,
    bounce: t = gt.bounce,
    velocity: n = gt.velocity,
    mass: r = gt.mass
}) {
    let i, o, a = 1 - t;
    a = Ji(gt.minDamping, gt.maxDamping, a), e = Ji(gt.minDuration, gt.maxDuration, Vi(e)), a < 1 ? (i = l => {
        const c = l * a,
            f = c * e,
            d = c - n,
            h = hx(l, a),
            m = Math.exp(-f);
        return g2 - d / h * m
    }, o = l => {
        const f = l * a * e,
            d = f * n + n,
            h = Math.pow(a, 2) * Math.pow(l, 2) * e,
            m = Math.exp(-f),
            p = hx(Math.pow(l, 2), a);
        return (-i(l) + g2 > 0 ? -1 : 1) * ((d - h) * m) / p
    }) : (i = l => {
        const c = Math.exp(-l * e),
            f = (l - n) * e + 1;
        return -.001 + c * f
    }, o = l => {
        const c = Math.exp(-l * e),
            f = (n - l) * (e * e);
        return c * f
    });
    const s = 5 / e,
        u = W7(i, o, s);
    if (e = Hi(e), isNaN(u)) return {
        stiffness: gt.stiffness,
        damping: gt.damping,
        duration: e
    }; {
        const l = Math.pow(u, 2) * r;
        return {
            stiffness: l,
            damping: a * 2 * Math.sqrt(r * l),
            duration: e
        }
    }
}
const z7 = 12;

function W7(e, t, n) {
    let r = n;
    for (let i = 1; i < z7; i++) r = r - e(r) / t(r);
    return r
}

function hx(e, t) {
    return e * Math.sqrt(1 - t * t)
}
const G7 = ["duration", "bounce"],
    q7 = ["stiffness", "damping", "mass"];

function y2(e, t) {
    return t.some(n => e[n] !== void 0)
}

function K7(e) {
    let t = {
        velocity: gt.velocity,
        stiffness: gt.stiffness,
        damping: gt.damping,
        mass: gt.mass,
        isResolvedFromDuration: !1,
        ...e
    };
    if (!y2(e, q7) && y2(e, G7))
        if (e.visualDuration) {
            const n = e.visualDuration,
                r = 2 * Math.PI / (n * 1.2),
                i = r * r,
                o = 2 * Ji(.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(i);
            t = { ...t,
                mass: gt.mass,
                stiffness: i,
                damping: o
            }
        } else {
            const n = V7(e);
            t = { ...t,
                ...n,
                mass: gt.mass
            }, t.isResolvedFromDuration = !0
        }
    return t
}

function ZB(e = gt.visualDuration, t = gt.bounce) {
    const n = typeof e != "object" ? {
        visualDuration: e,
        keyframes: [0, 1],
        bounce: t
    } : e;
    let {
        restSpeed: r,
        restDelta: i
    } = n;
    const o = n.keyframes[0],
        a = n.keyframes[n.keyframes.length - 1],
        s = {
            done: !1,
            value: o
        },
        {
            stiffness: u,
            damping: l,
            mass: c,
            duration: f,
            velocity: d,
            isResolvedFromDuration: h
        } = K7({ ...n,
            velocity: -Vi(n.velocity || 0)
        }),
        m = d || 0,
        p = l / (2 * Math.sqrt(u * c)),
        y = a - o,
        g = Vi(Math.sqrt(u / c)),
        b = Math.abs(y) < 5;
    r || (r = b ? gt.restSpeed.granular : gt.restSpeed.default), i || (i = b ? gt.restDelta.granular : gt.restDelta.default);
    let v;
    if (p < 1) {
        const w = hx(g, p);
        v = x => {
            const T = Math.exp(-p * g * x);
            return a - T * ((m + p * g * y) / w * Math.sin(w * x) + y * Math.cos(w * x))
        }
    } else if (p === 1) v = w => a - Math.exp(-g * w) * (y + (m + g * y) * w);
    else {
        const w = g * Math.sqrt(p * p - 1);
        v = x => {
            const T = Math.exp(-p * g * x),
                _ = Math.min(w * x, 300);
            return a - T * ((m + p * g * y) * Math.sinh(_) + w * y * Math.cosh(_)) / w
        }
    }
    const A = {
        calculatedDuration: h && f || null,
        next: w => {
            const x = v(w);
            if (h) s.done = w >= f;
            else {
                let T = 0;
                p < 1 && (T = w === 0 ? Hi(m) : XB(v, w, x));
                const _ = Math.abs(T) <= r,
                    O = Math.abs(a - x) <= i;
                s.done = _ && O
            }
            return s.value = s.done ? a : x, s
        },
        toString: () => {
            const w = Math.min(gB(A), ox),
                x = yB(T => A.next(w * T).value, w, 30);
            return w + "ms " + x
        }
    };
    return A
}

function v2({
    keyframes: e,
    velocity: t = 0,
    power: n = .8,
    timeConstant: r = 325,
    bounceDamping: i = 10,
    bounceStiffness: o = 500,
    modifyTarget: a,
    min: s,
    max: u,
    restDelta: l = .5,
    restSpeed: c
}) {
    const f = e[0],
        d = {
            done: !1,
            value: f
        },
        h = _ => s !== void 0 && _ < s || u !== void 0 && _ > u,
        m = _ => s === void 0 ? u : u === void 0 || Math.abs(s - _) < Math.abs(u - _) ? s : u;
    let p = n * t;
    const y = f + p,
        g = a === void 0 ? y : a(y);
    g !== y && (p = g - f);
    const b = _ => -p * Math.exp(-_ / r),
        v = _ => g + b(_),
        A = _ => {
            const O = b(_),
                k = v(_);
            d.done = Math.abs(O) <= l, d.value = d.done ? g : k
        };
    let w, x;
    const T = _ => {
        h(d.value) && (w = _, x = ZB({
            keyframes: [d.value, m(d.value)],
            velocity: XB(v, _, d.value),
            damping: i,
            stiffness: o,
            restDelta: l,
            restSpeed: c
        }))
    };
    return T(0), {
        calculatedDuration: null,
        next: _ => {
            let O = !1;
            return !x && w === void 0 && (O = !0, A(_), T(_)), w !== void 0 && _ >= w ? x.next(_ - w) : (!O && A(_), d)
        }
    }
}
const Q7 = ch(.42, 0, 1, 1),
    Y7 = ch(0, 0, .58, 1),
    JB = ch(.42, 0, .58, 1),
    X7 = e => Array.isArray(e) && typeof e[0] != "number",
    Z7 = {
        linear: Hn,
        easeIn: Q7,
        easeInOut: JB,
        easeOut: Y7,
        circIn: dS,
        circInOut: NB,
        circOut: MB,
        backIn: fS,
        backInOut: CB,
        backOut: kB,
        anticipate: IB
    },
    b2 = e => {
        if (aS(e)) {
            Xj(e.length === 4);
            const [t, n, r, i] = e;
            return ch(t, n, r, i)
        } else if (typeof e == "string") return Z7[e];
        return e
    };

function J7(e, t, n) {
    const r = [],
        i = n || YB,
        o = e.length - 1;
    for (let a = 0; a < o; a++) {
        let s = i(e[a], e[a + 1]);
        if (t) {
            const u = Array.isArray(t) ? t[a] || Hn : t;
            s = fh(u, s)
        }
        r.push(s)
    }
    return r
}

function ez(e, t, {
    clamp: n = !0,
    ease: r,
    mixer: i
} = {}) {
    const o = e.length;
    if (Xj(o === t.length), o === 1) return () => t[0];
    if (o === 2 && t[0] === t[1]) return () => t[1];
    const a = e[0] === e[1];
    e[0] > e[o - 1] && (e = [...e].reverse(), t = [...t].reverse());
    const s = J7(t, r, i),
        u = s.length,
        l = c => {
            if (a && c < e[0]) return t[0];
            let f = 0;
            if (u > 1)
                for (; f < e.length - 2 && !(c < e[f + 1]); f++);
            const d = Ku(e[f], e[f + 1], c);
            return s[f](d)
        };
    return n ? c => l(Ji(e[0], e[o - 1], c)) : l
}

function tz(e, t) {
    const n = e[e.length - 1];
    for (let r = 1; r <= t; r++) {
        const i = Ku(0, t, r);
        e.push(ut(n, 1, i))
    }
}

function nz(e) {
    const t = [0];
    return tz(t, e.length - 1), t
}

function rz(e, t) {
    return e.map(n => n * t)
}

function iz(e, t) {
    return e.map(() => t || JB).splice(0, e.length - 1)
}

function km({
    duration: e = 300,
    keyframes: t,
    times: n,
    ease: r = "easeInOut"
}) {
    const i = X7(r) ? r.map(b2) : b2(r),
        o = {
            done: !1,
            value: t[0]
        },
        a = rz(n && n.length === t.length ? n : nz(t), e),
        s = ez(a, t, {
            ease: Array.isArray(i) ? i : iz(t, i)
        });
    return {
        calculatedDuration: e,
        next: u => (o.value = s(u), o.done = u >= e, o)
    }
}
const oz = e => {
        const t = ({
            timestamp: n
        }) => e(n);
        return {
            start: () => Ye.update(t, !0),
            stop: () => ra(t),
            now: () => Wt.isProcessing ? Wt.timestamp : ui.now()
        }
    },
    az = {
        decay: v2,
        inertia: v2,
        tween: km,
        keyframes: km,
        spring: ZB
    },
    sz = e => e / 100;
class vS extends KB {
    constructor(t) {
        super(t), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
            if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return;
            this.teardown();
            const {
                onStop: u
            } = this.options;
            u && u()
        };
        const {
            name: n,
            motionValue: r,
            element: i,
            keyframes: o
        } = this.options, a = (i == null ? void 0 : i.KeyframeResolver) || gS, s = (u, l) => this.onKeyframesResolved(u, l);
        this.resolver = new a(o, s, n, r, i), this.resolver.scheduleResolve()
    }
    flatten() {
        super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes))
    }
    initPlayback(t) {
        const {
            type: n = "keyframes",
            repeat: r = 0,
            repeatDelay: i = 0,
            repeatType: o,
            velocity: a = 0
        } = this.options, s = oS(n) ? n : az[n] || km;
        let u, l;
        s !== km && typeof t[0] != "number" && (u = fh(sz, YB(t[0], t[1])), t = [0, 100]);
        const c = s({ ...this.options,
            keyframes: t
        });
        o === "mirror" && (l = s({ ...this.options,
            keyframes: [...t].reverse(),
            velocity: -a
        })), c.calculatedDuration === null && (c.calculatedDuration = gB(c));
        const {
            calculatedDuration: f
        } = c, d = f + i, h = d * (r + 1) - i;
        return {
            generator: c,
            mirroredGenerator: l,
            mapPercentToKeyframes: u,
            calculatedDuration: f,
            resolvedDuration: d,
            totalDuration: h
        }
    }
    onPostResolved() {
        const {
            autoplay: t = !0
        } = this.options;
        this.play(), this.pendingPlayState === "paused" || !t ? this.pause() : this.state = this.pendingPlayState
    }
    tick(t, n = !1) {
        const {
            resolved: r
        } = this;
        if (!r) {
            const {
                keyframes: _
            } = this.options;
            return {
                done: !0,
                value: _[_.length - 1]
            }
        }
        const {
            finalKeyframe: i,
            generator: o,
            mirroredGenerator: a,
            mapPercentToKeyframes: s,
            keyframes: u,
            calculatedDuration: l,
            totalDuration: c,
            resolvedDuration: f
        } = r;
        if (this.startTime === null) return o.next(0);
        const {
            delay: d,
            repeat: h,
            repeatType: m,
            repeatDelay: p,
            onUpdate: y
        } = this.options;
        this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - c / this.speed, this.startTime)), n ? this.currentTime = t : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(t - this.startTime) * this.speed;
        const g = this.currentTime - d * (this.speed >= 0 ? 1 : -1),
            b = this.speed >= 0 ? g < 0 : g > c;
        this.currentTime = Math.max(g, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = c);
        let v = this.currentTime,
            A = o;
        if (h) {
            const _ = Math.min(this.currentTime, c) / f;
            let O = Math.floor(_),
                k = _ % 1;
            !k && _ >= 1 && (k = 1), k === 1 && O--, O = Math.min(O, h + 1), !!(O % 2) && (m === "reverse" ? (k = 1 - k, p && (k -= p / f)) : m === "mirror" && (A = a)), v = Ji(0, 1, k) * f
        }
        const w = b ? {
            done: !1,
            value: u[0]
        } : A.next(v);
        s && (w.value = s(w.value));
        let {
            done: x
        } = w;
        !b && l !== null && (x = this.speed >= 0 ? this.currentTime >= c : this.currentTime <= 0);
        const T = this.holdTime === null && (this.state === "finished" || this.state === "running" && x);
        return T && i !== void 0 && (w.value = tv(u, this.options, i)), y && y(w.value), T && this.finish(), w
    }
    get duration() {
        const {
            resolved: t
        } = this;
        return t ? Vi(t.calculatedDuration) : 0
    }
    get time() {
        return Vi(this.currentTime)
    }
    set time(t) {
        t = Hi(t), this.currentTime = t, this.holdTime !== null || this.speed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.speed)
    }
    get speed() {
        return this.playbackSpeed
    }
    set speed(t) {
        const n = this.playbackSpeed !== t;
        this.playbackSpeed = t, n && (this.time = Vi(this.currentTime))
    }
    play() {
        if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
            this.pendingPlayState = "running";
            return
        }
        if (this.isStopped) return;
        const {
            driver: t = oz,
            onPlay: n,
            startTime: r
        } = this.options;
        this.driver || (this.driver = t(o => this.tick(o))), n && n();
        const i = this.driver.now();
        this.holdTime !== null ? this.startTime = i - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = i) : this.startTime = r ? ? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start()
    }
    pause() {
        var t;
        if (!this._resolved) {
            this.pendingPlayState = "paused";
            return
        }
        this.state = "paused", this.holdTime = (t = this.currentTime) !== null && t !== void 0 ? t : 0
    }
    complete() {
        this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null
    }
    finish() {
        this.teardown(), this.state = "finished";
        const {
            onComplete: t
        } = this.options;
        t && t()
    }
    cancel() {
        this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise()
    }
    teardown() {
        this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel()
    }
    stopDriver() {
        this.driver && (this.driver.stop(), this.driver = void 0)
    }
    sample(t) {
        return this.startTime = 0, this.tick(t, !0)
    }
}
const uz = new Set(["opacity", "clipPath", "filter", "transform"]);

function lz(e, t, n, {
    delay: r = 0,
    duration: i = 300,
    repeat: o = 0,
    repeatType: a = "loop",
    ease: s = "easeInOut",
    times: u
} = {}) {
    const l = {
        [t]: n
    };
    u && (l.offset = u);
    const c = bB(s, i);
    return Array.isArray(c) && (l.easing = c), e.animate(l, {
        delay: r,
        duration: i,
        easing: Array.isArray(c) ? "linear" : c,
        fill: "both",
        iterations: o + 1,
        direction: a === "reverse" ? "alternate" : "normal"
    })
}
const cz = VE(() => Object.hasOwnProperty.call(Element.prototype, "animate")),
    Cm = 10,
    fz = 2e4;

function dz(e) {
    return oS(e.type) || e.type === "spring" || !vB(e.ease)
}

function hz(e, t) {
    const n = new vS({ ...t,
        keyframes: e,
        repeat: 0,
        delay: 0,
        isGenerator: !0
    });
    let r = {
        done: !1,
        value: e[0]
    };
    const i = [];
    let o = 0;
    for (; !r.done && o < fz;) r = n.sample(o), i.push(r.value), o += Cm;
    return {
        times: void 0,
        keyframes: i,
        duration: o - Cm,
        ease: "linear"
    }
}
const e3 = {
    anticipate: IB,
    backInOut: CB,
    circInOut: NB
};

function pz(e) {
    return e in e3
}
class w2 extends KB {
    constructor(t) {
        super(t);
        const {
            name: n,
            motionValue: r,
            element: i,
            keyframes: o
        } = this.options;
        this.resolver = new qB(o, (a, s) => this.onKeyframesResolved(a, s), n, r, i), this.resolver.scheduleResolve()
    }
    initPlayback(t, n) {
        let {
            duration: r = 300,
            times: i,
            ease: o,
            type: a,
            motionValue: s,
            name: u,
            startTime: l
        } = this.options;
        if (!s.owner || !s.owner.current) return !1;
        if (typeof o == "string" && Tm() && pz(o) && (o = e3[o]), dz(this.options)) {
            const {
                onComplete: f,
                onUpdate: d,
                motionValue: h,
                element: m,
                ...p
            } = this.options, y = hz(t, p);
            t = y.keyframes, t.length === 1 && (t[1] = t[0]), r = y.duration, i = y.times, o = y.ease, a = "keyframes"
        }
        const c = lz(s.owner.current, u, t, { ...this.options,
            duration: r,
            times: i,
            ease: o
        });
        return c.startTime = l ? ? this.calcStartTime(), this.pendingTimeline ? (r2(c, this.pendingTimeline), this.pendingTimeline = void 0) : c.onfinish = () => {
            const {
                onComplete: f
            } = this.options;
            s.set(tv(t, this.options, n)), f && f(), this.cancel(), this.resolveFinishedPromise()
        }, {
            animation: c,
            duration: r,
            times: i,
            type: a,
            ease: o,
            keyframes: t
        }
    }
    get duration() {
        const {
            resolved: t
        } = this;
        if (!t) return 0;
        const {
            duration: n
        } = t;
        return Vi(n)
    }
    get time() {
        const {
            resolved: t
        } = this;
        if (!t) return 0;
        const {
            animation: n
        } = t;
        return Vi(n.currentTime || 0)
    }
    set time(t) {
        const {
            resolved: n
        } = this;
        if (!n) return;
        const {
            animation: r
        } = n;
        r.currentTime = Hi(t)
    }
    get speed() {
        const {
            resolved: t
        } = this;
        if (!t) return 1;
        const {
            animation: n
        } = t;
        return n.playbackRate
    }
    set speed(t) {
        const {
            resolved: n
        } = this;
        if (!n) return;
        const {
            animation: r
        } = n;
        r.playbackRate = t
    }
    get state() {
        const {
            resolved: t
        } = this;
        if (!t) return "idle";
        const {
            animation: n
        } = t;
        return n.playState
    }
    get startTime() {
        const {
            resolved: t
        } = this;
        if (!t) return null;
        const {
            animation: n
        } = t;
        return n.startTime
    }
    attachTimeline(t) {
        if (!this._resolved) this.pendingTimeline = t;
        else {
            const {
                resolved: n
            } = this;
            if (!n) return Hn;
            const {
                animation: r
            } = n;
            r2(r, t)
        }
        return Hn
    }
    play() {
        if (this.isStopped) return;
        const {
            resolved: t
        } = this;
        if (!t) return;
        const {
            animation: n
        } = t;
        n.playState === "finished" && this.updateFinishedPromise(), n.play()
    }
    pause() {
        const {
            resolved: t
        } = this;
        if (!t) return;
        const {
            animation: n
        } = t;
        n.pause()
    }
    stop() {
        if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return;
        this.resolveFinishedPromise(), this.updateFinishedPromise();
        const {
            resolved: t
        } = this;
        if (!t) return;
        const {
            animation: n,
            keyframes: r,
            duration: i,
            type: o,
            ease: a,
            times: s
        } = t;
        if (n.playState === "idle" || n.playState === "finished") return;
        if (this.time) {
            const {
                motionValue: l,
                onUpdate: c,
                onComplete: f,
                element: d,
                ...h
            } = this.options, m = new vS({ ...h,
                keyframes: r,
                duration: i,
                type: o,
                ease: a,
                times: s,
                isGenerator: !0
            }), p = Hi(this.time);
            l.setWithVelocity(m.sample(p - Cm).value, m.sample(p).value, Cm)
        }
        const {
            onStop: u
        } = this.options;
        u && u(), this.cancel()
    }
    complete() {
        const {
            resolved: t
        } = this;
        t && t.animation.finish()
    }
    cancel() {
        const {
            resolved: t
        } = this;
        t && t.animation.cancel()
    }
    static supports(t) {
        const {
            motionValue: n,
            name: r,
            repeatDelay: i,
            repeatType: o,
            damping: a,
            type: s
        } = t;
        if (!n || !n.owner || !(n.owner.current instanceof HTMLElement)) return !1;
        const {
            onUpdate: u,
            transformTemplate: l
        } = n.owner.getProps();
        return cz() && r && uz.has(r) && !u && !l && !i && o !== "mirror" && a !== 0 && s !== "inertia"
    }
}
const mz = {
        type: "spring",
        stiffness: 500,
        damping: 25,
        restSpeed: 10
    },
    gz = e => ({
        type: "spring",
        stiffness: 550,
        damping: e === 0 ? 2 * Math.sqrt(550) : 30,
        restSpeed: 10
    }),
    yz = {
        type: "keyframes",
        duration: .8
    },
    vz = {
        type: "keyframes",
        ease: [.25, .1, .35, 1],
        duration: .3
    },
    bz = (e, {
        keyframes: t
    }) => t.length > 2 ? yz : js.has(e) ? e.startsWith("scale") ? gz(t[1]) : mz : vz;

function wz({
    when: e,
    delay: t,
    delayChildren: n,
    staggerChildren: r,
    staggerDirection: i,
    repeat: o,
    repeatType: a,
    repeatDelay: s,
    from: u,
    elapsed: l,
    ...c
}) {
    return !!Object.keys(c).length
}
const bS = (e, t, n, r = {}, i, o) => a => {
    const s = iS(r, e) || {},
        u = s.delay || r.delay || 0;
    let {
        elapsed: l = 0
    } = r;
    l = l - Hi(u);
    let c = {
        keyframes: Array.isArray(n) ? n : [null, n],
        ease: "easeOut",
        velocity: t.getVelocity(),
        ...s,
        delay: -l,
        onUpdate: d => {
            t.set(d), s.onUpdate && s.onUpdate(d)
        },
        onComplete: () => {
            a(), s.onComplete && s.onComplete()
        },
        name: e,
        motionValue: t,
        element: o ? void 0 : i
    };
    wz(s) || (c = { ...c,
        ...bz(e, c)
    }), c.duration && (c.duration = Hi(c.duration)), c.repeatDelay && (c.repeatDelay = Hi(c.repeatDelay)), c.from !== void 0 && (c.keyframes[0] = c.from);
    let f = !1;
    if ((c.type === !1 || c.duration === 0 && !c.repeatDelay) && (c.duration = 0, c.delay === 0 && (f = !0)), f && !o && t.get() !== void 0) {
        const d = tv(c.keyframes, s);
        if (d !== void 0) return Ye.update(() => {
            c.onUpdate(d), c.onComplete()
        }), new $V([])
    }
    return !o && w2.supports(c) ? new w2(c) : new vS(c)
};

function xz({
    protectedKeys: e,
    needsAnimating: t
}, n) {
    const r = e.hasOwnProperty(n) && t[n] !== !0;
    return t[n] = !1, r
}

function t3(e, t, {
    delay: n = 0,
    transitionOverride: r,
    type: i
} = {}) {
    var o;
    let {
        transition: a = e.getDefaultTransition(),
        transitionEnd: s,
        ...u
    } = t;
    r && (a = r);
    const l = [],
        c = i && e.animationState && e.animationState.getState()[i];
    for (const f in u) {
        const d = e.getValue(f, (o = e.latestValues[f]) !== null && o !== void 0 ? o : null),
            h = u[f];
        if (h === void 0 || c && xz(c, f)) continue;
        const m = {
            delay: n,
            ...iS(a || {}, f)
        };
        let p = !1;
        if (window.MotionHandoffAnimation) {
            const g = _B(e);
            if (g) {
                const b = window.MotionHandoffAnimation(g, f, Ye);
                b !== null && (m.startTime = b, p = !0)
            }
        }
        sx(e, f), d.start(bS(f, d, h, e.shouldReduceMotion && EB.has(f) ? {
            type: !1
        } : m, e, p));
        const y = d.animation;
        y && l.push(y)
    }
    return s && Promise.all(l).then(() => {
        Ye.update(() => {
            s && JV(e, s)
        })
    }), l
}

function px(e, t, n = {}) {
    var r;
    const i = Hf(e, t, n.type === "exit" ? (r = e.presenceContext) === null || r === void 0 ? void 0 : r.custom : void 0);
    let {
        transition: o = e.getDefaultTransition() || {}
    } = i || {};
    n.transitionOverride && (o = n.transitionOverride);
    const a = i ? () => Promise.all(t3(e, i, n)) : () => Promise.resolve(),
        s = e.variantChildren && e.variantChildren.size ? (l = 0) => {
            const {
                delayChildren: c = 0,
                staggerChildren: f,
                staggerDirection: d
            } = o;
            return Az(e, t, c + l, f, d, n)
        } : () => Promise.resolve(),
        {
            when: u
        } = o;
    if (u) {
        const [l, c] = u === "beforeChildren" ? [a, s] : [s, a];
        return l().then(() => c())
    } else return Promise.all([a(), s(n.delay)])
}

function Az(e, t, n = 0, r = 0, i = 1, o) {
    const a = [],
        s = (e.variantChildren.size - 1) * r,
        u = i === 1 ? (l = 0) => l * r : (l = 0) => s - l * r;
    return Array.from(e.variantChildren).sort(Ez).forEach((l, c) => {
        l.notify("AnimationStart", t), a.push(px(l, t, { ...o,
            delay: n + u(c)
        }).then(() => l.notify("AnimationComplete", t)))
    }), Promise.all(a)
}

function Ez(e, t) {
    return e.sortNodePosition(t)
}

function Sz(e, t, n = {}) {
    e.notify("AnimationStart", t);
    let r;
    if (Array.isArray(t)) {
        const i = t.map(o => px(e, o, n));
        r = Promise.all(i)
    } else if (typeof t == "string") r = px(e, t, n);
    else {
        const i = typeof t == "function" ? Hf(e, t, n.custom) : t;
        r = Promise.all(t3(e, i, n))
    }
    return r.then(() => {
        e.notify("AnimationComplete", t)
    })
}

function n3(e, t) {
    if (!Array.isArray(t)) return !1;
    const n = t.length;
    if (n !== e.length) return !1;
    for (let r = 0; r < n; r++)
        if (t[r] !== e[r]) return !1;
    return !0
}
const _z = WE.length;

function r3(e) {
    if (!e) return;
    if (!e.isControllingVariants) {
        const n = e.parent ? r3(e.parent) || {} : {};
        return e.props.initial !== void 0 && (n.initial = e.props.initial), n
    }
    const t = {};
    for (let n = 0; n < _z; n++) {
        const r = WE[n],
            i = e.props[r];
        (Lf(i) || i === !1) && (t[r] = i)
    }
    return t
}
const Tz = [...zE].reverse(),
    Pz = zE.length;

function Oz(e) {
    return t => Promise.all(t.map(({
        animation: n,
        options: r
    }) => Sz(e, n, r)))
}

function kz(e) {
    let t = Oz(e),
        n = x2(),
        r = !0;
    const i = u => (l, c) => {
        var f;
        const d = Hf(e, c, u === "exit" ? (f = e.presenceContext) === null || f === void 0 ? void 0 : f.custom : void 0);
        if (d) {
            const {
                transition: h,
                transitionEnd: m,
                ...p
            } = d;
            l = { ...l,
                ...p,
                ...m
            }
        }
        return l
    };

    function o(u) {
        t = u(e)
    }

    function a(u) {
        const {
            props: l
        } = e, c = r3(e.parent) || {}, f = [], d = new Set;
        let h = {},
            m = 1 / 0;
        for (let y = 0; y < Pz; y++) {
            const g = Tz[y],
                b = n[g],
                v = l[g] !== void 0 ? l[g] : c[g],
                A = Lf(v),
                w = g === u ? b.isActive : null;
            w === !1 && (m = y);
            let x = v === c[g] && v !== l[g] && A;
            if (x && r && e.manuallyAnimateOnMount && (x = !1), b.protectedKeys = { ...h
                }, !b.isActive && w === null || !v && !b.prevProp || Jy(v) || typeof v == "boolean") continue;
            const T = Cz(b.prevProp, v);
            let _ = T || g === u && b.isActive && !x && A || y > m && A,
                O = !1;
            const k = Array.isArray(v) ? v : [v];
            let I = k.reduce(i(g), {});
            w === !1 && (I = {});
            const {
                prevResolvedValues: M = {}
            } = b, B = { ...M,
                ...I
            }, L = j => {
                _ = !0, d.has(j) && (O = !0, d.delete(j)), b.needsAnimating[j] = !0;
                const N = e.getValue(j);
                N && (N.liveStyle = !1)
            };
            for (const j in B) {
                const N = I[j],
                    D = M[j];
                if (h.hasOwnProperty(j)) continue;
                let $ = !1;
                ix(N) && ix(D) ? $ = !n3(N, D) : $ = N !== D, $ ? N != null ? L(j) : d.add(j) : N !== void 0 && d.has(j) ? L(j) : b.protectedKeys[j] = !0
            }
            b.prevProp = v, b.prevResolvedValues = I, b.isActive && (h = { ...h,
                ...I
            }), r && e.blockInitialAnimation && (_ = !1), _ && (!(x && T) || O) && f.push(...k.map(j => ({
                animation: j,
                options: {
                    type: g
                }
            })))
        }
        if (d.size) {
            const y = {};
            if (typeof l.initial != "boolean") {
                const g = Hf(e, Array.isArray(l.initial) ? l.initial[0] : l.initial);
                g && g.transition && (y.transition = g.transition)
            }
            d.forEach(g => {
                const b = e.getBaseTarget(g),
                    v = e.getValue(g);
                v && (v.liveStyle = !0), y[g] = b ? ? null
            }), f.push({
                animation: y
            })
        }
        let p = !!f.length;
        return r && (l.initial === !1 || l.initial === l.animate) && !e.manuallyAnimateOnMount && (p = !1), r = !1, p ? t(f) : Promise.resolve()
    }

    function s(u, l) {
        var c;
        if (n[u].isActive === l) return Promise.resolve();
        (c = e.variantChildren) === null || c === void 0 || c.forEach(d => {
            var h;
            return (h = d.animationState) === null || h === void 0 ? void 0 : h.setActive(u, l)
        }), n[u].isActive = l;
        const f = a(u);
        for (const d in n) n[d].protectedKeys = {};
        return f
    }
    return {
        animateChanges: a,
        setActive: s,
        setAnimateFunction: o,
        getState: () => n,
        reset: () => {
            n = x2(), r = !0
        }
    }
}

function Cz(e, t) {
    return typeof t == "string" ? t !== e : Array.isArray(t) ? !n3(t, e) : !1
}

function Ea(e = !1) {
    return {
        isActive: e,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}

function x2() {
    return {
        animate: Ea(!0),
        whileInView: Ea(),
        whileHover: Ea(),
        whileTap: Ea(),
        whileDrag: Ea(),
        whileFocus: Ea(),
        exit: Ea()
    }
}
class ha {
    constructor(t) {
        this.isMounted = !1, this.node = t
    }
    update() {}
}
class Iz extends ha {
    constructor(t) {
        super(t), t.animationState || (t.animationState = kz(t))
    }
    updateAnimationControlsSubscription() {
        const {
            animate: t
        } = this.node.getProps();
        Jy(t) && (this.unmountControls = t.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        const {
            animate: t
        } = this.node.getProps(), {
            animate: n
        } = this.node.prevProps || {};
        t !== n && this.updateAnimationControlsSubscription()
    }
    unmount() {
        var t;
        this.node.animationState.reset(), (t = this.unmountControls) === null || t === void 0 || t.call(this)
    }
}
let Mz = 0;
class Nz extends ha {
    constructor() {
        super(...arguments), this.id = Mz++
    }
    update() {
        if (!this.node.presenceContext) return;
        const {
            isPresent: t,
            onExitComplete: n
        } = this.node.presenceContext, {
            isPresent: r
        } = this.node.prevPresenceContext || {};
        if (!this.node.animationState || t === r) return;
        const i = this.node.animationState.setActive("exit", !t);
        n && !t && i.then(() => {
            n(this.id)
        })
    }
    mount() {
        const {
            register: t,
            onExitComplete: n
        } = this.node.presenceContext || {};
        n && n(this.id), t && (this.unmount = t(this.id))
    }
    unmount() {}
}
const Rz = {
    animation: {
        Feature: Iz
    },
    exit: {
        Feature: Nz
    }
};

function Wf(e, t, n, r = {
    passive: !0
}) {
    return e.addEventListener(t, n, r), () => e.removeEventListener(t, n)
}

function dh(e) {
    return {
        point: {
            x: e.pageX,
            y: e.pageY
        }
    }
}
const jz = e => t => sS(t) && e(t, dh(t));

function vu(e, t, n, r) {
    return Wf(e, t, jz(n), r)
}

function i3({
    top: e,
    left: t,
    right: n,
    bottom: r
}) {
    return {
        x: {
            min: t,
            max: n
        },
        y: {
            min: e,
            max: r
        }
    }
}

function Bz({
    x: e,
    y: t
}) {
    return {
        top: t.min,
        right: e.max,
        bottom: t.max,
        left: e.min
    }
}

function Dz(e, t) {
    if (!t) return e;
    const n = t({
            x: e.left,
            y: e.top
        }),
        r = t({
            x: e.right,
            y: e.bottom
        });
    return {
        top: n.y,
        left: n.x,
        bottom: r.y,
        right: r.x
    }
}
const o3 = 1e-4,
    $z = 1 - o3,
    Lz = 1 + o3,
    a3 = .01,
    Fz = 0 - a3,
    Uz = 0 + a3;

function fn(e) {
    return e.max - e.min
}

function Hz(e, t, n) {
    return Math.abs(e - t) <= n
}

function A2(e, t, n, r = .5) {
    e.origin = r, e.originPoint = ut(t.min, t.max, e.origin), e.scale = fn(n) / fn(t), e.translate = ut(n.min, n.max, e.origin) - e.originPoint, (e.scale >= $z && e.scale <= Lz || isNaN(e.scale)) && (e.scale = 1), (e.translate >= Fz && e.translate <= Uz || isNaN(e.translate)) && (e.translate = 0)
}

function sf(e, t, n, r) {
    A2(e.x, t.x, n.x, r ? r.originX : void 0), A2(e.y, t.y, n.y, r ? r.originY : void 0)
}

function E2(e, t, n) {
    e.min = n.min + t.min, e.max = e.min + fn(t)
}

function Vz(e, t, n) {
    E2(e.x, t.x, n.x), E2(e.y, t.y, n.y)
}

function S2(e, t, n) {
    e.min = t.min - n.min, e.max = e.min + fn(t)
}

function uf(e, t, n) {
    S2(e.x, t.x, n.x), S2(e.y, t.y, n.y)
}
const _2 = () => ({
        translate: 0,
        scale: 1,
        origin: 0,
        originPoint: 0
    }),
    bu = () => ({
        x: _2(),
        y: _2()
    }),
    T2 = () => ({
        min: 0,
        max: 0
    }),
    wt = () => ({
        x: T2(),
        y: T2()
    });

function tr(e) {
    return [e("x"), e("y")]
}

function rb(e) {
    return e === void 0 || e === 1
}

function mx({
    scale: e,
    scaleX: t,
    scaleY: n
}) {
    return !rb(e) || !rb(t) || !rb(n)
}

function Ca(e) {
    return mx(e) || s3(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY
}

function s3(e) {
    return P2(e.x) || P2(e.y)
}

function P2(e) {
    return e && e !== "0%"
}

function Im(e, t, n) {
    const r = e - n,
        i = t * r;
    return n + i
}

function O2(e, t, n, r, i) {
    return i !== void 0 && (e = Im(e, i, r)), Im(e, n, r) + t
}

function gx(e, t = 0, n = 1, r, i) {
    e.min = O2(e.min, t, n, r, i), e.max = O2(e.max, t, n, r, i)
}

function u3(e, {
    x: t,
    y: n
}) {
    gx(e.x, t.translate, t.scale, t.originPoint), gx(e.y, n.translate, n.scale, n.originPoint)
}
const k2 = .999999999999,
    C2 = 1.0000000000001;

function zz(e, t, n, r = !1) {
    const i = n.length;
    if (!i) return;
    t.x = t.y = 1;
    let o, a;
    for (let s = 0; s < i; s++) {
        o = n[s], a = o.projectionDelta;
        const {
            visualElement: u
        } = o.options;
        u && u.props.style && u.props.style.display === "contents" || (r && o.options.layoutScroll && o.scroll && o !== o.root && xu(e, {
            x: -o.scroll.offset.x,
            y: -o.scroll.offset.y
        }), a && (t.x *= a.x.scale, t.y *= a.y.scale, u3(e, a)), r && Ca(o.latestValues) && xu(e, o.latestValues))
    }
    t.x < C2 && t.x > k2 && (t.x = 1), t.y < C2 && t.y > k2 && (t.y = 1)
}

function wu(e, t) {
    e.min = e.min + t, e.max = e.max + t
}

function I2(e, t, n, r, i = .5) {
    const o = ut(e.min, e.max, i);
    gx(e, t, n, o, r)
}

function xu(e, t) {
    I2(e.x, t.x, t.scaleX, t.scale, t.originX), I2(e.y, t.y, t.scaleY, t.scale, t.originY)
}

function l3(e, t) {
    return i3(Dz(e.getBoundingClientRect(), t))
}

function Wz(e, t, n) {
    const r = l3(e, n),
        {
            scroll: i
        } = t;
    return i && (wu(r.x, i.offset.x), wu(r.y, i.offset.y)), r
}
const M2 = (e, t) => Math.abs(e - t);

function Gz(e, t) {
    const n = M2(e.x, t.x),
        r = M2(e.y, t.y);
    return Math.sqrt(n ** 2 + r ** 2)
}
class c3 {
    constructor(t, n, {
        transformPagePoint: r,
        dragSnapToOrigin: i = !1
    } = {}) {
        if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = () => {
                if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
                const c = ob(this.lastMoveEventInfo, this.history),
                    f = this.startEvent !== null,
                    d = Gz(c.offset, {
                        x: 0,
                        y: 0
                    }) >= 3;
                if (!f && !d) return;
                const {
                    point: h
                } = c, {
                    timestamp: m
                } = Wt;
                this.history.push({ ...h,
                    timestamp: m
                });
                const {
                    onStart: p,
                    onMove: y
                } = this.handlers;
                f || (p && p(this.lastMoveEvent, c), this.startEvent = this.lastMoveEvent), y && y(this.lastMoveEvent, c)
            }, this.handlePointerMove = (c, f) => {
                if (c.target instanceof Element && c.target.hasPointerCapture && c.pointerId !== void 0) try {
                    if (!c.target.hasPointerCapture(c.pointerId)) return
                } catch {}
                this.lastMoveEvent = c, this.lastMoveEventInfo = ib(f, this.transformPagePoint), Ye.update(this.updatePoint, !0)
            }, this.handlePointerUp = (c, f) => {
                Pm(c, "release"), this.end();
                const {
                    onEnd: d,
                    onSessionEnd: h,
                    resumeAnimation: m
                } = this.handlers;
                if (this.dragSnapToOrigin && m && m(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return;
                const p = ob(c.type === "pointercancel" || c.type === "lostpointercapture" ? this.lastMoveEventInfo : ib(f, this.transformPagePoint), this.history);
                this.startEvent && d && d(c, p), h && h(c, p)
            }, !sS(t)) return;
        this.dragSnapToOrigin = i, this.handlers = n, this.transformPagePoint = r;
        const o = dh(t),
            a = ib(o, this.transformPagePoint),
            {
                point: s
            } = a,
            {
                timestamp: u
            } = Wt;
        this.history = [{ ...s,
            timestamp: u
        }];
        const {
            onSessionStart: l
        } = n;
        l && l(t, ob(a, this.history)), Pm(t, "set"), this.removeListeners = fh(vu(t.currentTarget, "pointermove", this.handlePointerMove), vu(t.currentTarget, "pointerup", this.handlePointerUp), vu(t.currentTarget, "pointercancel", this.handlePointerUp), vu(t.currentTarget, "lostpointercapture", this.handlePointerUp))
    }
    updateHandlers(t) {
        this.handlers = t
    }
    end() {
        this.removeListeners && this.removeListeners(), ra(this.updatePoint)
    }
}

function ib(e, t) {
    return t ? {
        point: t(e.point)
    } : e
}

function N2(e, t) {
    return {
        x: e.x - t.x,
        y: e.y - t.y
    }
}

function ob({
    point: e
}, t) {
    return {
        point: e,
        delta: N2(e, f3(t)),
        offset: N2(e, qz(t)),
        velocity: Kz(t, .1)
    }
}

function qz(e) {
    return e[0]
}

function f3(e) {
    return e[e.length - 1]
}

function Kz(e, t) {
    if (e.length < 2) return {
        x: 0,
        y: 0
    };
    let n = e.length - 1,
        r = null;
    const i = f3(e);
    for (; n >= 0 && (r = e[n], !(i.timestamp - r.timestamp > Hi(t)));) n--;
    if (!r) return {
        x: 0,
        y: 0
    };
    const o = Vi(i.timestamp - r.timestamp);
    if (o === 0) return {
        x: 0,
        y: 0
    };
    const a = {
        x: (i.x - r.x) / o,
        y: (i.y - r.y) / o
    };
    return a.x === 1 / 0 && (a.x = 0), a.y === 1 / 0 && (a.y = 0), a
}

function Qz(e, {
    min: t,
    max: n
}, r) {
    return t !== void 0 && e < t ? e = r ? ut(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? ut(n, e, r.max) : Math.min(e, n)), e
}

function R2(e, t, n) {
    return {
        min: t !== void 0 ? e.min + t : void 0,
        max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
    }
}

function Yz(e, {
    top: t,
    left: n,
    bottom: r,
    right: i
}) {
    return {
        x: R2(e.x, n, i),
        y: R2(e.y, t, r)
    }
}

function j2(e, t) {
    let n = t.min - e.min,
        r = t.max - e.max;
    return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), {
        min: n,
        max: r
    }
}

function Xz(e, t) {
    return {
        x: j2(e.x, t.x),
        y: j2(e.y, t.y)
    }
}

function Zz(e, t) {
    let n = .5;
    const r = fn(e),
        i = fn(t);
    return i > r ? n = Ku(t.min, t.max - r, e.min) : r > i && (n = Ku(e.min, e.max - i, t.min)), Ji(0, 1, n)
}

function Jz(e, t) {
    const n = {};
    return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n
}
const yx = .35;

function eW(e = yx) {
    return e === !1 ? e = 0 : e === !0 && (e = yx), {
        x: B2(e, "left", "right"),
        y: B2(e, "top", "bottom")
    }
}

function B2(e, t, n) {
    return {
        min: D2(e, t),
        max: D2(e, n)
    }
}

function D2(e, t) {
    return typeof e == "number" ? e : e[t] || 0
}
const tW = new WeakMap;
class nW {
    constructor(t) {
        this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = {
            x: 0,
            y: 0
        }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = wt(), this.visualElement = t
    }
    start(t, {
        snapToCursor: n = !1
    } = {}) {
        const {
            presenceContext: r
        } = this.visualElement;
        if (r && r.isPresent === !1) return;
        const i = c => {
                const {
                    dragSnapToOrigin: f
                } = this.getProps();
                f ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(dh(c).point)
            },
            o = (c, f) => {
                const {
                    drag: d,
                    dragPropagation: h,
                    onDragStart: m
                } = this.getProps();
                if (d && !h && (this.openDragLock && this.openDragLock(), this.openDragLock = KV(d), !this.openDragLock)) return;
                this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), tr(y => {
                    let g = this.getAxisMotionValue(y).get() || 0;
                    if (si.test(g)) {
                        const {
                            projection: b
                        } = this.visualElement;
                        if (b && b.layout) {
                            const v = b.layout.layoutBox[y];
                            v && (g = fn(v) * (parseFloat(g) / 100))
                        }
                    }
                    this.originPoint[y] = g
                }), m && Ye.postRender(() => m(c, f)), sx(this.visualElement, "transform");
                const {
                    animationState: p
                } = this.visualElement;
                p && p.setActive("whileDrag", !0)
            },
            a = (c, f) => {
                const {
                    dragPropagation: d,
                    dragDirectionLock: h,
                    onDirectionLock: m,
                    onDrag: p
                } = this.getProps();
                if (!d && !this.openDragLock) return;
                const {
                    offset: y
                } = f;
                if (h && this.currentDirection === null) {
                    this.currentDirection = rW(y), this.currentDirection !== null && m && m(this.currentDirection);
                    return
                }
                this.updateAxis("x", f.point, y), this.updateAxis("y", f.point, y), this.visualElement.render(), p && p(c, f)
            },
            s = (c, f) => this.stop(c, f),
            u = () => tr(c => {
                var f;
                return this.getAnimationState(c) === "paused" && ((f = this.getAxisMotionValue(c).animation) === null || f === void 0 ? void 0 : f.play())
            }),
            {
                dragSnapToOrigin: l
            } = this.getProps();
        this.panSession = new c3(t, {
            onSessionStart: i,
            onStart: o,
            onMove: a,
            onSessionEnd: s,
            resumeAnimation: u
        }, {
            transformPagePoint: this.visualElement.getTransformPagePoint(),
            dragSnapToOrigin: l
        })
    }
    stop(t, n) {
        const r = this.isDragging;
        if (this.cancel(), !r) return;
        const {
            velocity: i
        } = n;
        this.startAnimation(i);
        const {
            onDragEnd: o
        } = this.getProps();
        o && Ye.postRender(() => o(t, n))
    }
    cancel() {
        this.isDragging = !1;
        const {
            projection: t,
            animationState: n
        } = this.visualElement;
        t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
        const {
            dragPropagation: r
        } = this.getProps();
        !r && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1)
    }
    updateAxis(t, n, r) {
        const {
            drag: i
        } = this.getProps();
        if (!r || !ep(t, i, this.currentDirection)) return;
        const o = this.getAxisMotionValue(t);
        let a = this.originPoint[t] + r[t];
        this.constraints && this.constraints[t] && (a = Qz(a, this.constraints[t], this.elastic[t])), o.set(a)
    }
    resolveConstraints() {
        var t;
        const {
            dragConstraints: n,
            dragElastic: r
        } = this.getProps(), i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (t = this.visualElement.projection) === null || t === void 0 ? void 0 : t.layout, o = this.constraints;
        n && gu(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && i ? this.constraints = Yz(i.layoutBox, n) : this.constraints = !1, this.elastic = eW(r), o !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && tr(a => {
            this.constraints !== !1 && this.getAxisMotionValue(a) && (this.constraints[a] = Jz(i.layoutBox[a], this.constraints[a]))
        })
    }
    resolveRefConstraints() {
        const {
            dragConstraints: t,
            onMeasureDragConstraints: n
        } = this.getProps();
        if (!t || !gu(t)) return !1;
        const r = t.current,
            {
                projection: i
            } = this.visualElement;
        if (!i || !i.layout) return !1;
        const o = Wz(r, i.root, this.visualElement.getTransformPagePoint());
        let a = Xz(i.layout.layoutBox, o);
        if (n) {
            const s = n(Bz(a));
            this.hasMutatedConstraints = !!s, s && (a = i3(s))
        }
        return a
    }
    startAnimation(t) {
        const {
            drag: n,
            dragMomentum: r,
            dragElastic: i,
            dragTransition: o,
            dragSnapToOrigin: a,
            onDragTransitionEnd: s
        } = this.getProps(), u = this.constraints || {}, l = tr(c => {
            if (!ep(c, n, this.currentDirection)) return;
            let f = u && u[c] || {};
            a && (f = {
                min: 0,
                max: 0
            });
            const d = i ? 200 : 1e6,
                h = i ? 40 : 1e7,
                m = {
                    type: "inertia",
                    velocity: r ? t[c] : 0,
                    bounceStiffness: d,
                    bounceDamping: h,
                    timeConstant: 750,
                    restDelta: 1,
                    restSpeed: 10,
                    ...o,
                    ...f
                };
            return this.startAxisValueAnimation(c, m)
        });
        return Promise.all(l).then(s)
    }
    startAxisValueAnimation(t, n) {
        const r = this.getAxisMotionValue(t);
        return sx(this.visualElement, t), r.start(bS(t, r, 0, n, this.visualElement, !1))
    }
    stopAnimation() {
        tr(t => this.getAxisMotionValue(t).stop())
    }
    pauseAnimation() {
        tr(t => {
            var n;
            return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.pause()
        })
    }
    getAnimationState(t) {
        var n;
        return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.state
    }
    getAxisMotionValue(t) {
        const n = `_drag${t.toUpperCase()}`,
            r = this.visualElement.getProps(),
            i = r[n];
        return i || this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0)
    }
    snapToCursor(t) {
        tr(n => {
            const {
                drag: r
            } = this.getProps();
            if (!ep(n, r, this.currentDirection)) return;
            const {
                projection: i
            } = this.visualElement, o = this.getAxisMotionValue(n);
            if (i && i.layout) {
                const {
                    min: a,
                    max: s
                } = i.layout.layoutBox[n];
                o.set(t[n] - ut(a, s, .5))
            }
        })
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current) return;
        const {
            drag: t,
            dragConstraints: n
        } = this.getProps(), {
            projection: r
        } = this.visualElement;
        if (!gu(n) || !r || !this.constraints) return;
        this.stopAnimation();
        const i = {
            x: 0,
            y: 0
        };
        tr(a => {
            const s = this.getAxisMotionValue(a);
            if (s && this.constraints !== !1) {
                const u = s.get();
                i[a] = Zz({
                    min: u,
                    max: u
                }, this.constraints[a])
            }
        });
        const {
            transformTemplate: o
        } = this.visualElement.getProps();
        this.visualElement.current.style.transform = o ? o({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), tr(a => {
            if (!ep(a, t, null)) return;
            const s = this.getAxisMotionValue(a),
                {
                    min: u,
                    max: l
                } = this.constraints[a];
            s.set(ut(u, l, i[a]))
        })
    }
    addListeners() {
        if (!this.visualElement.current) return;
        tW.set(this.visualElement, this);
        const t = this.visualElement.current,
            n = vu(t, "pointerdown", u => {
                const {
                    drag: l,
                    dragListener: c = !0
                } = this.getProps();
                l && c && this.start(u)
            }),
            r = () => {
                const {
                    dragConstraints: u
                } = this.getProps();
                gu(u) && u.current && (this.constraints = this.resolveRefConstraints())
            },
            {
                projection: i
            } = this.visualElement,
            o = i.addEventListener("measure", r);
        i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), Ye.read(r);
        const a = Wf(window, "resize", () => this.scalePositionWithinConstraints()),
            s = i.addEventListener("didUpdate", ({
                delta: u,
                hasLayoutChanged: l
            }) => {
                this.isDragging && l && (tr(c => {
                    const f = this.getAxisMotionValue(c);
                    f && (this.originPoint[c] += u[c].translate, f.set(f.get() + u[c].translate))
                }), this.visualElement.render())
            });
        return () => {
            a(), n(), o(), s && s()
        }
    }
    getProps() {
        const t = this.visualElement.getProps(),
            {
                drag: n = !1,
                dragDirectionLock: r = !1,
                dragPropagation: i = !1,
                dragConstraints: o = !1,
                dragElastic: a = yx,
                dragMomentum: s = !0
            } = t;
        return { ...t,
            drag: n,
            dragDirectionLock: r,
            dragPropagation: i,
            dragConstraints: o,
            dragElastic: a,
            dragMomentum: s
        }
    }
}

function ep(e, t, n) {
    return (t === !0 || t === e) && (n === null || n === e)
}

function rW(e, t = 10) {
    let n = null;
    return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n
}
class iW extends ha {
    constructor(t) {
        super(t), this.removeGroupControls = Hn, this.removeListeners = Hn, this.controls = new nW(t)
    }
    mount() {
        const {
            dragControls: t
        } = this.node.getProps();
        t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Hn
    }
    unmount() {
        this.removeGroupControls(), this.removeListeners()
    }
}
const $2 = e => (t, n) => {
    e && Ye.postRender(() => e(t, n))
};
class oW extends ha {
    constructor() {
        super(...arguments), this.removePointerDownListener = Hn
    }
    onPointerDown(t) {
        this.session = new c3(t, this.createPanHandlers(), {
            transformPagePoint: this.node.getTransformPagePoint()
        })
    }
    createPanHandlers() {
        const {
            onPanSessionStart: t,
            onPanStart: n,
            onPan: r,
            onPanEnd: i
        } = this.node.getProps();
        return {
            onSessionStart: $2(t),
            onStart: $2(n),
            onMove: r,
            onEnd: (o, a) => {
                delete this.session, i && Ye.postRender(() => i(o, a))
            }
        }
    }
    mount() {
        this.removePointerDownListener = vu(this.node.current, "pointerdown", t => this.onPointerDown(t))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(), this.session && this.session.end()
    }
}
const Hp = {
    hasAnimatedSinceResize: !0,
    hasEverUpdated: !1
};

function L2(e, t) {
    return t.max === t.min ? 0 : e / (t.max - t.min) * 100
}
const bc = {
        correct: (e, t) => {
            if (!t.target) return e;
            if (typeof e == "string")
                if (ue.test(e)) e = parseFloat(e);
                else return e;
            const n = L2(e, t.target.x),
                r = L2(e, t.target.y);
            return `${n}% ${r}%`
        }
    },
    aW = {
        correct: (e, {
            treeScale: t,
            projectionDelta: n
        }) => {
            const r = e,
                i = ia.parse(e);
            if (i.length > 5) return r;
            const o = ia.createTransformer(e),
                a = typeof i[0] != "number" ? 1 : 0,
                s = n.x.scale * t.x,
                u = n.y.scale * t.y;
            i[0 + a] /= s, i[1 + a] /= u;
            const l = ut(s, u, .5);
            return typeof i[2 + a] == "number" && (i[2 + a] /= l), typeof i[3 + a] == "number" && (i[3 + a] /= l), o(i)
        }
    };
class sW extends S.Component {
    componentDidMount() {
        const {
            visualElement: t,
            layoutGroup: n,
            switchLayoutGroup: r,
            layoutId: i
        } = this.props, {
            projection: o
        } = t;
        fV(uW), o && (n.group && n.group.add(o), r && r.register && i && r.register(o), o.root.didUpdate(), o.addEventListener("animationComplete", () => {
            this.safeToRemove()
        }), o.setOptions({ ...o.options,
            onExitComplete: () => this.safeToRemove()
        })), Hp.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(t) {
        const {
            layoutDependency: n,
            visualElement: r,
            drag: i,
            isPresent: o
        } = this.props, a = r.projection;
        return a && (a.isPresent = o, i || t.layoutDependency !== n || n === void 0 ? a.willUpdate() : this.safeToRemove(), t.isPresent !== o && (o ? a.promote() : a.relegate() || Ye.postRender(() => {
            const s = a.getStack();
            (!s || !s.members.length) && this.safeToRemove()
        }))), null
    }
    componentDidUpdate() {
        const {
            projection: t
        } = this.props.visualElement;
        t && (t.root.didUpdate(), qE.postRender(() => {
            !t.currentAnimation && t.isLead() && this.safeToRemove()
        }))
    }
    componentWillUnmount() {
        const {
            visualElement: t,
            layoutGroup: n,
            switchLayoutGroup: r
        } = this.props, {
            projection: i
        } = t;
        i && (i.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(i), r && r.deregister && r.deregister(i))
    }
    safeToRemove() {
        const {
            safeToRemove: t
        } = this.props;
        t && t()
    }
    render() {
        return null
    }
}

function d3(e) {
    const [t, n] = Qj(), r = S.useContext(LE);
    return E.jsx(sW, { ...e,
        layoutGroup: r,
        switchLayoutGroup: S.useContext(rB),
        isPresent: t,
        safeToRemove: n
    })
}
const uW = {
    borderRadius: { ...bc,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
    },
    borderTopLeftRadius: bc,
    borderTopRightRadius: bc,
    borderBottomLeftRadius: bc,
    borderBottomRightRadius: bc,
    boxShadow: aW
};

function lW(e, t, n) {
    const r = rn(e) ? e : Vf(e);
    return r.start(bS("", r, t, n)), r.animation
}

function cW(e) {
    return e instanceof SVGElement && e.tagName !== "svg"
}
const fW = (e, t) => e.depth - t.depth;
class dW {
    constructor() {
        this.children = [], this.isDirty = !1
    }
    add(t) {
        uS(this.children, t), this.isDirty = !0
    }
    remove(t) {
        lS(this.children, t), this.isDirty = !0
    }
    forEach(t) {
        this.isDirty && this.children.sort(fW), this.isDirty = !1, this.children.forEach(t)
    }
}

function hW(e, t) {
    const n = ui.now(),
        r = ({
            timestamp: i
        }) => {
            const o = i - n;
            o >= t && (ra(r), e(o - t))
        };
    return Ye.read(r, !0), () => ra(r)
}
const h3 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
    pW = h3.length,
    F2 = e => typeof e == "string" ? parseFloat(e) : e,
    U2 = e => typeof e == "number" || ue.test(e);

function mW(e, t, n, r, i, o) {
    i ? (e.opacity = ut(0, n.opacity !== void 0 ? n.opacity : 1, gW(r)), e.opacityExit = ut(t.opacity !== void 0 ? t.opacity : 1, 0, yW(r))) : o && (e.opacity = ut(t.opacity !== void 0 ? t.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r));
    for (let a = 0; a < pW; a++) {
        const s = `border${h3[a]}Radius`;
        let u = H2(t, s),
            l = H2(n, s);
        if (u === void 0 && l === void 0) continue;
        u || (u = 0), l || (l = 0), u === 0 || l === 0 || U2(u) === U2(l) ? (e[s] = Math.max(ut(F2(u), F2(l), r), 0), (si.test(l) || si.test(u)) && (e[s] += "%")) : e[s] = l
    }(t.rotate || n.rotate) && (e.rotate = ut(t.rotate || 0, n.rotate || 0, r))
}

function H2(e, t) {
    return e[t] !== void 0 ? e[t] : e.borderRadius
}
const gW = p3(0, .5, MB),
    yW = p3(.5, .95, Hn);

function p3(e, t, n) {
    return r => r < e ? 0 : r > t ? 1 : n(Ku(e, t, r))
}

function V2(e, t) {
    e.min = t.min, e.max = t.max
}

function Yn(e, t) {
    V2(e.x, t.x), V2(e.y, t.y)
}

function z2(e, t) {
    e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin
}

function W2(e, t, n, r, i) {
    return e -= t, e = Im(e, 1 / n, r), i !== void 0 && (e = Im(e, 1 / i, r)), e
}

function vW(e, t = 0, n = 1, r = .5, i, o = e, a = e) {
    if (si.test(t) && (t = parseFloat(t), t = ut(a.min, a.max, t / 100) - a.min), typeof t != "number") return;
    let s = ut(o.min, o.max, r);
    e === o && (s -= t), e.min = W2(e.min, t, n, s, i), e.max = W2(e.max, t, n, s, i)
}

function G2(e, t, [n, r, i], o, a) {
    vW(e, t[n], t[r], t[i], t.scale, o, a)
}
const bW = ["x", "scaleX", "originX"],
    wW = ["y", "scaleY", "originY"];

function q2(e, t, n, r) {
    G2(e.x, t, bW, n ? n.x : void 0, r ? r.x : void 0), G2(e.y, t, wW, n ? n.y : void 0, r ? r.y : void 0)
}

function K2(e) {
    return e.translate === 0 && e.scale === 1
}

function m3(e) {
    return K2(e.x) && K2(e.y)
}

function Q2(e, t) {
    return e.min === t.min && e.max === t.max
}

function xW(e, t) {
    return Q2(e.x, t.x) && Q2(e.y, t.y)
}

function Y2(e, t) {
    return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max)
}

function g3(e, t) {
    return Y2(e.x, t.x) && Y2(e.y, t.y)
}

function X2(e) {
    return fn(e.x) / fn(e.y)
}

function Z2(e, t) {
    return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint
}
class AW {
    constructor() {
        this.members = []
    }
    add(t) {
        uS(this.members, t), t.scheduleRender()
    }
    remove(t) {
        if (lS(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
            const n = this.members[this.members.length - 1];
            n && this.promote(n)
        }
    }
    relegate(t) {
        const n = this.members.findIndex(i => t === i);
        if (n === 0) return !1;
        let r;
        for (let i = n; i >= 0; i--) {
            const o = this.members[i];
            if (o.isPresent !== !1) {
                r = o;
                break
            }
        }
        return r ? (this.promote(r), !0) : !1
    }
    promote(t, n) {
        const r = this.lead;
        if (t !== r && (this.prevLead = r, this.lead = t, t.show(), r)) {
            r.instance && r.scheduleRender(), t.scheduleRender(), t.resumeFrom = r, n && (t.resumeFrom.preserveOpacity = !0), r.snapshot && (t.snapshot = r.snapshot, t.snapshot.latestValues = r.animationValues || r.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0);
            const {
                crossfade: i
            } = t.options;
            i === !1 && r.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(t => {
            const {
                options: n,
                resumingFrom: r
            } = t;
            n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete()
        })
    }
    scheduleRender() {
        this.members.forEach(t => {
            t.instance && t.scheduleRender(!1)
        })
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}

function EW(e, t, n) {
    let r = "";
    const i = e.x.translate / t.x,
        o = e.y.translate / t.y,
        a = (n == null ? void 0 : n.z) || 0;
    if ((i || o || a) && (r = `translate3d(${i}px, ${o}px, ${a}px) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1/t.x}, ${1/t.y}) `), n) {
        const {
            transformPerspective: l,
            rotate: c,
            rotateX: f,
            rotateY: d,
            skewX: h,
            skewY: m
        } = n;
        l && (r = `perspective(${l}px) ${r}`), c && (r += `rotate(${c}deg) `), f && (r += `rotateX(${f}deg) `), d && (r += `rotateY(${d}deg) `), h && (r += `skewX(${h}deg) `), m && (r += `skewY(${m}deg) `)
    }
    const s = e.x.scale * t.x,
        u = e.y.scale * t.y;
    return (s !== 1 || u !== 1) && (r += `scale(${s}, ${u})`), r || "none"
}
const ab = ["", "X", "Y", "Z"],
    SW = {
        visibility: "hidden"
    },
    J2 = 1e3;
let _W = 0;

function sb(e, t, n, r) {
    const {
        latestValues: i
    } = t;
    i[e] && (n[e] = i[e], t.setStaticValue(e, 0), r && (r[e] = 0))
}

function y3(e) {
    if (e.hasCheckedOptimisedAppear = !0, e.root === e) return;
    const {
        visualElement: t
    } = e.options;
    if (!t) return;
    const n = _B(t);
    if (window.MotionHasOptimisedAnimation(n, "transform")) {
        const {
            layout: i,
            layoutId: o
        } = e.options;
        window.MotionCancelOptimisedAnimation(n, "transform", Ye, !(i || o))
    }
    const {
        parent: r
    } = e;
    r && !r.hasCheckedOptimisedAppear && y3(r)
}

function v3({
    attachResizeListener: e,
    defaultParent: t,
    measureScroll: n,
    checkIsScrollRoot: r,
    resetTransform: i
}) {
    return class {
        constructor(a = {}, s = t == null ? void 0 : t()) {
            this.id = _W++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = {
                x: 1,
                y: 1
            }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
                this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots())
            }, this.updateProjection = () => {
                this.projectionUpdateScheduled = !1, this.nodes.forEach(OW), this.nodes.forEach(NW), this.nodes.forEach(RW), this.nodes.forEach(kW)
            }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = a, this.root = s ? s.root || s : this, this.path = s ? [...s.path, s] : [], this.parent = s, this.depth = s ? s.depth + 1 : 0;
            for (let u = 0; u < this.path.length; u++) this.path[u].shouldResetTransform = !0;
            this.root === this && (this.nodes = new dW)
        }
        addEventListener(a, s) {
            return this.eventHandlers.has(a) || this.eventHandlers.set(a, new cS), this.eventHandlers.get(a).add(s)
        }
        notifyListeners(a, ...s) {
            const u = this.eventHandlers.get(a);
            u && u.notify(...s)
        }
        hasListeners(a) {
            return this.eventHandlers.has(a)
        }
        mount(a, s = this.root.hasTreeAnimated) {
            if (this.instance) return;
            this.isSVG = cW(a), this.instance = a;
            const {
                layoutId: u,
                layout: l,
                visualElement: c
            } = this.options;
            if (c && !c.current && c.mount(a), this.root.nodes.add(this), this.parent && this.parent.children.add(this), s && (l || u) && (this.isLayoutDirty = !0), e) {
                let f;
                const d = () => this.root.updateBlockedByResize = !1;
                e(a, () => {
                    this.root.updateBlockedByResize = !0, f && f(), f = hW(d, 250), Hp.hasAnimatedSinceResize && (Hp.hasAnimatedSinceResize = !1, this.nodes.forEach(tO))
                })
            }
            u && this.root.registerSharedNode(u, this), this.options.animate !== !1 && c && (u || l) && this.addEventListener("didUpdate", ({
                delta: f,
                hasLayoutChanged: d,
                hasRelativeLayoutChanged: h,
                layout: m
            }) => {
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0, this.relativeTarget = void 0;
                    return
                }
                const p = this.options.transition || c.getDefaultTransition() || LW,
                    {
                        onLayoutAnimationStart: y,
                        onLayoutAnimationComplete: g
                    } = c.getProps(),
                    b = !this.targetLayout || !g3(this.targetLayout, m),
                    v = !d && h;
                if (this.options.layoutRoot || this.resumeFrom || v || d && (b || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(f, v);
                    const A = { ...iS(p, "layout"),
                        onPlay: y,
                        onComplete: g
                    };
                    (c.shouldReduceMotion || this.options.layoutRoot) && (A.delay = 0, A.type = !1), this.startAnimation(A)
                } else d || tO(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = m
            })
        }
        unmount() {
            this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
            const a = this.getStack();
            a && a.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, ra(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(jW), this.animationId++)
        }
        getTransformTemplate() {
            const {
                visualElement: a
            } = this.options;
            return a && a.getProps().transformTemplate
        }
        willUpdate(a = !0) {
            if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && y3(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return;
            this.isLayoutDirty = !0;
            for (let c = 0; c < this.path.length; c++) {
                const f = this.path[c];
                f.shouldResetTransform = !0, f.updateScroll("snapshot"), f.options.layoutRoot && f.willUpdate(!1)
            }
            const {
                layoutId: s,
                layout: u
            } = this.options;
            if (s === void 0 && !u) return;
            const l = this.getTransformTemplate();
            this.prevTransformTemplateValue = l ? l(this.latestValues, "") : void 0, this.updateSnapshot(), a && this.notifyListeners("willUpdate")
        }
        update() {
            if (this.updateScheduled = !1, this.isUpdateBlocked()) {
                this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(eO);
                return
            }
            this.isUpdating || this.nodes.forEach(IW), this.isUpdating = !1, this.nodes.forEach(MW), this.nodes.forEach(TW), this.nodes.forEach(PW), this.clearAllSnapshots();
            const s = ui.now();
            Wt.delta = Ji(0, 1e3 / 60, s - Wt.timestamp), Wt.timestamp = s, Wt.isProcessing = !0, Z0.update.process(Wt), Z0.preRender.process(Wt), Z0.render.process(Wt), Wt.isProcessing = !1
        }
        didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0, qE.read(this.scheduleUpdate))
        }
        clearAllSnapshots() {
            this.nodes.forEach(CW), this.sharedNodes.forEach(BW)
        }
        scheduleUpdateProjection() {
            this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Ye.preRender(this.updateProjection, !1, !0))
        }
        scheduleCheckAfterUnmount() {
            Ye.postRender(() => {
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            })
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !fn(this.snapshot.measuredBox.x) && !fn(this.snapshot.measuredBox.y) && (this.snapshot = void 0))
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let u = 0; u < this.path.length; u++) this.path[u].updateScroll();
            const a = this.layout;
            this.layout = this.measure(!1), this.layoutCorrected = wt(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
            const {
                visualElement: s
            } = this.options;
            s && s.notify("LayoutMeasure", this.layout.layoutBox, a ? a.layoutBox : void 0)
        }
        updateScroll(a = "measure") {
            let s = !!(this.options.layoutScroll && this.instance);
            if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === a && (s = !1), s) {
                const u = r(this.instance);
                this.scroll = {
                    animationId: this.root.animationId,
                    phase: a,
                    isRoot: u,
                    offset: n(this.instance),
                    wasRoot: this.scroll ? this.scroll.isRoot : u
                }
            }
        }
        resetTransform() {
            if (!i) return;
            const a = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout,
                s = this.projectionDelta && !m3(this.projectionDelta),
                u = this.getTransformTemplate(),
                l = u ? u(this.latestValues, "") : void 0,
                c = l !== this.prevTransformTemplateValue;
            a && (s || Ca(this.latestValues) || c) && (i(this.instance, l), this.shouldResetTransform = !1, this.scheduleRender())
        }
        measure(a = !0) {
            const s = this.measurePageBox();
            let u = this.removeElementScroll(s);
            return a && (u = this.removeTransform(u)), FW(u), {
                animationId: this.root.animationId,
                measuredBox: s,
                layoutBox: u,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            var a;
            const {
                visualElement: s
            } = this.options;
            if (!s) return wt();
            const u = s.measureViewportBox();
            if (!(((a = this.scroll) === null || a === void 0 ? void 0 : a.wasRoot) || this.path.some(UW))) {
                const {
                    scroll: c
                } = this.root;
                c && (wu(u.x, c.offset.x), wu(u.y, c.offset.y))
            }
            return u
        }
        removeElementScroll(a) {
            var s;
            const u = wt();
            if (Yn(u, a), !((s = this.scroll) === null || s === void 0) && s.wasRoot) return u;
            for (let l = 0; l < this.path.length; l++) {
                const c = this.path[l],
                    {
                        scroll: f,
                        options: d
                    } = c;
                c !== this.root && f && d.layoutScroll && (f.wasRoot && Yn(u, a), wu(u.x, f.offset.x), wu(u.y, f.offset.y))
            }
            return u
        }
        applyTransform(a, s = !1) {
            const u = wt();
            Yn(u, a);
            for (let l = 0; l < this.path.length; l++) {
                const c = this.path[l];
                !s && c.options.layoutScroll && c.scroll && c !== c.root && xu(u, {
                    x: -c.scroll.offset.x,
                    y: -c.scroll.offset.y
                }), Ca(c.latestValues) && xu(u, c.latestValues)
            }
            return Ca(this.latestValues) && xu(u, this.latestValues), u
        }
        removeTransform(a) {
            const s = wt();
            Yn(s, a);
            for (let u = 0; u < this.path.length; u++) {
                const l = this.path[u];
                if (!l.instance || !Ca(l.latestValues)) continue;
                mx(l.latestValues) && l.updateSnapshot();
                const c = wt(),
                    f = l.measurePageBox();
                Yn(c, f), q2(s, l.latestValues, l.snapshot ? l.snapshot.layoutBox : void 0, c)
            }
            return Ca(this.latestValues) && q2(s, this.latestValues), s
        }
        setTargetDelta(a) {
            this.targetDelta = a, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0
        }
        setOptions(a) {
            this.options = { ...this.options,
                ...a,
                crossfade: a.crossfade !== void 0 ? a.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1
        }
        forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Wt.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }
        resolveTargetDelta(a = !1) {
            var s;
            const u = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = u.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = u.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = u.isSharedProjectionDirty);
            const l = !!this.resumingFrom || this !== u;
            if (!(a || l && this.isSharedProjectionDirty || this.isProjectionDirty || !((s = this.parent) === null || s === void 0) && s.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return;
            const {
                layout: f,
                layoutId: d
            } = this.options;
            if (!(!this.layout || !(f || d))) {
                if (this.resolvedRelativeTargetAt = Wt.timestamp, !this.targetDelta && !this.relativeTarget) {
                    const h = this.getClosestProjectingParent();
                    h && h.layout && this.animationProgress !== 1 ? (this.relativeParent = h, this.forceRelativeParentToResolveTarget(), this.relativeTarget = wt(), this.relativeTargetOrigin = wt(), uf(this.relativeTargetOrigin, this.layout.layoutBox, h.layout.layoutBox), Yn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = wt(), this.targetWithTransforms = wt()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), Vz(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Yn(this.target, this.layout.layoutBox), u3(this.target, this.targetDelta)) : Yn(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget)) {
                    this.attemptToResolveRelativeTarget = !1;
                    const h = this.getClosestProjectingParent();
                    h && !!h.resumingFrom == !!this.resumingFrom && !h.options.layoutScroll && h.target && this.animationProgress !== 1 ? (this.relativeParent = h, this.forceRelativeParentToResolveTarget(), this.relativeTarget = wt(), this.relativeTargetOrigin = wt(), uf(this.relativeTargetOrigin, this.target, h.target), Yn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || mx(this.parent.latestValues) || s3(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var a;
            const s = this.getLead(),
                u = !!this.resumingFrom || this !== s;
            let l = !0;
            if ((this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty) && (l = !1), u && (this.isSharedProjectionDirty || this.isTransformDirty) && (l = !1), this.resolvedRelativeTargetAt === Wt.timestamp && (l = !1), l) return;
            const {
                layout: c,
                layoutId: f
            } = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(c || f)) return;
            Yn(this.layoutCorrected, this.layout.layoutBox);
            const d = this.treeScale.x,
                h = this.treeScale.y;
            zz(this.layoutCorrected, this.treeScale, this.path, u), s.layout && !s.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (s.target = s.layout.layoutBox, s.targetWithTransforms = wt());
            const {
                target: m
            } = s;
            if (!m) {
                this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
                return
            }!this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (z2(this.prevProjectionDelta.x, this.projectionDelta.x), z2(this.prevProjectionDelta.y, this.projectionDelta.y)), sf(this.projectionDelta, this.layoutCorrected, m, this.latestValues), (this.treeScale.x !== d || this.treeScale.y !== h || !Z2(this.projectionDelta.x, this.prevProjectionDelta.x) || !Z2(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", m))
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(a = !0) {
            var s;
            if ((s = this.options.visualElement) === null || s === void 0 || s.scheduleRender(), a) {
                const u = this.getStack();
                u && u.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        createProjectionDeltas() {
            this.prevProjectionDelta = bu(), this.projectionDelta = bu(), this.projectionDeltaWithTransform = bu()
        }
        setAnimationOrigin(a, s = !1) {
            const u = this.snapshot,
                l = u ? u.latestValues : {},
                c = { ...this.latestValues
                },
                f = bu();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !s;
            const d = wt(),
                h = u ? u.source : void 0,
                m = this.layout ? this.layout.source : void 0,
                p = h !== m,
                y = this.getStack(),
                g = !y || y.members.length <= 1,
                b = !!(p && !g && this.options.crossfade === !0 && !this.path.some($W));
            this.animationProgress = 0;
            let v;
            this.mixTargetDelta = A => {
                const w = A / 1e3;
                nO(f.x, a.x, w), nO(f.y, a.y, w), this.setTargetDelta(f), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (uf(d, this.layout.layoutBox, this.relativeParent.layout.layoutBox), DW(this.relativeTarget, this.relativeTargetOrigin, d, w), v && xW(this.relativeTarget, v) && (this.isProjectionDirty = !1), v || (v = wt()), Yn(v, this.relativeTarget)), p && (this.animationValues = c, mW(c, l, this.latestValues, w, b, g)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = w
            }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(a) {
            this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (ra(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Ye.update(() => {
                Hp.hasAnimatedSinceResize = !0, this.currentAnimation = lW(0, J2, { ...a,
                    onUpdate: s => {
                        this.mixTargetDelta(s), a.onUpdate && a.onUpdate(s)
                    },
                    onStop: () => {},
                    onComplete: () => {
                        a.onComplete && a.onComplete(), this.completeAnimation()
                    }
                }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0
            })
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
            const a = this.getStack();
            a && a.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(J2), this.currentAnimation.stop()), this.completeAnimation()
        }
        applyTransformsToTarget() {
            const a = this.getLead();
            let {
                targetWithTransforms: s,
                target: u,
                layout: l,
                latestValues: c
            } = a;
            if (!(!s || !u || !l)) {
                if (this !== a && this.layout && l && b3(this.options.animationType, this.layout.layoutBox, l.layoutBox)) {
                    u = this.target || wt();
                    const f = fn(this.layout.layoutBox.x);
                    u.x.min = a.target.x.min, u.x.max = u.x.min + f;
                    const d = fn(this.layout.layoutBox.y);
                    u.y.min = a.target.y.min, u.y.max = u.y.min + d
                }
                Yn(s, u), xu(s, c), sf(this.projectionDeltaWithTransform, this.layoutCorrected, s, c)
            }
        }
        registerSharedNode(a, s) {
            this.sharedNodes.has(a) || this.sharedNodes.set(a, new AW), this.sharedNodes.get(a).add(s);
            const l = s.options.initialPromotionConfig;
            s.promote({
                transition: l ? l.transition : void 0,
                preserveFollowOpacity: l && l.shouldPreserveFollowOpacity ? l.shouldPreserveFollowOpacity(s) : void 0
            })
        }
        isLead() {
            const a = this.getStack();
            return a ? a.lead === this : !0
        }
        getLead() {
            var a;
            const {
                layoutId: s
            } = this.options;
            return s ? ((a = this.getStack()) === null || a === void 0 ? void 0 : a.lead) || this : this
        }
        getPrevLead() {
            var a;
            const {
                layoutId: s
            } = this.options;
            return s ? (a = this.getStack()) === null || a === void 0 ? void 0 : a.prevLead : void 0
        }
        getStack() {
            const {
                layoutId: a
            } = this.options;
            if (a) return this.root.sharedNodes.get(a)
        }
        promote({
            needsReset: a,
            transition: s,
            preserveFollowOpacity: u
        } = {}) {
            const l = this.getStack();
            l && l.promote(this, u), a && (this.projectionDelta = void 0, this.needsReset = !0), s && this.setOptions({
                transition: s
            })
        }
        relegate() {
            const a = this.getStack();
            return a ? a.relegate(this) : !1
        }
        resetSkewAndRotation() {
            const {
                visualElement: a
            } = this.options;
            if (!a) return;
            let s = !1;
            const {
                latestValues: u
            } = a;
            if ((u.z || u.rotate || u.rotateX || u.rotateY || u.rotateZ || u.skewX || u.skewY) && (s = !0), !s) return;
            const l = {};
            u.z && sb("z", a, l, this.animationValues);
            for (let c = 0; c < ab.length; c++) sb(`rotate${ab[c]}`, a, l, this.animationValues), sb(`skew${ab[c]}`, a, l, this.animationValues);
            a.render();
            for (const c in l) a.setStaticValue(c, l[c]), this.animationValues && (this.animationValues[c] = l[c]);
            a.scheduleRender()
        }
        getProjectionStyles(a) {
            var s, u;
            if (!this.instance || this.isSVG) return;
            if (!this.isVisible) return SW;
            const l = {
                    visibility: ""
                },
                c = this.getTransformTemplate();
            if (this.needsReset) return this.needsReset = !1, l.opacity = "", l.pointerEvents = Fp(a == null ? void 0 : a.pointerEvents) || "", l.transform = c ? c(this.latestValues, "") : "none", l;
            const f = this.getLead();
            if (!this.projectionDelta || !this.layout || !f.target) {
                const p = {};
                return this.options.layoutId && (p.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, p.pointerEvents = Fp(a == null ? void 0 : a.pointerEvents) || ""), this.hasProjected && !Ca(this.latestValues) && (p.transform = c ? c({}, "") : "none", this.hasProjected = !1), p
            }
            const d = f.animationValues || f.latestValues;
            this.applyTransformsToTarget(), l.transform = EW(this.projectionDeltaWithTransform, this.treeScale, d), c && (l.transform = c(d, l.transform));
            const {
                x: h,
                y: m
            } = this.projectionDelta;
            l.transformOrigin = `${h.origin*100}% ${m.origin*100}% 0`, f.animationValues ? l.opacity = f === this ? (u = (s = d.opacity) !== null && s !== void 0 ? s : this.latestValues.opacity) !== null && u !== void 0 ? u : 1 : this.preserveOpacity ? this.latestValues.opacity : d.opacityExit : l.opacity = f === this ? d.opacity !== void 0 ? d.opacity : "" : d.opacityExit !== void 0 ? d.opacityExit : 0;
            for (const p in Ff) {
                if (d[p] === void 0) continue;
                const {
                    correct: y,
                    applyTo: g,
                    isCSSVariable: b
                } = Ff[p], v = l.transform === "none" ? d[p] : y(d[p], f);
                if (g) {
                    const A = g.length;
                    for (let w = 0; w < A; w++) l[g[w]] = v
                } else b ? this.options.visualElement.renderState.vars[p] = v : l[p] = v
            }
            return this.options.layoutId && (l.pointerEvents = f === this ? Fp(a == null ? void 0 : a.pointerEvents) || "" : "none"), l
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(a => {
                var s;
                return (s = a.currentAnimation) === null || s === void 0 ? void 0 : s.stop()
            }), this.root.nodes.forEach(eO), this.root.sharedNodes.clear()
        }
    }
}

function TW(e) {
    e.updateLayout()
}

function PW(e) {
    var t;
    const n = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot;
    if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) {
        const {
            layoutBox: r,
            measuredBox: i
        } = e.layout, {
            animationType: o
        } = e.options, a = n.source !== e.layout.source;
        o === "size" ? tr(f => {
            const d = a ? n.measuredBox[f] : n.layoutBox[f],
                h = fn(d);
            d.min = r[f].min, d.max = d.min + h
        }) : b3(o, n.layoutBox, r) && tr(f => {
            const d = a ? n.measuredBox[f] : n.layoutBox[f],
                h = fn(r[f]);
            d.max = d.min + h, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[f].max = e.relativeTarget[f].min + h)
        });
        const s = bu();
        sf(s, r, n.layoutBox);
        const u = bu();
        a ? sf(u, e.applyTransform(i, !0), n.measuredBox) : sf(u, r, n.layoutBox);
        const l = !m3(s);
        let c = !1;
        if (!e.resumeFrom) {
            const f = e.getClosestProjectingParent();
            if (f && !f.resumeFrom) {
                const {
                    snapshot: d,
                    layout: h
                } = f;
                if (d && h) {
                    const m = wt();
                    uf(m, n.layoutBox, d.layoutBox);
                    const p = wt();
                    uf(p, r, h.layoutBox), g3(m, p) || (c = !0), f.options.layoutRoot && (e.relativeTarget = p, e.relativeTargetOrigin = m, e.relativeParent = f)
                }
            }
        }
        e.notifyListeners("didUpdate", {
            layout: r,
            snapshot: n,
            delta: u,
            layoutDelta: s,
            hasLayoutChanged: l,
            hasRelativeLayoutChanged: c
        })
    } else if (e.isLead()) {
        const {
            onExitComplete: r
        } = e.options;
        r && r()
    }
    e.options.transition = void 0
}

function OW(e) {
    e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty))
}

function kW(e) {
    e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1
}

function CW(e) {
    e.clearSnapshot()
}

function eO(e) {
    e.clearMeasurements()
}

function IW(e) {
    e.isLayoutDirty = !1
}

function MW(e) {
    const {
        visualElement: t
    } = e.options;
    t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform()
}

function tO(e) {
    e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0
}

function NW(e) {
    e.resolveTargetDelta()
}

function RW(e) {
    e.calcProjection()
}

function jW(e) {
    e.resetSkewAndRotation()
}

function BW(e) {
    e.removeLeadSnapshot()
}

function nO(e, t, n) {
    e.translate = ut(t.translate, 0, n), e.scale = ut(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint
}

function rO(e, t, n, r) {
    e.min = ut(t.min, n.min, r), e.max = ut(t.max, n.max, r)
}

function DW(e, t, n, r) {
    rO(e.x, t.x, n.x, r), rO(e.y, t.y, n.y, r)
}

function $W(e) {
    return e.animationValues && e.animationValues.opacityExit !== void 0
}
const LW = {
        duration: .45,
        ease: [.4, 0, .1, 1]
    },
    iO = e => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e),
    oO = iO("applewebkit/") && !iO("chrome/") ? Math.round : Hn;

function aO(e) {
    e.min = oO(e.min), e.max = oO(e.max)
}

function FW(e) {
    aO(e.x), aO(e.y)
}

function b3(e, t, n) {
    return e === "position" || e === "preserve-aspect" && !Hz(X2(t), X2(n), .2)
}

function UW(e) {
    var t;
    return e !== e.root && ((t = e.scroll) === null || t === void 0 ? void 0 : t.wasRoot)
}
const HW = v3({
        attachResizeListener: (e, t) => Wf(e, "resize", t),
        measureScroll: () => ({
            x: document.documentElement.scrollLeft || document.body.scrollLeft,
            y: document.documentElement.scrollTop || document.body.scrollTop
        }),
        checkIsScrollRoot: () => !0
    }),
    ub = {
        current: void 0
    },
    w3 = v3({
        measureScroll: e => ({
            x: e.scrollLeft,
            y: e.scrollTop
        }),
        defaultParent: () => {
            if (!ub.current) {
                const e = new HW({});
                e.mount(window), e.setOptions({
                    layoutScroll: !0
                }), ub.current = e
            }
            return ub.current
        },
        resetTransform: (e, t) => {
            e.style.transform = t !== void 0 ? t : "none"
        },
        checkIsScrollRoot: e => window.getComputedStyle(e).position === "fixed"
    }),
    VW = {
        pan: {
            Feature: oW
        },
        drag: {
            Feature: iW,
            ProjectionNode: w3,
            MeasureLayout: d3
        }
    };

function sO(e, t, n) {
    const {
        props: r
    } = e;
    e.animationState && r.whileHover && e.animationState.setActive("whileHover", n === "Start");
    const i = "onHover" + n,
        o = r[i];
    o && Ye.postRender(() => o(t, dh(t)))
}
class zW extends ha {
    mount() {
        const {
            current: t
        } = this.node;
        t && (this.unmount = HV(t, (n, r) => (sO(this.node, r, "Start"), i => sO(this.node, i, "End"))))
    }
    unmount() {}
}
class WW extends ha {
    constructor() {
        super(...arguments), this.isActive = !1
    }
    onFocus() {
        let t = !1;
        try {
            t = this.node.current.matches(":focus-visible")
        } catch {
            t = !0
        }!t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1)
    }
    mount() {
        this.unmount = fh(Wf(this.node.current, "focus", () => this.onFocus()), Wf(this.node.current, "blur", () => this.onBlur()))
    }
    unmount() {}
}

function uO(e, t, n) {
    const {
        props: r
    } = e;
    if (e.current instanceof HTMLButtonElement && e.current.disabled) return;
    e.animationState && r.whileTap && e.animationState.setActive("whileTap", n === "Start");
    const i = "onTap" + (n === "End" ? "" : n),
        o = r[i];
    o && Ye.postRender(() => o(t, dh(t)))
}
class GW extends ha {
    mount() {
        const {
            current: t
        } = this.node;
        t && (this.unmount = GV(t, (n, r) => (uO(this.node, r, "Start"), (i, {
            success: o
        }) => uO(this.node, i, o ? "End" : "Cancel")), {
            useGlobalTarget: this.node.props.globalTapTarget
        }))
    }
    unmount() {}
}
const vx = new WeakMap,
    lb = new WeakMap,
    qW = e => {
        const t = vx.get(e.target);
        t && t(e)
    },
    KW = e => {
        e.forEach(qW)
    };

function QW({
    root: e,
    ...t
}) {
    const n = e || document;
    lb.has(n) || lb.set(n, {});
    const r = lb.get(n),
        i = JSON.stringify(t);
    return r[i] || (r[i] = new IntersectionObserver(KW, {
        root: e,
        ...t
    })), r[i]
}

function YW(e, t, n) {
    const r = QW(t);
    return vx.set(e, n), r.observe(e), () => {
        vx.delete(e), r.unobserve(e)
    }
}
const XW = {
    some: 0,
    all: 1
};
class ZW extends ha {
    constructor() {
        super(...arguments), this.hasEnteredView = !1, this.isInView = !1
    }
    startObserver() {
        this.unmount();
        const {
            viewport: t = {}
        } = this.node.getProps(), {
            root: n,
            margin: r,
            amount: i = "some",
            once: o
        } = t, a = {
            root: n ? n.current : void 0,
            rootMargin: r,
            threshold: typeof i == "number" ? i : XW[i]
        }, s = u => {
            const {
                isIntersecting: l
            } = u;
            if (this.isInView === l || (this.isInView = l, o && !l && this.hasEnteredView)) return;
            l && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", l);
            const {
                onViewportEnter: c,
                onViewportLeave: f
            } = this.node.getProps(), d = l ? c : f;
            d && d(u)
        };
        return YW(this.node.current, a, s)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u") return;
        const {
            props: t,
            prevProps: n
        } = this.node;
        ["amount", "margin", "root"].some(JW(t, n)) && this.startObserver()
    }
    unmount() {}
}

function JW({
    viewport: e = {}
}, {
    viewport: t = {}
} = {}) {
    return n => e[n] !== t[n]
}
const eG = {
        inView: {
            Feature: ZW
        },
        tap: {
            Feature: GW
        },
        focus: {
            Feature: WW
        },
        hover: {
            Feature: zW
        }
    },
    tG = {
        layout: {
            ProjectionNode: w3,
            MeasureLayout: d3
        }
    },
    bx = {
        current: null
    },
    x3 = {
        current: !1
    };

function nG() {
    if (x3.current = !0, !!HE)
        if (window.matchMedia) {
            const e = window.matchMedia("(prefers-reduced-motion)"),
                t = () => bx.current = e.matches;
            e.addListener(t), t()
        } else bx.current = !1
}
const rG = [...GB, Jt, ia],
    iG = e => rG.find(WB(e)),
    oG = new WeakMap;

function aG(e, t, n) {
    for (const r in t) {
        const i = t[r],
            o = n[r];
        if (rn(i)) e.addValue(r, i);
        else if (rn(o)) e.addValue(r, Vf(i, {
            owner: e
        }));
        else if (o !== i)
            if (e.hasValue(r)) {
                const a = e.getValue(r);
                a.liveStyle === !0 ? a.jump(i) : a.hasAnimated || a.set(i)
            } else {
                const a = e.getStaticValue(r);
                e.addValue(r, Vf(a !== void 0 ? a : i, {
                    owner: e
                }))
            }
    }
    for (const r in n) t[r] === void 0 && e.removeValue(r);
    return t
}
const lO = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"];
class sG {
    scrapeMotionValuesFromProps(t, n, r) {
        return {}
    }
    constructor({
        parent: t,
        props: n,
        presenceContext: r,
        reducedMotionConfig: i,
        blockInitialAnimation: o,
        visualState: a
    }, s = {}) {
        this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = gS, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
            this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }, this.renderScheduledAt = 0, this.scheduleRender = () => {
            const h = ui.now();
            this.renderScheduledAt < h && (this.renderScheduledAt = h, Ye.render(this.render, !1, !0))
        };
        const {
            latestValues: u,
            renderState: l,
            onUpdate: c
        } = a;
        this.onUpdate = c, this.latestValues = u, this.baseTarget = { ...u
        }, this.initialValues = n.initial ? { ...u
        } : {}, this.renderState = l, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = i, this.options = s, this.blockInitialAnimation = !!o, this.isControllingVariants = ev(n), this.isVariantNode = tB(n), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(t && t.current);
        const {
            willChange: f,
            ...d
        } = this.scrapeMotionValuesFromProps(n, {}, this);
        for (const h in d) {
            const m = d[h];
            u[h] !== void 0 && rn(m) && m.set(u[h], !1)
        }
    }
    mount(t) {
        this.current = t, oG.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), x3.current || nG(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : bx.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext)
    }
    unmount() {
        this.projection && this.projection.unmount(), ra(this.notifyUpdate), ra(this.render), this.valueSubscriptions.forEach(t => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
        for (const t in this.events) this.events[t].clear();
        for (const t in this.features) {
            const n = this.features[t];
            n && (n.unmount(), n.isMounted = !1)
        }
        this.current = null
    }
    bindToMotionValue(t, n) {
        this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
        const r = js.has(t);
        r && this.onBindTransform && this.onBindTransform();
        const i = n.on("change", s => {
                this.latestValues[t] = s, this.props.onUpdate && Ye.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0)
            }),
            o = n.on("renderRequest", this.scheduleRender);
        let a;
        window.MotionCheckAppearSync && (a = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => {
            i(), o(), a && a(), n.owner && n.stop()
        })
    }
    sortNodePosition(t) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current)
    }
    updateFeatures() {
        let t = "animation";
        for (t in Qu) {
            const n = Qu[t];
            if (!n) continue;
            const {
                isEnabled: r,
                Feature: i
            } = n;
            if (!this.features[t] && i && r(this.props) && (this.features[t] = new i(this)), this.features[t]) {
                const o = this.features[t];
                o.isMounted ? o.update() : (o.mount(), o.isMounted = !0)
            }
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : wt()
    }
    getStaticValue(t) {
        return this.latestValues[t]
    }
    setStaticValue(t, n) {
        this.latestValues[t] = n
    }
    update(t, n) {
        (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
        for (let r = 0; r < lO.length; r++) {
            const i = lO[r];
            this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
            const o = "on" + i,
                a = t[o];
            a && (this.propEventSubscriptions[i] = this.on(i, a))
        }
        this.prevMotionValues = aG(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue(), this.onUpdate && this.onUpdate(this)
    }
    getProps() {
        return this.props
    }
    getVariant(t) {
        return this.props.variants ? this.props.variants[t] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    addVariantChild(t) {
        const n = this.getClosestVariantNode();
        if (n) return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t)
    }
    addValue(t, n) {
        const r = this.values.get(t);
        n !== r && (r && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get())
    }
    removeValue(t) {
        this.values.delete(t);
        const n = this.valueSubscriptions.get(t);
        n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState)
    }
    hasValue(t) {
        return this.values.has(t)
    }
    getValue(t, n) {
        if (this.props.values && this.props.values[t]) return this.props.values[t];
        let r = this.values.get(t);
        return r === void 0 && n !== void 0 && (r = Vf(n === null ? void 0 : n, {
            owner: this
        }), this.addValue(t, r)), r
    }
    readValue(t, n) {
        var r;
        let i = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : (r = this.getBaseTargetFromProps(this.props, t)) !== null && r !== void 0 ? r : this.readValueFromInstance(this.current, t, this.options);
        return i != null && (typeof i == "string" && (VB(i) || RB(i)) ? i = parseFloat(i) : !iG(i) && ia.test(n) && (i = FB(t, n)), this.setBaseTarget(t, rn(i) ? i.get() : i)), rn(i) ? i.get() : i
    }
    setBaseTarget(t, n) {
        this.baseTarget[t] = n
    }
    getBaseTarget(t) {
        var n;
        const {
            initial: r
        } = this.props;
        let i;
        if (typeof r == "string" || typeof r == "object") {
            const a = nS(this.props, r, (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom);
            a && (i = a[t])
        }
        if (r && i !== void 0) return i;
        const o = this.getBaseTargetFromProps(this.props, t);
        return o !== void 0 && !rn(o) ? o : this.initialValues[t] !== void 0 && i === void 0 ? void 0 : this.baseTarget[t]
    }
    on(t, n) {
        return this.events[t] || (this.events[t] = new cS), this.events[t].add(n)
    }
    notify(t, ...n) {
        this.events[t] && this.events[t].notify(...n)
    }
}
class A3 extends sG {
    constructor() {
        super(...arguments), this.KeyframeResolver = qB
    }
    sortInstanceNodePosition(t, n) {
        return t.compareDocumentPosition(n) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(t, n) {
        return t.style ? t.style[n] : void 0
    }
    removeValueFromRenderState(t, {
        vars: n,
        style: r
    }) {
        delete n[t], delete r[t]
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(), delete this.childSubscription);
        const {
            children: t
        } = this.props;
        rn(t) && (this.childSubscription = t.on("change", n => {
            this.current && (this.current.textContent = `${n}`)
        }))
    }
}

function uG(e) {
    return window.getComputedStyle(e)
}
class lG extends A3 {
    constructor() {
        super(...arguments), this.type = "html", this.renderInstance = dB
    }
    readValueFromInstance(t, n) {
        if (js.has(n)) {
            const r = mS(n);
            return r && r.default || 0
        } else {
            const r = uG(t),
                i = (KE(n) ? r.getPropertyValue(n) : r[n]) || 0;
            return typeof i == "string" ? i.trim() : i
        }
    }
    measureInstanceViewportBox(t, {
        transformPagePoint: n
    }) {
        return l3(t, n)
    }
    build(t, n, r) {
        XE(t, n, r.transformTemplate)
    }
    scrapeMotionValuesFromProps(t, n, r) {
        return rS(t, n, r)
    }
}
class cG extends A3 {
    constructor() {
        super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = wt, this.updateDimensions = () => {
            this.current && !this.renderState.dimensions && fB(this.current, this.renderState)
        }
    }
    getBaseTargetFromProps(t, n) {
        return t[n]
    }
    readValueFromInstance(t, n) {
        if (js.has(n)) {
            const r = mS(n);
            return r && r.default || 0
        }
        return n = hB.has(n) ? n : GE(n), t.getAttribute(n)
    }
    scrapeMotionValuesFromProps(t, n, r) {
        return mB(t, n, r)
    }
    onBindTransform() {
        this.current && !this.renderState.dimensions && Ye.postRender(this.updateDimensions)
    }
    build(t, n, r) {
        eS(t, n, this.isSVGTag, r.transformTemplate)
    }
    renderInstance(t, n, r, i) {
        pB(t, n, r, i)
    }
    mount(t) {
        this.isSVGTag = tS(t.tagName), super.mount(t)
    }
}
const fG = (e, t) => JE(e) ? new cG(t) : new lG(t, {
        allowProjection: e !== S.Fragment
    }),
    dG = jV({ ...Rz,
        ...eG,
        ...VW,
        ...tG
    }, fG),
    Ve = X9(dG);

function hG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M19.5 13.5 12 21m0 0-7.5-7.5M12 21V3"
    }))
}
const pG = S.forwardRef(hG);

function mG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99"
    }))
}
const gG = S.forwardRef(mG);

function yG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M4.5 10.5 12 3m0 0 7.5 7.5M12 3v18"
    }))
}
const vG = S.forwardRef(yG);

function bG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"
    }))
}
const wG = S.forwardRef(bG);

function xG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M15.75 15.75V18m-7.5-6.75h.008v.008H8.25v-.008Zm0 2.25h.008v.008H8.25V13.5Zm0 2.25h.008v.008H8.25v-.008Zm0 2.25h.008v.008H8.25V18Zm2.498-6.75h.007v.008h-.007v-.008Zm0 2.25h.007v.008h-.007V13.5Zm0 2.25h.007v.008h-.007v-.008Zm0 2.25h.007v.008h-.007V18Zm2.504-6.75h.008v.008h-.008v-.008Zm0 2.25h.008v.008h-.008V13.5Zm0 2.25h.008v.008h-.008v-.008Zm0 2.25h.008v.008h-.008V18Zm2.498-6.75h.008v.008h-.008v-.008Zm0 2.25h.008v.008h-.008V13.5ZM8.25 6h7.5v2.25h-7.5V6ZM12 2.25c-1.892 0-3.758.11-5.593.322C5.307 2.7 4.5 3.65 4.5 4.757V19.5a2.25 2.25 0 0 0 2.25 2.25h10.5a2.25 2.25 0 0 0 2.25-2.25V4.757c0-1.108-.806-2.057-1.907-2.185A48.507 48.507 0 0 0 12 2.25Z"
    }))
}
const AG = S.forwardRef(xG);

function EG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 0 1 3 19.875v-6.75ZM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V8.625ZM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V4.125Z"
    }))
}
const wS = S.forwardRef(EG);

function SG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M9 12.75 11.25 15 15 9.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
    }))
}
const _G = S.forwardRef(SG);

function TG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "m4.5 12.75 6 6 9-13.5"
    }))
}
const PG = S.forwardRef(TG);

function OG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "m19.5 8.25-7.5 7.5-7.5-7.5"
    }))
}
const kG = S.forwardRef(OG);

function CG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M15.666 3.888A2.25 2.25 0 0 0 13.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 0 1-.75.75H9a.75.75 0 0 1-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 0 1-2.25 2.25H6.75A2.25 2.25 0 0 1 4.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 0 1 1.927-.184"
    }))
}
const IG = S.forwardRef(CG);

function MG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
    }))
}
const NG = S.forwardRef(MG);

function RG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M12 6v12m-3-2.818.879.659c1.171.879 3.07.879 4.242 0 1.172-.879 1.172-2.303 0-3.182C13.536 12.219 12.768 12 12 12c-.725 0-1.45-.22-2.003-.659-1.106-.879-1.106-2.303 0-3.182s2.9-.879 4.006 0l.415.33M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
    }))
}
const E3 = S.forwardRef(RG);

function jG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z"
    }))
}
const xS = S.forwardRef(jG);

function BG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"
    }))
}
const DG = S.forwardRef(BG);

function $G({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M16.5 10.5V6.75a4.5 4.5 0 1 0-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 0 0 2.25-2.25v-6.75a2.25 2.25 0 0 0-2.25-2.25H6.75a2.25 2.25 0 0 0-2.25 2.25v6.75a2.25 2.25 0 0 0 2.25 2.25Z"
    }))
}
const LG = S.forwardRef($G);

function FG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M7.217 10.907a2.25 2.25 0 1 0 0 2.186m0-2.186c.18.324.283.696.283 1.093s-.103.77-.283 1.093m0-2.186 9.566-5.314m-9.566 7.5 9.566 5.314m0 0a2.25 2.25 0 1 0 3.935 2.186 2.25 2.25 0 0 0-3.935-2.186Zm0-12.814a2.25 2.25 0 1 0 3.933-2.185 2.25 2.25 0 0 0-3.933 2.185Z"
    }))
}
const tp = S.forwardRef(FG);

function UG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M9 12.75 11.25 15 15 9.75m-3-7.036A11.959 11.959 0 0 1 3.598 6 11.99 11.99 0 0 0 3 9.749c0 5.592 3.824 10.29 9 11.623 5.176-1.332 9-6.03 9-11.622 0-1.31-.21-2.571-.598-3.751h-.152c-3.196 0-6.1-1.248-8.25-3.285Z"
    }))
}
const Gf = S.forwardRef(UG);

function HG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M18 18.72a9.094 9.094 0 0 0 3.741-.479 3 3 0 0 0-4.682-2.72m.94 3.198.001.031c0 .225-.012.447-.037.666A11.944 11.944 0 0 1 12 21c-2.17 0-4.207-.576-5.963-1.584A6.062 6.062 0 0 1 6 18.719m12 0a5.971 5.971 0 0 0-.941-3.197m0 0A5.995 5.995 0 0 0 12 12.75a5.995 5.995 0 0 0-5.058 2.772m0 0a3 3 0 0 0-4.681 2.72 8.986 8.986 0 0 0 3.74.477m.94-3.197a5.971 5.971 0 0 0-.94 3.197M15 6.75a3 3 0 1 1-6 0 3 3 0 0 1 6 0Zm6 3a2.25 2.25 0 1 1-4.5 0 2.25 2.25 0 0 1 4.5 0Zm-13.5 0a2.25 2.25 0 1 1-4.5 0 2.25 2.25 0 0 1 4.5 0Z"
    }))
}
const VG = S.forwardRef(HG);

function zG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M15 19.128a9.38 9.38 0 0 0 2.625.372 9.337 9.337 0 0 0 4.121-.952 4.125 4.125 0 0 0-7.533-2.493M15 19.128v-.003c0-1.113-.285-2.16-.786-3.07M15 19.128v.106A12.318 12.318 0 0 1 8.624 21c-2.331 0-4.512-.645-6.374-1.766l-.001-.109a6.375 6.375 0 0 1 11.964-3.07M12 6.375a3.375 3.375 0 1 1-6.75 0 3.375 3.375 0 0 1 6.75 0Zm8.25 2.25a2.625 2.625 0 1 1-5.25 0 2.625 2.625 0 0 1 5.25 0Z"
    }))
}
const WG = S.forwardRef(zG);

function GG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "m9.75 9.75 4.5 4.5m0-4.5-4.5 4.5M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
    }))
}
const qG = S.forwardRef(GG);

function KG({
    title: e,
    titleId: t,
    ...n
}, r) {
    return S.createElement("svg", Object.assign({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        strokeWidth: 1.5,
        stroke: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon",
        ref: r,
        "aria-labelledby": t
    }, n), e ? S.createElement("title", {
        id: t
    }, e) : null, S.createElement("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M6 18 18 6M6 6l12 12"
    }))
}
const wx = S.forwardRef(KG),
    QG = "modulepreload",
    YG = function(e) {
        return "/" + e
    },
    cO = {},
    XG = function(t, n, r) {
        let i = Promise.resolve();
        if (n && n.length > 0) {
            document.getElementsByTagName("link");
            const a = document.querySelector("meta[property=csp-nonce]"),
                s = (a == null ? void 0 : a.nonce) || (a == null ? void 0 : a.getAttribute("nonce"));
            i = Promise.allSettled(n.map(u => {
                if (u = YG(u), u in cO) return;
                cO[u] = !0;
                const l = u.endsWith(".css"),
                    c = l ? '[rel="stylesheet"]' : "";
                if (document.querySelector(`link[href="${u}"]${c}`)) return;
                const f = document.createElement("link");
                if (f.rel = l ? "stylesheet" : QG, l || (f.as = "script"), f.crossOrigin = "", f.href = u, s && f.setAttribute("nonce", s), document.head.appendChild(f), l) return new Promise((d, h) => {
                    f.addEventListener("load", d), f.addEventListener("error", () => h(new Error(`Unable to preload CSS for ${u}`)))
                })
            }))
        }

        function o(a) {
            const s = new Event("vite:preloadError", {
                cancelable: !0
            });
            if (s.payload = a, window.dispatchEvent(s), !s.defaultPrevented) throw a
        }
        return i.then(a => {
            for (const s of a || []) s.status === "rejected" && o(s.reason);
            return t().catch(o)
        })
    };
var ur;
(function(e) {
    e.NUMBER = "NUMBER_NUMBER", e.HEX = "NUMBER_HEX", e.STR = "NUMBER_STR", e.BIGINT = "NUMBER_BIGINT"
})(ur || (ur = {}));
var eo;
(function(e) {
    e.HEX = "BYTES_HEX", e.UINT8ARRAY = "BYTES_UINT8ARRAY"
})(eo || (eo = {}));
const mn = {
        number: ur.BIGINT,
        bytes: eo.HEX
    },
    pe = {
        number: ur.HEX,
        bytes: eo.HEX
    };
var Mi;
(function(e) {
    e.EARLIEST = "earliest", e.LATEST = "latest", e.PENDING = "pending", e.SAFE = "safe", e.FINALIZED = "finalized", e.COMMITTED = "committed"
})(Mi || (Mi = {}));
var lf;
(function(e) {
    e.chainstart = "chainstart", e.frontier = "frontier", e.homestead = "homestead", e.dao = "dao", e.tangerineWhistle = "tangerineWhistle", e.spuriousDragon = "spuriousDragon", e.byzantium = "byzantium", e.constantinople = "constantinople", e.petersburg = "petersburg", e.istanbul = "istanbul", e.muirGlacier = "muirGlacier", e.berlin = "berlin", e.london = "london", e.altair = "altair", e.arrowGlacier = "arrowGlacier", e.grayGlacier = "grayGlacier", e.bellatrix = "bellatrix", e.merge = "merge", e.capella = "capella", e.shanghai = "shanghai"
})(lf || (lf = {}));
const AS = Object.getPrototypeOf(Uint8Array);
var fO = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
const dO = Symbol.for("web3/base-provider");
class hh {
    static isWeb3Provider(t) {
        return t instanceof hh || !!(t && t[dO])
    }
    get[dO]() {
        return !0
    }
    send(t, n) {
        this.request(t).then(r => {
            n(null, r)
        }).catch(r => {
            n(r)
        })
    }
    sendAsync(t) {
        return fO(this, void 0, void 0, function*() {
            return this.request(t)
        })
    }
    asEIP1193Provider() {
        const t = Object.create(this),
            n = t.request;
        return t.request = function(i) {
            return fO(this, void 0, void 0, function*() {
                return (yield n(i)).result
            })
        }, t.asEIP1193Provider = void 0, t
    }
}
class ZG extends Array {
    constructor(t) {
        super(), this._accountProvider = t
    }
}
const JG = 100,
    eq = 101,
    tq = 201,
    nq = 202,
    rq = 203,
    iq = 204,
    oq = 205,
    aq = 206,
    sq = 207,
    uq = 208,
    lq = 300,
    cq = 301,
    fq = 310,
    dq = 311,
    hq = 400,
    pq = 402,
    mq = 405,
    gq = 407,
    yq = 408,
    vq = 410,
    bq = 411,
    wq = 412,
    xq = 413,
    Aq = 414,
    Eq = 415,
    Sq = 416,
    _q = 417,
    Tq = 418,
    Pq = 419,
    Oq = 420,
    kq = 421,
    Cq = 422,
    Iq = 423,
    Mq = 424,
    Nq = 425,
    Rq = 426,
    jq = 427,
    Bq = 428,
    Dq = 429,
    $q = 430,
    Lq = 431,
    Fq = 432,
    Uq = 433,
    Hq = 434,
    Vq = 435,
    zq = 436,
    Wq = 437,
    Gq = 438,
    qq = 439,
    Kq = 440,
    Qq = 441,
    Yq = 500,
    Xq = 503,
    Zq = 505,
    Jq = 506,
    eK = 507,
    tK = 600,
    nK = 602,
    rK = 603,
    iK = 604,
    oK = 701,
    aK = 702,
    sK = 703,
    uK = 704,
    lK = 705,
    cK = 706,
    fK = 707,
    dK = 709,
    hK = 801,
    pK = 802,
    mK = 4001,
    gK = 4100,
    yK = 4200,
    vK = 4900,
    bK = 4901,
    wK = 902,
    xK = 903,
    AK = 1001,
    EK = 1002,
    SK = 1003,
    _K = 1004,
    TK = 1005,
    PK = 1006,
    OK = 1008,
    kK = 1009,
    CK = 1010,
    IK = 1011,
    MK = 1012,
    NK = 1014,
    RK = 1015,
    jK = 1100,
    S3 = 1101,
    BK = 1200,
    Mm = -32700,
    Nm = -32600,
    Rm = -32601,
    jm = -32602,
    Bm = -32603,
    Dm = -32e3,
    $m = -32001,
    Lm = -32002,
    Fm = -32003,
    Um = -32004,
    Hm = -32005,
    Vm = -32006;
class fe extends Error {
    get innerError() {
        return this.cause instanceof cf ? this.cause.errors : this.cause
    }
    set innerError(t) {
        Array.isArray(t) ? this.cause = new cf(t) : this.cause = t
    }
    constructor(t, n) {
        super(t), Array.isArray(n) ? this.cause = new cf(n) : this.cause = n, this.name = this.constructor.name, typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(new.target.constructor) : this.stack = new Error().stack
    }
    static convertToString(t, n = !1) {
        if (t == null) return "undefined";
        const r = JSON.stringify(t, (i, o) => typeof o == "bigint" ? o.toString() : o);
        return n && ["bigint", "string"].includes(typeof t) ? r.replace(/['\\"]+/g, "") : r
    }
    toJSON() {
        return {
            name: this.name,
            code: this.code,
            message: this.message,
            cause: this.cause,
            innerError: this.cause
        }
    }
}
class cf extends fe {
    constructor(t) {
        super(`Multiple errors occurred: [${t.map(n=>n.message).join("], [")}]`), this.code = uq, this.errors = t
    }
}
class xe extends fe {
    constructor(t, n) {
        super(`Invalid value given "${fe.convertToString(t,!0)}". Error: ${n}.`), this.name = this.constructor.name
    }
}
class hO extends fe {
    constructor() {
        super("Private key must be 32 bytes."), this.code = oK
    }
}
class DK extends fe {
    constructor() {
        super("Invalid Private Key, Not a valid string or uint8Array"), this.code = aK
    }
}
class $K extends fe {
    constructor(t) {
        super(`"${t}"`), this.code = pK
    }
}
class _3 extends fe {
    constructor() {
        super("Invalid key derivation function"), this.code = sK
    }
}
class LK extends fe {
    constructor() {
        super("Key derivation failed - possibly wrong password"), this.code = uK
    }
}
class FK extends fe {
    constructor() {
        super("Unsupported key store version"), this.code = lK
    }
}
class UK extends fe {
    constructor() {
        super("Password cannot be empty"), this.code = cK
    }
}
class HK extends fe {
    constructor() {
        super("Initialization vector must be 16 bytes"), this.code = fK
    }
}
class VK extends fe {
    constructor() {
        super("c > 1000, pbkdf2 is less secure with less iterations"), this.code = dK
    }
}
class ph extends fe {
    constructor(t, n) {
        super(t), this.code = Yq, n && (this.errorCode = n.code, this.errorReason = n.reason)
    }
    toJSON() {
        return Object.assign(Object.assign({}, super.toJSON()), {
            errorCode: this.errorCode,
            errorReason: this.errorReason
        })
    }
}
class xx extends ph {
    constructor(t) {
        super("Connection not open", t), this.code = Xq
    }
}
class zK extends ph {
    constructor(t) {
        super(`Maximum number of reconnect attempts reached! (${t})`), this.code = Zq
    }
}
class WK extends ph {
    constructor() {
        super("CONNECTION ERROR: Provider started to reconnect before the response got received!"), this.code = Jq
    }
}
class GK extends ph {
    constructor(t) {
        super(`Request already sent with following id: ${t}`), this.code = eK
    }
}
class gn extends fe {
    constructor(t, n) {
        super(t), this.code = lq, this.receipt = n
    }
}
class pO extends fe {
    constructor(t, n) {
        super(`The resolver at ${t} does not implement requested method: "${n}".`), this.address = t, this.name = n, this.code = cq
    }
    toJSON() {
        return Object.assign(Object.assign({}, super.toJSON()), {
            address: this.address,
            name: this.name
        })
    }
}
class nv extends gn {
    constructor(t) {
        if (super(t.message || "Error"), this.name = "name" in t && t.name || this.constructor.name, this.stack = "stack" in t && t.stack || void 0, this.code = t.code, typeof t.data == "object") {
            let n;
            t.data && "originalError" in t.data ? n = t.data.originalError : n = t.data, this.data = n.data, this.cause = new nv(n)
        } else this.data = t.data
    }
    setDecodedProperties(t, n, r) {
        this.errorName = t, this.errorSignature = n, this.errorArgs = r
    }
    toJSON() {
        let t = Object.assign(Object.assign({}, super.toJSON()), {
            data: this.data
        });
        return this.errorName && (t = Object.assign(Object.assign({}, t), {
            errorName: this.errorName,
            errorSignature: this.errorSignature,
            errorArgs: this.errorArgs
        })), t
    }
}
class ns extends gn {
    constructor(t) {
        super("Error happened while trying to execute a function inside a smart contract"), this.code = fq, this.cause = new nv(t)
    }
}
class qK extends xe {
    constructor(t) {
        var n, r;
        super(`data: ${(n=t.data)!==null&&n!==void 0?n:"undefined"}, input: ${(r=t.input)!==null&&r!==void 0?r:"undefined"}`, `You can't have "data" and "input" as properties of a contract at the same time, please use either "data" or "input" instead.`), this.code = dq
    }
}
class KK extends fe {
    constructor(t) {
        super(`ENS is not supported on network ${t}`), this.code = wK
    }
}
class QK extends fe {
    constructor() {
        super("Network not synced"), this.code = xK
    }
}
class mO extends fe {
    constructor(t) {
        super(`Invalid parameters passed. "${typeof t<"u"?t:""}"`), this.hint = t, this.code = sq
    }
    toJSON() {
        return Object.assign(Object.assign({}, super.toJSON()), {
            hint: this.hint
        })
    }
}
class Ax extends fe {
    constructor() {
        super(...arguments), this.code = tq
    }
}
class Ai extends fe {
    constructor() {
        super("The method you're trying to call is not implemented."), this.code = nq
    }
}
class T3 extends fe {
    constructor() {
        super(...arguments), this.code = rq
    }
}
class YK extends fe {
    constructor() {
        super(...arguments), this.code = iq
    }
}
class Te extends fe {
    constructor(t, n) {
        super(t), this.code = oq, this.props = n ? ? {}
    }
}
class XK extends fe {
    constructor(t) {
        super(`A plugin with the namespace: ${t} has already been registered.`), this.code = aq
    }
}
class Vp extends fe {
    constructor() {
        super(...arguments), this.code = tK
    }
}
class Ex extends fe {
    constructor(t) {
        super(`Client URL "${t}" is invalid.`), this.code = nK
    }
}
class ki extends fe {
    constructor() {
        super(...arguments), this.code = rK
    }
}
class ZK extends fe {
    constructor() {
        super(...arguments), this.code = iK
    }
}
class JK extends xe {
    constructor() {
        super(...arguments), this.code = hK
    }
}
class ES extends fe {
    constructor(t, n) {
        super(t), this.receipt = n, this.code = hq
    }
    toJSON() {
        return Object.assign(Object.assign({}, super.toJSON()), {
            receipt: this.receipt
        })
    }
}
class zm extends fe {
    constructor(t, n, r, i) {
        super(`Transaction has been reverted by the EVM${r===void 0?"":`:
 ${fe.convertToString(r)}`}`), this.reason = t, this.signature = n, this.receipt = r, this.data = i, this.code = pq
    }
    toJSON() {
        return Object.assign(Object.assign({}, super.toJSON()), {
            reason: this.reason,
            signature: this.signature,
            receipt: this.receipt,
            data: this.data
        })
    }
}
class P3 extends zm {
    constructor(t, n, r, i, o, a, s) {
        super(t), this.reason = t, this.customErrorName = n, this.customErrorDecodedSignature = r, this.customErrorArguments = i, this.signature = o, this.receipt = a, this.data = s, this.code = Gq
    }
    toJSON() {
        return Object.assign(Object.assign({}, super.toJSON()), {
            reason: this.reason,
            customErrorName: this.customErrorName,
            customErrorDecodedSignature: this.customErrorDecodedSignature,
            customErrorArguments: this.customErrorArguments,
            signature: this.signature,
            receipt: this.receipt,
            data: this.data
        })
    }
}
class O3 extends ES {
    constructor(t) {
        super(`Transaction has been reverted by the EVM${t===void 0?"":`:
 ${fe.convertToString(t)}`}`, t), this.code = mq
    }
}
class eQ extends ES {
    constructor() {
        super("Raw transaction undefined"), this.code = gq
    }
}
class gO extends ES {
    constructor() {
        super("Transaction not found"), this.code = $q
    }
}
class tQ extends xe {
    constructor(t) {
        super(t, "invalid transaction with invalid sender"), this.code = yq
    }
}
class nQ extends xe {
    constructor(t) {
        super(t, "invalid transaction with invalid receiver"), this.code = Wq
    }
}
class rQ extends xe {
    constructor() {
        super("MissingCustomChainError", "If tx.common is provided it must have tx.common.customChain"), this.code = vq
    }
}
class iQ extends xe {
    constructor() {
        super("MissingCustomChainIdError", "If tx.common is provided it must have tx.common.customChain and tx.common.customChain.chainId"), this.code = bq
    }
}
class oQ extends xe {
    constructor(t) {
        super(JSON.stringify(t), "Chain Id doesnt match in tx.chainId tx.common.customChain.chainId"), this.code = wq
    }
}
class aQ extends xe {
    constructor(t) {
        super(JSON.stringify(t), "Chain doesnt match in tx.chain tx.common.basechain"), this.code = Vq
    }
}
class sQ extends xe {
    constructor(t) {
        super(JSON.stringify(t), "hardfork doesnt match in tx.hardfork tx.common.hardfork"), this.code = zq
    }
}
class uQ extends xe {
    constructor() {
        super("CommonOrChainAndHardforkError", "Please provide the common object or the chain and hardfork property but not all together."), this.code = xq
    }
}
class lQ extends xe {
    constructor(t) {
        var n, r;
        super("MissingChainOrHardforkError", `When specifying chain and hardfork, both values must be defined. Received "chain": ${(n=t.chain)!==null&&n!==void 0?n:"undefined"}, "hardfork": ${(r=t.hardfork)!==null&&r!==void 0?r:"undefined"}`), this.code = Aq
    }
}
class cQ extends fe {
    constructor() {
        super('Missing properties in transaction, either define "gas" and "gasPrice" for type 0 transactions or "gas", "maxPriorityFeePerGas" and "maxFeePerGas" for type 2 transactions'), this.code = Kq
    }
}
class fQ extends xe {
    constructor(t) {
        var n, r, i, o;
        super(`gas: ${(n=t.gas)!==null&&n!==void 0?n:"undefined"}, gasPrice: ${(r=t.gasPrice)!==null&&r!==void 0?r:"undefined"}, maxPriorityFeePerGas: ${(i=t.maxPriorityFeePerGas)!==null&&i!==void 0?i:"undefined"}, maxFeePerGas: ${(o=t.maxFeePerGas)!==null&&o!==void 0?o:"undefined"}`, '"gas" is missing'), this.code = Eq, this.cause = new cQ
    }
}
class dQ extends fe {
    constructor() {
        super('Missing properties in transaction, either define "gas" and "gasPrice" for type 0 transactions or "gas", "maxPriorityFeePerGas" and "maxFeePerGas" for type 2 transactions, not both'), this.code = Qq
    }
}
class hQ extends xe {
    constructor(t) {
        var n, r, i, o;
        super(`gas: ${(n=t.gas)!==null&&n!==void 0?n:"undefined"}, gasPrice: ${(r=t.gasPrice)!==null&&r!==void 0?r:"undefined"}, maxPriorityFeePerGas: ${(i=t.maxPriorityFeePerGas)!==null&&i!==void 0?i:"undefined"}, maxFeePerGas: ${(o=t.maxFeePerGas)!==null&&o!==void 0?o:"undefined"}`, "transaction must specify legacy or fee market gas properties, not both"), this.code = Hq, this.cause = new dQ
    }
}
class pQ extends xe {
    constructor(t) {
        var n, r;
        super(`gas: ${(n=t.gas)!==null&&n!==void 0?n:"undefined"}, gasPrice: ${(r=t.gasPrice)!==null&&r!==void 0?r:"undefined"}`, "Gas or gasPrice is lower than 0"), this.code = Sq
    }
}
class mQ extends xe {
    constructor(t) {
        var n, r;
        super(`maxPriorityFeePerGas: ${(n=t.maxPriorityFeePerGas)!==null&&n!==void 0?n:"undefined"}, maxFeePerGas: ${(r=t.maxFeePerGas)!==null&&r!==void 0?r:"undefined"}`, "maxPriorityFeePerGas or maxFeePerGas is lower than 0"), this.code = _q
    }
}
class gQ extends xe {
    constructor(t) {
        super(t, "eip-1559 transactions don't support gasPrice"), this.code = Tq
    }
}
class k3 extends xe {
    constructor(t) {
        var n, r;
        super(`maxPriorityFeePerGas: ${(n=t.maxPriorityFeePerGas)!==null&&n!==void 0?n:"undefined"}, maxFeePerGas: ${(r=t.maxFeePerGas)!==null&&r!==void 0?r:"undefined"}`, "pre-eip-1559 transaction don't support maxFeePerGas/maxPriorityFeePerGas"), this.code = Pq
    }
}
class yQ extends xe {
    constructor(t) {
        super(t, "invalid transaction object"), this.code = Oq
    }
}
class vQ extends xe {
    constructor(t) {
        var n, r;
        super(`nonce: ${(n=t.nonce)!==null&&n!==void 0?n:"undefined"}, chainId: ${(r=t.chainId)!==null&&r!==void 0?r:"undefined"}`, "Nonce or chainId is lower than 0"), this.code = kq
    }
}
class bQ extends xe {
    constructor() {
        super("UnableToPopulateNonceError", "unable to populate nonce, no from address available"), this.code = Cq
    }
}
class wQ extends xe {
    constructor() {
        super("Eip1559NotSupportedError", "Network doesn't support eip-1559"), this.code = Iq
    }
}
class yO extends xe {
    constructor(t) {
        super(t, "unsupported transaction type"), this.code = Mq
    }
}
class C3 extends xe {
    constructor(t) {
        var n, r;
        super(`data: ${(n=t.data)!==null&&n!==void 0?n:"undefined"}, input: ${(r=t.input)!==null&&r!==void 0?r:"undefined"}`, `You can't have "data" and "input" as properties of transactions at the same time, please use either "data" or "input" instead.`), this.code = Nq
    }
}
class xQ extends fe {
    constructor(t) {
        super(`The connected Ethereum Node did not respond within ${t.numberOfSeconds} seconds, please make sure your transaction was properly sent and you are connected to a healthy Node. Be aware that transaction might still be pending or mined!
	Transaction Hash: ${t.transactionHash?t.transactionHash.toString():"not available"}`), this.code = Lq
    }
}

function I3(e) {
    return `Please make sure your transaction was properly sent and there are no previous pending transaction for the same account. However, be aware that it might still be mined!
	Transaction Hash: ${e?e.toString():"not available"}`
}
class M3 extends fe {
    constructor(t) {
        super(`Transaction was not mined within ${t.numberOfSeconds} seconds. ${I3(t.transactionHash)}`), this.code = Rq
    }
}
class N3 extends fe {
    constructor(t) {
        super(`Transaction started at ${t.starterBlockNumber} but was not mined within ${t.numberOfBlocks} blocks. ${I3(t.transactionHash)}`), this.code = Fq
    }
}
class AQ extends xe {
    constructor(t) {
        var n, r;
        super(`receipt: ${JSON.stringify(t.receipt)}, blockHash: ${(n=t.blockHash)===null||n===void 0?void 0:n.toString()}, transactionHash: ${(r=t.transactionHash)===null||r===void 0?void 0:r.toString()}`, "Receipt missing or blockHash null"), this.code = jq
    }
}
class EQ extends xe {
    constructor(t) {
        super(`receipt: ${JSON.stringify(t.receipt)}`, "Receipt missing block number"), this.code = Bq
    }
}
class Sx extends fe {
    constructor(t) {
        super(`Invalid signature. "${t}"`), this.code = Uq
    }
}
class vO extends xe {
    constructor() {
        super("LocalWalletNotAvailableError", "Attempted to index account in local wallet, but no wallet is available"), this.code = Dq
    }
}
class SQ extends fe {
    constructor(t, n) {
        const r = [];
        t.forEach(i => r.push(i.keyword)), super(`The following properties are invalid for the transaction type ${n}: ${r.join(", ")}`), this.code = qq
    }
}
class Nu extends xe {
    constructor(t) {
        super(t, "can not parse as byte data"), this.code = EK
    }
}
class SS extends xe {
    constructor(t) {
        super(t, "can not parse as number data"), this.code = SK
    }
}
class _S extends xe {
    constructor(t) {
        super(t, "invalid ethereum address"), this.code = TK
    }
}
class _Q extends xe {
    constructor(t) {
        super(t, "not a valid string"), this.code = AK
    }
}
class R3 extends xe {
    constructor(t) {
        super(t, "invalid unit"), this.code = _K
    }
}
class j3 extends xe {
    constructor(t) {
        super(t, "not a valid unit. Must be a positive integer"), this.code = RK
    }
}
class TQ extends xe {
    constructor(t) {
        super(t, "can not be converted to hex"), this.code = PK
    }
}
class B3 extends xe {
    constructor(t) {
        super(t, "value greater than the nibble width"), this.code = NK
    }
}
class TS extends xe {
    constructor(t) {
        super(t, "not a valid boolean."), this.code = OK
    }
}
class PQ extends xe {
    constructor(t) {
        super(t, "not a valid unsigned integer."), this.code = kK
    }
}
class bO extends xe {
    constructor(t) {
        super(t, "invalid size given."), this.code = CK
    }
}
class wO extends xe {
    constructor(t) {
        super(t, "value is larger than size."), this.code = IK
    }
}
class OQ extends xe {
    constructor(t) {
        super(t, "invalid string given"), this.code = MK
    }
}
const kQ = e => !Array.isArray(e) && e.jsonrpc === "2.0" && !!e && (e.result === void 0 || e.result === null) && "error" in e && (typeof e.id == "number" || typeof e.id == "string"),
    xO = e => kQ(e) ? e.error.message : "";
class Jr extends fe {
    constructor(t, n, r, i) {
        var o;
        super(n ? ? `Returned error: ${Array.isArray(t)?t.map(s=>xO(s)).join(","):xO(t)}`), this.code = JG, n || (this.data = Array.isArray(t) ? t.map(s => {
            var u;
            return (u = s.error) === null || u === void 0 ? void 0 : u.data
        }) : (o = t == null ? void 0 : t.error) === null || o === void 0 ? void 0 : o.data), this.statusCode = i, this.request = r;
        let a;
        "error" in t ? a = t.error : t instanceof Array && (a = t.filter(s => s.error).map(s => s.error)), Array.isArray(a) && a.length > 0 ? this.cause = new cf(a) : this.cause = a
    }
    toJSON() {
        return Object.assign(Object.assign({}, super.toJSON()), {
            data: this.data,
            request: this.request,
            statusCode: this.statusCode
        })
    }
}
class rv extends Jr {
    constructor(t, n) {
        super(t, void 0, n), this.code = eq;
        let r;
        "error" in t ? r = t.error : t instanceof Array && (r = t.map(i => i.error)), Array.isArray(r) ? this.cause = new cf(r) : this.cause = r
    }
}
class AO extends fe {
    constructor(t, n) {
        super(`Web3Config hardfork doesnt match in defaultHardfork ${t} and common.hardfork ${n}`), this.code = S3
    }
}
class EO extends fe {
    constructor(t, n) {
        super(`Web3Config chain doesnt match in defaultHardfork ${t} and common.hardfork ${n}`), this.code = S3
    }
}
const D3 = "An Rpc error has occured with a code of *code*",
    on = {
        [Mm]: {
            message: "Parse error",
            description: "Invalid JSON"
        },
        [Nm]: {
            message: "Invalid request",
            description: "JSON is not a valid request object	"
        },
        [Rm]: {
            message: "Method not found",
            description: "Method does not exist	"
        },
        [jm]: {
            message: "Invalid params",
            description: "Invalid method parameters"
        },
        [Bm]: {
            message: "Internal error",
            description: "Internal JSON-RPC error"
        },
        [Dm]: {
            message: "Invalid input",
            description: "Missing or invalid parameters"
        },
        [$m]: {
            message: "Resource not found",
            description: "Requested resource not found"
        },
        [Lm]: {
            message: "Resource unavailable",
            description: "Requested resource not available"
        },
        [Fm]: {
            message: "Transaction rejected",
            description: "Transaction creation failed"
        },
        [Um]: {
            message: "Method not supported",
            description: "Method is not implemented"
        },
        [Hm]: {
            message: "Limit exceeded",
            description: "Request exceeds defined limit"
        },
        [Vm]: {
            message: "JSON-RPC version not supported",
            description: "Version of JSON-RPC protocol is not supported"
        },
        [mK]: {
            name: "User Rejected Request",
            message: "The user rejected the request."
        },
        [gK]: {
            name: "Unauthorized",
            message: "The requested method and/or account has not been authorized by the user."
        },
        [yK]: {
            name: "Unsupported Method",
            message: "The Provider does not support the requested method."
        },
        [vK]: {
            name: "Disconnected",
            message: "The Provider is disconnected from all chains."
        },
        [bK]: {
            name: "Chain Disconnected",
            message: "The Provider is not connected to the requested chain."
        },
        "0-999": {
            name: "",
            message: "Not used."
        },
        1e3: {
            name: "Normal Closure",
            message: "The connection successfully completed the purpose for which it was created."
        },
        1001: {
            name: "Going Away",
            message: "The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection."
        },
        1002: {
            name: "Protocol error",
            message: "The endpoint is terminating the connection due to a protocol error."
        },
        1003: {
            name: "Unsupported Data",
            message: "The connection is being terminated because the endpoint received data of a type it cannot accept. (For example, a text-only endpoint received binary data.)"
        },
        1004: {
            name: "Reserved",
            message: "Reserved. A meaning might be defined in the future."
        },
        1005: {
            name: "No Status Rcvd",
            message: "Reserved. Indicates that no status code was provided even though one was expected."
        },
        1006: {
            name: "Abnormal Closure",
            message: "Reserved. Indicates that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected."
        },
        1007: {
            name: "Invalid frame payload data",
            message: "The endpoint is terminating the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message)."
        },
        1008: {
            name: "Policy Violation",
            message: "The endpoint is terminating the connection because it received a message that violates its policy. This is a generic status code, used when codes 1003 and 1009 are not suitable."
        },
        1009: {
            name: "Message Too Big",
            message: "The endpoint is terminating the connection because a data frame was received that is too large."
        },
        1010: {
            name: "Mandatory Ext.",
            message: "The client is terminating the connection because it expected the server to negotiate one or more extension, but the server didn't."
        },
        1011: {
            name: "Internal Error",
            message: "The server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request."
        },
        1012: {
            name: "Service Restart",
            message: "The server is terminating the connection because it is restarting."
        },
        1013: {
            name: "Try Again Later",
            message: "The server is terminating the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients."
        },
        1014: {
            name: "Bad Gateway",
            message: "The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code."
        },
        1015: {
            name: "TLS handshake",
            message: "Reserved. Indicates that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified)."
        },
        "1016-2999": {
            name: "",
            message: "For definition by future revisions of the WebSocket Protocol specification, and for definition by extension specifications."
        },
        "3000-3999": {
            name: "",
            message: "For use by libraries, frameworks, and applications. These status codes are registered directly with IANA. The interpretation of these codes is undefined by the WebSocket protocol."
        },
        "4000-4999": {
            name: "",
            message: "For private use, and thus can't be registered. Such codes can be used by prior agreements between WebSocket applications. The interpretation of these codes is undefined by the WebSocket protocol."
        }
    };
class Qn extends fe {
    constructor(t, n) {
        super(n ? ? D3.replace("*code*", t.error.code.toString())), this.code = t.error.code, this.id = t.id, this.jsonrpc = t.jsonrpc, this.jsonRpcError = t.error
    }
    toJSON() {
        return Object.assign(Object.assign({}, super.toJSON()), {
            error: this.jsonRpcError,
            id: this.id,
            jsonRpc: this.jsonrpc
        })
    }
}
class CQ extends fe {
    constructor(t, n) {
        var r, i, o, a;
        if (!t) super();
        else if (!((r = on[t]) === null || r === void 0) && r.message) super(on[t].message);
        else {
            const s = Object.keys(on).find(u => typeof u == "string" && t >= parseInt(u.split("-")[0], 10) && t <= parseInt(u.split("-")[1], 10));
            super((o = (i = on[s ? ? ""]) === null || i === void 0 ? void 0 : i.message) !== null && o !== void 0 ? o : D3.replace("*code*", (a = t == null ? void 0 : t.toString()) !== null && a !== void 0 ? a : '""'))
        }
        this.code = t, this.data = n
    }
}
class IQ extends Qn {
    constructor(t) {
        super(t, on[Mm].message), this.code = Mm
    }
}
class MQ extends Qn {
    constructor(t) {
        super(t, on[Nm].message), this.code = Nm
    }
}
class NQ extends Qn {
    constructor(t) {
        super(t, on[Rm].message), this.code = Rm
    }
}
class RQ extends Qn {
    constructor(t) {
        super(t, on[jm].message), this.code = jm
    }
}
class jQ extends Qn {
    constructor(t) {
        super(t, on[Bm].message), this.code = Bm
    }
}
class BQ extends Qn {
    constructor(t) {
        super(t, on[Dm].message), this.code = Dm
    }
}
class DQ extends Qn {
    constructor(t) {
        super(t, on[Um].message), this.code = Um
    }
}
class $Q extends Qn {
    constructor(t) {
        super(t, on[Lm].message), this.code = Lm
    }
}
class LQ extends Qn {
    constructor(t) {
        super(t, on[$m].message), this.code = $m
    }
}
class FQ extends Qn {
    constructor(t) {
        super(t, on[Vm].message), this.code = Vm
    }
}
class UQ extends Qn {
    constructor(t) {
        super(t, on[Fm].message), this.code = Fm
    }
}
class HQ extends Qn {
    constructor(t) {
        super(t, on[Hm].message), this.code = Hm
    }
}
const yn = new Map;
yn.set(Mm, {
    error: IQ
});
yn.set(Nm, {
    error: MQ
});
yn.set(Rm, {
    error: NQ
});
yn.set(jm, {
    error: RQ
});
yn.set(Bm, {
    error: jQ
});
yn.set(Dm, {
    error: BQ
});
yn.set(Um, {
    error: DQ
});
yn.set(Lm, {
    error: $Q
});
yn.set(Fm, {
    error: UQ
});
yn.set($m, {
    error: LQ
});
yn.set(Vm, {
    error: FQ
});
yn.set(Hm, {
    error: HQ
});
class VQ extends fe {
    constructor(t) {
        super(`Format for the type ${t} is unsupported`), this.type = t, this.code = BK
    }
    toJSON() {
        return Object.assign(Object.assign({}, super.toJSON()), {
            type: this.type
        })
    }
}

function _n(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error(`positive integer expected, not ${e}`)
}

function zQ(e) {
    if (typeof e != "boolean") throw new Error(`boolean expected, not ${e}`)
}

function WQ(e) {
    return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array"
}

function Vl(e, ...t) {
    if (!WQ(e)) throw new Error("Uint8Array expected");
    if (t.length > 0 && !t.includes(e.length)) throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)
}

function PS(e) {
    if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    _n(e.outputLen), _n(e.blockLen)
}

function vs(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called")
}

function OS(e, t) {
    Vl(e);
    const n = t.outputLen;
    if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`)
}
const $3 = {
        number: _n,
        bool: zQ,
        bytes: Vl,
        hash: PS,
        exists: vs,
        output: OS
    },
    np = BigInt(2 ** 32 - 1),
    SO = BigInt(32);

function GQ(e, t = !1) {
    return t ? {
        h: Number(e & np),
        l: Number(e >> SO & np)
    } : {
        h: Number(e >> SO & np) | 0,
        l: Number(e & np) | 0
    }
}

function qQ(e, t = !1) {
    let n = new Uint32Array(e.length),
        r = new Uint32Array(e.length);
    for (let i = 0; i < e.length; i++) {
        const {
            h: o,
            l: a
        } = GQ(e[i], t);
        [n[i], r[i]] = [o, a]
    }
    return [n, r]
}
const KQ = (e, t, n) => e << n | t >>> 32 - n,
    QQ = (e, t, n) => t << n | e >>> 32 - n,
    YQ = (e, t, n) => t << n - 32 | e >>> 64 - n,
    XQ = (e, t, n) => e << n - 32 | t >>> 64 - n,
    zp = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0; /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Wp = e => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)),
    Gp = e => new DataView(e.buffer, e.byteOffset, e.byteLength),
    Vr = (e, t) => e << 32 - t | e >>> t,
    Ce = (e, t) => e << t | e >>> 32 - t >>> 0,
    Wm = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68,
    ZQ = e => e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;

function Gm(e) {
    for (let t = 0; t < e.length; t++) e[t] = ZQ(e[t])
}

function Xu(e) {
    if (typeof e != "string") throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
    return new Uint8Array(new TextEncoder().encode(e))
}

function Zu(e) {
    return typeof e == "string" && (e = Xu(e)), Vl(e), e
}

function qm(...e) {
    let t = 0;
    for (let r = 0; r < e.length; r++) {
        const i = e[r];
        Vl(i), t += i.length
    }
    const n = new Uint8Array(t);
    for (let r = 0, i = 0; r < e.length; r++) {
        const o = e[r];
        n.set(o, i), i += o.length
    }
    return n
}
let kS = class {
    clone() {
        return this._cloneInto()
    }
};
const JQ = {}.toString;

function L3(e, t) {
    if (t !== void 0 && JQ.call(t) !== "[object Object]") throw new Error("Options should be object or undefined");
    return Object.assign(e, t)
}

function F3(e) {
    const t = r => e().update(Zu(r)).digest(),
        n = e();
    return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t
}

function U3(e = 32) {
    if (zp && typeof zp.getRandomValues == "function") return zp.getRandomValues(new Uint8Array(e));
    throw new Error("crypto.getRandomValues must be defined")
}
const H3 = [],
    V3 = [],
    z3 = [],
    eY = BigInt(0),
    wc = BigInt(1),
    tY = BigInt(2),
    nY = BigInt(7),
    rY = BigInt(256),
    iY = BigInt(113);
for (let e = 0, t = wc, n = 1, r = 0; e < 24; e++) {
    [n, r] = [r, (2 * n + 3 * r) % 5], H3.push(2 * (5 * r + n)), V3.push((e + 1) * (e + 2) / 2 % 64);
    let i = eY;
    for (let o = 0; o < 7; o++) t = (t << wc ^ (t >> nY) * iY) % rY, t & tY && (i ^= wc << (wc << BigInt(o)) - wc);
    z3.push(i)
}
const [oY, aY] = qQ(z3, !0), _O = (e, t, n) => n > 32 ? YQ(e, t, n) : KQ(e, t, n), TO = (e, t, n) => n > 32 ? XQ(e, t, n) : QQ(e, t, n);

function sY(e, t = 24) {
    const n = new Uint32Array(10);
    for (let r = 24 - t; r < 24; r++) {
        for (let a = 0; a < 10; a++) n[a] = e[a] ^ e[a + 10] ^ e[a + 20] ^ e[a + 30] ^ e[a + 40];
        for (let a = 0; a < 10; a += 2) {
            const s = (a + 8) % 10,
                u = (a + 2) % 10,
                l = n[u],
                c = n[u + 1],
                f = _O(l, c, 1) ^ n[s],
                d = TO(l, c, 1) ^ n[s + 1];
            for (let h = 0; h < 50; h += 10) e[a + h] ^= f, e[a + h + 1] ^= d
        }
        let i = e[2],
            o = e[3];
        for (let a = 0; a < 24; a++) {
            const s = V3[a],
                u = _O(i, o, s),
                l = TO(i, o, s),
                c = H3[a];
            i = e[c], o = e[c + 1], e[c] = u, e[c + 1] = l
        }
        for (let a = 0; a < 50; a += 10) {
            for (let s = 0; s < 10; s++) n[s] = e[a + s];
            for (let s = 0; s < 10; s++) e[a + s] ^= ~n[(s + 2) % 10] & n[(s + 4) % 10]
        }
        e[0] ^= oY[r], e[1] ^= aY[r]
    }
    n.fill(0)
}
class CS extends kS {
    constructor(t, n, r, i = !1, o = 24) {
        if (super(), this.blockLen = t, this.suffix = n, this.outputLen = r, this.enableXOF = i, this.rounds = o, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, _n(r), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200), this.state32 = Wp(this.state)
    }
    keccak() {
        Wm || Gm(this.state32), sY(this.state32, this.rounds), Wm || Gm(this.state32), this.posOut = 0, this.pos = 0
    }
    update(t) {
        vs(this);
        const {
            blockLen: n,
            state: r
        } = this;
        t = Zu(t);
        const i = t.length;
        for (let o = 0; o < i;) {
            const a = Math.min(n - this.pos, i - o);
            for (let s = 0; s < a; s++) r[this.pos++] ^= t[o++];
            this.pos === n && this.keccak()
        }
        return this
    }
    finish() {
        if (this.finished) return;
        this.finished = !0;
        const {
            state: t,
            suffix: n,
            pos: r,
            blockLen: i
        } = this;
        t[r] ^= n, n & 128 && r === i - 1 && this.keccak(), t[i - 1] ^= 128, this.keccak()
    }
    writeInto(t) {
        vs(this, !1), Vl(t), this.finish();
        const n = this.state,
            {
                blockLen: r
            } = this;
        for (let i = 0, o = t.length; i < o;) {
            this.posOut >= r && this.keccak();
            const a = Math.min(r - this.posOut, o - i);
            t.set(n.subarray(this.posOut, this.posOut + a), i), this.posOut += a, i += a
        }
        return t
    }
    xofInto(t) {
        if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
        return this.writeInto(t)
    }
    xof(t) {
        return _n(t), this.xofInto(new Uint8Array(t))
    }
    digestInto(t) {
        if (OS(t, this), this.finished) throw new Error("digest() was already called");
        return this.writeInto(t), this.destroy(), t
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
    }
    destroy() {
        this.destroyed = !0, this.state.fill(0)
    }
    _cloneInto(t) {
        const {
            blockLen: n,
            suffix: r,
            outputLen: i,
            rounds: o,
            enableXOF: a
        } = this;
        return t || (t = new CS(n, r, i, a, o)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = o, t.suffix = r, t.outputLen = i, t.enableXOF = a, t.destroyed = this.destroyed, t
    }
}
const uY = (e, t, n) => F3(() => new CS(t, e, n)),
    PO = uY(1, 136, 256 / 8);

function OO(e) {
    throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
}
const Km = $3.bytes;

function W3(e) {
    if (!(e instanceof Uint8Array)) throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof e}`);
    return new TextDecoder().decode(e)
}

function lY(e, t) {
    if (e.length !== t.length) return !1;
    for (let n = 0; n < e.length; n++)
        if (e[n] !== t[n]) return !1;
    return !0
}

function cY(e) {
    return t => ($3.bytes(t), e(t))
}(() => {
    const e = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0,
        t = typeof module < "u" && typeof OO == "function" && OO.bind(module);
    return {
        node: t && !e ? t("crypto") : void 0,
        web: e
    }
})();
const dn = (() => {
    const e = cY(PO);
    return e.create = PO.create, e
})();
var Ie;
(function(e) {
    e.assertEqual = i => i;

    function t(i) {}
    e.assertIs = t;

    function n(i) {
        throw new Error
    }
    e.assertNever = n, e.arrayToEnum = i => {
        const o = {};
        for (const a of i) o[a] = a;
        return o
    }, e.getValidEnumValues = i => {
        const o = e.objectKeys(i).filter(s => typeof i[i[s]] != "number"),
            a = {};
        for (const s of o) a[s] = i[s];
        return e.objectValues(a)
    }, e.objectValues = i => e.objectKeys(i).map(function(o) {
        return i[o]
    }), e.objectKeys = typeof Object.keys == "function" ? i => Object.keys(i) : i => {
        const o = [];
        for (const a in i) Object.prototype.hasOwnProperty.call(i, a) && o.push(a);
        return o
    }, e.find = (i, o) => {
        for (const a of i)
            if (o(a)) return a
    }, e.isInteger = typeof Number.isInteger == "function" ? i => Number.isInteger(i) : i => typeof i == "number" && isFinite(i) && Math.floor(i) === i;

    function r(i, o = " | ") {
        return i.map(a => typeof a == "string" ? `'${a}'` : a).join(o)
    }
    e.joinValues = r, e.jsonStringifyReplacer = (i, o) => typeof o == "bigint" ? o.toString() : o
})(Ie || (Ie = {}));
var _x;
(function(e) {
    e.mergeShapes = (t, n) => ({ ...t,
        ...n
    })
})(_x || (_x = {}));
const J = Ie.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]),
    Ro = e => {
        switch (typeof e) {
            case "undefined":
                return J.undefined;
            case "string":
                return J.string;
            case "number":
                return isNaN(e) ? J.nan : J.number;
            case "boolean":
                return J.boolean;
            case "function":
                return J.function;
            case "bigint":
                return J.bigint;
            case "symbol":
                return J.symbol;
            case "object":
                return Array.isArray(e) ? J.array : e === null ? J.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? J.promise : typeof Map < "u" && e instanceof Map ? J.map : typeof Set < "u" && e instanceof Set ? J.set : typeof Date < "u" && e instanceof Date ? J.date : J.object;
            default:
                return J.unknown
        }
    },
    q = Ie.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]),
    fY = e => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class jr extends Error {
    constructor(t) {
        super(), this.issues = [], this.addIssue = r => {
            this.issues = [...this.issues, r]
        }, this.addIssues = (r = []) => {
            this.issues = [...this.issues, ...r]
        };
        const n = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t
    }
    get errors() {
        return this.issues
    }
    format(t) {
        const n = t || function(o) {
                return o.message
            },
            r = {
                _errors: []
            },
            i = o => {
                for (const a of o.issues)
                    if (a.code === "invalid_union") a.unionErrors.map(i);
                    else if (a.code === "invalid_return_type") i(a.returnTypeError);
                else if (a.code === "invalid_arguments") i(a.argumentsError);
                else if (a.path.length === 0) r._errors.push(n(a));
                else {
                    let s = r,
                        u = 0;
                    for (; u < a.path.length;) {
                        const l = a.path[u];
                        u === a.path.length - 1 ? (s[l] = s[l] || {
                            _errors: []
                        }, s[l]._errors.push(n(a))) : s[l] = s[l] || {
                            _errors: []
                        }, s = s[l], u++
                    }
                }
            };
        return i(this), r
    }
    toString() {
        return this.message
    }
    get message() {
        return JSON.stringify(this.issues, Ie.jsonStringifyReplacer, 2)
    }
    get isEmpty() {
        return this.issues.length === 0
    }
    flatten(t = n => n.message) {
        const n = {},
            r = [];
        for (const i of this.issues) i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [], n[i.path[0]].push(t(i))) : r.push(t(i));
        return {
            formErrors: r,
            fieldErrors: n
        }
    }
    get formErrors() {
        return this.flatten()
    }
}
jr.create = e => new jr(e);
const qf = (e, t) => {
    let n;
    switch (e.code) {
        case q.invalid_type:
            e.received === J.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
            break;
        case q.invalid_literal:
            n = `Invalid literal value, expected ${JSON.stringify(e.expected,Ie.jsonStringifyReplacer)}`;
            break;
        case q.unrecognized_keys:
            n = `Unrecognized key(s) in object: ${Ie.joinValues(e.keys,", ")}`;
            break;
        case q.invalid_union:
            n = "Invalid input";
            break;
        case q.invalid_union_discriminator:
            n = `Invalid discriminator value. Expected ${Ie.joinValues(e.options)}`;
            break;
        case q.invalid_enum_value:
            n = `Invalid enum value. Expected ${Ie.joinValues(e.options)}, received '${e.received}'`;
            break;
        case q.invalid_arguments:
            n = "Invalid function arguments";
            break;
        case q.invalid_return_type:
            n = "Invalid function return type";
            break;
        case q.invalid_date:
            n = "Invalid date";
            break;
        case q.invalid_string:
            typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : Ie.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
            break;
        case q.too_small:
            e.type === "array" ? n = `Array must contain ${e.exact?"exactly":e.inclusive?"at least":"more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact?"exactly":e.inclusive?"at least":"over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact?"exactly equal to ":e.inclusive?"greater than or equal to ":"greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact?"exactly equal to ":e.inclusive?"greater than or equal to ":"greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
            break;
        case q.too_big:
            e.type === "array" ? n = `Array must contain ${e.exact?"exactly":e.inclusive?"at most":"less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact?"exactly":e.inclusive?"at most":"under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact?"exactly":e.inclusive?"less than or equal to":"less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact?"exactly":e.inclusive?"less than or equal to":"less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact?"exactly":e.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
            break;
        case q.custom:
            n = "Invalid input";
            break;
        case q.invalid_intersection_types:
            n = "Intersection results could not be merged";
            break;
        case q.not_multiple_of:
            n = `Number must be a multiple of ${e.multipleOf}`;
            break;
        case q.not_finite:
            n = "Number must be finite";
            break;
        default:
            n = t.defaultError, Ie.assertNever(e)
    }
    return {
        message: n
    }
};
let G3 = qf;

function dY(e) {
    G3 = e
}

function Qm() {
    return G3
}
const Ym = e => {
        const {
            data: t,
            path: n,
            errorMaps: r,
            issueData: i
        } = e, o = [...n, ...i.path || []], a = { ...i,
            path: o
        };
        let s = "";
        const u = r.filter(l => !!l).slice().reverse();
        for (const l of u) s = l(a, {
            data: t,
            defaultError: s
        }).message;
        return { ...i,
            path: o,
            message: i.message || s
        }
    },
    hY = [];

function ee(e, t) {
    const n = Ym({
        issueData: t,
        data: e.data,
        path: e.path,
        errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, Qm(), qf].filter(r => !!r)
    });
    e.common.issues.push(n)
}
class un {
    constructor() {
        this.value = "valid"
    }
    dirty() {
        this.value === "valid" && (this.value = "dirty")
    }
    abort() {
        this.value !== "aborted" && (this.value = "aborted")
    }
    static mergeArray(t, n) {
        const r = [];
        for (const i of n) {
            if (i.status === "aborted") return ye;
            i.status === "dirty" && t.dirty(), r.push(i.value)
        }
        return {
            status: t.value,
            value: r
        }
    }
    static async mergeObjectAsync(t, n) {
        const r = [];
        for (const i of n) r.push({
            key: await i.key,
            value: await i.value
        });
        return un.mergeObjectSync(t, r)
    }
    static mergeObjectSync(t, n) {
        const r = {};
        for (const i of n) {
            const {
                key: o,
                value: a
            } = i;
            if (o.status === "aborted" || a.status === "aborted") return ye;
            o.status === "dirty" && t.dirty(), a.status === "dirty" && t.dirty(), o.value !== "__proto__" && (typeof a.value < "u" || i.alwaysSet) && (r[o.value] = a.value)
        }
        return {
            status: t.value,
            value: r
        }
    }
}
const ye = Object.freeze({
        status: "aborted"
    }),
    q3 = e => ({
        status: "dirty",
        value: e
    }),
    vn = e => ({
        status: "valid",
        value: e
    }),
    Tx = e => e.status === "aborted",
    Px = e => e.status === "dirty",
    Kf = e => e.status === "valid",
    Xm = e => typeof Promise < "u" && e instanceof Promise;
var ie;
(function(e) {
    e.errToObj = t => typeof t == "string" ? {
        message: t
    } : t || {}, e.toString = t => typeof t == "string" ? t : t == null ? void 0 : t.message
})(ie || (ie = {}));
class hi {
    constructor(t, n, r, i) {
        this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = i
    }
    get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath
    }
}
const kO = (e, t) => {
    if (Kf(t)) return {
        success: !0,
        data: t.value
    };
    if (!e.common.issues.length) throw new Error("Validation failed but no issues detected.");
    return {
        success: !1,
        get error() {
            if (this._error) return this._error;
            const n = new jr(e.common.issues);
            return this._error = n, this._error
        }
    }
};

function be(e) {
    if (!e) return {};
    const {
        errorMap: t,
        invalid_type_error: n,
        required_error: r,
        description: i
    } = e;
    if (t && (n || r)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return t ? {
        errorMap: t,
        description: i
    } : {
        errorMap: (a, s) => a.code !== "invalid_type" ? {
            message: s.defaultError
        } : typeof s.data > "u" ? {
            message: r ? ? s.defaultError
        } : {
            message: n ? ? s.defaultError
        },
        description: i
    }
}
class we {
    constructor(t) {
        this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this)
    }
    get description() {
        return this._def.description
    }
    _getType(t) {
        return Ro(t.data)
    }
    _getOrReturnCtx(t, n) {
        return n || {
            common: t.parent.common,
            data: t.data,
            parsedType: Ro(t.data),
            schemaErrorMap: this._def.errorMap,
            path: t.path,
            parent: t.parent
        }
    }
    _processInputParams(t) {
        return {
            status: new un,
            ctx: {
                common: t.parent.common,
                data: t.data,
                parsedType: Ro(t.data),
                schemaErrorMap: this._def.errorMap,
                path: t.path,
                parent: t.parent
            }
        }
    }
    _parseSync(t) {
        const n = this._parse(t);
        if (Xm(n)) throw new Error("Synchronous parse encountered promise.");
        return n
    }
    _parseAsync(t) {
        const n = this._parse(t);
        return Promise.resolve(n)
    }
    parse(t, n) {
        const r = this.safeParse(t, n);
        if (r.success) return r.data;
        throw r.error
    }
    safeParse(t, n) {
        var r;
        const i = {
                common: {
                    issues: [],
                    async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
                    contextualErrorMap: n == null ? void 0 : n.errorMap
                },
                path: (n == null ? void 0 : n.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: t,
                parsedType: Ro(t)
            },
            o = this._parseSync({
                data: t,
                path: i.path,
                parent: i
            });
        return kO(i, o)
    }
    async parseAsync(t, n) {
        const r = await this.safeParseAsync(t, n);
        if (r.success) return r.data;
        throw r.error
    }
    async safeParseAsync(t, n) {
        const r = {
                common: {
                    issues: [],
                    contextualErrorMap: n == null ? void 0 : n.errorMap,
                    async: !0
                },
                path: (n == null ? void 0 : n.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: t,
                parsedType: Ro(t)
            },
            i = this._parse({
                data: t,
                path: r.path,
                parent: r
            }),
            o = await (Xm(i) ? i : Promise.resolve(i));
        return kO(r, o)
    }
    refine(t, n) {
        const r = i => typeof n == "string" || typeof n > "u" ? {
            message: n
        } : typeof n == "function" ? n(i) : n;
        return this._refinement((i, o) => {
            const a = t(i),
                s = () => o.addIssue({
                    code: q.custom,
                    ...r(i)
                });
            return typeof Promise < "u" && a instanceof Promise ? a.then(u => u ? !0 : (s(), !1)) : a ? !0 : (s(), !1)
        })
    }
    refinement(t, n) {
        return this._refinement((r, i) => t(r) ? !0 : (i.addIssue(typeof n == "function" ? n(r, i) : n), !1))
    }
    _refinement(t) {
        return new Lr({
            schema: this,
            typeName: ce.ZodEffects,
            effect: {
                type: "refinement",
                refinement: t
            }
        })
    }
    superRefine(t) {
        return this._refinement(t)
    }
    optional() {
        return zi.create(this, this._def)
    }
    nullable() {
        return xs.create(this, this._def)
    }
    nullish() {
        return this.nullable().optional()
    }
    array() {
        return Br.create(this, this._def)
    }
    promise() {
        return el.create(this, this._def)
    }
    or(t) {
        return Zf.create([this, t], this._def)
    }
    and(t) {
        return Jf.create(this, t, this._def)
    }
    transform(t) {
        return new Lr({ ...be(this._def),
            schema: this,
            typeName: ce.ZodEffects,
            effect: {
                type: "transform",
                transform: t
            }
        })
    }
    default (t) {
        const n = typeof t == "function" ? t : () => t;
        return new id({ ...be(this._def),
            innerType: this,
            defaultValue: n,
            typeName: ce.ZodDefault
        })
    }
    brand() {
        return new Q3({
            typeName: ce.ZodBranded,
            type: this,
            ...be(this._def)
        })
    } catch (t) {
        const n = typeof t == "function" ? t : () => t;
        return new tg({ ...be(this._def),
            innerType: this,
            catchValue: n,
            typeName: ce.ZodCatch
        })
    }
    describe(t) {
        const n = this.constructor;
        return new n({ ...this._def,
            description: t
        })
    }
    pipe(t) {
        return mh.create(this, t)
    }
    readonly() {
        return rg.create(this)
    }
    isOptional() {
        return this.safeParse(void 0).success
    }
    isNullable() {
        return this.safeParse(null).success
    }
}
const pY = /^c[^\s-]{8,}$/i,
    mY = /^[a-z][a-z0-9]*$/,
    gY = /^[0-9A-HJKMNP-TV-Z]{26}$/,
    yY = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
    vY = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
    bY = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let cb;
const wY = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/,
    xY = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    AY = e => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");

function EY(e, t) {
    return !!((t === "v4" || !t) && wY.test(e) || (t === "v6" || !t) && xY.test(e))
}
class Ir extends we {
    _parse(t) {
        if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== J.string) {
            const o = this._getOrReturnCtx(t);
            return ee(o, {
                code: q.invalid_type,
                expected: J.string,
                received: o.parsedType
            }), ye
        }
        const r = new un;
        let i;
        for (const o of this._def.checks)
            if (o.kind === "min") t.data.length < o.value && (i = this._getOrReturnCtx(t, i), ee(i, {
                code: q.too_small,
                minimum: o.value,
                type: "string",
                inclusive: !0,
                exact: !1,
                message: o.message
            }), r.dirty());
            else if (o.kind === "max") t.data.length > o.value && (i = this._getOrReturnCtx(t, i), ee(i, {
            code: q.too_big,
            maximum: o.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: o.message
        }), r.dirty());
        else if (o.kind === "length") {
            const a = t.data.length > o.value,
                s = t.data.length < o.value;
            (a || s) && (i = this._getOrReturnCtx(t, i), a ? ee(i, {
                code: q.too_big,
                maximum: o.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: o.message
            }) : s && ee(i, {
                code: q.too_small,
                minimum: o.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: o.message
            }), r.dirty())
        } else if (o.kind === "email") vY.test(t.data) || (i = this._getOrReturnCtx(t, i), ee(i, {
            validation: "email",
            code: q.invalid_string,
            message: o.message
        }), r.dirty());
        else if (o.kind === "emoji") cb || (cb = new RegExp(bY, "u")), cb.test(t.data) || (i = this._getOrReturnCtx(t, i), ee(i, {
            validation: "emoji",
            code: q.invalid_string,
            message: o.message
        }), r.dirty());
        else if (o.kind === "uuid") yY.test(t.data) || (i = this._getOrReturnCtx(t, i), ee(i, {
            validation: "uuid",
            code: q.invalid_string,
            message: o.message
        }), r.dirty());
        else if (o.kind === "cuid") pY.test(t.data) || (i = this._getOrReturnCtx(t, i), ee(i, {
            validation: "cuid",
            code: q.invalid_string,
            message: o.message
        }), r.dirty());
        else if (o.kind === "cuid2") mY.test(t.data) || (i = this._getOrReturnCtx(t, i), ee(i, {
            validation: "cuid2",
            code: q.invalid_string,
            message: o.message
        }), r.dirty());
        else if (o.kind === "ulid") gY.test(t.data) || (i = this._getOrReturnCtx(t, i), ee(i, {
            validation: "ulid",
            code: q.invalid_string,
            message: o.message
        }), r.dirty());
        else if (o.kind === "url") try {
            new URL(t.data)
        } catch {
            i = this._getOrReturnCtx(t, i), ee(i, {
                validation: "url",
                code: q.invalid_string,
                message: o.message
            }), r.dirty()
        } else o.kind === "regex" ? (o.regex.lastIndex = 0, o.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), ee(i, {
            validation: "regex",
            code: q.invalid_string,
            message: o.message
        }), r.dirty())) : o.kind === "trim" ? t.data = t.data.trim() : o.kind === "includes" ? t.data.includes(o.value, o.position) || (i = this._getOrReturnCtx(t, i), ee(i, {
            code: q.invalid_string,
            validation: {
                includes: o.value,
                position: o.position
            },
            message: o.message
        }), r.dirty()) : o.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : o.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : o.kind === "startsWith" ? t.data.startsWith(o.value) || (i = this._getOrReturnCtx(t, i), ee(i, {
            code: q.invalid_string,
            validation: {
                startsWith: o.value
            },
            message: o.message
        }), r.dirty()) : o.kind === "endsWith" ? t.data.endsWith(o.value) || (i = this._getOrReturnCtx(t, i), ee(i, {
            code: q.invalid_string,
            validation: {
                endsWith: o.value
            },
            message: o.message
        }), r.dirty()) : o.kind === "datetime" ? AY(o).test(t.data) || (i = this._getOrReturnCtx(t, i), ee(i, {
            code: q.invalid_string,
            validation: "datetime",
            message: o.message
        }), r.dirty()) : o.kind === "ip" ? EY(t.data, o.version) || (i = this._getOrReturnCtx(t, i), ee(i, {
            validation: "ip",
            code: q.invalid_string,
            message: o.message
        }), r.dirty()) : Ie.assertNever(o);
        return {
            status: r.value,
            value: t.data
        }
    }
    _regex(t, n, r) {
        return this.refinement(i => t.test(i), {
            validation: n,
            code: q.invalid_string,
            ...ie.errToObj(r)
        })
    }
    _addCheck(t) {
        return new Ir({ ...this._def,
            checks: [...this._def.checks, t]
        })
    }
    email(t) {
        return this._addCheck({
            kind: "email",
            ...ie.errToObj(t)
        })
    }
    url(t) {
        return this._addCheck({
            kind: "url",
            ...ie.errToObj(t)
        })
    }
    emoji(t) {
        return this._addCheck({
            kind: "emoji",
            ...ie.errToObj(t)
        })
    }
    uuid(t) {
        return this._addCheck({
            kind: "uuid",
            ...ie.errToObj(t)
        })
    }
    cuid(t) {
        return this._addCheck({
            kind: "cuid",
            ...ie.errToObj(t)
        })
    }
    cuid2(t) {
        return this._addCheck({
            kind: "cuid2",
            ...ie.errToObj(t)
        })
    }
    ulid(t) {
        return this._addCheck({
            kind: "ulid",
            ...ie.errToObj(t)
        })
    }
    ip(t) {
        return this._addCheck({
            kind: "ip",
            ...ie.errToObj(t)
        })
    }
    datetime(t) {
        var n;
        return typeof t == "string" ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            message: t
        }) : this._addCheck({
            kind: "datetime",
            precision: typeof(t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
            offset: (n = t == null ? void 0 : t.offset) !== null && n !== void 0 ? n : !1,
            ...ie.errToObj(t == null ? void 0 : t.message)
        })
    }
    regex(t, n) {
        return this._addCheck({
            kind: "regex",
            regex: t,
            ...ie.errToObj(n)
        })
    }
    includes(t, n) {
        return this._addCheck({
            kind: "includes",
            value: t,
            position: n == null ? void 0 : n.position,
            ...ie.errToObj(n == null ? void 0 : n.message)
        })
    }
    startsWith(t, n) {
        return this._addCheck({
            kind: "startsWith",
            value: t,
            ...ie.errToObj(n)
        })
    }
    endsWith(t, n) {
        return this._addCheck({
            kind: "endsWith",
            value: t,
            ...ie.errToObj(n)
        })
    }
    min(t, n) {
        return this._addCheck({
            kind: "min",
            value: t,
            ...ie.errToObj(n)
        })
    }
    max(t, n) {
        return this._addCheck({
            kind: "max",
            value: t,
            ...ie.errToObj(n)
        })
    }
    length(t, n) {
        return this._addCheck({
            kind: "length",
            value: t,
            ...ie.errToObj(n)
        })
    }
    nonempty(t) {
        return this.min(1, ie.errToObj(t))
    }
    trim() {
        return new Ir({ ...this._def,
            checks: [...this._def.checks, {
                kind: "trim"
            }]
        })
    }
    toLowerCase() {
        return new Ir({ ...this._def,
            checks: [...this._def.checks, {
                kind: "toLowerCase"
            }]
        })
    }
    toUpperCase() {
        return new Ir({ ...this._def,
            checks: [...this._def.checks, {
                kind: "toUpperCase"
            }]
        })
    }
    get isDatetime() {
        return !!this._def.checks.find(t => t.kind === "datetime")
    }
    get isEmail() {
        return !!this._def.checks.find(t => t.kind === "email")
    }
    get isURL() {
        return !!this._def.checks.find(t => t.kind === "url")
    }
    get isEmoji() {
        return !!this._def.checks.find(t => t.kind === "emoji")
    }
    get isUUID() {
        return !!this._def.checks.find(t => t.kind === "uuid")
    }
    get isCUID() {
        return !!this._def.checks.find(t => t.kind === "cuid")
    }
    get isCUID2() {
        return !!this._def.checks.find(t => t.kind === "cuid2")
    }
    get isULID() {
        return !!this._def.checks.find(t => t.kind === "ulid")
    }
    get isIP() {
        return !!this._def.checks.find(t => t.kind === "ip")
    }
    get minLength() {
        let t = null;
        for (const n of this._def.checks) n.kind === "min" && (t === null || n.value > t) && (t = n.value);
        return t
    }
    get maxLength() {
        let t = null;
        for (const n of this._def.checks) n.kind === "max" && (t === null || n.value < t) && (t = n.value);
        return t
    }
}
Ir.create = e => {
    var t;
    return new Ir({
        checks: [],
        typeName: ce.ZodString,
        coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
        ...be(e)
    })
};

function SY(e, t) {
    const n = (e.toString().split(".")[1] || "").length,
        r = (t.toString().split(".")[1] || "").length,
        i = n > r ? n : r,
        o = parseInt(e.toFixed(i).replace(".", "")),
        a = parseInt(t.toFixed(i).replace(".", ""));
    return o % a / Math.pow(10, i)
}
class oa extends we {
    constructor() {
        super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf
    }
    _parse(t) {
        if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== J.number) {
            const o = this._getOrReturnCtx(t);
            return ee(o, {
                code: q.invalid_type,
                expected: J.number,
                received: o.parsedType
            }), ye
        }
        let r;
        const i = new un;
        for (const o of this._def.checks) o.kind === "int" ? Ie.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), ee(r, {
            code: q.invalid_type,
            expected: "integer",
            received: "float",
            message: o.message
        }), i.dirty()) : o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (r = this._getOrReturnCtx(t, r), ee(r, {
            code: q.too_small,
            minimum: o.value,
            type: "number",
            inclusive: o.inclusive,
            exact: !1,
            message: o.message
        }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (r = this._getOrReturnCtx(t, r), ee(r, {
            code: q.too_big,
            maximum: o.value,
            type: "number",
            inclusive: o.inclusive,
            exact: !1,
            message: o.message
        }), i.dirty()) : o.kind === "multipleOf" ? SY(t.data, o.value) !== 0 && (r = this._getOrReturnCtx(t, r), ee(r, {
            code: q.not_multiple_of,
            multipleOf: o.value,
            message: o.message
        }), i.dirty()) : o.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), ee(r, {
            code: q.not_finite,
            message: o.message
        }), i.dirty()) : Ie.assertNever(o);
        return {
            status: i.value,
            value: t.data
        }
    }
    gte(t, n) {
        return this.setLimit("min", t, !0, ie.toString(n))
    }
    gt(t, n) {
        return this.setLimit("min", t, !1, ie.toString(n))
    }
    lte(t, n) {
        return this.setLimit("max", t, !0, ie.toString(n))
    }
    lt(t, n) {
        return this.setLimit("max", t, !1, ie.toString(n))
    }
    setLimit(t, n, r, i) {
        return new oa({ ...this._def,
            checks: [...this._def.checks, {
                kind: t,
                value: n,
                inclusive: r,
                message: ie.toString(i)
            }]
        })
    }
    _addCheck(t) {
        return new oa({ ...this._def,
            checks: [...this._def.checks, t]
        })
    }
    int(t) {
        return this._addCheck({
            kind: "int",
            message: ie.toString(t)
        })
    }
    positive(t) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: ie.toString(t)
        })
    }
    negative(t) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: ie.toString(t)
        })
    }
    nonpositive(t) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: ie.toString(t)
        })
    }
    nonnegative(t) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: ie.toString(t)
        })
    }
    multipleOf(t, n) {
        return this._addCheck({
            kind: "multipleOf",
            value: t,
            message: ie.toString(n)
        })
    }
    finite(t) {
        return this._addCheck({
            kind: "finite",
            message: ie.toString(t)
        })
    }
    safe(t) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: ie.toString(t)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: ie.toString(t)
        })
    }
    get minValue() {
        let t = null;
        for (const n of this._def.checks) n.kind === "min" && (t === null || n.value > t) && (t = n.value);
        return t
    }
    get maxValue() {
        let t = null;
        for (const n of this._def.checks) n.kind === "max" && (t === null || n.value < t) && (t = n.value);
        return t
    }
    get isInt() {
        return !!this._def.checks.find(t => t.kind === "int" || t.kind === "multipleOf" && Ie.isInteger(t.value))
    }
    get isFinite() {
        let t = null,
            n = null;
        for (const r of this._def.checks) {
            if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf") return !0;
            r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value)
        }
        return Number.isFinite(n) && Number.isFinite(t)
    }
}
oa.create = e => new oa({
    checks: [],
    typeName: ce.ZodNumber,
    coerce: (e == null ? void 0 : e.coerce) || !1,
    ...be(e)
});
class aa extends we {
    constructor() {
        super(...arguments), this.min = this.gte, this.max = this.lte
    }
    _parse(t) {
        if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== J.bigint) {
            const o = this._getOrReturnCtx(t);
            return ee(o, {
                code: q.invalid_type,
                expected: J.bigint,
                received: o.parsedType
            }), ye
        }
        let r;
        const i = new un;
        for (const o of this._def.checks) o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (r = this._getOrReturnCtx(t, r), ee(r, {
            code: q.too_small,
            type: "bigint",
            minimum: o.value,
            inclusive: o.inclusive,
            message: o.message
        }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (r = this._getOrReturnCtx(t, r), ee(r, {
            code: q.too_big,
            type: "bigint",
            maximum: o.value,
            inclusive: o.inclusive,
            message: o.message
        }), i.dirty()) : o.kind === "multipleOf" ? t.data % o.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), ee(r, {
            code: q.not_multiple_of,
            multipleOf: o.value,
            message: o.message
        }), i.dirty()) : Ie.assertNever(o);
        return {
            status: i.value,
            value: t.data
        }
    }
    gte(t, n) {
        return this.setLimit("min", t, !0, ie.toString(n))
    }
    gt(t, n) {
        return this.setLimit("min", t, !1, ie.toString(n))
    }
    lte(t, n) {
        return this.setLimit("max", t, !0, ie.toString(n))
    }
    lt(t, n) {
        return this.setLimit("max", t, !1, ie.toString(n))
    }
    setLimit(t, n, r, i) {
        return new aa({ ...this._def,
            checks: [...this._def.checks, {
                kind: t,
                value: n,
                inclusive: r,
                message: ie.toString(i)
            }]
        })
    }
    _addCheck(t) {
        return new aa({ ...this._def,
            checks: [...this._def.checks, t]
        })
    }
    positive(t) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: ie.toString(t)
        })
    }
    negative(t) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: ie.toString(t)
        })
    }
    nonpositive(t) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: ie.toString(t)
        })
    }
    nonnegative(t) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: ie.toString(t)
        })
    }
    multipleOf(t, n) {
        return this._addCheck({
            kind: "multipleOf",
            value: t,
            message: ie.toString(n)
        })
    }
    get minValue() {
        let t = null;
        for (const n of this._def.checks) n.kind === "min" && (t === null || n.value > t) && (t = n.value);
        return t
    }
    get maxValue() {
        let t = null;
        for (const n of this._def.checks) n.kind === "max" && (t === null || n.value < t) && (t = n.value);
        return t
    }
}
aa.create = e => {
    var t;
    return new aa({
        checks: [],
        typeName: ce.ZodBigInt,
        coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
        ...be(e)
    })
};
class Qf extends we {
    _parse(t) {
        if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== J.boolean) {
            const r = this._getOrReturnCtx(t);
            return ee(r, {
                code: q.invalid_type,
                expected: J.boolean,
                received: r.parsedType
            }), ye
        }
        return vn(t.data)
    }
}
Qf.create = e => new Qf({
    typeName: ce.ZodBoolean,
    coerce: (e == null ? void 0 : e.coerce) || !1,
    ...be(e)
});
class bs extends we {
    _parse(t) {
        if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== J.date) {
            const o = this._getOrReturnCtx(t);
            return ee(o, {
                code: q.invalid_type,
                expected: J.date,
                received: o.parsedType
            }), ye
        }
        if (isNaN(t.data.getTime())) {
            const o = this._getOrReturnCtx(t);
            return ee(o, {
                code: q.invalid_date
            }), ye
        }
        const r = new un;
        let i;
        for (const o of this._def.checks) o.kind === "min" ? t.data.getTime() < o.value && (i = this._getOrReturnCtx(t, i), ee(i, {
            code: q.too_small,
            message: o.message,
            inclusive: !0,
            exact: !1,
            minimum: o.value,
            type: "date"
        }), r.dirty()) : o.kind === "max" ? t.data.getTime() > o.value && (i = this._getOrReturnCtx(t, i), ee(i, {
            code: q.too_big,
            message: o.message,
            inclusive: !0,
            exact: !1,
            maximum: o.value,
            type: "date"
        }), r.dirty()) : Ie.assertNever(o);
        return {
            status: r.value,
            value: new Date(t.data.getTime())
        }
    }
    _addCheck(t) {
        return new bs({ ...this._def,
            checks: [...this._def.checks, t]
        })
    }
    min(t, n) {
        return this._addCheck({
            kind: "min",
            value: t.getTime(),
            message: ie.toString(n)
        })
    }
    max(t, n) {
        return this._addCheck({
            kind: "max",
            value: t.getTime(),
            message: ie.toString(n)
        })
    }
    get minDate() {
        let t = null;
        for (const n of this._def.checks) n.kind === "min" && (t === null || n.value > t) && (t = n.value);
        return t != null ? new Date(t) : null
    }
    get maxDate() {
        let t = null;
        for (const n of this._def.checks) n.kind === "max" && (t === null || n.value < t) && (t = n.value);
        return t != null ? new Date(t) : null
    }
}
bs.create = e => new bs({
    checks: [],
    coerce: (e == null ? void 0 : e.coerce) || !1,
    typeName: ce.ZodDate,
    ...be(e)
});
class Zm extends we {
    _parse(t) {
        if (this._getType(t) !== J.symbol) {
            const r = this._getOrReturnCtx(t);
            return ee(r, {
                code: q.invalid_type,
                expected: J.symbol,
                received: r.parsedType
            }), ye
        }
        return vn(t.data)
    }
}
Zm.create = e => new Zm({
    typeName: ce.ZodSymbol,
    ...be(e)
});
class Yf extends we {
    _parse(t) {
        if (this._getType(t) !== J.undefined) {
            const r = this._getOrReturnCtx(t);
            return ee(r, {
                code: q.invalid_type,
                expected: J.undefined,
                received: r.parsedType
            }), ye
        }
        return vn(t.data)
    }
}
Yf.create = e => new Yf({
    typeName: ce.ZodUndefined,
    ...be(e)
});
class Xf extends we {
    _parse(t) {
        if (this._getType(t) !== J.null) {
            const r = this._getOrReturnCtx(t);
            return ee(r, {
                code: q.invalid_type,
                expected: J.null,
                received: r.parsedType
            }), ye
        }
        return vn(t.data)
    }
}
Xf.create = e => new Xf({
    typeName: ce.ZodNull,
    ...be(e)
});
class Ju extends we {
    constructor() {
        super(...arguments), this._any = !0
    }
    _parse(t) {
        return vn(t.data)
    }
}
Ju.create = e => new Ju({
    typeName: ce.ZodAny,
    ...be(e)
});
class rs extends we {
    constructor() {
        super(...arguments), this._unknown = !0
    }
    _parse(t) {
        return vn(t.data)
    }
}
rs.create = e => new rs({
    typeName: ce.ZodUnknown,
    ...be(e)
});
class to extends we {
    _parse(t) {
        const n = this._getOrReturnCtx(t);
        return ee(n, {
            code: q.invalid_type,
            expected: J.never,
            received: n.parsedType
        }), ye
    }
}
to.create = e => new to({
    typeName: ce.ZodNever,
    ...be(e)
});
class Jm extends we {
    _parse(t) {
        if (this._getType(t) !== J.undefined) {
            const r = this._getOrReturnCtx(t);
            return ee(r, {
                code: q.invalid_type,
                expected: J.void,
                received: r.parsedType
            }), ye
        }
        return vn(t.data)
    }
}
Jm.create = e => new Jm({
    typeName: ce.ZodVoid,
    ...be(e)
});
class Br extends we {
    _parse(t) {
        const {
            ctx: n,
            status: r
        } = this._processInputParams(t), i = this._def;
        if (n.parsedType !== J.array) return ee(n, {
            code: q.invalid_type,
            expected: J.array,
            received: n.parsedType
        }), ye;
        if (i.exactLength !== null) {
            const a = n.data.length > i.exactLength.value,
                s = n.data.length < i.exactLength.value;
            (a || s) && (ee(n, {
                code: a ? q.too_big : q.too_small,
                minimum: s ? i.exactLength.value : void 0,
                maximum: a ? i.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: i.exactLength.message
            }), r.dirty())
        }
        if (i.minLength !== null && n.data.length < i.minLength.value && (ee(n, {
                code: q.too_small,
                minimum: i.minLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: i.minLength.message
            }), r.dirty()), i.maxLength !== null && n.data.length > i.maxLength.value && (ee(n, {
                code: q.too_big,
                maximum: i.maxLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: i.maxLength.message
            }), r.dirty()), n.common.async) return Promise.all([...n.data].map((a, s) => i.type._parseAsync(new hi(n, a, n.path, s)))).then(a => un.mergeArray(r, a));
        const o = [...n.data].map((a, s) => i.type._parseSync(new hi(n, a, n.path, s)));
        return un.mergeArray(r, o)
    }
    get element() {
        return this._def.type
    }
    min(t, n) {
        return new Br({ ...this._def,
            minLength: {
                value: t,
                message: ie.toString(n)
            }
        })
    }
    max(t, n) {
        return new Br({ ...this._def,
            maxLength: {
                value: t,
                message: ie.toString(n)
            }
        })
    }
    length(t, n) {
        return new Br({ ...this._def,
            exactLength: {
                value: t,
                message: ie.toString(n)
            }
        })
    }
    nonempty(t) {
        return this.min(1, t)
    }
}
Br.create = (e, t) => new Br({
    type: e,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ce.ZodArray,
    ...be(t)
});

function Js(e) {
    if (e instanceof at) {
        const t = {};
        for (const n in e.shape) {
            const r = e.shape[n];
            t[n] = zi.create(Js(r))
        }
        return new at({ ...e._def,
            shape: () => t
        })
    } else return e instanceof Br ? new Br({ ...e._def,
        type: Js(e.element)
    }) : e instanceof zi ? zi.create(Js(e.unwrap())) : e instanceof xs ? xs.create(Js(e.unwrap())) : e instanceof pi ? pi.create(e.items.map(t => Js(t))) : e
}
class at extends we {
    constructor() {
        super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend
    }
    _getCached() {
        if (this._cached !== null) return this._cached;
        const t = this._def.shape(),
            n = Ie.objectKeys(t);
        return this._cached = {
            shape: t,
            keys: n
        }
    }
    _parse(t) {
        if (this._getType(t) !== J.object) {
            const l = this._getOrReturnCtx(t);
            return ee(l, {
                code: q.invalid_type,
                expected: J.object,
                received: l.parsedType
            }), ye
        }
        const {
            status: r,
            ctx: i
        } = this._processInputParams(t), {
            shape: o,
            keys: a
        } = this._getCached(), s = [];
        if (!(this._def.catchall instanceof to && this._def.unknownKeys === "strip"))
            for (const l in i.data) a.includes(l) || s.push(l);
        const u = [];
        for (const l of a) {
            const c = o[l],
                f = i.data[l];
            u.push({
                key: {
                    status: "valid",
                    value: l
                },
                value: c._parse(new hi(i, f, i.path, l)),
                alwaysSet: l in i.data
            })
        }
        if (this._def.catchall instanceof to) {
            const l = this._def.unknownKeys;
            if (l === "passthrough")
                for (const c of s) u.push({
                    key: {
                        status: "valid",
                        value: c
                    },
                    value: {
                        status: "valid",
                        value: i.data[c]
                    }
                });
            else if (l === "strict") s.length > 0 && (ee(i, {
                code: q.unrecognized_keys,
                keys: s
            }), r.dirty());
            else if (l !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.")
        } else {
            const l = this._def.catchall;
            for (const c of s) {
                const f = i.data[c];
                u.push({
                    key: {
                        status: "valid",
                        value: c
                    },
                    value: l._parse(new hi(i, f, i.path, c)),
                    alwaysSet: c in i.data
                })
            }
        }
        return i.common.async ? Promise.resolve().then(async () => {
            const l = [];
            for (const c of u) {
                const f = await c.key;
                l.push({
                    key: f,
                    value: await c.value,
                    alwaysSet: c.alwaysSet
                })
            }
            return l
        }).then(l => un.mergeObjectSync(r, l)) : un.mergeObjectSync(r, u)
    }
    get shape() {
        return this._def.shape()
    }
    strict(t) {
        return ie.errToObj, new at({ ...this._def,
            unknownKeys: "strict",
            ...t !== void 0 ? {
                errorMap: (n, r) => {
                    var i, o, a, s;
                    const u = (a = (o = (i = this._def).errorMap) === null || o === void 0 ? void 0 : o.call(i, n, r).message) !== null && a !== void 0 ? a : r.defaultError;
                    return n.code === "unrecognized_keys" ? {
                        message: (s = ie.errToObj(t).message) !== null && s !== void 0 ? s : u
                    } : {
                        message: u
                    }
                }
            } : {}
        })
    }
    strip() {
        return new at({ ...this._def,
            unknownKeys: "strip"
        })
    }
    passthrough() {
        return new at({ ...this._def,
            unknownKeys: "passthrough"
        })
    }
    extend(t) {
        return new at({ ...this._def,
            shape: () => ({ ...this._def.shape(),
                ...t
            })
        })
    }
    merge(t) {
        return new at({
            unknownKeys: t._def.unknownKeys,
            catchall: t._def.catchall,
            shape: () => ({ ...this._def.shape(),
                ...t._def.shape()
            }),
            typeName: ce.ZodObject
        })
    }
    setKey(t, n) {
        return this.augment({
            [t]: n
        })
    }
    catchall(t) {
        return new at({ ...this._def,
            catchall: t
        })
    }
    pick(t) {
        const n = {};
        return Ie.objectKeys(t).forEach(r => {
            t[r] && this.shape[r] && (n[r] = this.shape[r])
        }), new at({ ...this._def,
            shape: () => n
        })
    }
    omit(t) {
        const n = {};
        return Ie.objectKeys(this.shape).forEach(r => {
            t[r] || (n[r] = this.shape[r])
        }), new at({ ...this._def,
            shape: () => n
        })
    }
    deepPartial() {
        return Js(this)
    }
    partial(t) {
        const n = {};
        return Ie.objectKeys(this.shape).forEach(r => {
            const i = this.shape[r];
            t && !t[r] ? n[r] = i : n[r] = i.optional()
        }), new at({ ...this._def,
            shape: () => n
        })
    }
    required(t) {
        const n = {};
        return Ie.objectKeys(this.shape).forEach(r => {
            if (t && !t[r]) n[r] = this.shape[r];
            else {
                let o = this.shape[r];
                for (; o instanceof zi;) o = o._def.innerType;
                n[r] = o
            }
        }), new at({ ...this._def,
            shape: () => n
        })
    }
    keyof() {
        return K3(Ie.objectKeys(this.shape))
    }
}
at.create = (e, t) => new at({
    shape: () => e,
    unknownKeys: "strip",
    catchall: to.create(),
    typeName: ce.ZodObject,
    ...be(t)
});
at.strictCreate = (e, t) => new at({
    shape: () => e,
    unknownKeys: "strict",
    catchall: to.create(),
    typeName: ce.ZodObject,
    ...be(t)
});
at.lazycreate = (e, t) => new at({
    shape: e,
    unknownKeys: "strip",
    catchall: to.create(),
    typeName: ce.ZodObject,
    ...be(t)
});
class Zf extends we {
    _parse(t) {
        const {
            ctx: n
        } = this._processInputParams(t), r = this._def.options;

        function i(o) {
            for (const s of o)
                if (s.result.status === "valid") return s.result;
            for (const s of o)
                if (s.result.status === "dirty") return n.common.issues.push(...s.ctx.common.issues), s.result;
            const a = o.map(s => new jr(s.ctx.common.issues));
            return ee(n, {
                code: q.invalid_union,
                unionErrors: a
            }), ye
        }
        if (n.common.async) return Promise.all(r.map(async o => {
            const a = { ...n,
                common: { ...n.common,
                    issues: []
                },
                parent: null
            };
            return {
                result: await o._parseAsync({
                    data: n.data,
                    path: n.path,
                    parent: a
                }),
                ctx: a
            }
        })).then(i); {
            let o;
            const a = [];
            for (const u of r) {
                const l = { ...n,
                        common: { ...n.common,
                            issues: []
                        },
                        parent: null
                    },
                    c = u._parseSync({
                        data: n.data,
                        path: n.path,
                        parent: l
                    });
                if (c.status === "valid") return c;
                c.status === "dirty" && !o && (o = {
                    result: c,
                    ctx: l
                }), l.common.issues.length && a.push(l.common.issues)
            }
            if (o) return n.common.issues.push(...o.ctx.common.issues), o.result;
            const s = a.map(u => new jr(u));
            return ee(n, {
                code: q.invalid_union,
                unionErrors: s
            }), ye
        }
    }
    get options() {
        return this._def.options
    }
}
Zf.create = (e, t) => new Zf({
    options: e,
    typeName: ce.ZodUnion,
    ...be(t)
});
const qp = e => e instanceof td ? qp(e.schema) : e instanceof Lr ? qp(e.innerType()) : e instanceof nd ? [e.value] : e instanceof sa ? e.options : e instanceof rd ? Object.keys(e.enum) : e instanceof id ? qp(e._def.innerType) : e instanceof Yf ? [void 0] : e instanceof Xf ? [null] : null;
class iv extends we {
    _parse(t) {
        const {
            ctx: n
        } = this._processInputParams(t);
        if (n.parsedType !== J.object) return ee(n, {
            code: q.invalid_type,
            expected: J.object,
            received: n.parsedType
        }), ye;
        const r = this.discriminator,
            i = n.data[r],
            o = this.optionsMap.get(i);
        return o ? n.common.async ? o._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        }) : o._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }) : (ee(n, {
            code: q.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [r]
        }), ye)
    }
    get discriminator() {
        return this._def.discriminator
    }
    get options() {
        return this._def.options
    }
    get optionsMap() {
        return this._def.optionsMap
    }
    static create(t, n, r) {
        const i = new Map;
        for (const o of n) {
            const a = qp(o.shape[t]);
            if (!a) throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
            for (const s of a) {
                if (i.has(s)) throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(s)}`);
                i.set(s, o)
            }
        }
        return new iv({
            typeName: ce.ZodDiscriminatedUnion,
            discriminator: t,
            options: n,
            optionsMap: i,
            ...be(r)
        })
    }
}

function Ox(e, t) {
    const n = Ro(e),
        r = Ro(t);
    if (e === t) return {
        valid: !0,
        data: e
    };
    if (n === J.object && r === J.object) {
        const i = Ie.objectKeys(t),
            o = Ie.objectKeys(e).filter(s => i.indexOf(s) !== -1),
            a = { ...e,
                ...t
            };
        for (const s of o) {
            const u = Ox(e[s], t[s]);
            if (!u.valid) return {
                valid: !1
            };
            a[s] = u.data
        }
        return {
            valid: !0,
            data: a
        }
    } else if (n === J.array && r === J.array) {
        if (e.length !== t.length) return {
            valid: !1
        };
        const i = [];
        for (let o = 0; o < e.length; o++) {
            const a = e[o],
                s = t[o],
                u = Ox(a, s);
            if (!u.valid) return {
                valid: !1
            };
            i.push(u.data)
        }
        return {
            valid: !0,
            data: i
        }
    } else return n === J.date && r === J.date && +e == +t ? {
        valid: !0,
        data: e
    } : {
        valid: !1
    }
}
class Jf extends we {
    _parse(t) {
        const {
            status: n,
            ctx: r
        } = this._processInputParams(t), i = (o, a) => {
            if (Tx(o) || Tx(a)) return ye;
            const s = Ox(o.value, a.value);
            return s.valid ? ((Px(o) || Px(a)) && n.dirty(), {
                status: n.value,
                value: s.data
            }) : (ee(r, {
                code: q.invalid_intersection_types
            }), ye)
        };
        return r.common.async ? Promise.all([this._def.left._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        }), this._def.right._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        })]).then(([o, a]) => i(o, a)) : i(this._def.left._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }), this._def.right._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }))
    }
}
Jf.create = (e, t, n) => new Jf({
    left: e,
    right: t,
    typeName: ce.ZodIntersection,
    ...be(n)
});
class pi extends we {
    _parse(t) {
        const {
            status: n,
            ctx: r
        } = this._processInputParams(t);
        if (r.parsedType !== J.array) return ee(r, {
            code: q.invalid_type,
            expected: J.array,
            received: r.parsedType
        }), ye;
        if (r.data.length < this._def.items.length) return ee(r, {
            code: q.too_small,
            minimum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), ye;
        !this._def.rest && r.data.length > this._def.items.length && (ee(r, {
            code: q.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), n.dirty());
        const o = [...r.data].map((a, s) => {
            const u = this._def.items[s] || this._def.rest;
            return u ? u._parse(new hi(r, a, r.path, s)) : null
        }).filter(a => !!a);
        return r.common.async ? Promise.all(o).then(a => un.mergeArray(n, a)) : un.mergeArray(n, o)
    }
    get items() {
        return this._def.items
    }
    rest(t) {
        return new pi({ ...this._def,
            rest: t
        })
    }
}
pi.create = (e, t) => {
    if (!Array.isArray(e)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new pi({
        items: e,
        typeName: ce.ZodTuple,
        rest: null,
        ...be(t)
    })
};
class ed extends we {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(t) {
        const {
            status: n,
            ctx: r
        } = this._processInputParams(t);
        if (r.parsedType !== J.object) return ee(r, {
            code: q.invalid_type,
            expected: J.object,
            received: r.parsedType
        }), ye;
        const i = [],
            o = this._def.keyType,
            a = this._def.valueType;
        for (const s in r.data) i.push({
            key: o._parse(new hi(r, s, r.path, s)),
            value: a._parse(new hi(r, r.data[s], r.path, s))
        });
        return r.common.async ? un.mergeObjectAsync(n, i) : un.mergeObjectSync(n, i)
    }
    get element() {
        return this._def.valueType
    }
    static create(t, n, r) {
        return n instanceof we ? new ed({
            keyType: t,
            valueType: n,
            typeName: ce.ZodRecord,
            ...be(r)
        }) : new ed({
            keyType: Ir.create(),
            valueType: t,
            typeName: ce.ZodRecord,
            ...be(n)
        })
    }
}
class eg extends we {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(t) {
        const {
            status: n,
            ctx: r
        } = this._processInputParams(t);
        if (r.parsedType !== J.map) return ee(r, {
            code: q.invalid_type,
            expected: J.map,
            received: r.parsedType
        }), ye;
        const i = this._def.keyType,
            o = this._def.valueType,
            a = [...r.data.entries()].map(([s, u], l) => ({
                key: i._parse(new hi(r, s, r.path, [l, "key"])),
                value: o._parse(new hi(r, u, r.path, [l, "value"]))
            }));
        if (r.common.async) {
            const s = new Map;
            return Promise.resolve().then(async () => {
                for (const u of a) {
                    const l = await u.key,
                        c = await u.value;
                    if (l.status === "aborted" || c.status === "aborted") return ye;
                    (l.status === "dirty" || c.status === "dirty") && n.dirty(), s.set(l.value, c.value)
                }
                return {
                    status: n.value,
                    value: s
                }
            })
        } else {
            const s = new Map;
            for (const u of a) {
                const l = u.key,
                    c = u.value;
                if (l.status === "aborted" || c.status === "aborted") return ye;
                (l.status === "dirty" || c.status === "dirty") && n.dirty(), s.set(l.value, c.value)
            }
            return {
                status: n.value,
                value: s
            }
        }
    }
}
eg.create = (e, t, n) => new eg({
    valueType: t,
    keyType: e,
    typeName: ce.ZodMap,
    ...be(n)
});
class ws extends we {
    _parse(t) {
        const {
            status: n,
            ctx: r
        } = this._processInputParams(t);
        if (r.parsedType !== J.set) return ee(r, {
            code: q.invalid_type,
            expected: J.set,
            received: r.parsedType
        }), ye;
        const i = this._def;
        i.minSize !== null && r.data.size < i.minSize.value && (ee(r, {
            code: q.too_small,
            minimum: i.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i.minSize.message
        }), n.dirty()), i.maxSize !== null && r.data.size > i.maxSize.value && (ee(r, {
            code: q.too_big,
            maximum: i.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i.maxSize.message
        }), n.dirty());
        const o = this._def.valueType;

        function a(u) {
            const l = new Set;
            for (const c of u) {
                if (c.status === "aborted") return ye;
                c.status === "dirty" && n.dirty(), l.add(c.value)
            }
            return {
                status: n.value,
                value: l
            }
        }
        const s = [...r.data.values()].map((u, l) => o._parse(new hi(r, u, r.path, l)));
        return r.common.async ? Promise.all(s).then(u => a(u)) : a(s)
    }
    min(t, n) {
        return new ws({ ...this._def,
            minSize: {
                value: t,
                message: ie.toString(n)
            }
        })
    }
    max(t, n) {
        return new ws({ ...this._def,
            maxSize: {
                value: t,
                message: ie.toString(n)
            }
        })
    }
    size(t, n) {
        return this.min(t, n).max(t, n)
    }
    nonempty(t) {
        return this.min(1, t)
    }
}
ws.create = (e, t) => new ws({
    valueType: e,
    minSize: null,
    maxSize: null,
    typeName: ce.ZodSet,
    ...be(t)
});
class Ru extends we {
    constructor() {
        super(...arguments), this.validate = this.implement
    }
    _parse(t) {
        const {
            ctx: n
        } = this._processInputParams(t);
        if (n.parsedType !== J.function) return ee(n, {
            code: q.invalid_type,
            expected: J.function,
            received: n.parsedType
        }), ye;

        function r(s, u) {
            return Ym({
                data: s,
                path: n.path,
                errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, Qm(), qf].filter(l => !!l),
                issueData: {
                    code: q.invalid_arguments,
                    argumentsError: u
                }
            })
        }

        function i(s, u) {
            return Ym({
                data: s,
                path: n.path,
                errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, Qm(), qf].filter(l => !!l),
                issueData: {
                    code: q.invalid_return_type,
                    returnTypeError: u
                }
            })
        }
        const o = {
                errorMap: n.common.contextualErrorMap
            },
            a = n.data;
        if (this._def.returns instanceof el) {
            const s = this;
            return vn(async function(...u) {
                const l = new jr([]),
                    c = await s._def.args.parseAsync(u, o).catch(h => {
                        throw l.addIssue(r(u, h)), l
                    }),
                    f = await Reflect.apply(a, this, c);
                return await s._def.returns._def.type.parseAsync(f, o).catch(h => {
                    throw l.addIssue(i(f, h)), l
                })
            })
        } else {
            const s = this;
            return vn(function(...u) {
                const l = s._def.args.safeParse(u, o);
                if (!l.success) throw new jr([r(u, l.error)]);
                const c = Reflect.apply(a, this, l.data),
                    f = s._def.returns.safeParse(c, o);
                if (!f.success) throw new jr([i(c, f.error)]);
                return f.data
            })
        }
    }
    parameters() {
        return this._def.args
    }
    returnType() {
        return this._def.returns
    }
    args(...t) {
        return new Ru({ ...this._def,
            args: pi.create(t).rest(rs.create())
        })
    }
    returns(t) {
        return new Ru({ ...this._def,
            returns: t
        })
    }
    implement(t) {
        return this.parse(t)
    }
    strictImplement(t) {
        return this.parse(t)
    }
    static create(t, n, r) {
        return new Ru({
            args: t || pi.create([]).rest(rs.create()),
            returns: n || rs.create(),
            typeName: ce.ZodFunction,
            ...be(r)
        })
    }
}
class td extends we {
    get schema() {
        return this._def.getter()
    }
    _parse(t) {
        const {
            ctx: n
        } = this._processInputParams(t);
        return this._def.getter()._parse({
            data: n.data,
            path: n.path,
            parent: n
        })
    }
}
td.create = (e, t) => new td({
    getter: e,
    typeName: ce.ZodLazy,
    ...be(t)
});
class nd extends we {
    _parse(t) {
        if (t.data !== this._def.value) {
            const n = this._getOrReturnCtx(t);
            return ee(n, {
                received: n.data,
                code: q.invalid_literal,
                expected: this._def.value
            }), ye
        }
        return {
            status: "valid",
            value: t.data
        }
    }
    get value() {
        return this._def.value
    }
}
nd.create = (e, t) => new nd({
    value: e,
    typeName: ce.ZodLiteral,
    ...be(t)
});

function K3(e, t) {
    return new sa({
        values: e,
        typeName: ce.ZodEnum,
        ...be(t)
    })
}
class sa extends we {
    _parse(t) {
        if (typeof t.data != "string") {
            const n = this._getOrReturnCtx(t),
                r = this._def.values;
            return ee(n, {
                expected: Ie.joinValues(r),
                received: n.parsedType,
                code: q.invalid_type
            }), ye
        }
        if (this._def.values.indexOf(t.data) === -1) {
            const n = this._getOrReturnCtx(t),
                r = this._def.values;
            return ee(n, {
                received: n.data,
                code: q.invalid_enum_value,
                options: r
            }), ye
        }
        return vn(t.data)
    }
    get options() {
        return this._def.values
    }
    get enum() {
        const t = {};
        for (const n of this._def.values) t[n] = n;
        return t
    }
    get Values() {
        const t = {};
        for (const n of this._def.values) t[n] = n;
        return t
    }
    get Enum() {
        const t = {};
        for (const n of this._def.values) t[n] = n;
        return t
    }
    extract(t) {
        return sa.create(t)
    }
    exclude(t) {
        return sa.create(this.options.filter(n => !t.includes(n)))
    }
}
sa.create = K3;
class rd extends we {
    _parse(t) {
        const n = Ie.getValidEnumValues(this._def.values),
            r = this._getOrReturnCtx(t);
        if (r.parsedType !== J.string && r.parsedType !== J.number) {
            const i = Ie.objectValues(n);
            return ee(r, {
                expected: Ie.joinValues(i),
                received: r.parsedType,
                code: q.invalid_type
            }), ye
        }
        if (n.indexOf(t.data) === -1) {
            const i = Ie.objectValues(n);
            return ee(r, {
                received: r.data,
                code: q.invalid_enum_value,
                options: i
            }), ye
        }
        return vn(t.data)
    }
    get enum() {
        return this._def.values
    }
}
rd.create = (e, t) => new rd({
    values: e,
    typeName: ce.ZodNativeEnum,
    ...be(t)
});
class el extends we {
    unwrap() {
        return this._def.type
    }
    _parse(t) {
        const {
            ctx: n
        } = this._processInputParams(t);
        if (n.parsedType !== J.promise && n.common.async === !1) return ee(n, {
            code: q.invalid_type,
            expected: J.promise,
            received: n.parsedType
        }), ye;
        const r = n.parsedType === J.promise ? n.data : Promise.resolve(n.data);
        return vn(r.then(i => this._def.type.parseAsync(i, {
            path: n.path,
            errorMap: n.common.contextualErrorMap
        })))
    }
}
el.create = (e, t) => new el({
    type: e,
    typeName: ce.ZodPromise,
    ...be(t)
});
class Lr extends we {
    innerType() {
        return this._def.schema
    }
    sourceType() {
        return this._def.schema._def.typeName === ce.ZodEffects ? this._def.schema.sourceType() : this._def.schema
    }
    _parse(t) {
        const {
            status: n,
            ctx: r
        } = this._processInputParams(t), i = this._def.effect || null, o = {
            addIssue: a => {
                ee(r, a), a.fatal ? n.abort() : n.dirty()
            },
            get path() {
                return r.path
            }
        };
        if (o.addIssue = o.addIssue.bind(o), i.type === "preprocess") {
            const a = i.transform(r.data, o);
            return r.common.issues.length ? {
                status: "dirty",
                value: r.data
            } : r.common.async ? Promise.resolve(a).then(s => this._def.schema._parseAsync({
                data: s,
                path: r.path,
                parent: r
            })) : this._def.schema._parseSync({
                data: a,
                path: r.path,
                parent: r
            })
        }
        if (i.type === "refinement") {
            const a = s => {
                const u = i.refinement(s, o);
                if (r.common.async) return Promise.resolve(u);
                if (u instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return s
            };
            if (r.common.async === !1) {
                const s = this._def.schema._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: r
                });
                return s.status === "aborted" ? ye : (s.status === "dirty" && n.dirty(), a(s.value), {
                    status: n.value,
                    value: s.value
                })
            } else return this._def.schema._parseAsync({
                data: r.data,
                path: r.path,
                parent: r
            }).then(s => s.status === "aborted" ? ye : (s.status === "dirty" && n.dirty(), a(s.value).then(() => ({
                status: n.value,
                value: s.value
            }))))
        }
        if (i.type === "transform")
            if (r.common.async === !1) {
                const a = this._def.schema._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: r
                });
                if (!Kf(a)) return a;
                const s = i.transform(a.value, o);
                if (s instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                return {
                    status: n.value,
                    value: s
                }
            } else return this._def.schema._parseAsync({
                data: r.data,
                path: r.path,
                parent: r
            }).then(a => Kf(a) ? Promise.resolve(i.transform(a.value, o)).then(s => ({
                status: n.value,
                value: s
            })) : a);
        Ie.assertNever(i)
    }
}
Lr.create = (e, t, n) => new Lr({
    schema: e,
    typeName: ce.ZodEffects,
    effect: t,
    ...be(n)
});
Lr.createWithPreprocess = (e, t, n) => new Lr({
    schema: t,
    effect: {
        type: "preprocess",
        transform: e
    },
    typeName: ce.ZodEffects,
    ...be(n)
});
class zi extends we {
    _parse(t) {
        return this._getType(t) === J.undefined ? vn(void 0) : this._def.innerType._parse(t)
    }
    unwrap() {
        return this._def.innerType
    }
}
zi.create = (e, t) => new zi({
    innerType: e,
    typeName: ce.ZodOptional,
    ...be(t)
});
class xs extends we {
    _parse(t) {
        return this._getType(t) === J.null ? vn(null) : this._def.innerType._parse(t)
    }
    unwrap() {
        return this._def.innerType
    }
}
xs.create = (e, t) => new xs({
    innerType: e,
    typeName: ce.ZodNullable,
    ...be(t)
});
class id extends we {
    _parse(t) {
        const {
            ctx: n
        } = this._processInputParams(t);
        let r = n.data;
        return n.parsedType === J.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
            data: r,
            path: n.path,
            parent: n
        })
    }
    removeDefault() {
        return this._def.innerType
    }
}
id.create = (e, t) => new id({
    innerType: e,
    typeName: ce.ZodDefault,
    defaultValue: typeof t.default == "function" ? t.default : () => t.default,
    ...be(t)
});
class tg extends we {
    _parse(t) {
        const {
            ctx: n
        } = this._processInputParams(t), r = { ...n,
            common: { ...n.common,
                issues: []
            }
        }, i = this._def.innerType._parse({
            data: r.data,
            path: r.path,
            parent: { ...r
            }
        });
        return Xm(i) ? i.then(o => ({
            status: "valid",
            value: o.status === "valid" ? o.value : this._def.catchValue({
                get error() {
                    return new jr(r.common.issues)
                },
                input: r.data
            })
        })) : {
            status: "valid",
            value: i.status === "valid" ? i.value : this._def.catchValue({
                get error() {
                    return new jr(r.common.issues)
                },
                input: r.data
            })
        }
    }
    removeCatch() {
        return this._def.innerType
    }
}
tg.create = (e, t) => new tg({
    innerType: e,
    typeName: ce.ZodCatch,
    catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
    ...be(t)
});
class ng extends we {
    _parse(t) {
        if (this._getType(t) !== J.nan) {
            const r = this._getOrReturnCtx(t);
            return ee(r, {
                code: q.invalid_type,
                expected: J.nan,
                received: r.parsedType
            }), ye
        }
        return {
            status: "valid",
            value: t.data
        }
    }
}
ng.create = e => new ng({
    typeName: ce.ZodNaN,
    ...be(e)
});
const _Y = Symbol("zod_brand");
class Q3 extends we {
    _parse(t) {
        const {
            ctx: n
        } = this._processInputParams(t), r = n.data;
        return this._def.type._parse({
            data: r,
            path: n.path,
            parent: n
        })
    }
    unwrap() {
        return this._def.type
    }
}
class mh extends we {
    _parse(t) {
        const {
            status: n,
            ctx: r
        } = this._processInputParams(t);
        if (r.common.async) return (async () => {
            const o = await this._def.in._parseAsync({
                data: r.data,
                path: r.path,
                parent: r
            });
            return o.status === "aborted" ? ye : o.status === "dirty" ? (n.dirty(), q3(o.value)) : this._def.out._parseAsync({
                data: o.value,
                path: r.path,
                parent: r
            })
        })(); {
            const i = this._def.in._parseSync({
                data: r.data,
                path: r.path,
                parent: r
            });
            return i.status === "aborted" ? ye : i.status === "dirty" ? (n.dirty(), {
                status: "dirty",
                value: i.value
            }) : this._def.out._parseSync({
                data: i.value,
                path: r.path,
                parent: r
            })
        }
    }
    static create(t, n) {
        return new mh({ in: t,
            out: n,
            typeName: ce.ZodPipeline
        })
    }
}
class rg extends we {
    _parse(t) {
        const n = this._def.innerType._parse(t);
        return Kf(n) && (n.value = Object.freeze(n.value)), n
    }
}
rg.create = (e, t) => new rg({
    innerType: e,
    typeName: ce.ZodReadonly,
    ...be(t)
});
const Y3 = (e, t = {}, n) => e ? Ju.create().superRefine((r, i) => {
        var o, a;
        if (!e(r)) {
            const s = typeof t == "function" ? t(r) : typeof t == "string" ? {
                    message: t
                } : t,
                u = (a = (o = s.fatal) !== null && o !== void 0 ? o : n) !== null && a !== void 0 ? a : !0,
                l = typeof s == "string" ? {
                    message: s
                } : s;
            i.addIssue({
                code: "custom",
                ...l,
                fatal: u
            })
        }
    }) : Ju.create(),
    TY = {
        object: at.lazycreate
    };
var ce;
(function(e) {
    e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly"
})(ce || (ce = {}));
const PY = (e, t = {
        message: `Input not instance of ${e.name}`
    }) => Y3(n => n instanceof e, t),
    X3 = Ir.create,
    Z3 = oa.create,
    OY = ng.create,
    kY = aa.create,
    J3 = Qf.create,
    CY = bs.create,
    IY = Zm.create,
    MY = Yf.create,
    NY = Xf.create,
    RY = Ju.create,
    jY = rs.create,
    BY = to.create,
    DY = Jm.create,
    $Y = Br.create,
    LY = at.create,
    FY = at.strictCreate,
    UY = Zf.create,
    HY = iv.create,
    VY = Jf.create,
    zY = pi.create,
    WY = ed.create,
    GY = eg.create,
    qY = ws.create,
    KY = Ru.create,
    QY = td.create,
    YY = nd.create,
    XY = sa.create,
    ZY = rd.create,
    JY = el.create,
    CO = Lr.create,
    eX = zi.create,
    tX = xs.create,
    nX = Lr.createWithPreprocess,
    rX = mh.create,
    iX = () => X3().optional(),
    oX = () => Z3().optional(),
    aX = () => J3().optional(),
    sX = {
        string: e => Ir.create({ ...e,
            coerce: !0
        }),
        number: e => oa.create({ ...e,
            coerce: !0
        }),
        boolean: e => Qf.create({ ...e,
            coerce: !0
        }),
        bigint: e => aa.create({ ...e,
            coerce: !0
        }),
        date: e => bs.create({ ...e,
            coerce: !0
        })
    },
    uX = ye;
var zr = Object.freeze({
    __proto__: null,
    defaultErrorMap: qf,
    setErrorMap: dY,
    getErrorMap: Qm,
    makeIssue: Ym,
    EMPTY_PATH: hY,
    addIssueToContext: ee,
    ParseStatus: un,
    INVALID: ye,
    DIRTY: q3,
    OK: vn,
    isAborted: Tx,
    isDirty: Px,
    isValid: Kf,
    isAsync: Xm,
    get util() {
        return Ie
    },
    get objectUtil() {
        return _x
    },
    ZodParsedType: J,
    getParsedType: Ro,
    ZodType: we,
    ZodString: Ir,
    ZodNumber: oa,
    ZodBigInt: aa,
    ZodBoolean: Qf,
    ZodDate: bs,
    ZodSymbol: Zm,
    ZodUndefined: Yf,
    ZodNull: Xf,
    ZodAny: Ju,
    ZodUnknown: rs,
    ZodNever: to,
    ZodVoid: Jm,
    ZodArray: Br,
    ZodObject: at,
    ZodUnion: Zf,
    ZodDiscriminatedUnion: iv,
    ZodIntersection: Jf,
    ZodTuple: pi,
    ZodRecord: ed,
    ZodMap: eg,
    ZodSet: ws,
    ZodFunction: Ru,
    ZodLazy: td,
    ZodLiteral: nd,
    ZodEnum: sa,
    ZodNativeEnum: rd,
    ZodPromise: el,
    ZodEffects: Lr,
    ZodTransformer: Lr,
    ZodOptional: zi,
    ZodNullable: xs,
    ZodDefault: id,
    ZodCatch: tg,
    ZodNaN: ng,
    BRAND: _Y,
    ZodBranded: Q3,
    ZodPipeline: mh,
    ZodReadonly: rg,
    custom: Y3,
    Schema: we,
    ZodSchema: we,
    late: TY,
    get ZodFirstPartyTypeKind() {
        return ce
    },
    coerce: sX,
    any: RY,
    array: $Y,
    bigint: kY,
    boolean: J3,
    date: CY,
    discriminatedUnion: HY,
    effect: CO,
    enum: XY,
    function: KY,
    instanceof: PY,
    intersection: VY,
    lazy: QY,
    literal: YY,
    map: GY,
    nan: OY,
    nativeEnum: ZY,
    never: BY,
    null: NY,
    nullable: tX,
    number: Z3,
    object: LY,
    oboolean: aX,
    onumber: oX,
    optional: eX,
    ostring: iX,
    pipeline: rX,
    preprocess: nX,
    promise: JY,
    record: WY,
    set: qY,
    strictObject: FY,
    string: X3,
    symbol: IY,
    transformer: CO,
    tuple: zY,
    undefined: MY,
    union: UY,
    unknown: jY,
    void: DY,
    NEVER: uX,
    ZodIssueCode: q,
    quotelessJson: fY,
    ZodError: jr
});
const lX = e => e.message ? e.message : "unspecified error";
class tl extends fe {
    constructor(t) {
        super(), this.code = jK, this.errors = t, super.message = `Web3 validator found ${t.length} error[s]:
${this._compileErrors().join(`
`)}`
    }
    _compileErrors() {
        return this.errors.map(lX)
    }
}
const cX = ["bool", "int", "uint", "bytes", "string", "address", "tuple"],
    eD = e => typeof e == "object" && "type" in e && "name" in e,
    IS = e => typeof e == "string",
    Re = e => typeof e == "string" && /^((-)?0x[0-9a-f]+|(0x))$/i.test(e);

function tD(e, t) {
    return !(typeof e != "string" || !e.match(/^0x[0-9A-Fa-f]*$/))
}
const ig = e => typeof e == "number" || typeof e == "bigint" || typeof e == "string" && /^((-0x|0x|-)?[0-9a-f]+|(0x))$/i.test(e);

function MS(e) {
    if (typeof e != "string") throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof e}`);
    return e.startsWith("0x")
}
const NS = function(e) {
        for (const [t, n] of Object.entries(e))
            if (n !== void 0 && n.length > 0 && n[0] === 0) throw new Error(`${t} cannot have leading zeroes, received: ${n.toString()}`)
    },
    fX = ["hex", "number", "blockNumber", "blockNumberOrTag", "filter", "bloom"],
    Bs = e => {
        let t = e.replace(/ /, ""),
            n, r = !1,
            i = [];
        if (e.includes("[") && (t = t.slice(0, t.indexOf("[")), i = [...e.matchAll(/(?:\[(\d*)\])/g)].map(o => parseInt(o[1], 10)).map(o => Number.isNaN(o) ? -1 : o), r = i.length > 0), cX.includes(t)) return {
            baseType: t,
            isArray: r,
            baseTypeSize: n,
            arraySizes: i
        };
        if (t.startsWith("int")) n = parseInt(t.substring(3), 10), t = "int";
        else if (t.startsWith("uint")) n = parseInt(e.substring(4), 10), t = "uint";
        else if (t.startsWith("bytes")) n = parseInt(t.substring(5), 10), t = "bytes";
        else return {
            baseType: void 0,
            isArray: !1,
            baseTypeSize: void 0,
            arraySizes: i
        };
        return {
            baseType: t,
            isArray: r,
            baseTypeSize: n,
            arraySizes: i
        }
    },
    fb = (e, t = {}) => {
        if (Object.keys(t).includes("type")) throw new tl([{
            keyword: "eth",
            message: 'Either "eth" or "type" can be presented in schema',
            params: {
                eth: e
            },
            instancePath: "",
            schemaPath: ""
        }]);
        const {
            baseType: r,
            baseTypeSize: i
        } = Bs(e);
        if (!r && !fX.includes(e)) throw new tl([{
            keyword: "eth",
            message: `Eth data type "${e}" is not valid`,
            params: {
                eth: e
            },
            instancePath: "",
            schemaPath: ""
        }]);
        if (r) {
            if (r === "tuple") throw new Error('"tuple" type is not implemented directly.');
            return {
                format: `${r}${i??""}`,
                required: !0
            }
        }
        return e ? {
            format: e,
            required: !0
        } : {}
    },
    og = (e, t = "/0") => {
        const n = {
            type: "array",
            items: [],
            maxItems: e.length,
            minItems: e.length
        };
        for (const [r, i] of e.entries()) {
            let o, a, s = [];
            eD(i) ? (o = i.type, a = i.name || `${t}/${r}`, s = i.components) : typeof i == "string" ? (o = i, a = `${t}/${r}`) : Array.isArray(i) && (i[0] && typeof i[0] == "string" && i[0].startsWith("tuple") && !Array.isArray(i[0]) && i[1] && Array.isArray(i[1]) ? (o = i[0], a = `${t}/${r}`, s = i[1]) : (o = "tuple", a = `${t}/${r}`, s = i));
            const {
                baseType: u,
                isArray: l,
                arraySizes: c
            } = Bs(o);
            let f, d = n;
            for (let h = c.length - 1; h > 0; h -= 1) f = {
                type: "array",
                $id: a,
                items: [],
                maxItems: c[h],
                minItems: c[h]
            }, c[h] < 0 && (delete f.maxItems, delete f.minItems), Array.isArray(d.items) ? d.items.length === 0 ? d.items = [f] : d.items.push(f) : d.items = [d.items, f], d = f;
            if (u === "tuple" && !l) {
                const h = og(s, a);
                h.$id = a, d.items.push(h)
            } else if (u === "tuple" && l) {
                const h = c[0],
                    m = Object.assign({
                        type: "array",
                        $id: a,
                        items: og(s, a)
                    }, h >= 0 && {
                        minItems: h,
                        maxItems: h
                    });
                d.items.push(m)
            } else if (l) {
                const h = c[0],
                    m = Object.assign({
                        type: "array",
                        $id: a,
                        items: fb(o)
                    }, h >= 0 && {
                        minItems: h,
                        maxItems: h
                    });
                d.items.push(m)
            } else Array.isArray(d.items) ? d.items.push(Object.assign({
                $id: a
            }, fb(o))) : d.items.push(Object.assign({
                $id: a
            }, fb(o)));
            d = n
        }
        return n
    },
    RS = e => og(e),
    jS = (e, t) => t === 1 ? e : jS(e[0], t - 1),
    ff = (e, t, n) => {
        const r = [];
        for (const [i, o] of e.entries()) {
            let a, s, u = [];
            eD(o) ? (a = o.type, s = o.name, u = o.components) : typeof o == "string" ? a = o : Array.isArray(o) && (o[1] && Array.isArray(o[1]) ? (a = o[0], u = o[1]) : (a = "tuple", u = o));
            const {
                baseType: l,
                isArray: c,
                arraySizes: f
            } = Bs(a), d = Array.isArray(t) ? t[i] : t[s];
            if (l === "tuple" && !c) r.push(ff(u, d, n));
            else if (l === "tuple" && c) {
                const h = [];
                for (const m of d)
                    if (f.length > 1) {
                        const p = jS(m, f.length - 1),
                            y = [];
                        for (const g of p) y.push(ff(u, g, n));
                        h.push(y)
                    } else h.push(ff(u, m, n));
                r.push(h)
            } else r.push(d)
        }
        return n = n ? ? [], n.push(...r), n
    },
    nD = e => {
        if (e >= 48 && e <= 57) return e - 48;
        if (e >= 65 && e <= 70) return e - 55;
        if (e >= 97 && e <= 102) return e - 87;
        throw new Error(`Invalid code point: ${e}`)
    },
    ov = e => {
        if (!Re(e)) throw new Error("Invalid hex string");
        const [t, n] = e.startsWith("-") ? [!0, e.slice(1)] : [!1, e], r = BigInt(n);
        return r > Number.MAX_SAFE_INTEGER ? t ? -r : r : r < Number.MIN_SAFE_INTEGER ? r : t ? -1 * Number(r) : Number(r)
    },
    av = e => {
        if ((typeof e == "number" || typeof e == "bigint") && e < 0) return `-0x${e.toString(16).slice(1)}`;
        if ((typeof e == "number" || typeof e == "bigint") && e >= 0) return `0x${e.toString(16)}`;
        if (typeof e == "string" && Re(e)) {
            const [t, n] = e.startsWith("-") ? [!0, e.slice(1)] : [!1, e], r = n.split(/^(-)?0(x|X)/).slice(-1)[0];
            return `${t?"-":""}0x${r.replace(/^0+/,"").toLowerCase()}`
        }
        if (typeof e == "string" && !Re(e)) return av(BigInt(e));
        throw new SS(e)
    },
    ag = (e, t, n = "0") => {
        if (typeof e == "string" && !Re(e)) return e.padStart(t, n);
        const r = typeof e == "string" && Re(e) ? e : av(e),
            [i, o] = r.startsWith("-") ? ["-0x", r.slice(3)] : ["0x", r.slice(2)];
        return `${i}${o.padStart(t,n)}`
    };

function ho(e) {
    let t = "0x";
    for (const n of e) {
        const r = n.toString(16);
        t += r.length === 1 ? `0${r}` : r
    }
    return t
}
const Ei = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};

function IO(e) {
    if (e >= Ei.zero && e <= Ei.nine) return e - Ei.zero;
    if (e >= Ei.A && e <= Ei.F) return e - (Ei.A - 10);
    if (e >= Ei.a && e <= Ei.f) return e - (Ei.a - 10)
}

function Ds(e) {
    let t = 0;
    if (e.startsWith("0") && (e[1] === "x" || e[1] === "X") && (t = 2), e.length % 2 !== 0) throw new Nu(`hex string has odd length: ${e}`);
    const n = (e.length - t) / 2,
        r = new Uint8Array(n);
    for (let i = 0, o = t; i < n; i += 1) {
        const a = IO(e.charCodeAt(o++)),
            s = IO(e.charCodeAt(o++));
        if (a === void 0 || s === void 0) throw new Nu(`Invalid byte sequence ("${e[o-2]}${e[o-1]}" in "${e}").`);
        r[i] = a * 16 + s
    }
    return r
}

function sv(e) {
    var t;
    return !(e instanceof Uint8Array) && ((t = e == null ? void 0 : e.constructor) === null || t === void 0 ? void 0 : t.name) === "Uint8Array" ? Uint8Array.from(e) : e
}
const rD = Object.freeze(Object.defineProperty({
        __proto__: null,
        abiSchemaToJsonSchema: og,
        codePointToInt: nD,
        ensureIfUint8Array: sv,
        ethAbiToJsonSchema: RS,
        fetchArrayElement: jS,
        hexToNumber: ov,
        hexToUint8Array: Ds,
        numberToHex: av,
        padLeft: ag,
        parseBaseType: Bs,
        transformJsonDataToAbiFormat: ff,
        uint8ArrayToHexString: ho
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    kx = e => {
        var t, n;
        return e instanceof Uint8Array || ((t = e == null ? void 0 : e.constructor) === null || t === void 0 ? void 0 : t.name) === "Uint8Array" || ((n = e == null ? void 0 : e.constructor) === null || n === void 0 ? void 0 : n.name) === "Buffer"
    },
    pa = (e, t = {
        abiType: "bytes"
    }) => {
        if (typeof e != "string" && !Array.isArray(e) && !kx(e) || typeof e == "string" && Re(e) && e.startsWith("-") || typeof e == "string" && !Re(e)) return !1;
        let n;
        if (typeof e == "string") {
            if (e.length % 2 !== 0) return !1;
            n = Ds(e)
        } else if (Array.isArray(e)) {
            if (e.some(r => r < 0 || r > 255 || !Number.isInteger(r))) return !1;
            n = new Uint8Array(e)
        } else n = e;
        if (t != null && t.abiType) {
            const {
                baseTypeSize: r
            } = Bs(t.abiType);
            return r ? n.length === r : !0
        }
        return t != null && t.size ? n.length === (t == null ? void 0 : t.size) : !0
    },
    iD = e => {
        if (!/^(0x)?[0-9a-f]{40}$/i.test(e)) return !1;
        const t = e.slice(2),
            n = Xu(t.toLowerCase()),
            r = ho(dn(sv(n))).slice(2);
        for (let i = 0; i < 40; i += 1)
            if (parseInt(r[i], 16) > 7 && t[i].toUpperCase() !== t[i] || parseInt(r[i], 16) <= 7 && t[i].toLowerCase() !== t[i]) return !1;
        return !0
    },
    zn = (e, t = !0) => {
        if (typeof e != "string" && !kx(e)) return !1;
        let n;
        return kx(e) ? n = ho(e) : typeof e == "string" && !Re(e) ? n = e.toLowerCase().startsWith("0x") ? e : `0x${e}` : n = e, /^(0x)?[0-9a-f]{40}$/i.test(n) ? /^(0x|0X)?[0-9a-f]{40}$/.test(n) || /^(0x|0X)?[0-9A-F]{40}$/.test(n) ? !0 : t ? iD(n) : !0 : !1
    },
    As = (e, t) => {
        if (t === BigInt(0)) return BigInt(1);
        let n = e;
        for (let r = 1; r < t; r += 1) n *= e;
        return n
    },
    no = (e, t = {
        abiType: "uint"
    }) => {
        if (!["number", "string", "bigint"].includes(typeof e) || typeof e == "string" && e.length === 0) return !1;
        let n;
        if (t != null && t.abiType) {
            const {
                baseTypeSize: i
            } = Bs(t.abiType);
            i && (n = i)
        } else t.bitSize && (n = t.bitSize);
        const r = As(BigInt(2), BigInt(n ? ? 256)) - BigInt(1);
        try {
            const i = typeof e == "string" && Re(e) ? BigInt(ov(e)) : BigInt(e);
            return i >= 0 && i <= r
        } catch {
            return !1
        }
    },
    od = (e, t = {
        abiType: "int"
    }) => {
        if (!["number", "string", "bigint"].includes(typeof e) || typeof e == "number" && e > Number.MAX_SAFE_INTEGER) return !1;
        let n;
        if (t != null && t.abiType) {
            const {
                baseTypeSize: o,
                baseType: a
            } = Bs(t.abiType);
            if (a !== "int") return !1;
            o && (n = o)
        } else t.bitSize && (n = t.bitSize);
        const r = As(BigInt(2), BigInt((n ? ? 256) - 1)),
            i = BigInt(-1) * As(BigInt(2), BigInt((n ? ? 256) - 1));
        try {
            const o = typeof e == "string" && Re(e) ? BigInt(ov(e)) : BigInt(e);
            return o >= i && o <= r
        } catch {
            return !1
        }
    },
    oD = e => !!(od(e) || typeof e == "string" && /[0-9.]/.test(e) && e.indexOf(".") === e.lastIndexOf(".") || typeof e == "number"),
    aD = e => no(e),
    Ut = e => Object.values(Mi).includes(e),
    Cx = e => Ut(e) || aD(e),
    zl = e => typeof e != "string" || !/^(0x)?[0-9a-f]{512}$/i.test(e) ? !1 : !!(/^(0x)?[0-9a-f]{512}$/.test(e) || /^(0x)?[0-9A-F]{512}$/.test(e)),
    uv = (e, t) => {
        if (typeof t == "string" && !Re(t) || !zl(e)) return !1;
        const n = typeof t == "string" ? Ds(t) : t,
            r = ho(dn(n)).slice(2);
        for (let i = 0; i < 12; i += 4) {
            const o = (parseInt(r.slice(i, i + 2), 16) << 8) + parseInt(r.slice(i + 2, i + 4), 16) & 2047,
                a = nD(e.charCodeAt(e.length - 1 - Math.floor(o / 4))),
                s = 1 << o % 4;
            if ((a & s) !== s) return !1
        }
        return !0
    },
    dX = (e, t) => {
        if (!zl(e) || !zn(t)) return !1;
        const n = ag(t, 64);
        return uv(e, n)
    },
    hX = (e, t) => !zl(e) || !zn(t) ? !1 : uv(e, t),
    pX = e => ["number", "string", "boolean"].includes(typeof e) ? typeof e == "boolean" ? !0 : typeof e == "string" && !Re(e) ? e === "1" || e === "0" : typeof e == "string" && Re(e) ? e === "0x1" || e === "0x0" : e === 1 || e === 0 : !1,
    F = e => e == null,
    nl = e => typeof e == "object" && !F(e) && !Array.isArray(e) && !(e instanceof AS),
    sg = e => typeof e != "string" || !/^(0x)?[0-9a-f]{64}$/i.test(e) ? !1 : !!(/^(0x)?[0-9a-f]{64}$/.test(e) || /^(0x)?[0-9A-F]{64}$/.test(e)),
    mX = (e, t) => !zl(e) || !sg(t) ? !1 : uv(e, t),
    gX = e => {
        const t = ["fromBlock", "toBlock", "address", "topics", "blockHash"];
        if (F(e) || typeof e != "object" || !Object.keys(e).every(n => t.includes(n)) || !F(e.fromBlock) && !Cx(e.fromBlock) || !F(e.toBlock) && !Cx(e.toBlock)) return !1;
        if (!F(e.address)) {
            if (Array.isArray(e.address)) {
                if (!e.address.every(n => zn(n))) return !1
            } else if (!zn(e.address)) return !1
        }
        return !(!F(e.topics) && !e.topics.every(n => F(n) ? !0 : Array.isArray(n) ? n.every(r => sg(r)) : !!sg(n)))
    },
    Es = {
        address: e => zn(e),
        bloom: e => zl(e),
        blockNumber: e => aD(e),
        blockTag: e => Ut(e),
        blockNumberOrTag: e => Cx(e),
        bool: e => pX(e),
        bytes: e => pa(e),
        filter: e => gX(e),
        hex: e => Re(e),
        uint: e => no(e),
        int: e => od(e),
        number: e => oD(e),
        string: e => IS(e)
    };
for (let e = 8; e <= 256; e += 8) Es[`int${e}`] = t => od(t, {
    bitSize: e
}), Es[`uint${e}`] = t => no(t, {
    bitSize: e
});
for (let e = 1; e <= 32; e += 1) Es[`bytes${e}`] = t => pa(t, {
    size: e
});
Es.bytes256 = Es.bytes;
const Wc = e => {
    if ((!(e != null && e.type) || (e == null ? void 0 : e.type) === "object") && (e != null && e.properties)) {
        const t = {};
        for (const n of Object.keys(e.properties)) {
            const r = Wc(e.properties[n]);
            r && (t[n] = r)
        }
        return Array.isArray(e.required) ? zr.object(t).partial().required(e.required.reduce((n, r) => Object.assign(Object.assign({}, n), {
            [r]: !0
        }), {})) : zr.object(t).partial()
    }
    if ((e == null ? void 0 : e.type) === "array" && (e != null && e.items)) {
        if (Array.isArray(e.items) && e.items.length > 1 && e.maxItems !== void 0 && new Set(e.items.map(r => r.$id)).size === e.items.length) {
            const r = [];
            for (const i of e.items) {
                const o = Wc(i);
                o && r.push(o)
            }
            return zr.tuple(r)
        }
        const t = Array.isArray(e.items) ? e.items[0] : e.items;
        let n = zr.array(Wc(t));
        return n = e.minItems !== void 0 ? n.min(e.minItems) : n, n = e.maxItems !== void 0 ? n.max(e.maxItems) : n, n
    }
    if (e.oneOf && Array.isArray(e.oneOf)) return zr.union(e.oneOf.map(t => Wc(t)));
    if (e != null && e.format) {
        if (!Es[e.format]) throw new VQ(e.format);
        return zr.any().refine(Es[e.format], t => ({
            params: {
                value: t,
                format: e.format
            }
        }))
    }
    return e != null && e.type && (e == null ? void 0 : e.type) !== "object" && typeof zr[String(e.type)] == "function" ? zr[String(e.type)]() : zr.object({
        data: zr.any()
    }).partial()
};
class Au {
    static factory() {
        return Au.validatorInstance || (Au.validatorInstance = new Au), Au.validatorInstance
    }
    validate(t, n, r) {
        var i, o;
        const s = Wc(t).safeParse(n);
        if (!s.success) {
            const u = this.convertErrors((o = (i = s.error) === null || i === void 0 ? void 0 : i.issues) !== null && o !== void 0 ? o : []);
            if (u) {
                if (r != null && r.silent) return u;
                throw new tl(u)
            }
        }
    }
    convertErrors(t) {
        if (t && Array.isArray(t) && t.length > 0) return t.map(n => {
            var r;
            let i, o, a, s;
            s = n.path.join("/");
            const u = String(n.path[n.path.length - 1]),
                l = n.path.join("/");
            if (n.code === q.too_big) o = "maxItems", s = `${l}/maxItems`, a = {
                limit: n.maximum
            }, i = `must NOT have more than ${n.maximum} items`;
            else if (n.code === q.too_small) o = "minItems", s = `${l}/minItems`, a = {
                limit: n.minimum
            }, i = `must NOT have fewer than ${n.minimum} items`;
            else if (n.code === q.custom) {
                const {
                    value: c,
                    format: f
                } = (r = n.params) !== null && r !== void 0 ? r : {};
                typeof c > "u" ? i = `value at "/${s}" is required` : i = `value "${typeof c=="object"?JSON.stringify(c):c}" at "/${s}" must pass "${f}" validation`, a = {
                    value: c
                }
            }
            return {
                keyword: o ? ? u,
                instancePath: l ? `/${l}` : "",
                schemaPath: s ? `#${s}` : "#",
                params: a ? ? {
                    value: n.message
                },
                message: i ? ? n.message
            }
        })
    }
}
class yX {
    constructor() {
        this._validator = Au.factory()
    }
    validateJSONSchema(t, n, r) {
        return this._validator.validate(t, n, r)
    }
    validate(t, n, r = {
        silent: !1
    }) {
        var i, o;
        const a = RS(t);
        if (!(Array.isArray(a.items) && ((i = a.items) === null || i === void 0 ? void 0 : i.length) === 0 && n.length === 0)) {
            if (Array.isArray(a.items) && ((o = a.items) === null || o === void 0 ? void 0 : o.length) === 0 && n.length !== 0) throw new tl([{
                instancePath: "/0",
                schemaPath: "/",
                keyword: "required",
                message: "empty schema against data can not be validated",
                params: n
            }]);
            return this._validator.validate(a, n, r)
        }
    }
}
const oe = new yX;

function ma(e) {
    var t, n;
    return e instanceof Uint8Array || ((t = e == null ? void 0 : e.constructor) === null || t === void 0 ? void 0 : t.name) === "Uint8Array" || ((n = e == null ? void 0 : e.constructor) === null || n === void 0 ? void 0 : n.name) === "Buffer"
}

function bn(...e) {
    const t = e.reduce((i, o) => i + o.length, 0),
        n = new Uint8Array(t);
    let r = 0;
    for (const i of e) n.set(i, r), r += i.length;
    return n
}

function lv(e, t) {
    if (e === t) return !0;
    if (e.byteLength !== t.byteLength) return !1;
    for (let n = 0; n < e.byteLength; n += 1)
        if (e[n] !== t[n]) return !1;
    return !0
}
const cv = {
        noether: BigInt(0),
        wei: BigInt(1),
        kwei: BigInt(1e3),
        Kwei: BigInt(1e3),
        babbage: BigInt(1e3),
        femtoether: BigInt(1e3),
        mwei: BigInt(1e6),
        Mwei: BigInt(1e6),
        lovelace: BigInt(1e6),
        picoether: BigInt(1e6),
        gwei: BigInt(1e9),
        Gwei: BigInt(1e9),
        shannon: BigInt(1e9),
        nanoether: BigInt(1e9),
        nano: BigInt(1e9),
        szabo: BigInt(1e12),
        microether: BigInt(1e12),
        micro: BigInt(1e12),
        finney: BigInt(1e15),
        milliether: BigInt(1e15),
        milli: BigInt(1e15),
        ether: BigInt("1000000000000000000"),
        kether: BigInt("1000000000000000000000"),
        grand: BigInt("1000000000000000000000"),
        mether: BigInt("1000000000000000000000000"),
        gether: BigInt("1000000000000000000000000000"),
        tether: BigInt("1000000000000000000000000000000")
    },
    Ix = "Warning: Using type `number` with values that are large or contain many decimals may cause loss of precision, it is recommended to use type `string` or `BigInt` when using conversion methods",
    mi = e => {
        if (oe.validate(["bytes"], [e]), ma(e)) return e;
        if (Array.isArray(e)) return new Uint8Array(e);
        if (typeof e == "string") return Ds(e);
        throw new Nu(e)
    },
    {
        uint8ArrayToHexString: vX
    } = rD,
    Ee = e => vX(mi(e)),
    Ke = e => typeof e == "string" && e.slice(0, 2).toLowerCase() !== "0x" ? mi(`0x${e}`) : mi(e),
    gh = e => (oe.validate(["hex"], [e]), ov(e)),
    bX = gh,
    Nt = (e, t) => {
        typeof e != "bigint" && oe.validate(["int"], [e]);
        let n = av(e);
        return t && (!n.startsWith("-") && n.length % 2 === 1 ? n = "0x0".concat(n.slice(2)) : n.length % 2 === 0 && n.startsWith("-") && (n = "-0x0".concat(n.slice(3)))), n
    },
    wX = Nt,
    xX = e => gh(e).toString(),
    Fr = e => {
        oe.validate(["string"], [e]);
        let t = e.replace(/^(?:\u0000)/, "");
        return t = t.replace(/(?:\u0000)$/, ""), Ee(new TextEncoder().encode(t))
    },
    sD = Fr,
    AX = Fr,
    fv = e => W3(Ke(e)),
    EX = e => typeof e == "string" ? fv(e) : (oe.validate(["bytes"], [e]), W3(e)),
    BS = Xu,
    SX = fv,
    uD = e => {
        oe.validate(["string"], [e]);
        let t = "";
        for (let n = 0; n < e.length; n += 1) {
            const r = e.charCodeAt(n).toString(16);
            t += r.length % 2 !== 0 ? `0${r}` : r
        }
        return `0x${t}`
    },
    _X = uD,
    lD = e => new TextDecoder("ascii").decode(Ke(e)),
    TX = lD,
    ro = (e, t) => {
        if (typeof e == "string" && zn(e)) return t ? "address" : `0x${e.toLowerCase().replace(/^0x/i,"")}`;
        if (typeof e == "boolean") return t ? "bool" : e ? "0x01" : "0x00";
        if (typeof e == "number") return t ? e < 0 ? "int256" : "uint256" : Nt(e);
        if (typeof e == "bigint") return t ? "bigint" : Nt(e);
        if (ma(e)) return t ? "bytes" : Ee(e);
        if (typeof e == "object" && e) return t ? "string" : Fr(JSON.stringify(e));
        if (typeof e == "string") {
            if (e.startsWith("-0x") || e.startsWith("-0X")) return t ? "int256" : Nt(e);
            if (Re(e)) return t ? "bytes" : e;
            if (ig(e) && !od(e) && !no(e)) return t ? "bytes" : `0x${e}`;
            if (ig(e) && !od(e) && no(e)) return t ? "uint" : Nt(e);
            if (!Number.isFinite(e)) return t ? "string" : Fr(e)
        }
        throw new TQ(e)
    },
    On = e => {
        if (typeof e == "number") return e > 1e20 ? (console.warn(Ix), BigInt(e)) : e;
        if (typeof e == "bigint") return e >= Number.MIN_SAFE_INTEGER && e <= Number.MAX_SAFE_INTEGER ? Number(e) : e;
        if (typeof e == "string" && Re(e)) return gh(e);
        try {
            return On(BigInt(e))
        } catch {
            throw new SS(e)
        }
    },
    Ua = e => {
        if (typeof e == "number") return BigInt(e);
        if (typeof e == "bigint") return e;
        if (typeof e == "string" && ig(e)) return e.startsWith("-") ? -BigInt(e.substring(1)) : BigInt(e);
        throw new SS(e)
    },
    PX = (e, t) => {
        let n;
        if (typeof t == "string") {
            if (n = cv[t], !n) throw new R3(t)
        } else {
            if (t < 0 || !Number.isInteger(t)) throw new j3(t);
            n = As(BigInt(10), BigInt(t))
        }
        const r = String(On(e)),
            i = n.toString().length - 1;
        if (i <= 0) return r.toString();
        const o = r.padStart(i, "0"),
            a = o.slice(0, -i),
            s = o.slice(-i).replace(/\.?0+$/, "");
        return a === "" ? s ? `0.${s}` : "0" : s === "" ? a : `${a}.${s}`.slice(0, a.length + i + 1)
    },
    OX = (e, t) => {
        oe.validate(["number"], [e]);
        let n;
        if (typeof t == "string") {
            if (n = cv[t], !n) throw new R3(t)
        } else {
            if (t < 0 || !Number.isInteger(t)) throw new j3(t);
            n = As(BigInt(10), BigInt(t))
        }
        let r = e;
        typeof r == "number" && (r < 1e-15 && console.warn(Ix), r > 1e20 ? (console.warn(Ix), r = BigInt(r)) : r = r.toLocaleString("fullwide", {
            useGrouping: !1,
            maximumFractionDigits: 20
        }));
        const [i, o] = String(typeof r == "string" && !Re(r) ? r : On(r)).split(".").concat(""), s = BigInt(`${i}${o}`) * n, u = o.length;
        return u === 0 ? s.toString() : s.toString().slice(0, -u)
    },
    vi = e => {
        if (!zn(e, !1)) throw new _S(e);
        const t = e.toLowerCase().replace(/^0x/i, ""),
            n = ho(dn(sv(BS(t))));
        if (F(n) || n === "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470") return "";
        let r = "0x";
        const i = n.replace(/^0x/i, "");
        for (let o = 0; o < t.length; o += 1) parseInt(i[o], 16) > 7 ? r += t[o].toUpperCase() : r += t[o];
        return r
    },
    cD = e => {
        if (typeof e == "boolean") return e;
        if (typeof e == "number" && (e === 0 || e === 1) || typeof e == "bigint" && (e === BigInt(0) || e === BigInt(1))) return !!e;
        if (typeof e == "string" && !Re(e) && (e === "1" || e === "0" || e === "false" || e === "true")) return e === "true" ? !0 : e === "false" ? !1 : !!Number(e);
        if (typeof e == "string" && Re(e) && (e === "0x1" || e === "0x0")) return !!On(e);
        throw new TS(e)
    };
var fD = {
    exports: {}
};
(function(e) {
    var t = Object.prototype.hasOwnProperty,
        n = "~";

    function r() {}
    Object.create && (r.prototype = Object.create(null), new r().__proto__ || (n = !1));

    function i(u, l, c) {
        this.fn = u, this.context = l, this.once = c || !1
    }

    function o(u, l, c, f, d) {
        if (typeof c != "function") throw new TypeError("The listener must be a function");
        var h = new i(c, f || u, d),
            m = n ? n + l : l;
        return u._events[m] ? u._events[m].fn ? u._events[m] = [u._events[m], h] : u._events[m].push(h) : (u._events[m] = h, u._eventsCount++), u
    }

    function a(u, l) {
        --u._eventsCount === 0 ? u._events = new r : delete u._events[l]
    }

    function s() {
        this._events = new r, this._eventsCount = 0
    }
    s.prototype.eventNames = function() {
        var l = [],
            c, f;
        if (this._eventsCount === 0) return l;
        for (f in c = this._events) t.call(c, f) && l.push(n ? f.slice(1) : f);
        return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(c)) : l
    }, s.prototype.listeners = function(l) {
        var c = n ? n + l : l,
            f = this._events[c];
        if (!f) return [];
        if (f.fn) return [f.fn];
        for (var d = 0, h = f.length, m = new Array(h); d < h; d++) m[d] = f[d].fn;
        return m
    }, s.prototype.listenerCount = function(l) {
        var c = n ? n + l : l,
            f = this._events[c];
        return f ? f.fn ? 1 : f.length : 0
    }, s.prototype.emit = function(l, c, f, d, h, m) {
        var p = n ? n + l : l;
        if (!this._events[p]) return !1;
        var y = this._events[p],
            g = arguments.length,
            b, v;
        if (y.fn) {
            switch (y.once && this.removeListener(l, y.fn, void 0, !0), g) {
                case 1:
                    return y.fn.call(y.context), !0;
                case 2:
                    return y.fn.call(y.context, c), !0;
                case 3:
                    return y.fn.call(y.context, c, f), !0;
                case 4:
                    return y.fn.call(y.context, c, f, d), !0;
                case 5:
                    return y.fn.call(y.context, c, f, d, h), !0;
                case 6:
                    return y.fn.call(y.context, c, f, d, h, m), !0
            }
            for (v = 1, b = new Array(g - 1); v < g; v++) b[v - 1] = arguments[v];
            y.fn.apply(y.context, b)
        } else {
            var A = y.length,
                w;
            for (v = 0; v < A; v++) switch (y[v].once && this.removeListener(l, y[v].fn, void 0, !0), g) {
                case 1:
                    y[v].fn.call(y[v].context);
                    break;
                case 2:
                    y[v].fn.call(y[v].context, c);
                    break;
                case 3:
                    y[v].fn.call(y[v].context, c, f);
                    break;
                case 4:
                    y[v].fn.call(y[v].context, c, f, d);
                    break;
                default:
                    if (!b)
                        for (w = 1, b = new Array(g - 1); w < g; w++) b[w - 1] = arguments[w];
                    y[v].fn.apply(y[v].context, b)
            }
        }
        return !0
    }, s.prototype.on = function(l, c, f) {
        return o(this, l, c, f, !1)
    }, s.prototype.once = function(l, c, f) {
        return o(this, l, c, f, !0)
    }, s.prototype.removeListener = function(l, c, f, d) {
        var h = n ? n + l : l;
        if (!this._events[h]) return this;
        if (!c) return a(this, h), this;
        var m = this._events[h];
        if (m.fn) m.fn === c && (!d || m.once) && (!f || m.context === f) && a(this, h);
        else {
            for (var p = 0, y = [], g = m.length; p < g; p++)(m[p].fn !== c || d && !m[p].once || f && m[p].context !== f) && y.push(m[p]);
            y.length ? this._events[h] = y.length === 1 ? y[0] : y : a(this, h)
        }
        return this
    }, s.prototype.removeAllListeners = function(l) {
        var c;
        return l ? (c = n ? n + l : l, this._events[c] && a(this, c)) : (this._events = new r, this._eventsCount = 0), this
    }, s.prototype.off = s.prototype.removeListener, s.prototype.addListener = s.prototype.on, s.prefixed = n, s.EventEmitter = s, e.exports = s
})(fD);
var kX = fD.exports;
const dD = Fe(kX);
let DS = class extends dD {
    constructor() {
        super(...arguments), this.maxListeners = Number.MAX_SAFE_INTEGER
    }
    setMaxListeners(t) {
        return this.maxListeners = t, this
    }
    getMaxListeners() {
        return this.maxListeners
    }
};
const CX = Re,
    IX = ig,
    MX = iD,
    NX = zn,
    RX = zl,
    jX = uv,
    BX = dX,
    DX = hX,
    $X = sg,
    LX = mX,
    FX = (e, t) => {
        const n = typeof e == "string" && Ut(e),
            r = typeof t == "string" && Ut(t);
        if (e === t || (e === "earliest" || e === 0) && (t === "earliest" || t === 0)) return 0;
        if (e === "earliest") return -1;
        if (t === "earliest") return 1;
        if (n && r) {
            const a = {
                [Mi.EARLIEST]: 1,
                [Mi.FINALIZED]: 2,
                [Mi.SAFE]: 3,
                [Mi.LATEST]: 4,
                [Mi.PENDING]: 5
            };
            return a[e] < a[t] ? -1 : 1
        }
        if (n && !r || !n && r) throw new OQ("Cannot compare blocktag with provided non-blocktag input.");
        const i = BigInt(e),
            o = BigInt(t);
        return i < o ? -1 : i === o ? 0 : 1
    },
    $o = e => typeof e == "object" && !F(e) && Object.keys(e).length !== 0 && ["input", "data", "from", "gas", "gasPrice", "gasLimit", "address", "jsonInterface", "syncWithContext", "dataInputFill"].some(t => t in e),
    le = F,
    MO = e => typeof e == "object" && !F(e) && !Array.isArray(e) && !(e instanceof AS),
    ga = (e, ...t) => {
        if (!MO(e)) return e;
        const n = Object.assign({}, e);
        for (const r of t)
            for (const i in r) MO(r[i]) ? (n[i] || (n[i] = {}), n[i] = ga(n[i], r[i])) : !F(r[i]) && Object.hasOwnProperty.call(r, i) && (Array.isArray(r[i]) || r[i] instanceof AS ? n[i] = r[i].slice(0) : n[i] = r[i]);
        return n
    },
    rl = (e, t, n = "0") => typeof e == "string" ? Re(e) ? ag(e, t, n) : e.padStart(t, n) : (oe.validate(["int"], [e]), ag(e, t, n)),
    hD = (e, t, n = "0") => {
        if (typeof e == "string" && !Re(e)) return e.padEnd(t, n);
        const r = typeof e == "string" && Re(e) ? e : Nt(e),
            i = r.startsWith("-") ? 3 : 2;
        return oe.validate([r.startsWith("-") ? "int" : "uint"], [e]), r.padEnd(t + i, n)
    },
    pD = hD,
    ad = rl,
    mD = (e, t = 64) => {
        oe.validate(["int"], [e]);
        const n = On(e);
        if (n >= 0) return rl(ro(n), t);
        const r = As(BigInt(2), BigInt(t * 4));
        if (-n >= r) throw new B3(`value: ${e}, nibbleWidth: ${t}`);
        const o = BigInt(n) + r;
        return rl(Nt(o), t)
    },
    UX = (e, t = 64) => {
        oe.validate(["int"], [e]);
        const n = On(e);
        if (n < 0) return n;
        const r = Math.ceil(Math.log(Number(n)) / Math.log(2));
        if (r > t * 4) throw new B3(`value: "${e}", nibbleWidth: "${t}"`);
        if (t * 4 !== r) return n;
        const i = As(BigInt(2), BigInt(t) * BigInt(4));
        return On(BigInt(n) - i)
    },
    {
        parseBaseType: HX
    } = rD,
    Ii = e => typeof e == "object" && !F(e) && "number" in e && "bytes" in e,
    VX = (e, t, n = []) => {
        let r = Object.assign({}, e),
            i;
        for (const o of t) {
            if (r.oneOf && i) {
                const a = i,
                    s = n.find(([u]) => u === a);
                s && s[0] === i && (r = r.oneOf[s[1]])
            }
            if (!r.properties && !r.items) return;
            r.properties ? r = r.properties[o] : r.items && r.items.properties ? r = r.items.properties[o] : r.items && nl(r.items) ? r = r.items : r.items && Array.isArray(r.items) && (r = r.items[parseInt(o, 10)]), r && o && (i = o)
        }
        return r
    },
    sd = (e, t, n) => {
        try {
            const {
                baseType: r,
                baseTypeSize: i
            } = HX(t);
            if (r === "int" || r === "uint") switch (n.number) {
                case ur.NUMBER:
                    return Number(Ua(e));
                case ur.HEX:
                    return Nt(Ua(e));
                case ur.STR:
                    return Ua(e).toString();
                case ur.BIGINT:
                    return Ua(e);
                default:
                    throw new Ax(`Invalid format: ${String(n.number)}`)
            }
            if (r === "bytes") {
                let o;
                switch (i ? typeof e == "string" ? o = rl(e, i * 2) : ma(e) && (o = bn(new Uint8Array(i - e.length), e)) : o = e, n.bytes) {
                    case eo.HEX:
                        return Ee(mi(o));
                    case eo.UINT8ARRAY:
                        return mi(o);
                    default:
                        throw new Ax(`Invalid format: ${String(n.bytes)}`)
                }
            }
            if (r === "string") return String(e)
        } catch {
            return e
        }
        return e
    },
    NO = ({
        value: e,
        schemaProp: t,
        schema: n,
        object: r,
        key: i,
        dataPath: o,
        format: a,
        oneOfPath: s = []
    }) => {
        var u, l;
        if (Array.isArray(e)) {
            let c = t;
            if ((t == null ? void 0 : t.oneOf) !== void 0 && t.oneOf.forEach((f, d) => {
                    var h, m;
                    !Array.isArray(t == null ? void 0 : t.items) && (typeof e[0] == "object" && ((h = f == null ? void 0 : f.items) === null || h === void 0 ? void 0 : h.type) === "object" || typeof e[0] == "string" && ((m = f == null ? void 0 : f.items) === null || m === void 0 ? void 0 : m.type) !== "object") && (c = f, s.push([i, d]))
                }), F(c == null ? void 0 : c.items)) return delete r[i], o.pop(), !0;
            if (nl(c.items) && !F(c.items.format)) {
                for (let f = 0; f < e.length; f += 1) r[i][f] = sd(e[f], (u = c == null ? void 0 : c.items) === null || u === void 0 ? void 0 : u.format, a);
                return o.pop(), !0
            }
            if (!Array.isArray(c == null ? void 0 : c.items) && ((l = c == null ? void 0 : c.items) === null || l === void 0 ? void 0 : l.type) === "object") {
                for (const f of e) dv(f, n, o, a, s);
                return o.pop(), !0
            }
            if (Array.isArray(c == null ? void 0 : c.items)) {
                for (let f = 0; f < e.length; f += 1) r[i][f] = sd(e[f], c.items[f].format, a);
                return o.pop(), !0
            }
        }
        return !1
    },
    dv = (e, t, n, r, i = []) => {
        var o;
        if (!nl(e) && !Array.isArray(e)) return sd(e, t == null ? void 0 : t.format, r);
        const a = e;
        if (Array.isArray(a) && (t == null ? void 0 : t.type) === "array" && ((o = t == null ? void 0 : t.items) === null || o === void 0 ? void 0 : o.type) === "object") NO({
            value: a,
            schemaProp: t,
            schema: t,
            object: a,
            key: "",
            dataPath: n,
            format: r,
            oneOfPath: i
        });
        else
            for (const [s, u] of Object.entries(a)) {
                n.push(s);
                let l = VX(t, n, i);
                if (F(l)) {
                    delete a[s], n.pop();
                    continue
                }
                if (nl(u)) {
                    dv(u, t, n, r, i), n.pop();
                    continue
                }
                if (!NO({
                        value: u,
                        schemaProp: l,
                        schema: t,
                        object: a,
                        key: s,
                        dataPath: n,
                        format: r,
                        oneOfPath: i
                    })) {
                    if ((l == null ? void 0 : l.format) === void 0 && (l == null ? void 0 : l.oneOf) !== void 0) {
                        for (const [c, f] of l.oneOf.entries())
                            if ((f == null ? void 0 : f.format) !== void 0) {
                                l = f;
                                break
                            }
                    }
                    a[s] = sd(u, l.format, r), n.pop()
                }
            }
        return a
    },
    W = (e, t, n = mn) => {
        let r;
        nl(t) ? r = ga({}, t) : Array.isArray(t) ? r = [...t] : r = t;
        const i = nl(e) ? e : RS(e);
        if (!i.properties && !i.items && !i.format) throw new Ax("Invalid json schema for formatting");
        return dv(r, i, [], n)
    },
    gD = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470",
    il = e => {
        let t;
        return typeof e == "bigint" || typeof e == "number" ? t = Xu(e.toString()) : Array.isArray(e) ? t = new Uint8Array(e) : typeof e == "string" && !Re(e) ? t = Xu(e) : t = mi(e), Ee(dn(sv(t)))
    },
    yh = e => {
        let t;
        typeof e == "string" ? e.startsWith("0x") && Re(e) ? t = Ke(e) : t = Xu(e) : t = e;
        const n = il(t);
        return n === gD ? void 0 : n
    },
    Wn = e => {
        const t = yh(e);
        return F(t) ? gD : t
    },
    zX = e => {
        if (Array.isArray(e)) throw new Error("Autodetection of array types is not supported.");
        let t, n;
        if (typeof e == "object" && ("t" in e || "type" in e) && ("v" in e || "value" in e)) t = "t" in e ? e.t : e.type, n = "v" in e ? e.v : e.value, t = t.toLowerCase() === "bigint" ? "int" : t;
        else {
            if (typeof e == "bigint") return ["int", e];
            t = ro(e, !0), n = ro(e), !t.startsWith("int") && !t.startsWith("uint") && (t = "bytes")
        }
        return (t.startsWith("int") || t.startsWith("uint")) && typeof n == "string" && !/^(-)?0x/i.test(n) && (n = Ua(n)), [t, n]
    },
    WX = e => e.startsWith("int[") ? `int256${e.slice(3)}` : e === "int" ? "int256" : e.startsWith("uint[") ? `uint256'${e.slice(4)}` : e === "uint" ? "uint256" : e,
    db = (e, t) => {
        const n = /^(\d+).*$/.exec(e.slice(t));
        return n ? parseInt(n[1], 10) : 0
    },
    RO = e => e.toString(2).length,
    jO = (e, t) => {
        const n = t.toString();
        if (e === "string") {
            if (typeof t == "string") return Fr(t);
            throw new _Q(t)
        }
        if (e === "bool" || e === "boolean") {
            if (typeof t == "boolean") return t ? "01" : "00";
            throw new TS(t)
        }
        if (e === "address") {
            if (!zn(n)) throw new _S(n);
            return n
        }
        const r = WX(e);
        if (e.startsWith("uint")) {
            const i = db(r, 4);
            if (i % 8 || i < 8 || i > 256) throw new bO(n);
            const o = On(n);
            if (RO(o) > i) throw new wO(n);
            if (o < BigInt(0)) throw new PQ(n);
            return i ? ad(o.toString(16), i / 8 * 2) : o.toString(16)
        }
        if (e.startsWith("int")) {
            const i = db(r, 3);
            if (i % 8 || i < 8 || i > 256) throw new bO(e);
            const o = On(n);
            if (RO(o) > i) throw new wO(n);
            return o < BigInt(0) ? mD(o.toString(), i / 8 * 2) : i ? ad(o.toString(16), i / 4) : o.toString(16)
        }
        if (r === "bytes") {
            if (n.replace(/^0x/i, "").length % 2 !== 0) throw new Nu(n);
            return n
        }
        if (e.startsWith("bytes")) {
            if (n.replace(/^0x/i, "").length % 2 !== 0) throw new Nu(n);
            const i = db(e, 5);
            if (!i || i < 1 || i > 64 || i < n.replace(/^0x/i, "").length / 2) throw new Nu(n);
            return pD(n, i * 2)
        }
        return ""
    },
    yD = e => {
        const [t, n] = zX(e);
        return Array.isArray(n) ? n.map(o => jO(t, o).replace("0x", "")).join("") : jO(t, n).replace("0x", "")
    },
    $S = (...e) => `0x${e.map(yD).join("").toLowerCase()}`,
    GX = (...e) => yh($S(...e)),
    qX = (...e) => Wn($S(...e)),
    KX = e => yh(`0x${(typeof e=="number"?e.toString():e).padStart(64,"0")}`);

function QX(e) {
    return U3(e)
}
const ud = e => QX(e),
    YX = e => Ee(ud(e));
var hv = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};

function vD(e) {
    return (typeof e == "object" || typeof e == "function") && typeof e.then == "function"
}

function bD(e, t, n) {
    return hv(this, void 0, void 0, function*() {
        let r;
        const i = yield Promise.race([e instanceof Promise ? e : e(), new Promise((o, a) => {
            r = setTimeout(() => n ? a(n) : o(void 0), t)
        })]);
        if (r && clearTimeout(r), i instanceof Error) throw i;
        return i
    })
}

function LS(e, t) {
    let n;
    return [new Promise((i, o) => {
        n = setInterval(function a() {
            return hv(this, void 0, void 0, function*() {
                try {
                    const s = yield bD(e, t);
                    F(s) || (clearInterval(n), i(s))
                } catch (s) {
                    clearInterval(n), o(s)
                }
            }), a
        }(), t)
    }), n]
}

function XX(e, t) {
    return hv(this, void 0, void 0, function*() {
        return LS(e, t)[0]
    })
}

function FS(e, t) {
    let n;
    const r = new Promise((i, o) => {
        n = setTimeout(() => {
            o(t)
        }, e)
    });
    return [n, r]
}

function wD(e, t) {
    let n;
    const r = new Promise((i, o) => {
        n = setInterval(() => {
            hv(this, void 0, void 0, function*() {
                const a = yield e();
                a && (clearInterval(n), o(a))
            })
        }, t)
    });
    return [n, r]
}
const US = () => {
        const e = ud(16);
        e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128;
        const t = Ee(e);
        return [t.substring(2, 10), t.substring(10, 14), t.substring(14, 18), t.substring(18, 22), t.substring(22, 34)].join("-")
    },
    HS = e => {
        const t = e.error.code;
        return yn.has(t) || t >= -32099 && t <= -32e3
    },
    Yo = e => !Array.isArray(e) && !!e && e.jsonrpc === "2.0" && "result" in e && F(e.error) && (typeof e.id == "number" || typeof e.id == "string"),
    Xo = e => !Array.isArray(e) && e.jsonrpc === "2.0" && !!e && F(e.result) && "error" in e && (typeof e.id == "number" || typeof e.id == "string"),
    pv = e => !Array.isArray(e) && !!e && e.jsonrpc === "2.0" && !F(e.params) && !F(e.method),
    xD = e => !Array.isArray(e) && !!e && e.jsonrpc === "2.0" && "id" in e && "result" in e,
    ug = e => Yo(e) || Xo(e),
    VS = e => Array.isArray(e) ? e.every(ug) : ug(e),
    ld = e => Array.isArray(e) && e.length > 0 && VS(e);
let Kp;
const AD = e => {
        Kp = e
    },
    Ss = e => {
        var t, n, r, i;
        return typeof Kp < "u" && (Kp += 1), {
            jsonrpc: (t = e.jsonrpc) !== null && t !== void 0 ? t : "2.0",
            id: (r = (n = e.id) !== null && n !== void 0 ? n : Kp) !== null && r !== void 0 ? r : US(),
            method: e.method,
            params: (i = e.params) !== null && i !== void 0 ? i : void 0
        }
    },
    zS = e => e.map(t => Ss(t)),
    qr = e => Array.isArray(e) && e.length > 0,
    ZX = Object.freeze(Object.defineProperty({
        __proto__: null,
        isBatchRequest: qr,
        isBatchResponse: ld,
        isResponseRpcError: HS,
        isResponseWithError: Xo,
        isResponseWithNotification: pv,
        isResponseWithResult: Yo,
        isSubscriptionResult: xD,
        isValidResponse: VS,
        setRequestIdStart: AD,
        toBatchPayload: zS,
        toPayload: Ss,
        validateResponse: ug
    }, Symbol.toStringTag, {
        value: "Module"
    }));
var hb = function(e, t, n, r) {
        function i(o) {
            return o instanceof n ? o : new n(function(a) {
                a(o)
            })
        }
        return new(n || (n = Promise))(function(o, a) {
            function s(c) {
                try {
                    l(r.next(c))
                } catch (f) {
                    a(f)
                }
            }

            function u(c) {
                try {
                    l(r.throw(c))
                } catch (f) {
                    a(f)
                }
            }

            function l(c) {
                c.done ? o(c.value) : i(c.value).then(s, u)
            }
            l((r = r.apply(e, t || [])).next())
        })
    },
    ED;
class lg {
    constructor({
        timeout: t,
        eagerStart: n,
        timeoutMessage: r
    } = {
        timeout: 0,
        eagerStart: !1,
        timeoutMessage: "DeferredPromise timed out"
    }) {
        this[ED] = "Promise", this._state = "pending", this._promise = new Promise((i, o) => {
            this._resolve = i, this._reject = o
        }), this._timeoutMessage = r, this._timeoutInterval = t, n && this.startTimer()
    }
    get state() {
        return this._state
    }
    then(t, n) {
        return hb(this, void 0, void 0, function*() {
            return this._promise.then(t, n)
        })
    } catch (t) {
        return hb(this, void 0, void 0, function*() {
            return this._promise.catch(t)
        })
    } finally(t) {
        return hb(this, void 0, void 0, function*() {
            return this._promise.finally(t)
        })
    }
    resolve(t) {
        this._resolve(t), this._state = "fulfilled", this._clearTimeout()
    }
    reject(t) {
        this._reject(t), this._state = "rejected", this._clearTimeout()
    }
    startTimer() {
        this._timeoutInterval && this._timeoutInterval > 0 && (this._timeoutId = setTimeout(this._checkTimeout.bind(this), this._timeoutInterval))
    }
    _checkTimeout() {
        this._state === "pending" && this._timeoutId && this.reject(new T3(this._timeoutMessage))
    }
    _clearTimeout() {
        this._timeoutId && clearTimeout(this._timeoutId)
    }
}
ED = Symbol.toStringTag;
class SD {
    constructor(t, n) {
        this.eventEmitter = t, this.autoReconnect = n, this.chunkTimeout = 1e3 * 15
    }
    clearQueues() {
        typeof this._clearQueues == "function" && this._clearQueues()
    }
    onError(t) {
        this._clearQueues = t
    }
    parseResponse(t) {
        const n = [];
        return t.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|").forEach(i => {
            let o = i;
            this.lastChunk && (o = this.lastChunk + o);
            let a;
            try {
                a = JSON.parse(o)
            } catch {
                this.lastChunk = o, this.lastChunkTimeout && clearTimeout(this.lastChunkTimeout), this.lastChunkTimeout = setTimeout(() => {
                    this.autoReconnect || (this.clearQueues(), this.eventEmitter.emit("error", new rv({
                        id: 1,
                        jsonrpc: "2.0",
                        error: {
                            code: 2,
                            message: "Chunk timeout"
                        }
                    })))
                }, this.chunkTimeout);
                return
            }
            clearTimeout(this.lastChunkTimeout), this.lastChunk = void 0, a && n.push(a)
        }), n
    }
}
var BO = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
class WS extends hh {
    constructor() {
        super(...arguments), this._eventEmitter = new dD, this._chainId = "", this._accounts = []
    }
    _getChainId() {
        return BO(this, void 0, void 0, function*() {
            var t;
            const n = yield this.request(Ss({
                method: "eth_chainId",
                params: []
            }));
            return (t = n == null ? void 0 : n.result) !== null && t !== void 0 ? t : ""
        })
    }
    _getAccounts() {
        return BO(this, void 0, void 0, function*() {
            var t;
            const n = yield this.request(Ss({
                method: "eth_accounts",
                params: []
            }));
            return (t = n == null ? void 0 : n.result) !== null && t !== void 0 ? t : []
        })
    }
    _onConnect() {
        Promise.all([this._getChainId().then(t => {
            t !== this._chainId && (this._chainId = t, this._eventEmitter.emit("chainChanged", this._chainId))
        }).catch(t => {
            console.error(t)
        }), this._getAccounts().then(t => {
            this._accounts.length === t.length && t.every(n => t.includes(n)) || (this._accounts = t, this._onAccountsChanged())
        }).catch(t => {
            console.error(t)
        })]).then(() => this._eventEmitter.emit("connect", {
            chainId: this._chainId
        })).catch(t => {
            console.error(t)
        })
    }
    _onDisconnect(t, n) {
        this._eventEmitter.emit("disconnect", new CQ(t, n))
    }
    _onAccountsChanged() {
        this._eventEmitter.emit("accountsChanged", this._accounts)
    }
}
var pb = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
const JX = {
        autoReconnect: !0,
        delay: 5e3,
        maxAttempts: 5
    },
    eZ = 1e3;
class _D extends WS {
    get SocketConnection() {
        return this._socketConnection
    }
    constructor(t, n, r) {
        if (super(), this._connectionStatus = "connecting", this._onMessageHandler = this._onMessage.bind(this), this._onOpenHandler = this._onConnect.bind(this), this._onCloseHandler = this._onCloseEvent.bind(this), this._onErrorHandler = this._onError.bind(this), !this._validateProviderPath(t)) throw new Ex(t);
        this._socketPath = t, this._socketOptions = n, this._reconnectOptions = Object.assign(Object.assign({}, JX), r ? ? {}), this._pendingRequestsQueue = new Map, this._sentRequestsQueue = new Map, this._init(), this.connect(), this.chunkResponseParser = new SD(this._eventEmitter, this._reconnectOptions.autoReconnect), this.chunkResponseParser.onError(() => {
            this._clearQueues()
        }), this.isReconnecting = !1
    }
    _init() {
        this._reconnectAttempts = 0
    }
    connect() {
        try {
            this._openSocketConnection(), this._connectionStatus = "connecting", this._addSocketListeners()
        } catch (t) {
            if (this.isReconnecting) setImmediate(() => {
                this._reconnect()
            });
            else throw this._connectionStatus = "disconnected", t && t.message ? new ph(`Error while connecting to ${this._socketPath}. Reason: ${t.message}`) : new Ex(this._socketPath)
        }
    }
    _validateProviderPath(t) {
        return !!t
    }
    getPendingRequestQueueSize() {
        return this._pendingRequestsQueue.size
    }
    getSentRequestsQueueSize() {
        return this._sentRequestsQueue.size
    }
    supportsSubscriptions() {
        return !0
    }
    on(t, n) {
        this._eventEmitter.on(t, n)
    }
    once(t, n) {
        this._eventEmitter.once(t, n)
    }
    removeListener(t, n) {
        this._eventEmitter.removeListener(t, n)
    }
    _onDisconnect(t, n) {
        this._connectionStatus = "disconnected", super._onDisconnect(t, n)
    }
    disconnect(t, n) {
        const r = t ? ? eZ;
        this._removeSocketListeners(), this.getStatus() !== "disconnected" && this._closeSocketConnection(r, n), this._onDisconnect(r, n)
    }
    safeDisconnect(t, n) {
        return pb(this, arguments, void 0, function*(r, i, o = !1, a = 1e3) {
            let s = 0;
            yield pb(this, void 0, void 0, function*() {
                return new Promise(l => {
                    const c = setInterval(() => {
                        o && s >= 5 && this.clearQueues(), this.getPendingRequestQueueSize() === 0 && this.getSentRequestsQueueSize() === 0 && (clearInterval(c), l(!0)), s += 1
                    }, a)
                })
            }), this.disconnect(r, i)
        })
    }
    removeAllListeners(t) {
        this._eventEmitter.removeAllListeners(t)
    }
    _onError(t) {
        this.isReconnecting ? this._reconnect() : this._eventEmitter.emit("error", t)
    }
    reset() {
        this._sentRequestsQueue.clear(), this._pendingRequestsQueue.clear(), this._init(), this._removeSocketListeners(), this._addSocketListeners()
    }
    _reconnect() {
        this.isReconnecting || (this.isReconnecting = !0, this._sentRequestsQueue.size > 0 && this._sentRequestsQueue.forEach((t, n) => {
            t.deferredPromise.reject(new WK), this._sentRequestsQueue.delete(n)
        }), this._reconnectAttempts < this._reconnectOptions.maxAttempts ? (this._reconnectAttempts += 1, setTimeout(() => {
            this._removeSocketListeners(), this.connect(), this.isReconnecting = !1
        }, this._reconnectOptions.delay)) : (this.isReconnecting = !1, this._clearQueues(), this._removeSocketListeners(), this._eventEmitter.emit("error", new zK(this._reconnectOptions.maxAttempts))))
    }
    request(t) {
        return pb(this, void 0, void 0, function*() {
            if (le(this._socketConnection)) throw new Error("Connection is undefined");
            this.getStatus() === "disconnected" && this.connect();
            const n = qr(t) ? t[0].id : t.id;
            if (!n) throw new ZK("Request Id not defined");
            if (this._sentRequestsQueue.has(n)) throw new GK(n);
            const r = new lg;
            r.catch(o => {
                this._eventEmitter.emit("error", o)
            });
            const i = {
                payload: t,
                deferredPromise: r
            };
            if (this.getStatus() === "connecting") return this._pendingRequestsQueue.set(n, i), i.deferredPromise;
            this._sentRequestsQueue.set(n, i);
            try {
                this._sendToSocket(i.payload)
            } catch (o) {
                this._sentRequestsQueue.delete(n), this._eventEmitter.emit("error", o)
            }
            return r
        })
    }
    _onConnect() {
        this._connectionStatus = "connected", this._reconnectAttempts = 0, super._onConnect(), this._sendPendingRequests()
    }
    _sendPendingRequests() {
        for (const [t, n] of this._pendingRequestsQueue.entries()) try {
            this._sendToSocket(n.payload), this._pendingRequestsQueue.delete(t), this._sentRequestsQueue.set(t, n)
        } catch (r) {
            this._pendingRequestsQueue.delete(t), this._eventEmitter.emit("error", r)
        }
    }
    _onMessage(t) {
        const n = this._parseResponses(t);
        if (!(le(n) || n.length === 0))
            for (const r of n) {
                if (pv(r) && r.method.endsWith("_subscription")) {
                    this._eventEmitter.emit("message", r);
                    return
                }
                const i = ld(r) ? r[0].id : r.id,
                    o = this._sentRequestsQueue.get(i);
                if (!o) return;
                (ld(r) || Yo(r) || Xo(r)) && (this._eventEmitter.emit("message", r), o.deferredPromise.resolve(r)), this._sentRequestsQueue.delete(i)
            }
    }
    clearQueues(t) {
        this._clearQueues(t)
    }
    _clearQueues(t) {
        this._pendingRequestsQueue.size > 0 && this._pendingRequestsQueue.forEach((n, r) => {
            n.deferredPromise.reject(new xx(t)), this._pendingRequestsQueue.delete(r)
        }), this._sentRequestsQueue.size > 0 && this._sentRequestsQueue.forEach((n, r) => {
            n.deferredPromise.reject(new xx(t)), this._sentRequestsQueue.delete(r)
        }), this._removeSocketListeners()
    }
}
const TD = Object.freeze(Object.defineProperty({
    __proto__: null,
    ChunkResponseParser: SD,
    Eip1193Provider: WS,
    EventEmitter: DS,
    SocketProvider: _D,
    Web3DeferredPromise: lg,
    asciiToHex: uD,
    bytesToHex: Ee,
    bytesToUint8Array: mi,
    checkAddressCheckSum: MX,
    compareBlockNumbers: FX,
    convert: dv,
    convertScalarValue: sd,
    encodePacked: $S,
    ethUnitMap: cv,
    format: W,
    fromAscii: _X,
    fromDecimal: wX,
    fromTwosComplement: UX,
    fromUtf8: sD,
    fromWei: PX,
    getStorageSlotNumForLongString: KX,
    hexToAscii: lD,
    hexToBytes: Ke,
    hexToNumber: gh,
    hexToNumberString: xX,
    hexToString: SX,
    hexToUtf8: fv,
    isAddress: NX,
    isBatchRequest: qr,
    isBatchResponse: ld,
    isBloom: RX,
    isContractAddressInBloom: DX,
    isContractInitOptions: $o,
    isDataFormat: Ii,
    isHex: IX,
    isHexStrict: CX,
    isInBloom: jX,
    isNullish: le,
    isPromise: vD,
    isResponseRpcError: HS,
    isResponseWithError: Xo,
    isResponseWithNotification: pv,
    isResponseWithResult: Yo,
    isSubscriptionResult: xD,
    isTopic: $X,
    isTopicInBloom: LX,
    isUint8Array: ma,
    isUserEthereumAddressInBloom: BX,
    isValidResponse: VS,
    jsonRpc: ZX,
    keccak256: il,
    keccak256Wrapper: il,
    leftPad: ad,
    mergeDeep: ga,
    numberToHex: Nt,
    padLeft: rl,
    padRight: hD,
    pollTillDefined: XX,
    pollTillDefinedAndReturnIntervalId: LS,
    processSolidityEncodePackedArgs: yD,
    randomBytes: ud,
    randomHex: YX,
    rejectIfConditionAtInterval: wD,
    rejectIfTimeout: FS,
    rightPad: pD,
    setRequestIdStart: AD,
    sha3: yh,
    sha3Raw: Wn,
    soliditySha3: GX,
    soliditySha3Raw: qX,
    stringToHex: AX,
    toAscii: TX,
    toBatchPayload: zS,
    toBigInt: Ua,
    toBool: cD,
    toChecksumAddress: vi,
    toDecimal: bX,
    toHex: ro,
    toNumber: On,
    toPayload: Ss,
    toTwosComplement: mD,
    toUtf8: EX,
    toWei: OX,
    uint8ArrayConcat: bn,
    uint8ArrayEquals: lv,
    utf8ToBytes: BS,
    utf8ToHex: Fr,
    uuidV4: US,
    validateResponse: ug,
    waitWithTimeout: bD
}, Symbol.toStringTag, {
    value: "Module"
}));
class mv {
    constructor() {
        this._emitter = new DS
    }
    on(t, n) {
        this._emitter.on(t, n)
    }
    once(t, n) {
        this._emitter.once(t, n)
    }
    off(t, n) {
        this._emitter.off(t, n)
    }
    emit(t, n) {
        this._emitter.emit(t, n)
    }
    listenerCount(t) {
        return this._emitter.listenerCount(t)
    }
    listeners(t) {
        return this._emitter.listeners(t)
    }
    eventNames() {
        return this._emitter.eventNames()
    }
    removeAllListeners() {
        return this._emitter.removeAllListeners()
    }
    setMaxListenerWarningThreshold(t) {
        this._emitter.setMaxListeners(t)
    }
    getMaxListeners() {
        return this._emitter.getMaxListeners()
    }
}
var _s;
(function(e) {
    e.CONFIG_CHANGE = "CONFIG_CHANGE"
})(_s || (_s = {}));
class tZ extends mv {
    constructor(t) {
        super(), this.config = {
            handleRevert: !1,
            defaultAccount: void 0,
            defaultBlock: "latest",
            transactionBlockTimeout: 50,
            transactionConfirmationBlocks: 24,
            transactionPollingInterval: 1e3,
            transactionPollingTimeout: 750 * 1e3,
            transactionReceiptPollingInterval: void 0,
            transactionSendTimeout: 750 * 1e3,
            transactionConfirmationPollingInterval: void 0,
            blockHeaderTimeout: 10,
            maxListenersWarningThreshold: 100,
            contractDataInputFill: "data",
            defaultNetworkId: void 0,
            defaultChain: "mainnet",
            defaultHardfork: "london",
            defaultCommon: void 0,
            defaultTransactionType: "0x2",
            defaultMaxPriorityFeePerGas: ro(25e8),
            enableExperimentalFeatures: {
                useSubscriptionWhenCheckingBlockTimeout: !1,
                useRpcCallSpecification: !1
            },
            transactionBuilder: void 0,
            transactionTypeParser: void 0,
            customTransactionSchema: void 0,
            defaultReturnFormat: mn,
            ignoreGasPricing: !1
        }, this.setConfig(t ? ? {})
    }
    setConfig(t) {
        const n = Object.keys(t);
        for (const r of n) this._triggerConfigChange(r, t[r]), !le(t[r]) && typeof t[r] == "number" && r === "maxListenersWarningThreshold" && this.setMaxListenerWarningThreshold(Number(t[r]));
        Object.assign(this.config, t)
    }
    get handleRevert() {
        return this.config.handleRevert
    }
    set handleRevert(t) {
        this._triggerConfigChange("handleRevert", t), this.config.handleRevert = t
    }
    get contractDataInputFill() {
        return this.config.contractDataInputFill
    }
    set contractDataInputFill(t) {
        this._triggerConfigChange("contractDataInputFill", t), this.config.contractDataInputFill = t
    }
    get defaultAccount() {
        return this.config.defaultAccount
    }
    set defaultAccount(t) {
        this._triggerConfigChange("defaultAccount", t), this.config.defaultAccount = t
    }
    get defaultBlock() {
        return this.config.defaultBlock
    }
    set defaultBlock(t) {
        this._triggerConfigChange("defaultBlock", t), this.config.defaultBlock = t
    }
    get transactionSendTimeout() {
        return this.config.transactionSendTimeout
    }
    set transactionSendTimeout(t) {
        this._triggerConfigChange("transactionSendTimeout", t), this.config.transactionSendTimeout = t
    }
    get transactionBlockTimeout() {
        return this.config.transactionBlockTimeout
    }
    set transactionBlockTimeout(t) {
        this._triggerConfigChange("transactionBlockTimeout", t), this.config.transactionBlockTimeout = t
    }
    get transactionConfirmationBlocks() {
        return this.config.transactionConfirmationBlocks
    }
    set transactionConfirmationBlocks(t) {
        this._triggerConfigChange("transactionConfirmationBlocks", t), this.config.transactionConfirmationBlocks = t
    }
    get transactionPollingInterval() {
        return this.config.transactionPollingInterval
    }
    set transactionPollingInterval(t) {
        this._triggerConfigChange("transactionPollingInterval", t), this.config.transactionPollingInterval = t, this.transactionReceiptPollingInterval = t, this.transactionConfirmationPollingInterval = t
    }
    get transactionPollingTimeout() {
        return this.config.transactionPollingTimeout
    }
    set transactionPollingTimeout(t) {
        this._triggerConfigChange("transactionPollingTimeout", t), this.config.transactionPollingTimeout = t
    }
    get transactionReceiptPollingInterval() {
        return this.config.transactionReceiptPollingInterval
    }
    set transactionReceiptPollingInterval(t) {
        this._triggerConfigChange("transactionReceiptPollingInterval", t), this.config.transactionReceiptPollingInterval = t
    }
    get transactionConfirmationPollingInterval() {
        return this.config.transactionConfirmationPollingInterval
    }
    set transactionConfirmationPollingInterval(t) {
        this._triggerConfigChange("transactionConfirmationPollingInterval", t), this.config.transactionConfirmationPollingInterval = t
    }
    get blockHeaderTimeout() {
        return this.config.blockHeaderTimeout
    }
    set blockHeaderTimeout(t) {
        this._triggerConfigChange("blockHeaderTimeout", t), this.config.blockHeaderTimeout = t
    }
    get enableExperimentalFeatures() {
        return this.config.enableExperimentalFeatures
    }
    set enableExperimentalFeatures(t) {
        this._triggerConfigChange("enableExperimentalFeatures", t), this.config.enableExperimentalFeatures = t
    }
    get maxListenersWarningThreshold() {
        return this.config.maxListenersWarningThreshold
    }
    set maxListenersWarningThreshold(t) {
        this._triggerConfigChange("maxListenersWarningThreshold", t), this.setMaxListenerWarningThreshold(t), this.config.maxListenersWarningThreshold = t
    }
    get defaultReturnFormat() {
        return this.config.defaultReturnFormat
    }
    set defaultReturnFormat(t) {
        this._triggerConfigChange("defaultReturnFormat", t), this.config.defaultReturnFormat = t
    }
    get defaultNetworkId() {
        return this.config.defaultNetworkId
    }
    set defaultNetworkId(t) {
        this._triggerConfigChange("defaultNetworkId", t), this.config.defaultNetworkId = t
    }
    get defaultChain() {
        return this.config.defaultChain
    }
    set defaultChain(t) {
        if (!le(this.config.defaultCommon) && !le(this.config.defaultCommon.baseChain) && t !== this.config.defaultCommon.baseChain) throw new EO(this.config.defaultChain, t);
        this._triggerConfigChange("defaultChain", t), this.config.defaultChain = t
    }
    get defaultHardfork() {
        return this.config.defaultHardfork
    }
    set defaultHardfork(t) {
        if (!le(this.config.defaultCommon) && !le(this.config.defaultCommon.hardfork) && t !== this.config.defaultCommon.hardfork) throw new AO(this.config.defaultCommon.hardfork, t);
        this._triggerConfigChange("defaultHardfork", t), this.config.defaultHardfork = t
    }
    get defaultCommon() {
        return this.config.defaultCommon
    }
    set defaultCommon(t) {
        if (!le(this.config.defaultHardfork) && !le(t) && !le(t.hardfork) && this.config.defaultHardfork !== t.hardfork) throw new AO(this.config.defaultHardfork, t.hardfork);
        if (!le(this.config.defaultChain) && !le(t) && !le(t.baseChain) && this.config.defaultChain !== t.baseChain) throw new EO(this.config.defaultChain, t.baseChain);
        this._triggerConfigChange("defaultCommon", t), this.config.defaultCommon = t
    }
    get ignoreGasPricing() {
        return this.config.ignoreGasPricing
    }
    set ignoreGasPricing(t) {
        this._triggerConfigChange("ignoreGasPricing", t), this.config.ignoreGasPricing = t
    }
    get defaultTransactionType() {
        return this.config.defaultTransactionType
    }
    set defaultTransactionType(t) {
        this._triggerConfigChange("defaultTransactionType", t), this.config.defaultTransactionType = t
    }
    get defaultMaxPriorityFeePerGas() {
        return this.config.defaultMaxPriorityFeePerGas
    }
    set defaultMaxPriorityFeePerGas(t) {
        this._triggerConfigChange("defaultMaxPriorityFeePerGas", t), this.config.defaultMaxPriorityFeePerGas = t
    }
    get transactionBuilder() {
        return this.config.transactionBuilder
    }
    set transactionBuilder(t) {
        this._triggerConfigChange("transactionBuilder", t), this.config.transactionBuilder = t
    }
    get transactionTypeParser() {
        return this.config.transactionTypeParser
    }
    set transactionTypeParser(t) {
        this._triggerConfigChange("transactionTypeParser", t), this.config.transactionTypeParser = t
    }
    get customTransactionSchema() {
        return this.config.customTransactionSchema
    }
    set customTransactionSchema(t) {
        this._triggerConfigChange("customTransactionSchema", t), this.config.customTransactionSchema = t
    }
    _triggerConfigChange(t, n) {
        this.emit(_s.CONFIG_CHANGE, {
            name: t,
            oldValue: this.config[t],
            newValue: n
        })
    }
}
var Mx = {
    exports: {}
};
(function(e, t) {
    var n = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof globalThis < "u" && globalThis,
        r = function() {
            function o() {
                this.fetch = !1, this.DOMException = n.DOMException
            }
            return o.prototype = n, new o
        }();
    (function(o) {
        (function(a) {
            var s = typeof o < "u" && o || typeof self < "u" && self || typeof o < "u" && o || {},
                u = {
                    searchParams: "URLSearchParams" in s,
                    iterable: "Symbol" in s && "iterator" in Symbol,
                    blob: "FileReader" in s && "Blob" in s && function() {
                        try {
                            return new Blob, !0
                        } catch {
                            return !1
                        }
                    }(),
                    formData: "FormData" in s,
                    arrayBuffer: "ArrayBuffer" in s
                };

            function l(P) {
                return P && DataView.prototype.isPrototypeOf(P)
            }
            if (u.arrayBuffer) var c = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
                f = ArrayBuffer.isView || function(P) {
                    return P && c.indexOf(Object.prototype.toString.call(P)) > -1
                };

            function d(P) {
                if (typeof P != "string" && (P = String(P)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(P) || P === "") throw new TypeError('Invalid character in header field name: "' + P + '"');
                return P.toLowerCase()
            }

            function h(P) {
                return typeof P != "string" && (P = String(P)), P
            }

            function m(P) {
                var C = {
                    next: function() {
                        var j = P.shift();
                        return {
                            done: j === void 0,
                            value: j
                        }
                    }
                };
                return u.iterable && (C[Symbol.iterator] = function() {
                    return C
                }), C
            }

            function p(P) {
                this.map = {}, P instanceof p ? P.forEach(function(C, j) {
                    this.append(j, C)
                }, this) : Array.isArray(P) ? P.forEach(function(C) {
                    if (C.length != 2) throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + C.length);
                    this.append(C[0], C[1])
                }, this) : P && Object.getOwnPropertyNames(P).forEach(function(C) {
                    this.append(C, P[C])
                }, this)
            }
            p.prototype.append = function(P, C) {
                P = d(P), C = h(C);
                var j = this.map[P];
                this.map[P] = j ? j + ", " + C : C
            }, p.prototype.delete = function(P) {
                delete this.map[d(P)]
            }, p.prototype.get = function(P) {
                return P = d(P), this.has(P) ? this.map[P] : null
            }, p.prototype.has = function(P) {
                return this.map.hasOwnProperty(d(P))
            }, p.prototype.set = function(P, C) {
                this.map[d(P)] = h(C)
            }, p.prototype.forEach = function(P, C) {
                for (var j in this.map) this.map.hasOwnProperty(j) && P.call(C, this.map[j], j, this)
            }, p.prototype.keys = function() {
                var P = [];
                return this.forEach(function(C, j) {
                    P.push(j)
                }), m(P)
            }, p.prototype.values = function() {
                var P = [];
                return this.forEach(function(C) {
                    P.push(C)
                }), m(P)
            }, p.prototype.entries = function() {
                var P = [];
                return this.forEach(function(C, j) {
                    P.push([j, C])
                }), m(P)
            }, u.iterable && (p.prototype[Symbol.iterator] = p.prototype.entries);

            function y(P) {
                if (!P._noBody) {
                    if (P.bodyUsed) return Promise.reject(new TypeError("Already read"));
                    P.bodyUsed = !0
                }
            }

            function g(P) {
                return new Promise(function(C, j) {
                    P.onload = function() {
                        C(P.result)
                    }, P.onerror = function() {
                        j(P.error)
                    }
                })
            }

            function b(P) {
                var C = new FileReader,
                    j = g(C);
                return C.readAsArrayBuffer(P), j
            }

            function v(P) {
                var C = new FileReader,
                    j = g(C),
                    N = /charset=([A-Za-z0-9_-]+)/.exec(P.type),
                    D = N ? N[1] : "utf-8";
                return C.readAsText(P, D), j
            }

            function A(P) {
                for (var C = new Uint8Array(P), j = new Array(C.length), N = 0; N < C.length; N++) j[N] = String.fromCharCode(C[N]);
                return j.join("")
            }

            function w(P) {
                if (P.slice) return P.slice(0);
                var C = new Uint8Array(P.byteLength);
                return C.set(new Uint8Array(P)), C.buffer
            }

            function x() {
                return this.bodyUsed = !1, this._initBody = function(P) {
                    this.bodyUsed = this.bodyUsed, this._bodyInit = P, P ? typeof P == "string" ? this._bodyText = P : u.blob && Blob.prototype.isPrototypeOf(P) ? this._bodyBlob = P : u.formData && FormData.prototype.isPrototypeOf(P) ? this._bodyFormData = P : u.searchParams && URLSearchParams.prototype.isPrototypeOf(P) ? this._bodyText = P.toString() : u.arrayBuffer && u.blob && l(P) ? (this._bodyArrayBuffer = w(P.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : u.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(P) || f(P)) ? this._bodyArrayBuffer = w(P) : this._bodyText = P = Object.prototype.toString.call(P) : (this._noBody = !0, this._bodyText = ""), this.headers.get("content-type") || (typeof P == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : u.searchParams && URLSearchParams.prototype.isPrototypeOf(P) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                }, u.blob && (this.blob = function() {
                    var P = y(this);
                    if (P) return P;
                    if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                    if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                    if (this._bodyFormData) throw new Error("could not read FormData body as blob");
                    return Promise.resolve(new Blob([this._bodyText]))
                }), this.arrayBuffer = function() {
                    if (this._bodyArrayBuffer) {
                        var P = y(this);
                        return P || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer))
                    } else {
                        if (u.blob) return this.blob().then(b);
                        throw new Error("could not read as ArrayBuffer")
                    }
                }, this.text = function() {
                    var P = y(this);
                    if (P) return P;
                    if (this._bodyBlob) return v(this._bodyBlob);
                    if (this._bodyArrayBuffer) return Promise.resolve(A(this._bodyArrayBuffer));
                    if (this._bodyFormData) throw new Error("could not read FormData body as text");
                    return Promise.resolve(this._bodyText)
                }, u.formData && (this.formData = function() {
                    return this.text().then(k)
                }), this.json = function() {
                    return this.text().then(JSON.parse)
                }, this
            }
            var T = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];

            function _(P) {
                var C = P.toUpperCase();
                return T.indexOf(C) > -1 ? C : P
            }

            function O(P, C) {
                if (!(this instanceof O)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                C = C || {};
                var j = C.body;
                if (P instanceof O) {
                    if (P.bodyUsed) throw new TypeError("Already read");
                    this.url = P.url, this.credentials = P.credentials, C.headers || (this.headers = new p(P.headers)), this.method = P.method, this.mode = P.mode, this.signal = P.signal, !j && P._bodyInit != null && (j = P._bodyInit, P.bodyUsed = !0)
                } else this.url = String(P);
                if (this.credentials = C.credentials || this.credentials || "same-origin", (C.headers || !this.headers) && (this.headers = new p(C.headers)), this.method = _(C.method || this.method || "GET"), this.mode = C.mode || this.mode || null, this.signal = C.signal || this.signal || function() {
                        if ("AbortController" in s) {
                            var $ = new AbortController;
                            return $.signal
                        }
                    }(), this.referrer = null, (this.method === "GET" || this.method === "HEAD") && j) throw new TypeError("Body not allowed for GET or HEAD requests");
                if (this._initBody(j), (this.method === "GET" || this.method === "HEAD") && (C.cache === "no-store" || C.cache === "no-cache")) {
                    var N = /([?&])_=[^&]*/;
                    if (N.test(this.url)) this.url = this.url.replace(N, "$1_=" + new Date().getTime());
                    else {
                        var D = /\?/;
                        this.url += (D.test(this.url) ? "&" : "?") + "_=" + new Date().getTime()
                    }
                }
            }
            O.prototype.clone = function() {
                return new O(this, {
                    body: this._bodyInit
                })
            };

            function k(P) {
                var C = new FormData;
                return P.trim().split("&").forEach(function(j) {
                    if (j) {
                        var N = j.split("="),
                            D = N.shift().replace(/\+/g, " "),
                            $ = N.join("=").replace(/\+/g, " ");
                        C.append(decodeURIComponent(D), decodeURIComponent($))
                    }
                }), C
            }

            function I(P) {
                var C = new p,
                    j = P.replace(/\r?\n[\t ]+/g, " ");
                return j.split("\r").map(function(N) {
                    return N.indexOf(`
`) === 0 ? N.substr(1, N.length) : N
                }).forEach(function(N) {
                    var D = N.split(":"),
                        $ = D.shift().trim();
                    if ($) {
                        var V = D.join(":").trim();
                        try {
                            C.append($, V)
                        } catch (H) {
                            console.warn("Response " + H.message)
                        }
                    }
                }), C
            }
            x.call(O.prototype);

            function M(P, C) {
                if (!(this instanceof M)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                if (C || (C = {}), this.type = "default", this.status = C.status === void 0 ? 200 : C.status, this.status < 200 || this.status > 599) throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
                this.ok = this.status >= 200 && this.status < 300, this.statusText = C.statusText === void 0 ? "" : "" + C.statusText, this.headers = new p(C.headers), this.url = C.url || "", this._initBody(P)
            }
            x.call(M.prototype), M.prototype.clone = function() {
                return new M(this._bodyInit, {
                    status: this.status,
                    statusText: this.statusText,
                    headers: new p(this.headers),
                    url: this.url
                })
            }, M.error = function() {
                var P = new M(null, {
                    status: 200,
                    statusText: ""
                });
                return P.ok = !1, P.status = 0, P.type = "error", P
            };
            var B = [301, 302, 303, 307, 308];
            M.redirect = function(P, C) {
                if (B.indexOf(C) === -1) throw new RangeError("Invalid status code");
                return new M(null, {
                    status: C,
                    headers: {
                        location: P
                    }
                })
            }, a.DOMException = s.DOMException;
            try {
                new a.DOMException
            } catch {
                a.DOMException = function(C, j) {
                    this.message = C, this.name = j;
                    var N = Error(C);
                    this.stack = N.stack
                }, a.DOMException.prototype = Object.create(Error.prototype), a.DOMException.prototype.constructor = a.DOMException
            }

            function L(P, C) {
                return new Promise(function(j, N) {
                    var D = new O(P, C);
                    if (D.signal && D.signal.aborted) return N(new a.DOMException("Aborted", "AbortError"));
                    var $ = new XMLHttpRequest;

                    function V() {
                        $.abort()
                    }
                    $.onload = function() {
                        var X = {
                            statusText: $.statusText,
                            headers: I($.getAllResponseHeaders() || "")
                        };
                        D.url.indexOf("file://") === 0 && ($.status < 200 || $.status > 599) ? X.status = 200 : X.status = $.status, X.url = "responseURL" in $ ? $.responseURL : X.headers.get("X-Request-URL");
                        var ve = "response" in $ ? $.response : $.responseText;
                        setTimeout(function() {
                            j(new M(ve, X))
                        }, 0)
                    }, $.onerror = function() {
                        setTimeout(function() {
                            N(new TypeError("Network request failed"))
                        }, 0)
                    }, $.ontimeout = function() {
                        setTimeout(function() {
                            N(new TypeError("Network request timed out"))
                        }, 0)
                    }, $.onabort = function() {
                        setTimeout(function() {
                            N(new a.DOMException("Aborted", "AbortError"))
                        }, 0)
                    };

                    function H(X) {
                        try {
                            return X === "" && s.location.href ? s.location.href : X
                        } catch {
                            return X
                        }
                    }
                    if ($.open(D.method, H(D.url), !0), D.credentials === "include" ? $.withCredentials = !0 : D.credentials === "omit" && ($.withCredentials = !1), "responseType" in $ && (u.blob ? $.responseType = "blob" : u.arrayBuffer && ($.responseType = "arraybuffer")), C && typeof C.headers == "object" && !(C.headers instanceof p || s.Headers && C.headers instanceof s.Headers)) {
                        var Q = [];
                        Object.getOwnPropertyNames(C.headers).forEach(function(X) {
                            Q.push(d(X)), $.setRequestHeader(X, h(C.headers[X]))
                        }), D.headers.forEach(function(X, ve) {
                            Q.indexOf(ve) === -1 && $.setRequestHeader(ve, X)
                        })
                    } else D.headers.forEach(function(X, ve) {
                        $.setRequestHeader(ve, X)
                    });
                    D.signal && (D.signal.addEventListener("abort", V), $.onreadystatechange = function() {
                        $.readyState === 4 && D.signal.removeEventListener("abort", V)
                    }), $.send(typeof D._bodyInit > "u" ? null : D._bodyInit)
                })
            }
            return L.polyfill = !0, s.fetch || (s.fetch = L, s.Headers = p, s.Request = O, s.Response = M), a.Headers = p, a.Request = O, a.Response = M, a.fetch = L, a
        })({})
    })(r), r.fetch.ponyfill = !0, delete r.fetch.polyfill;
    var i = n.fetch ? n : r;
    t = i.fetch, t.default = i.fetch, t.fetch = i.fetch, t.Headers = i.Headers, t.Request = i.Request, t.Response = i.Response, e.exports = t
})(Mx, Mx.exports);
var nZ = Mx.exports;
const rZ = Fe(nZ);
var iZ = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
class gv extends hh {
    constructor(t, n) {
        if (super(), !gv.validateClientUrl(t)) throw new Ex(t);
        this.clientUrl = t, this.httpProviderOptions = n
    }
    static validateClientUrl(t) {
        return typeof t == "string" ? /^http(s)?:\/\//i.test(t) : !1
    }
    getStatus() {
        throw new Ai
    }
    supportsSubscriptions() {
        return !1
    }
    request(t, n) {
        var r;
        return iZ(this, void 0, void 0, function*() {
            const i = Object.assign(Object.assign({}, (r = this.httpProviderOptions) === null || r === void 0 ? void 0 : r.providerOptions), n),
                o = yield rZ(this.clientUrl, Object.assign(Object.assign({}, i), {
                    method: "POST",
                    headers: Object.assign(Object.assign({}, i.headers), {
                        "Content-Type": "application/json"
                    }),
                    body: JSON.stringify(t)
                }));
            if (!o.ok) throw new Jr(yield o.json(), void 0, void 0, o.status);
            return yield o.json()
        })
    }
    on() {
        throw new Ai
    }
    removeListener() {
        throw new Ai
    }
    once() {
        throw new Ai
    }
    removeAllListeners() {
        throw new Ai
    }
    connect() {
        throw new Ai
    }
    disconnect() {
        throw new Ai
    }
    reset() {
        throw new Ai
    }
    reconnect() {
        throw new Ai
    }
}
var eu = null;
typeof WebSocket < "u" ? eu = WebSocket : typeof MozWebSocket < "u" ? eu = MozWebSocket : typeof globalThis < "u" ? eu = globalThis.WebSocket || globalThis.MozWebSocket : typeof window < "u" ? eu = window.WebSocket || window.MozWebSocket : typeof self < "u" && (eu = self.WebSocket || self.MozWebSocket);
const oZ = eu;
class PD extends _D {
    constructor(t, n, r) {
        super(t, n, r)
    }
    _validateProviderPath(t) {
        return typeof t == "string" ? /^ws(s)?:\/\//i.test(t) : !1
    }
    getStatus() {
        if (this._socketConnection && !le(this._socketConnection)) switch (this._socketConnection.readyState) {
            case this._socketConnection.CONNECTING:
                return "connecting";
            case this._socketConnection.OPEN:
                return "connected";
            default:
                return "disconnected"
        }
        return "disconnected"
    }
    _openSocketConnection() {
        this._socketConnection = new oZ(this._socketPath, void 0, this._socketOptions && Object.keys(this._socketOptions).length === 0 ? void 0 : this._socketOptions)
    }
    _closeSocketConnection(t, n) {
        var r;
        (r = this._socketConnection) === null || r === void 0 || r.close(t, n)
    }
    _sendToSocket(t) {
        var n;
        if (this.getStatus() === "disconnected") throw new xx;
        (n = this._socketConnection) === null || n === void 0 || n.send(JSON.stringify(t))
    }
    _parseResponses(t) {
        return this.chunkResponseParser.parseResponse(t.data)
    }
    _addSocketListeners() {
        var t, n, r, i;
        (t = this._socketConnection) === null || t === void 0 || t.addEventListener("open", this._onOpenHandler), (n = this._socketConnection) === null || n === void 0 || n.addEventListener("message", this._onMessageHandler), (r = this._socketConnection) === null || r === void 0 || r.addEventListener("close", o => this._onCloseHandler(o)), (i = this._socketConnection) === null || i === void 0 || i.addEventListener("error", this._onErrorHandler)
    }
    _removeSocketListeners() {
        var t, n, r;
        (t = this._socketConnection) === null || t === void 0 || t.removeEventListener("message", this._onMessageHandler), (n = this._socketConnection) === null || n === void 0 || n.removeEventListener("open", this._onOpenHandler), (r = this._socketConnection) === null || r === void 0 || r.removeEventListener("close", this._onCloseHandler)
    }
    _onCloseEvent(t) {
        var n;
        if (this._reconnectOptions.autoReconnect && (![1e3, 1001].includes(t.code) || !t.wasClean)) {
            this._reconnect();
            return
        }
        this._clearQueues(t), this._removeSocketListeners(), this._onDisconnect(t.code, t.reason), (n = this._socketConnection) === null || n === void 0 || n.removeEventListener("error", this._onErrorHandler)
    }
}
const OD = e => hh.isWeb3Provider(e),
    kD = e => typeof e != "string" && "request" in e && e.request.constructor.name === "Function",
    CD = e => typeof e != "string" && "request" in e && e.request.constructor.name === "AsyncFunction",
    ID = e => typeof e != "string" && "send" in e,
    MD = e => typeof e != "string" && "sendAsync" in e,
    cg = e => e && (OD(e) || CD(e) || kD(e) || MD(e) || ID(e)),
    aZ = e => e && "supportsSubscriptions" in e ? e.supportsSubscriptions() : !!(e && typeof e != "string" && "on" in e);
var mb = function(e, t, n, r) {
        function i(o) {
            return o instanceof n ? o : new n(function(a) {
                a(o)
            })
        }
        return new(n || (n = Promise))(function(o, a) {
            function s(c) {
                try {
                    l(r.next(c))
                } catch (f) {
                    a(f)
                }
            }

            function u(c) {
                try {
                    l(r.throw(c))
                } catch (f) {
                    a(f)
                }
            }

            function l(c) {
                c.done ? o(c.value) : i(c.value).then(s, u)
            }
            l((r = r.apply(e, t || [])).next())
        })
    },
    ol;
(function(e) {
    e.PROVIDER_CHANGED = "PROVIDER_CHANGED", e.BEFORE_PROVIDER_CHANGE = "BEFORE_PROVIDER_CHANGE"
})(ol || (ol = {}));
const DO = {
    HttpProvider: gv,
    WebsocketProvider: PD
};
class is extends mv {
    constructor(t, n, r) {
        super(), le(t) || this.setProvider(t), this.useRpcCallSpecification = n, le(r) || (this.middleware = r)
    }
    static get providers() {
        return DO
    }
    get provider() {
        return this._provider
    }
    get providers() {
        return DO
    }
    setProvider(t) {
        let n;
        if (t && typeof t == "string" && this.providers)
            if (/^http(s)?:\/\//i.test(t)) n = new this.providers.HttpProvider(t);
            else if (/^ws(s)?:\/\//i.test(t)) n = new this.providers.WebsocketProvider(t);
        else throw new Vp(`Can't autodetect provider for "${t}"`);
        else le(t) ? n = void 0 : n = t;
        return this.emit(ol.BEFORE_PROVIDER_CHANGE, this._provider), this._provider = n, this.emit(ol.PROVIDER_CHANGED, this._provider), !0
    }
    setMiddleware(t) {
        this.middleware = t
    }
    send(t) {
        return mb(this, void 0, void 0, function*() {
            const n = Object.assign({}, t);
            let r = yield this._sendRequest(n);
            if (le(this.middleware) || (r = yield this.middleware.processResponse(r)), Yo(r)) return r.result;
            throw new Jr(r)
        })
    }
    sendBatch(t) {
        return mb(this, void 0, void 0, function*() {
            return yield this._sendRequest(t)
        })
    }
    _sendRequest(t) {
        return mb(this, void 0, void 0, function*() {
            const {
                provider: n
            } = this;
            if (le(n)) throw new Vp("Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.");
            let r = qr(t) ? zS(t) : Ss(t);
            if (le(this.middleware) || (r = yield this.middleware.processRequest(r)), OD(n)) {
                let i;
                try {
                    i = yield n.request(r)
                } catch (o) {
                    i = o
                }
                return this._processJsonRpcResponse(r, i, {
                    legacy: !1,
                    error: !1
                })
            }
            if (CD(n)) return n.request(r).then(i => this._processJsonRpcResponse(r, i, {
                legacy: !0,
                error: !1
            })).catch(i => this._processJsonRpcResponse(r, i, {
                legacy: !0,
                error: !0
            }));
            if (kD(n)) return new Promise((i, o) => {
                const a = l => {
                        o(this._processJsonRpcResponse(r, l, {
                            legacy: !0,
                            error: !0
                        }))
                    },
                    s = l => i(this._processJsonRpcResponse(r, l, {
                        legacy: !0,
                        error: !1
                    })),
                    u = n.request(r, (l, c) => l ? a(l) : s(c));
                vD(u) && u.then(s).catch(c => {
                    try {
                        const f = this._processJsonRpcResponse(r, c, {
                            legacy: !0,
                            error: !0
                        });
                        o(f)
                    } catch (f) {
                        o(f)
                    }
                })
            });
            if (ID(n)) return new Promise((i, o) => {
                n.send(r, (a, s) => {
                    if (a) return o(this._processJsonRpcResponse(r, a, {
                        legacy: !0,
                        error: !0
                    }));
                    if (le(s)) throw new Jr({}, 'Got a "nullish" response from provider.');
                    return i(this._processJsonRpcResponse(r, s, {
                        legacy: !0,
                        error: !1
                    }))
                })
            });
            if (MD(n)) return n.sendAsync(r).then(i => this._processJsonRpcResponse(r, i, {
                legacy: !0,
                error: !1
            })).catch(i => this._processJsonRpcResponse(r, i, {
                legacy: !0,
                error: !0
            }));
            throw new Vp("Provider does not have a request or send method to use.")
        })
    }
    _processJsonRpcResponse(t, n, {
        legacy: r,
        error: i
    }) {
        if (le(n)) return this._buildResponse(t, null, i);
        if (Xo(n)) {
            if (this.useRpcCallSpecification && HS(n)) {
                const o = n;
                if (yn.get(o.error.code)) {
                    const a = yn.get(o.error.code).error;
                    throw new a(o)
                } else throw new Qn(o)
            } else if (!is._isReverted(n)) throw new rv(n, t)
        }
        if (Yo(n)) return n;
        if (n instanceof Error) throw is._isReverted(n), n;
        if (!r && qr(t) && ld(n) || r && !i && qr(t)) return n;
        if (r && i && qr(t)) throw n;
        if (r && !Xo(n) && !Yo(n)) return this._buildResponse(t, n, i);
        throw qr(t) && !Array.isArray(n) ? new Jr(n, "Got normal response for a batch request.") : !qr(t) && Array.isArray(n) ? new Jr(n, "Got batch response for a normal request.") : new Jr(n, "Invalid response")
    }
    static _isReverted(t) {
        let n;
        if (Xo(t) ? n = t.error : t instanceof Error && (n = t), n != null && n.message.includes("revert")) throw new ns(n);
        return !1
    }
    _buildResponse(t, n, r) {
        const i = {
            jsonrpc: "2.0",
            id: qr(t) ? t[0].id : "id" in t ? t.id : null
        };
        return r ? Object.assign(Object.assign({}, i), {
            error: n
        }) : Object.assign(Object.assign({}, i), {
            result: n
        })
    }
}
var xc = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
class fg {
    constructor(t, n, r = !1) {
        this.requestManager = t, this.registeredSubscriptions = n, this.tolerateUnlinkedSubscription = r, this._subscriptions = new Map, this.requestManager.on(ol.BEFORE_PROVIDER_CHANGE, () => xc(this, void 0, void 0, function*() {
            yield this.unsubscribe()
        })), this.requestManager.on(ol.PROVIDER_CHANGED, () => {
            this.clear(), this.listenToProviderEvents()
        }), this.listenToProviderEvents()
    }
    listenToProviderEvents() {
        const t = this.requestManager.provider;
        !this.requestManager.provider || typeof(t == null ? void 0 : t.supportsSubscriptions) == "function" && !(t != null && t.supportsSubscriptions()) || typeof this.requestManager.provider.on == "function" && (typeof this.requestManager.provider.request == "function" ? this.requestManager.provider.on("message", n => this.messageListener(n)) : t.on("data", n => this.messageListener(n)))
    }
    messageListener(t) {
        var n, r, i;
        if (!t) throw new ki("Should not call messageListener with no data. Type was");
        const o = ((n = t.params) === null || n === void 0 ? void 0 : n.subscription) || ((r = t.data) === null || r === void 0 ? void 0 : r.subscription) || ((i = t.id) === null || i === void 0 ? void 0 : i.toString(16));
        if (o) {
            const a = this._subscriptions.get(o);
            a == null || a.processSubscriptionData(t)
        }
    }
    subscribe(t, n) {
        return xc(this, arguments, void 0, function*(r, i, o = mn) {
            const a = this.registeredSubscriptions[r];
            if (!a) throw new ki("Invalid subscription type");
            const s = new a(i ? ? void 0, {
                subscriptionManager: this,
                returnFormat: o
            });
            return yield this.addSubscription(s), s
        })
    }
    get subscriptions() {
        return this._subscriptions
    }
    addSubscription(t) {
        return xc(this, void 0, void 0, function*() {
            if (!this.requestManager.provider) throw new Vp("Provider not available");
            if (!this.supportsSubscriptions()) throw new ki("The current provider does not support subscriptions");
            if (t.id && this._subscriptions.has(t.id)) throw new ki(`Subscription with id "${t.id}" already exists`);
            if (yield t.sendSubscriptionRequest(), le(t.id)) throw new ki("Subscription is not subscribed yet.");
            return this._subscriptions.set(t.id, t), t.id
        })
    }
    removeSubscription(t) {
        return xc(this, void 0, void 0, function*() {
            const {
                id: n
            } = t;
            if (le(n)) throw new ki("Subscription is not subscribed yet. Or, had already been unsubscribed but not through the Subscription Manager.");
            if (!this._subscriptions.has(n) && !this.tolerateUnlinkedSubscription) throw new ki(`Subscription with id "${n.toString()}" does not exists`);
            return yield t.sendUnsubscribeRequest(), this._subscriptions.delete(n), n
        })
    }
    unsubscribe(t) {
        return xc(this, void 0, void 0, function*() {
            const n = [];
            for (const [r, i] of this.subscriptions.entries())(!t || typeof t == "function" && t({
                id: r,
                sub: i
            })) && n.push(this.removeSubscription(i));
            return Promise.all(n)
        })
    }
    clear() {
        this._subscriptions.clear()
    }
    supportsSubscriptions() {
        return le(this.requestManager.provider) ? !1 : aZ(this.requestManager.provider)
    }
}
var Ac = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
class vh extends mv {
    constructor(t, n) {
        var r;
        super(), this.args = t;
        const {
            requestManager: i
        } = n, {
            subscriptionManager: o
        } = n;
        i ? this._subscriptionManager = new fg(i, {}, !0) : this._subscriptionManager = o, this._returnFormat = (r = n == null ? void 0 : n.returnFormat) !== null && r !== void 0 ? r : mn
    }
    get id() {
        return this._id
    }
    get lastBlock() {
        return this._lastBlock
    }
    subscribe() {
        return Ac(this, void 0, void 0, function*() {
            return this._subscriptionManager.addSubscription(this)
        })
    }
    processSubscriptionData(t) {
        var n, r;
        t != null && t.data ? this._processSubscriptionResult((r = (n = t == null ? void 0 : t.data) === null || n === void 0 ? void 0 : n.result) !== null && r !== void 0 ? r : t == null ? void 0 : t.data) : t && pv(t) && this._processSubscriptionResult(t == null ? void 0 : t.params.result)
    }
    sendSubscriptionRequest() {
        return Ac(this, void 0, void 0, function*() {
            return this._id = yield this._subscriptionManager.requestManager.send({
                method: "eth_subscribe",
                params: this._buildSubscriptionParams()
            }), this.emit("connected", this._id), this._id
        })
    }
    get returnFormat() {
        return this._returnFormat
    }
    get subscriptionManager() {
        return this._subscriptionManager
    }
    resubscribe() {
        return Ac(this, void 0, void 0, function*() {
            yield this.unsubscribe(), yield this.subscribe()
        })
    }
    unsubscribe() {
        return Ac(this, void 0, void 0, function*() {
            this.id && (yield this._subscriptionManager.removeSubscription(this))
        })
    }
    sendUnsubscribeRequest() {
        return Ac(this, void 0, void 0, function*() {
            yield this._subscriptionManager.requestManager.send({
                method: "eth_unsubscribe",
                params: [this.id]
            }), this._id = void 0
        })
    }
    formatSubscriptionResult(t) {
        return t
    }
    _processSubscriptionResult(t) {
        this.emit("data", this.formatSubscriptionResult(t))
    }
    _processSubscriptionError(t) {
        this.emit("error", t)
    }
    _buildSubscriptionParams() {
        throw new Error("Implement in the child class")
    }
}
var zs = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
class dg extends ZG {
    constructor() {
        super(...arguments), this._addressMap = new Map, this._defaultKeyName = "web3js_wallet"
    }
    static getStorage() {
        let t;
        try {
            t = window.localStorage;
            const n = "__storage_test__";
            return t.setItem(n, n), t.removeItem(n), t
        } catch (n) {
            return n && (n.code === 22 || n.code === 1014 || n.name === "QuotaExceededError" || n.name === "NS_ERROR_DOM_QUOTA_REACHED") && !F(t) && t.length !== 0 ? t : void 0
        }
    }
    create(t) {
        for (let n = 0; n < t; n += 1) this.add(this._accountProvider.create());
        return this
    }
    add(t) {
        var n;
        if (typeof t == "string") return this.add(this._accountProvider.privateKeyToAccount(t));
        let r = this.length;
        return this.get(t.address) && (console.warn(`Account ${t.address.toLowerCase()} already exists.`), r = (n = this._addressMap.get(t.address.toLowerCase())) !== null && n !== void 0 ? n : r), this._addressMap.set(t.address.toLowerCase(), r), this[r] = t, this
    }
    get(t) {
        if (typeof t == "string") {
            const n = this._addressMap.get(t.toLowerCase());
            return F(n) ? void 0 : this[n]
        }
        return this[t]
    }
    remove(t) {
        if (typeof t == "string") {
            const n = this._addressMap.get(t.toLowerCase());
            return F(n) ? !1 : (this._addressMap.delete(t.toLowerCase()), this.splice(n, 1), !0)
        }
        return this[t] ? (this.splice(t, 1), !0) : !1
    }
    clear() {
        return this._addressMap.clear(), this.length = 0, this
    }
    encrypt(t, n) {
        return zs(this, void 0, void 0, function*() {
            return Promise.all(this.map(r => zs(this, void 0, void 0, function*() {
                return r.encrypt(t, n)
            })))
        })
    }
    decrypt(t, n, r) {
        return zs(this, void 0, void 0, function*() {
            const i = yield Promise.all(t.map(o => zs(this, void 0, void 0, function*() {
                return this._accountProvider.decrypt(o, n, r)
            })));
            for (const o of i) this.add(o);
            return this
        })
    }
    save(t, n) {
        return zs(this, void 0, void 0, function*() {
            const r = dg.getStorage();
            if (!r) throw new Error("Local storage not available.");
            return r.setItem(n ? ? this._defaultKeyName, JSON.stringify(yield this.encrypt(t))), !0
        })
    }
    load(t, n) {
        return zs(this, void 0, void 0, function*() {
            const r = dg.getStorage();
            if (!r) throw new Error("Local storage not available.");
            const i = r.getItem(n ? ? this._defaultKeyName);
            return i && (yield this.decrypt(JSON.parse(i) || [], t)), this
        })
    }
}
const ni = {
    web: zp
};

function ND(e, t, n) {
    if (!n.startsWith("aes-")) throw new Error(`AES submodule doesn't support mode ${n}`);
    if (t.length !== 16) throw new Error("AES: wrong IV length");
    if (n.startsWith("aes-128") && e.length !== 16 || n.startsWith("aes-256") && e.length !== 32) throw new Error("AES: wrong key length")
}
async function RD(e, t, n) {
    if (!ni.web) throw new Error("Browser crypto not available.");
    let r;
    if (["aes-128-cbc", "aes-256-cbc"].includes(e) && (r = "cbc"), ["aes-128-ctr", "aes-256-ctr"].includes(e) && (r = "ctr"), !r) throw new Error("AES: unsupported mode");
    return [await ni.web.subtle.importKey("raw", t, {
        name: `AES-${r.toUpperCase()}`,
        length: t.length * 8
    }, !0, ["encrypt", "decrypt"]), {
        name: `aes-${r}`,
        iv: n,
        counter: n,
        length: 128
    }]
}
async function GS(e, t, n, r = "aes-128-ctr", i = !0) {
    if (ND(t, n, r), ni.web) {
        const [o, a] = await RD(r, t, n), s = await ni.web.subtle.encrypt(a, o, e);
        let u = new Uint8Array(s);
        return !i && a.name === "aes-cbc" && !(e.length % 16) && (u = u.slice(0, -16)), u
    } else if (ni.node) {
        const o = ni.node.createCipheriv(r, t, n);
        return o.setAutoPadding(i), qm(o.update(e), o.final())
    } else throw new Error("The environment doesn't have AES module")
}
async function sZ(e, t, n, r) {
    const i = e.slice(-16);
    for (let a = 0; a < 16; a++) i[a] ^= n[a] ^ 16;
    return (await GS(i, t, n, r)).slice(0, 16)
}
async function uZ(e, t, n, r = "aes-128-ctr", i = !0) {
    if (ND(t, n, r), ni.web) {
        const [o, a] = await RD(r, t, n);
        if (!i && a.name === "aes-cbc") {
            const l = await sZ(e, t, n, r);
            e = qm(e, l)
        }
        const s = await ni.web.subtle.decrypt(a, o, e),
            u = new Uint8Array(s);
        if (a.name === "aes-cbc") {
            const l = await GS(u, t, n, r);
            if (!lY(l, e)) throw new Error("AES: wrong padding")
        }
        return u
    } else if (ni.node) {
        const o = ni.node.createDecipheriv(r, t, n);
        return o.setAutoPadding(i), qm(o.update(e), o.final())
    } else throw new Error("The environment doesn't have AES module")
}
class jD extends kS {
    constructor(t, n) {
        super(), this.finished = !1, this.destroyed = !1, PS(t);
        const r = Zu(n);
        if (this.iHash = t.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const i = this.blockLen,
            o = new Uint8Array(i);
        o.set(r.length > i ? t.create().update(r).digest() : r);
        for (let a = 0; a < o.length; a++) o[a] ^= 54;
        this.iHash.update(o), this.oHash = t.create();
        for (let a = 0; a < o.length; a++) o[a] ^= 106;
        this.oHash.update(o), o.fill(0)
    }
    update(t) {
        return vs(this), this.iHash.update(t), this
    }
    digestInto(t) {
        vs(this), Vl(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy()
    }
    digest() {
        const t = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(t), t
    }
    _cloneInto(t) {
        t || (t = Object.create(Object.getPrototypeOf(this), {}));
        const {
            oHash: n,
            iHash: r,
            finished: i,
            destroyed: o,
            blockLen: a,
            outputLen: s
        } = this;
        return t = t, t.finished = i, t.destroyed = o, t.blockLen = a, t.outputLen = s, t.oHash = n._cloneInto(t.oHash), t.iHash = r._cloneInto(t.iHash), t
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
    }
}
const qS = (e, t, n) => new jD(e, t).update(n).digest();
qS.create = (e, t) => new jD(e, t);

function lZ(e, t, n, r) {
    PS(e);
    const i = L3({
            dkLen: 32,
            asyncTick: 10
        }, r),
        {
            c: o,
            dkLen: a,
            asyncTick: s
        } = i;
    if (_n(o), _n(a), _n(s), o < 1) throw new Error("PBKDF2: iterations (c) should be >= 1");
    const u = Zu(t),
        l = Zu(n),
        c = new Uint8Array(a),
        f = qS.create(e, u),
        d = f._cloneInto().update(l);
    return {
        c: o,
        dkLen: a,
        asyncTick: s,
        DK: c,
        PRF: f,
        PRFSalt: d
    }
}

function cZ(e, t, n, r, i) {
    return e.destroy(), t.destroy(), r && r.destroy(), i.fill(0), n
}

function KS(e, t, n, r) {
    const {
        c: i,
        dkLen: o,
        DK: a,
        PRF: s,
        PRFSalt: u
    } = lZ(e, t, n, r);
    let l;
    const c = new Uint8Array(4),
        f = Gp(c),
        d = new Uint8Array(s.outputLen);
    for (let h = 1, m = 0; m < o; h++, m += s.outputLen) {
        const p = a.subarray(m, m + s.outputLen);
        f.setInt32(0, h, !1), (l = u._cloneInto(l)).update(c).digestInto(d), p.set(d.subarray(0, p.length));
        for (let y = 1; y < i; y++) {
            s._cloneInto(l).update(d).digestInto(d);
            for (let g = 0; g < p.length; g++) p[g] ^= d[g]
        }
    }
    return cZ(s, u, a, l, d)
}

function fZ(e, t, n, r) {
    if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, n, r);
    const i = BigInt(32),
        o = BigInt(4294967295),
        a = Number(n >> i & o),
        s = Number(n & o),
        u = r ? 4 : 0,
        l = r ? 0 : 4;
    e.setUint32(t + u, a, r), e.setUint32(t + l, s, r)
}
const dZ = (e, t, n) => e & t ^ ~e & n,
    hZ = (e, t, n) => e & t ^ e & n ^ t & n;
class pZ extends kS {
    constructor(t, n, r, i) {
        super(), this.blockLen = t, this.outputLen = n, this.padOffset = r, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = Gp(this.buffer)
    }
    update(t) {
        vs(this);
        const {
            view: n,
            buffer: r,
            blockLen: i
        } = this;
        t = Zu(t);
        const o = t.length;
        for (let a = 0; a < o;) {
            const s = Math.min(i - this.pos, o - a);
            if (s === i) {
                const u = Gp(t);
                for (; i <= o - a; a += i) this.process(u, a);
                continue
            }
            r.set(t.subarray(a, a + s), this.pos), this.pos += s, a += s, this.pos === i && (this.process(n, 0), this.pos = 0)
        }
        return this.length += t.length, this.roundClean(), this
    }
    digestInto(t) {
        vs(this), OS(t, this), this.finished = !0;
        const {
            buffer: n,
            view: r,
            blockLen: i,
            isLE: o
        } = this;
        let {
            pos: a
        } = this;
        n[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > i - a && (this.process(r, 0), a = 0);
        for (let f = a; f < i; f++) n[f] = 0;
        fZ(r, i - 8, BigInt(this.length * 8), o), this.process(r, 0);
        const s = Gp(t),
            u = this.outputLen;
        if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const l = u / 4,
            c = this.get();
        if (l > c.length) throw new Error("_sha2: outputLen bigger than state");
        for (let f = 0; f < l; f++) s.setUint32(4 * f, c[f], o)
    }
    digest() {
        const {
            buffer: t,
            outputLen: n
        } = this;
        this.digestInto(t);
        const r = t.slice(0, n);
        return this.destroy(), r
    }
    _cloneInto(t) {
        t || (t = new this.constructor), t.set(...this.get());
        const {
            blockLen: n,
            buffer: r,
            length: i,
            finished: o,
            destroyed: a,
            pos: s
        } = this;
        return t.length = i, t.pos = s, t.finished = o, t.destroyed = a, i % n && t.buffer.set(r), t
    }
}
const mZ = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
    So = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
    _o = new Uint32Array(64);
class gZ extends pZ {
    constructor() {
        super(64, 32, 8, !1), this.A = So[0] | 0, this.B = So[1] | 0, this.C = So[2] | 0, this.D = So[3] | 0, this.E = So[4] | 0, this.F = So[5] | 0, this.G = So[6] | 0, this.H = So[7] | 0
    }
    get() {
        const {
            A: t,
            B: n,
            C: r,
            D: i,
            E: o,
            F: a,
            G: s,
            H: u
        } = this;
        return [t, n, r, i, o, a, s, u]
    }
    set(t, n, r, i, o, a, s, u) {
        this.A = t | 0, this.B = n | 0, this.C = r | 0, this.D = i | 0, this.E = o | 0, this.F = a | 0, this.G = s | 0, this.H = u | 0
    }
    process(t, n) {
        for (let f = 0; f < 16; f++, n += 4) _o[f] = t.getUint32(n, !1);
        for (let f = 16; f < 64; f++) {
            const d = _o[f - 15],
                h = _o[f - 2],
                m = Vr(d, 7) ^ Vr(d, 18) ^ d >>> 3,
                p = Vr(h, 17) ^ Vr(h, 19) ^ h >>> 10;
            _o[f] = p + _o[f - 7] + m + _o[f - 16] | 0
        }
        let {
            A: r,
            B: i,
            C: o,
            D: a,
            E: s,
            F: u,
            G: l,
            H: c
        } = this;
        for (let f = 0; f < 64; f++) {
            const d = Vr(s, 6) ^ Vr(s, 11) ^ Vr(s, 25),
                h = c + d + dZ(s, u, l) + mZ[f] + _o[f] | 0,
                p = (Vr(r, 2) ^ Vr(r, 13) ^ Vr(r, 22)) + hZ(r, i, o) | 0;
            c = l, l = u, u = s, s = a + h | 0, a = o, o = i, i = r, r = h + p | 0
        }
        r = r + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, a = a + this.D | 0, s = s + this.E | 0, u = u + this.F | 0, l = l + this.G | 0, c = c + this.H | 0, this.set(r, i, o, a, s, u, l, c)
    }
    roundClean() {
        _o.fill(0)
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
    }
}
const yv = F3(() => new gZ);

function BD(e, t, n, r, i) {
    if (!["sha256", "sha512"].includes(i)) throw new Error("Only sha256 and sha512 are supported");
    return Km(e), Km(t), KS(yv, e, t, {
        c: n,
        dkLen: r
    })
}

function $O(e, t, n, r, i, o) {
    let a = e[t++] ^ n[r++],
        s = e[t++] ^ n[r++],
        u = e[t++] ^ n[r++],
        l = e[t++] ^ n[r++],
        c = e[t++] ^ n[r++],
        f = e[t++] ^ n[r++],
        d = e[t++] ^ n[r++],
        h = e[t++] ^ n[r++],
        m = e[t++] ^ n[r++],
        p = e[t++] ^ n[r++],
        y = e[t++] ^ n[r++],
        g = e[t++] ^ n[r++],
        b = e[t++] ^ n[r++],
        v = e[t++] ^ n[r++],
        A = e[t++] ^ n[r++],
        w = e[t++] ^ n[r++],
        x = a,
        T = s,
        _ = u,
        O = l,
        k = c,
        I = f,
        M = d,
        B = h,
        L = m,
        P = p,
        C = y,
        j = g,
        N = b,
        D = v,
        $ = A,
        V = w;
    for (let H = 0; H < 8; H += 2) k ^= Ce(x + N | 0, 7), L ^= Ce(k + x | 0, 9), N ^= Ce(L + k | 0, 13), x ^= Ce(N + L | 0, 18), P ^= Ce(I + T | 0, 7), D ^= Ce(P + I | 0, 9), T ^= Ce(D + P | 0, 13), I ^= Ce(T + D | 0, 18), $ ^= Ce(C + M | 0, 7), _ ^= Ce($ + C | 0, 9), M ^= Ce(_ + $ | 0, 13), C ^= Ce(M + _ | 0, 18), O ^= Ce(V + j | 0, 7), B ^= Ce(O + V | 0, 9), j ^= Ce(B + O | 0, 13), V ^= Ce(j + B | 0, 18), T ^= Ce(x + O | 0, 7), _ ^= Ce(T + x | 0, 9), O ^= Ce(_ + T | 0, 13), x ^= Ce(O + _ | 0, 18), M ^= Ce(I + k | 0, 7), B ^= Ce(M + I | 0, 9), k ^= Ce(B + M | 0, 13), I ^= Ce(k + B | 0, 18), j ^= Ce(C + P | 0, 7), L ^= Ce(j + C | 0, 9), P ^= Ce(L + j | 0, 13), C ^= Ce(P + L | 0, 18), N ^= Ce(V + $ | 0, 7), D ^= Ce(N + V | 0, 9), $ ^= Ce(D + N | 0, 13), V ^= Ce($ + D | 0, 18);
    i[o++] = a + x | 0, i[o++] = s + T | 0, i[o++] = u + _ | 0, i[o++] = l + O | 0, i[o++] = c + k | 0, i[o++] = f + I | 0, i[o++] = d + M | 0, i[o++] = h + B | 0, i[o++] = m + L | 0, i[o++] = p + P | 0, i[o++] = y + C | 0, i[o++] = g + j | 0, i[o++] = b + N | 0, i[o++] = v + D | 0, i[o++] = A + $ | 0, i[o++] = w + V | 0
}

function gb(e, t, n, r, i) {
    let o = r + 0,
        a = r + 16 * i;
    for (let s = 0; s < 16; s++) n[a + s] = e[t + (2 * i - 1) * 16 + s];
    for (let s = 0; s < i; s++, o += 16, t += 16) $O(n, a, e, t, n, o), s > 0 && (a += 16), $O(n, o, e, t += 16, n, a)
}

function yZ(e, t, n) {
    const r = L3({
            dkLen: 32,
            asyncTick: 10,
            maxmem: 1073742848
        }, n),
        {
            N: i,
            r: o,
            p: a,
            dkLen: s,
            asyncTick: u,
            maxmem: l,
            onProgress: c
        } = r;
    if (_n(i), _n(o), _n(a), _n(s), _n(u), _n(l), c !== void 0 && typeof c != "function") throw new Error("progressCb should be function");
    const f = 128 * o,
        d = f / 4;
    if (i <= 1 || i & i - 1 || i >= 2 ** (f / 8) || i > 2 ** 32) throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
    if (a < 0 || a > (2 ** 32 - 1) * 32 / f) throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
    if (s < 0 || s > (2 ** 32 - 1) * 32) throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
    const h = f * (i + a);
    if (h > l) throw new Error(`Scrypt: parameters too large, ${h} (128 * r * (N + p)) > ${l} (maxmem)`);
    const m = KS(yv, e, t, {
            c: 1,
            dkLen: f * a
        }),
        p = Wp(m),
        y = Wp(new Uint8Array(f * i)),
        g = Wp(new Uint8Array(f));
    let b = () => {};
    if (c) {
        const v = 2 * i * a,
            A = Math.max(Math.floor(v / 1e4), 1);
        let w = 0;
        b = () => {
            w++, c && (!(w % A) || w === v) && c(w / v)
        }
    }
    return {
        N: i,
        r: o,
        p: a,
        dkLen: s,
        blockSize32: d,
        V: y,
        B32: p,
        B: m,
        tmp: g,
        blockMixCb: b,
        asyncTick: u
    }
}

function vZ(e, t, n, r, i) {
    const o = KS(yv, e, n, {
        c: 1,
        dkLen: t
    });
    return n.fill(0), r.fill(0), i.fill(0), o
}

function bZ(e, t, n) {
    const {
        N: r,
        r: i,
        p: o,
        dkLen: a,
        blockSize32: s,
        V: u,
        B32: l,
        B: c,
        tmp: f,
        blockMixCb: d
    } = yZ(e, t, n);
    Wm || Gm(l);
    for (let h = 0; h < o; h++) {
        const m = s * h;
        for (let p = 0; p < s; p++) u[p] = l[m + p];
        for (let p = 0, y = 0; p < r - 1; p++) gb(u, y, u, y += s, i), d();
        gb(u, (r - 1) * s, l, m, i), d();
        for (let p = 0; p < r; p++) {
            const y = l[m + s - 16] % r;
            for (let g = 0; g < s; g++) f[g] = l[m + g] ^ u[y * s + g];
            gb(f, 0, l, m, i), d()
        }
    }
    return Wm || Gm(l), vZ(e, a, c, u, f)
}

function DD(e, t, n, r, i, o, a) {
    return Km(e), Km(t), bZ(e, t, {
        N: n,
        r: i,
        p: r,
        dkLen: o,
        onProgress: a
    })
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const $D = BigInt(0),
    vv = BigInt(1),
    wZ = BigInt(2);

function Ts(e) {
    return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array"
}

function bh(e) {
    if (!Ts(e)) throw new Error("Uint8Array expected")
}
const xZ = Array.from({
    length: 256
}, (e, t) => t.toString(16).padStart(2, "0"));

function al(e) {
    bh(e);
    let t = "";
    for (let n = 0; n < e.length; n++) t += xZ[e[n]];
    return t
}

function LD(e) {
    const t = e.toString(16);
    return t.length & 1 ? `0${t}` : t
}

function QS(e) {
    if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
    return BigInt(e === "" ? "0" : `0x${e}`)
}
const Si = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};

function LO(e) {
    if (e >= Si._0 && e <= Si._9) return e - Si._0;
    if (e >= Si._A && e <= Si._F) return e - (Si._A - 10);
    if (e >= Si._a && e <= Si._f) return e - (Si._a - 10)
}

function sl(e) {
    if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
    const t = e.length,
        n = t / 2;
    if (t % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t);
    const r = new Uint8Array(n);
    for (let i = 0, o = 0; i < n; i++, o += 2) {
        const a = LO(e.charCodeAt(o)),
            s = LO(e.charCodeAt(o + 1));
        if (a === void 0 || s === void 0) {
            const u = e[o] + e[o + 1];
            throw new Error('hex string expected, got non-hex character "' + u + '" at index ' + o)
        }
        r[i] = a * 16 + s
    }
    return r
}

function os(e) {
    return QS(al(e))
}

function YS(e) {
    return bh(e), QS(al(Uint8Array.from(e).reverse()))
}

function ul(e, t) {
    return sl(e.toString(16).padStart(t * 2, "0"))
}

function XS(e, t) {
    return ul(e, t).reverse()
}

function AZ(e) {
    return sl(LD(e))
}

function _r(e, t, n) {
    let r;
    if (typeof t == "string") try {
            r = sl(t)
        } catch (o) {
            throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${o}`)
        } else if (Ts(t)) r = Uint8Array.from(t);
        else throw new Error(`${e} must be hex string or Uint8Array`);
    const i = r.length;
    if (typeof n == "number" && i !== n) throw new Error(`${e} expected ${n} bytes, got ${i}`);
    return r
}

function cd(...e) {
    let t = 0;
    for (let r = 0; r < e.length; r++) {
        const i = e[r];
        bh(i), t += i.length
    }
    const n = new Uint8Array(t);
    for (let r = 0, i = 0; r < e.length; r++) {
        const o = e[r];
        n.set(o, i), i += o.length
    }
    return n
}

function EZ(e, t) {
    if (e.length !== t.length) return !1;
    let n = 0;
    for (let r = 0; r < e.length; r++) n |= e[r] ^ t[r];
    return n === 0
}

function SZ(e) {
    if (typeof e != "string") throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
    return new Uint8Array(new TextEncoder().encode(e))
}

function _Z(e) {
    let t;
    for (t = 0; e > $D; e >>= vv, t += 1);
    return t
}

function TZ(e, t) {
    return e >> BigInt(t) & vv
}

function PZ(e, t, n) {
    return e | (n ? vv : $D) << BigInt(t)
}
const ZS = e => (wZ << BigInt(e - 1)) - vv,
    yb = e => new Uint8Array(e),
    FO = e => Uint8Array.from(e);

function FD(e, t, n) {
    if (typeof e != "number" || e < 2) throw new Error("hashLen must be a number");
    if (typeof t != "number" || t < 2) throw new Error("qByteLen must be a number");
    if (typeof n != "function") throw new Error("hmacFn must be a function");
    let r = yb(e),
        i = yb(e),
        o = 0;
    const a = () => {
            r.fill(1), i.fill(0), o = 0
        },
        s = (...f) => n(i, r, ...f),
        u = (f = yb()) => {
            i = s(FO([0]), f), r = s(), f.length !== 0 && (i = s(FO([1]), f), r = s())
        },
        l = () => {
            if (o++ >= 1e3) throw new Error("drbg: tried 1000 values");
            let f = 0;
            const d = [];
            for (; f < t;) {
                r = s();
                const h = r.slice();
                d.push(h), f += r.length
            }
            return cd(...d)
        };
    return (f, d) => {
        a(), u(f);
        let h;
        for (; !(h = d(l()));) u();
        return a(), h
    }
}
const OZ = {
    bigint: e => typeof e == "bigint",
    function: e => typeof e == "function",
    boolean: e => typeof e == "boolean",
    string: e => typeof e == "string",
    stringOrUint8Array: e => typeof e == "string" || Ts(e),
    isSafeInteger: e => Number.isSafeInteger(e),
    array: e => Array.isArray(e),
    field: (e, t) => t.Fp.isValid(e),
    hash: e => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};

function wh(e, t, n = {}) {
    const r = (i, o, a) => {
        const s = OZ[o];
        if (typeof s != "function") throw new Error(`Invalid validator "${o}", expected function`);
        const u = e[i];
        if (!(a && u === void 0) && !s(u, e)) throw new Error(`Invalid param ${String(i)}=${u} (${typeof u}), expected ${o}`)
    };
    for (const [i, o] of Object.entries(t)) r(i, o, !1);
    for (const [i, o] of Object.entries(n)) r(i, o, !0);
    return e
}
const kZ = Object.freeze(Object.defineProperty({
    __proto__: null,
    abytes: bh,
    bitGet: TZ,
    bitLen: _Z,
    bitMask: ZS,
    bitSet: PZ,
    bytesToHex: al,
    bytesToNumberBE: os,
    bytesToNumberLE: YS,
    concatBytes: cd,
    createHmacDrbg: FD,
    ensureBytes: _r,
    equalBytes: EZ,
    hexToBytes: sl,
    hexToNumber: QS,
    isBytes: Ts,
    numberToBytesBE: ul,
    numberToBytesLE: XS,
    numberToHexUnpadded: LD,
    numberToVarBytesBE: AZ,
    utf8ToBytes: SZ,
    validateObject: wh
}, Symbol.toStringTag, {
    value: "Module"
})); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Lt = BigInt(0),
    At = BigInt(1),
    ja = BigInt(2),
    CZ = BigInt(3),
    Nx = BigInt(4),
    UO = BigInt(5),
    HO = BigInt(8);
BigInt(9);
BigInt(16);

function En(e, t) {
    const n = e % t;
    return n >= Lt ? n : t + n
}

function IZ(e, t, n) {
    if (n <= Lt || t < Lt) throw new Error("Expected power/modulo > 0");
    if (n === At) return Lt;
    let r = At;
    for (; t > Lt;) t & At && (r = r * e % n), e = e * e % n, t >>= At;
    return r
}

function Xn(e, t, n) {
    let r = e;
    for (; t-- > Lt;) r *= r, r %= n;
    return r
}

function Rx(e, t) {
    if (e === Lt || t <= Lt) throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
    let n = En(e, t),
        r = t,
        i = Lt,
        o = At;
    for (; n !== Lt;) {
        const s = r / n,
            u = r % n,
            l = i - o * s;
        r = n, n = u, i = o, o = l
    }
    if (r !== At) throw new Error("invert: does not exist");
    return En(i, t)
}

function MZ(e) {
    const t = (e - At) / ja;
    let n, r, i;
    for (n = e - At, r = 0; n % ja === Lt; n /= ja, r++);
    for (i = ja; i < e && IZ(i, t, e) !== e - At; i++);
    if (r === 1) {
        const a = (e + At) / Nx;
        return function(u, l) {
            const c = u.pow(l, a);
            if (!u.eql(u.sqr(c), l)) throw new Error("Cannot find square root");
            return c
        }
    }
    const o = (n + At) / ja;
    return function(s, u) {
        if (s.pow(u, t) === s.neg(s.ONE)) throw new Error("Cannot find square root");
        let l = r,
            c = s.pow(s.mul(s.ONE, i), n),
            f = s.pow(u, o),
            d = s.pow(u, n);
        for (; !s.eql(d, s.ONE);) {
            if (s.eql(d, s.ZERO)) return s.ZERO;
            let h = 1;
            for (let p = s.sqr(d); h < l && !s.eql(p, s.ONE); h++) p = s.sqr(p);
            const m = s.pow(c, At << BigInt(l - h - 1));
            c = s.sqr(m), f = s.mul(f, m), d = s.mul(d, c), l = h
        }
        return f
    }
}

function NZ(e) {
    if (e % Nx === CZ) {
        const t = (e + At) / Nx;
        return function(r, i) {
            const o = r.pow(i, t);
            if (!r.eql(r.sqr(o), i)) throw new Error("Cannot find square root");
            return o
        }
    }
    if (e % HO === UO) {
        const t = (e - UO) / HO;
        return function(r, i) {
            const o = r.mul(i, ja),
                a = r.pow(o, t),
                s = r.mul(i, a),
                u = r.mul(r.mul(s, ja), a),
                l = r.mul(s, r.sub(u, r.ONE));
            if (!r.eql(r.sqr(l), i)) throw new Error("Cannot find square root");
            return l
        }
    }
    return MZ(e)
}
const RZ = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

function jZ(e) {
    const t = {
            ORDER: "bigint",
            MASK: "bigint",
            BYTES: "isSafeInteger",
            BITS: "isSafeInteger"
        },
        n = RZ.reduce((r, i) => (r[i] = "function", r), t);
    return wh(e, n)
}

function BZ(e, t, n) {
    if (n < Lt) throw new Error("Expected power > 0");
    if (n === Lt) return e.ONE;
    if (n === At) return t;
    let r = e.ONE,
        i = t;
    for (; n > Lt;) n & At && (r = e.mul(r, i)), i = e.sqr(i), n >>= At;
    return r
}

function DZ(e, t) {
    const n = new Array(t.length),
        r = t.reduce((o, a, s) => e.is0(a) ? o : (n[s] = o, e.mul(o, a)), e.ONE),
        i = e.inv(r);
    return t.reduceRight((o, a, s) => e.is0(a) ? o : (n[s] = e.mul(o, n[s]), e.mul(o, a)), i), n
}

function UD(e, t) {
    const n = t !== void 0 ? t : e.toString(2).length,
        r = Math.ceil(n / 8);
    return {
        nBitLength: n,
        nByteLength: r
    }
}

function $Z(e, t, n = !1, r = {}) {
    if (e <= Lt) throw new Error(`Expected Field ORDER > 0, got ${e}`);
    const {
        nBitLength: i,
        nByteLength: o
    } = UD(e, t);
    if (o > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
    const a = NZ(e),
        s = Object.freeze({
            ORDER: e,
            BITS: i,
            BYTES: o,
            MASK: ZS(i),
            ZERO: Lt,
            ONE: At,
            create: u => En(u, e),
            isValid: u => {
                if (typeof u != "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof u}`);
                return Lt <= u && u < e
            },
            is0: u => u === Lt,
            isOdd: u => (u & At) === At,
            neg: u => En(-u, e),
            eql: (u, l) => u === l,
            sqr: u => En(u * u, e),
            add: (u, l) => En(u + l, e),
            sub: (u, l) => En(u - l, e),
            mul: (u, l) => En(u * l, e),
            pow: (u, l) => BZ(s, u, l),
            div: (u, l) => En(u * Rx(l, e), e),
            sqrN: u => u * u,
            addN: (u, l) => u + l,
            subN: (u, l) => u - l,
            mulN: (u, l) => u * l,
            inv: u => Rx(u, e),
            sqrt: r.sqrt || (u => a(s, u)),
            invertBatch: u => DZ(s, u),
            cmov: (u, l, c) => c ? l : u,
            toBytes: u => n ? XS(u, o) : ul(u, o),
            fromBytes: u => {
                if (u.length !== o) throw new Error(`Fp.fromBytes: expected ${o}, got ${u.length}`);
                return n ? YS(u) : os(u)
            }
        });
    return Object.freeze(s)
}

function HD(e) {
    if (typeof e != "bigint") throw new Error("field order must be bigint");
    const t = e.toString(2).length;
    return Math.ceil(t / 8)
}

function VD(e) {
    const t = HD(e);
    return t + Math.ceil(t / 2)
}

function LZ(e, t, n = !1) {
    const r = e.length,
        i = HD(t),
        o = VD(t);
    if (r < 16 || r < o || r > 1024) throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);
    const a = n ? os(e) : YS(e),
        s = En(a, t - At) + At;
    return n ? XS(s, i) : ul(s, i)
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const FZ = BigInt(0),
    vb = BigInt(1);

function UZ(e, t) {
    const n = (i, o) => {
            const a = o.negate();
            return i ? a : o
        },
        r = i => {
            const o = Math.ceil(t / i) + 1,
                a = 2 ** (i - 1);
            return {
                windows: o,
                windowSize: a
            }
        };
    return {
        constTimeNegate: n,
        unsafeLadder(i, o) {
            let a = e.ZERO,
                s = i;
            for (; o > FZ;) o & vb && (a = a.add(s)), s = s.double(), o >>= vb;
            return a
        },
        precomputeWindow(i, o) {
            const {
                windows: a,
                windowSize: s
            } = r(o), u = [];
            let l = i,
                c = l;
            for (let f = 0; f < a; f++) {
                c = l, u.push(c);
                for (let d = 1; d < s; d++) c = c.add(l), u.push(c);
                l = c.double()
            }
            return u
        },
        wNAF(i, o, a) {
            const {
                windows: s,
                windowSize: u
            } = r(i);
            let l = e.ZERO,
                c = e.BASE;
            const f = BigInt(2 ** i - 1),
                d = 2 ** i,
                h = BigInt(i);
            for (let m = 0; m < s; m++) {
                const p = m * u;
                let y = Number(a & f);
                a >>= h, y > u && (y -= d, a += vb);
                const g = p,
                    b = p + Math.abs(y) - 1,
                    v = m % 2 !== 0,
                    A = y < 0;
                y === 0 ? c = c.add(n(v, o[g])) : l = l.add(n(A, o[b]))
            }
            return {
                p: l,
                f: c
            }
        },
        wNAFCached(i, o, a, s) {
            const u = i._WINDOW_SIZE || 1;
            let l = o.get(i);
            return l || (l = this.precomputeWindow(i, u), u !== 1 && o.set(i, s(l))), this.wNAF(u, l, a)
        }
    }
}

function zD(e) {
    return jZ(e.Fp), wh(e, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }), Object.freeze({ ...UD(e.n, e.nBitLength),
        ...e,
        p: e.Fp.ORDER
    })
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function HZ(e) {
    const t = zD(e);
    wh(t, {
        a: "field",
        b: "field"
    }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
    });
    const {
        endo: n,
        Fp: r,
        a: i
    } = t;
    if (n) {
        if (!r.eql(i, r.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if (typeof n != "object" || typeof n.beta != "bigint" || typeof n.splitScalar != "function") throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
    }
    return Object.freeze({ ...t
    })
}
const {
    bytesToNumberBE: VZ,
    hexToBytes: zZ
} = kZ, Ha = {
    Err: class extends Error {
        constructor(t = "") {
            super(t)
        }
    },
    _parseInt(e) {
        const {
            Err: t
        } = Ha;
        if (e.length < 2 || e[0] !== 2) throw new t("Invalid signature integer tag");
        const n = e[1],
            r = e.subarray(2, n + 2);
        if (!n || r.length !== n) throw new t("Invalid signature integer: wrong length");
        if (r[0] & 128) throw new t("Invalid signature integer: negative");
        if (r[0] === 0 && !(r[1] & 128)) throw new t("Invalid signature integer: unnecessary leading zero");
        return {
            d: VZ(r),
            l: e.subarray(n + 2)
        }
    },
    toSig(e) {
        const {
            Err: t
        } = Ha, n = typeof e == "string" ? zZ(e) : e;
        bh(n);
        let r = n.length;
        if (r < 2 || n[0] != 48) throw new t("Invalid signature tag");
        if (n[1] !== r - 2) throw new t("Invalid signature: incorrect length");
        const {
            d: i,
            l: o
        } = Ha._parseInt(n.subarray(2)), {
            d: a,
            l: s
        } = Ha._parseInt(o);
        if (s.length) throw new t("Invalid signature: left bytes after parsing");
        return {
            r: i,
            s: a
        }
    },
    hexFromSig(e) {
        const t = l => Number.parseInt(l[0], 16) & 8 ? "00" + l : l,
            n = l => {
                const c = l.toString(16);
                return c.length & 1 ? `0${c}` : c
            },
            r = t(n(e.s)),
            i = t(n(e.r)),
            o = r.length / 2,
            a = i.length / 2,
            s = n(o),
            u = n(a);
        return `30${n(a+o+4)}02${u}${i}02${s}${r}`
    }
}, Ni = BigInt(0), nr = BigInt(1);
BigInt(2);
const VO = BigInt(3);
BigInt(4);

function WZ(e) {
    const t = HZ(e),
        {
            Fp: n
        } = t,
        r = t.toBytes || ((m, p, y) => {
            const g = p.toAffine();
            return cd(Uint8Array.from([4]), n.toBytes(g.x), n.toBytes(g.y))
        }),
        i = t.fromBytes || (m => {
            const p = m.subarray(1),
                y = n.fromBytes(p.subarray(0, n.BYTES)),
                g = n.fromBytes(p.subarray(n.BYTES, 2 * n.BYTES));
            return {
                x: y,
                y: g
            }
        });

    function o(m) {
        const {
            a: p,
            b: y
        } = t, g = n.sqr(m), b = n.mul(g, m);
        return n.add(n.add(b, n.mul(m, p)), y)
    }
    if (!n.eql(n.sqr(t.Gy), o(t.Gx))) throw new Error("bad generator point: equation left != right");

    function a(m) {
        return typeof m == "bigint" && Ni < m && m < t.n
    }

    function s(m) {
        if (!a(m)) throw new Error("Expected valid bigint: 0 < bigint < curve.n")
    }

    function u(m) {
        const {
            allowedPrivateKeyLengths: p,
            nByteLength: y,
            wrapPrivateKey: g,
            n: b
        } = t;
        if (p && typeof m != "bigint") {
            if (Ts(m) && (m = al(m)), typeof m != "string" || !p.includes(m.length)) throw new Error("Invalid key");
            m = m.padStart(y * 2, "0")
        }
        let v;
        try {
            v = typeof m == "bigint" ? m : os(_r("private key", m, y))
        } catch {
            throw new Error(`private key must be ${y} bytes, hex or bigint, not ${typeof m}`)
        }
        return g && (v = En(v, b)), s(v), v
    }
    const l = new Map;

    function c(m) {
        if (!(m instanceof f)) throw new Error("ProjectivePoint expected")
    }
    class f {
        constructor(p, y, g) {
            if (this.px = p, this.py = y, this.pz = g, p == null || !n.isValid(p)) throw new Error("x required");
            if (y == null || !n.isValid(y)) throw new Error("y required");
            if (g == null || !n.isValid(g)) throw new Error("z required")
        }
        static fromAffine(p) {
            const {
                x: y,
                y: g
            } = p || {};
            if (!p || !n.isValid(y) || !n.isValid(g)) throw new Error("invalid affine point");
            if (p instanceof f) throw new Error("projective point not allowed");
            const b = v => n.eql(v, n.ZERO);
            return b(y) && b(g) ? f.ZERO : new f(y, g, n.ONE)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static normalizeZ(p) {
            const y = n.invertBatch(p.map(g => g.pz));
            return p.map((g, b) => g.toAffine(y[b])).map(f.fromAffine)
        }
        static fromHex(p) {
            const y = f.fromAffine(i(_r("pointHex", p)));
            return y.assertValidity(), y
        }
        static fromPrivateKey(p) {
            return f.BASE.multiply(u(p))
        }
        _setWindowSize(p) {
            this._WINDOW_SIZE = p, l.delete(this)
        }
        assertValidity() {
            if (this.is0()) {
                if (t.allowInfinityPoint && !n.is0(this.py)) return;
                throw new Error("bad point: ZERO")
            }
            const {
                x: p,
                y
            } = this.toAffine();
            if (!n.isValid(p) || !n.isValid(y)) throw new Error("bad point: x or y not FE");
            const g = n.sqr(y),
                b = o(p);
            if (!n.eql(g, b)) throw new Error("bad point: equation left != right");
            if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup")
        }
        hasEvenY() {
            const {
                y: p
            } = this.toAffine();
            if (n.isOdd) return !n.isOdd(p);
            throw new Error("Field doesn't support isOdd")
        }
        equals(p) {
            c(p);
            const {
                px: y,
                py: g,
                pz: b
            } = this, {
                px: v,
                py: A,
                pz: w
            } = p, x = n.eql(n.mul(y, w), n.mul(v, b)), T = n.eql(n.mul(g, w), n.mul(A, b));
            return x && T
        }
        negate() {
            return new f(this.px, n.neg(this.py), this.pz)
        }
        double() {
            const {
                a: p,
                b: y
            } = t, g = n.mul(y, VO), {
                px: b,
                py: v,
                pz: A
            } = this;
            let w = n.ZERO,
                x = n.ZERO,
                T = n.ZERO,
                _ = n.mul(b, b),
                O = n.mul(v, v),
                k = n.mul(A, A),
                I = n.mul(b, v);
            return I = n.add(I, I), T = n.mul(b, A), T = n.add(T, T), w = n.mul(p, T), x = n.mul(g, k), x = n.add(w, x), w = n.sub(O, x), x = n.add(O, x), x = n.mul(w, x), w = n.mul(I, w), T = n.mul(g, T), k = n.mul(p, k), I = n.sub(_, k), I = n.mul(p, I), I = n.add(I, T), T = n.add(_, _), _ = n.add(T, _), _ = n.add(_, k), _ = n.mul(_, I), x = n.add(x, _), k = n.mul(v, A), k = n.add(k, k), _ = n.mul(k, I), w = n.sub(w, _), T = n.mul(k, O), T = n.add(T, T), T = n.add(T, T), new f(w, x, T)
        }
        add(p) {
            c(p);
            const {
                px: y,
                py: g,
                pz: b
            } = this, {
                px: v,
                py: A,
                pz: w
            } = p;
            let x = n.ZERO,
                T = n.ZERO,
                _ = n.ZERO;
            const O = t.a,
                k = n.mul(t.b, VO);
            let I = n.mul(y, v),
                M = n.mul(g, A),
                B = n.mul(b, w),
                L = n.add(y, g),
                P = n.add(v, A);
            L = n.mul(L, P), P = n.add(I, M), L = n.sub(L, P), P = n.add(y, b);
            let C = n.add(v, w);
            return P = n.mul(P, C), C = n.add(I, B), P = n.sub(P, C), C = n.add(g, b), x = n.add(A, w), C = n.mul(C, x), x = n.add(M, B), C = n.sub(C, x), _ = n.mul(O, P), x = n.mul(k, B), _ = n.add(x, _), x = n.sub(M, _), _ = n.add(M, _), T = n.mul(x, _), M = n.add(I, I), M = n.add(M, I), B = n.mul(O, B), P = n.mul(k, P), M = n.add(M, B), B = n.sub(I, B), B = n.mul(O, B), P = n.add(P, B), I = n.mul(M, P), T = n.add(T, I), I = n.mul(C, P), x = n.mul(L, x), x = n.sub(x, I), I = n.mul(L, M), _ = n.mul(C, _), _ = n.add(_, I), new f(x, T, _)
        }
        subtract(p) {
            return this.add(p.negate())
        }
        is0() {
            return this.equals(f.ZERO)
        }
        wNAF(p) {
            return h.wNAFCached(this, l, p, y => {
                const g = n.invertBatch(y.map(b => b.pz));
                return y.map((b, v) => b.toAffine(g[v])).map(f.fromAffine)
            })
        }
        multiplyUnsafe(p) {
            const y = f.ZERO;
            if (p === Ni) return y;
            if (s(p), p === nr) return this;
            const {
                endo: g
            } = t;
            if (!g) return h.unsafeLadder(this, p);
            let {
                k1neg: b,
                k1: v,
                k2neg: A,
                k2: w
            } = g.splitScalar(p), x = y, T = y, _ = this;
            for (; v > Ni || w > Ni;) v & nr && (x = x.add(_)), w & nr && (T = T.add(_)), _ = _.double(), v >>= nr, w >>= nr;
            return b && (x = x.negate()), A && (T = T.negate()), T = new f(n.mul(T.px, g.beta), T.py, T.pz), x.add(T)
        }
        multiply(p) {
            s(p);
            let y = p,
                g, b;
            const {
                endo: v
            } = t;
            if (v) {
                const {
                    k1neg: A,
                    k1: w,
                    k2neg: x,
                    k2: T
                } = v.splitScalar(y);
                let {
                    p: _,
                    f: O
                } = this.wNAF(w), {
                    p: k,
                    f: I
                } = this.wNAF(T);
                _ = h.constTimeNegate(A, _), k = h.constTimeNegate(x, k), k = new f(n.mul(k.px, v.beta), k.py, k.pz), g = _.add(k), b = O.add(I)
            } else {
                const {
                    p: A,
                    f: w
                } = this.wNAF(y);
                g = A, b = w
            }
            return f.normalizeZ([g, b])[0]
        }
        multiplyAndAddUnsafe(p, y, g) {
            const b = f.BASE,
                v = (w, x) => x === Ni || x === nr || !w.equals(b) ? w.multiplyUnsafe(x) : w.multiply(x),
                A = v(this, y).add(v(p, g));
            return A.is0() ? void 0 : A
        }
        toAffine(p) {
            const {
                px: y,
                py: g,
                pz: b
            } = this, v = this.is0();
            p == null && (p = v ? n.ONE : n.inv(b));
            const A = n.mul(y, p),
                w = n.mul(g, p),
                x = n.mul(b, p);
            if (v) return {
                x: n.ZERO,
                y: n.ZERO
            };
            if (!n.eql(x, n.ONE)) throw new Error("invZ was invalid");
            return {
                x: A,
                y: w
            }
        }
        isTorsionFree() {
            const {
                h: p,
                isTorsionFree: y
            } = t;
            if (p === nr) return !0;
            if (y) return y(f, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve")
        }
        clearCofactor() {
            const {
                h: p,
                clearCofactor: y
            } = t;
            return p === nr ? this : y ? y(f, this) : this.multiplyUnsafe(t.h)
        }
        toRawBytes(p = !0) {
            return this.assertValidity(), r(f, this, p)
        }
        toHex(p = !0) {
            return al(this.toRawBytes(p))
        }
    }
    f.BASE = new f(t.Gx, t.Gy, n.ONE), f.ZERO = new f(n.ZERO, n.ONE, n.ZERO);
    const d = t.nBitLength,
        h = UZ(f, t.endo ? Math.ceil(d / 2) : d);
    return {
        CURVE: t,
        ProjectivePoint: f,
        normPrivateKeyToScalar: u,
        weierstrassEquation: o,
        isWithinCurveOrder: a
    }
}

function GZ(e) {
    const t = zD(e);
    return wh(t, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    }), Object.freeze({
        lowS: !0,
        ...t
    })
}

function qZ(e) {
    const t = GZ(e),
        {
            Fp: n,
            n: r
        } = t,
        i = n.BYTES + 1,
        o = 2 * n.BYTES + 1;

    function a(P) {
        return Ni < P && P < n.ORDER
    }

    function s(P) {
        return En(P, r)
    }

    function u(P) {
        return Rx(P, r)
    }
    const {
        ProjectivePoint: l,
        normPrivateKeyToScalar: c,
        weierstrassEquation: f,
        isWithinCurveOrder: d
    } = WZ({ ...t,
        toBytes(P, C, j) {
            const N = C.toAffine(),
                D = n.toBytes(N.x),
                $ = cd;
            return j ? $(Uint8Array.from([C.hasEvenY() ? 2 : 3]), D) : $(Uint8Array.from([4]), D, n.toBytes(N.y))
        },
        fromBytes(P) {
            const C = P.length,
                j = P[0],
                N = P.subarray(1);
            if (C === i && (j === 2 || j === 3)) {
                const D = os(N);
                if (!a(D)) throw new Error("Point is not on curve");
                const $ = f(D);
                let V;
                try {
                    V = n.sqrt($)
                } catch (X) {
                    const ve = X instanceof Error ? ": " + X.message : "";
                    throw new Error("Point is not on curve" + ve)
                }
                const H = (V & nr) === nr;
                return (j & 1) === 1 !== H && (V = n.neg(V)), {
                    x: D,
                    y: V
                }
            } else if (C === o && j === 4) {
                const D = n.fromBytes(N.subarray(0, n.BYTES)),
                    $ = n.fromBytes(N.subarray(n.BYTES, 2 * n.BYTES));
                return {
                    x: D,
                    y: $
                }
            } else throw new Error(`Point of length ${C} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)
        }
    }), h = P => al(ul(P, t.nByteLength));

    function m(P) {
        const C = r >> nr;
        return P > C
    }

    function p(P) {
        return m(P) ? s(-P) : P
    }
    const y = (P, C, j) => os(P.slice(C, j));
    class g {
        constructor(C, j, N) {
            this.r = C, this.s = j, this.recovery = N, this.assertValidity()
        }
        static fromCompact(C) {
            const j = t.nByteLength;
            return C = _r("compactSignature", C, j * 2), new g(y(C, 0, j), y(C, j, 2 * j))
        }
        static fromDER(C) {
            const {
                r: j,
                s: N
            } = Ha.toSig(_r("DER", C));
            return new g(j, N)
        }
        assertValidity() {
            if (!d(this.r)) throw new Error("r must be 0 < r < CURVE.n");
            if (!d(this.s)) throw new Error("s must be 0 < s < CURVE.n")
        }
        addRecoveryBit(C) {
            return new g(this.r, this.s, C)
        }
        recoverPublicKey(C) {
            const {
                r: j,
                s: N,
                recovery: D
            } = this, $ = T(_r("msgHash", C));
            if (D == null || ![0, 1, 2, 3].includes(D)) throw new Error("recovery id invalid");
            const V = D === 2 || D === 3 ? j + t.n : j;
            if (V >= n.ORDER) throw new Error("recovery id 2 or 3 invalid");
            const H = D & 1 ? "03" : "02",
                Q = l.fromHex(H + h(V)),
                X = u(V),
                ve = s(-$ * X),
                De = s(N * X),
                ot = l.BASE.multiplyAndAddUnsafe(Q, ve, De);
            if (!ot) throw new Error("point at infinify");
            return ot.assertValidity(), ot
        }
        hasHighS() {
            return m(this.s)
        }
        normalizeS() {
            return this.hasHighS() ? new g(this.r, s(-this.s), this.recovery) : this
        }
        toDERRawBytes() {
            return sl(this.toDERHex())
        }
        toDERHex() {
            return Ha.hexFromSig({
                r: this.r,
                s: this.s
            })
        }
        toCompactRawBytes() {
            return sl(this.toCompactHex())
        }
        toCompactHex() {
            return h(this.r) + h(this.s)
        }
    }
    const b = {
        isValidPrivateKey(P) {
            try {
                return c(P), !0
            } catch {
                return !1
            }
        },
        normPrivateKeyToScalar: c,
        randomPrivateKey: () => {
            const P = VD(t.n);
            return LZ(t.randomBytes(P), t.n)
        },
        precompute(P = 8, C = l.BASE) {
            return C._setWindowSize(P), C.multiply(BigInt(3)), C
        }
    };

    function v(P, C = !0) {
        return l.fromPrivateKey(P).toRawBytes(C)
    }

    function A(P) {
        const C = Ts(P),
            j = typeof P == "string",
            N = (C || j) && P.length;
        return C ? N === i || N === o : j ? N === 2 * i || N === 2 * o : P instanceof l
    }

    function w(P, C, j = !0) {
        if (A(P)) throw new Error("first arg must be private key");
        if (!A(C)) throw new Error("second arg must be public key");
        return l.fromHex(C).multiply(c(P)).toRawBytes(j)
    }
    const x = t.bits2int || function(P) {
            const C = os(P),
                j = P.length * 8 - t.nBitLength;
            return j > 0 ? C >> BigInt(j) : C
        },
        T = t.bits2int_modN || function(P) {
            return s(x(P))
        },
        _ = ZS(t.nBitLength);

    function O(P) {
        if (typeof P != "bigint") throw new Error("bigint expected");
        if (!(Ni <= P && P < _)) throw new Error(`bigint expected < 2^${t.nBitLength}`);
        return ul(P, t.nByteLength)
    }

    function k(P, C, j = I) {
        if (["recovered", "canonical"].some(K => K in j)) throw new Error("sign() legacy options not supported");
        const {
            hash: N,
            randomBytes: D
        } = t;
        let {
            lowS: $,
            prehash: V,
            extraEntropy: H
        } = j;
        $ == null && ($ = !0), P = _r("msgHash", P), V && (P = _r("prehashed msgHash", N(P)));
        const Q = T(P),
            X = c(C),
            ve = [O(X), O(Q)];
        if (H != null && H !== !1) {
            const K = H === !0 ? D(n.BYTES) : H;
            ve.push(_r("extraEntropy", K))
        }
        const De = cd(...ve),
            ot = Q;

        function St(K) {
            const ae = x(K);
            if (!d(ae)) return;
            const re = u(ae),
                z = l.BASE.multiply(ae).toAffine(),
                he = s(z.x);
            if (he === Ni) return;
            const me = s(re * s(ot + he * X));
            if (me === Ni) return;
            let ht = (z.x === he ? 0 : 2) | Number(z.y & nr),
                pt = me;
            return $ && m(me) && (pt = p(me), ht ^= 1), new g(he, pt, ht)
        }
        return {
            seed: De,
            k2sig: St
        }
    }
    const I = {
            lowS: t.lowS,
            prehash: !1
        },
        M = {
            lowS: t.lowS,
            prehash: !1
        };

    function B(P, C, j = I) {
        const {
            seed: N,
            k2sig: D
        } = k(P, C, j), $ = t;
        return FD($.hash.outputLen, $.nByteLength, $.hmac)(N, D)
    }
    l.BASE._setWindowSize(8);

    function L(P, C, j, N = M) {
        var z;
        const D = P;
        if (C = _r("msgHash", C), j = _r("publicKey", j), "strict" in N) throw new Error("options.strict was renamed to lowS");
        const {
            lowS: $,
            prehash: V
        } = N;
        let H, Q;
        try {
            if (typeof D == "string" || Ts(D)) try {
                H = g.fromDER(D)
            } catch (he) {
                if (!(he instanceof Ha.Err)) throw he;
                H = g.fromCompact(D)
            } else if (typeof D == "object" && typeof D.r == "bigint" && typeof D.s == "bigint") {
                const {
                    r: he,
                    s: me
                } = D;
                H = new g(he, me)
            } else throw new Error("PARSE");
            Q = l.fromHex(j)
        } catch (he) {
            if (he.message === "PARSE") throw new Error("signature must be Signature instance, Uint8Array or hex string");
            return !1
        }
        if ($ && H.hasHighS()) return !1;
        V && (C = t.hash(C));
        const {
            r: X,
            s: ve
        } = H, De = T(C), ot = u(ve), St = s(De * ot), K = s(X * ot), ae = (z = l.BASE.multiplyAndAddUnsafe(Q, St, K)) == null ? void 0 : z.toAffine();
        return ae ? s(ae.x) === X : !1
    }
    return {
        CURVE: t,
        getPublicKey: v,
        getSharedSecret: w,
        sign: B,
        verify: L,
        ProjectivePoint: l,
        Signature: g,
        utils: b
    }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function KZ(e) {
    return {
        hash: e,
        hmac: (t, ...n) => qS(e, t, qm(...n)),
        randomBytes: U3
    }
}

function QZ(e, t) {
    const n = r => qZ({ ...e,
        ...KZ(r)
    });
    return Object.freeze({ ...n(t),
        create: n
    })
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const WD = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    zO = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    YZ = BigInt(1),
    jx = BigInt(2),
    WO = (e, t) => (e + t / jx) / t;

function XZ(e) {
    const t = WD,
        n = BigInt(3),
        r = BigInt(6),
        i = BigInt(11),
        o = BigInt(22),
        a = BigInt(23),
        s = BigInt(44),
        u = BigInt(88),
        l = e * e * e % t,
        c = l * l * e % t,
        f = Xn(c, n, t) * c % t,
        d = Xn(f, n, t) * c % t,
        h = Xn(d, jx, t) * l % t,
        m = Xn(h, i, t) * h % t,
        p = Xn(m, o, t) * m % t,
        y = Xn(p, s, t) * p % t,
        g = Xn(y, u, t) * y % t,
        b = Xn(g, s, t) * p % t,
        v = Xn(b, n, t) * c % t,
        A = Xn(v, a, t) * m % t,
        w = Xn(A, r, t) * l % t,
        x = Xn(w, jx, t);
    if (!Bx.eql(Bx.sqr(x), e)) throw new Error("Cannot find square root");
    return x
}
const Bx = $Z(WD, void 0, void 0, {
        sqrt: XZ
    }),
    JS = QZ({
        a: BigInt(0),
        b: BigInt(7),
        Fp: Bx,
        n: zO,
        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
        h: BigInt(1),
        lowS: !0,
        endo: {
            beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
            splitScalar: e => {
                const t = zO,
                    n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                    r = -YZ * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                    i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                    o = n,
                    a = BigInt("0x100000000000000000000000000000000"),
                    s = WO(o * e, t),
                    u = WO(-r * e, t);
                let l = En(e - s * n - u * i, t),
                    c = En(-s * r - u * o, t);
                const f = l > a,
                    d = c > a;
                if (f && (l = t - l), d && (c = t - c), l > a || c > a) throw new Error("splitScalar: Endomorphism failed, k=" + e);
                return {
                    k1neg: f,
                    k1: l,
                    k2neg: d,
                    k2: c
                }
            }
        }
    }, yv);
BigInt(0);
JS.ProjectivePoint;
const ZZ = Object.freeze(Object.defineProperty({
    __proto__: null,
    secp256k1: JS
}, Symbol.toStringTag, {
    value: "Module"
}));
var bb;
const po = (bb = JS) !== null && bb !== void 0 ? bb : ZZ,
    GO = BigInt("0xffffffffffffffff"),
    fd = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
    JZ = po.CURVE.n,
    eJ = JZ / BigInt(2),
    tJ = {
        type: "object",
        required: ["crypto", "id", "version", "address"],
        properties: {
            crypto: {
                type: "object",
                required: ["cipher", "ciphertext", "cipherparams", "kdf", "kdfparams", "mac"],
                properties: {
                    cipher: {
                        type: "string"
                    },
                    ciphertext: {
                        type: "string"
                    },
                    cipherparams: {
                        type: "object"
                    },
                    kdf: {
                        type: "string"
                    },
                    kdfparams: {
                        type: "object"
                    },
                    salt: {
                        type: "string"
                    },
                    mac: {
                        type: "string"
                    }
                }
            },
            id: {
                type: "string"
            },
            version: {
                type: "number"
            },
            address: {
                type: "string"
            }
        }
    };
var hg;
(function(e) {
    e[e.Mainnet = 1] = "Mainnet", e[e.Goerli = 5] = "Goerli", e[e.Sepolia = 11155111] = "Sepolia"
})(hg || (hg = {}));
var Ge;
(function(e) {
    e.Chainstart = "chainstart", e.Homestead = "homestead", e.Dao = "dao", e.TangerineWhistle = "tangerineWhistle", e.SpuriousDragon = "spuriousDragon", e.Byzantium = "byzantium", e.Constantinople = "constantinople", e.Petersburg = "petersburg", e.Istanbul = "istanbul", e.MuirGlacier = "muirGlacier", e.Berlin = "berlin", e.London = "london", e.ArrowGlacier = "arrowGlacier", e.GrayGlacier = "grayGlacier", e.MergeForkIdTransition = "mergeForkIdTransition", e.Merge = "merge", e.Shanghai = "shanghai", e.ShardingForkDev = "shardingFork"
})(Ge || (Ge = {}));
var qO;
(function(e) {
    e.ProofOfStake = "pos", e.ProofOfWork = "pow", e.ProofOfAuthority = "poa"
})(qO || (qO = {}));
var KO;
(function(e) {
    e.Ethash = "ethash", e.Clique = "clique", e.Casper = "casper"
})(KO || (KO = {}));
var Zt;
(function(e) {
    e.PolygonMainnet = "polygon-mainnet", e.PolygonMumbai = "polygon-mumbai", e.ArbitrumRinkebyTestnet = "arbitrum-rinkeby-testnet", e.ArbitrumOne = "arbitrum-one", e.xDaiChain = "x-dai-chain", e.OptimisticKovan = "optimistic-kovan", e.OptimisticEthereum = "optimistic-ethereum"
})(Zt || (Zt = {}));
var or;
(function(e) {
    e[e.Number = 0] = "Number", e[e.BigInt = 1] = "BigInt", e[e.Uint8Array = 2] = "Uint8Array", e[e.PrefixedHexString = 3] = "PrefixedHexString"
})(or || (or = {}));
const GD = e => {
    if (typeof e != "string") throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof e}`);
    return MS(e) ? e.slice(2) : e
};

function nJ(e) {
    return !e || e === "0x0" ? "0x0000000000000000" : MS(e) ? `0x${GD(e).padStart(16,"0")}` : `0x${e.padStart(16,"0")}`
}
const qD = function(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Received an invalid integer type: ${e}`);
    return `0x${e.toString(16)}`
};

function rJ(e, t = !0) {
    var n, r;
    const {
        name: i,
        config: o,
        difficulty: a,
        mixHash: s,
        gasLimit: u,
        coinbase: l,
        baseFeePerGas: c
    } = e;
    let {
        extraData: f,
        timestamp: d,
        nonce: h
    } = e;
    const m = Number(d),
        {
            chainId: p
        } = o;
    if (f === "" && (f = "0x"), MS(d) || (d = qD(parseInt(d))), h.length !== 18 && (h = nJ(h)), o.eip155Block !== o.eip158Block) throw new Error("EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork");
    const y = {
            name: i,
            chainId: p,
            networkId: p,
            genesis: {
                timestamp: d,
                gasLimit: parseInt(u),
                difficulty: parseInt(a),
                nonce: h,
                extraData: f,
                mixHash: s,
                coinbase: l,
                baseFeePerGas: c
            },
            hardfork: void 0,
            hardforks: [],
            bootstrapNodes: [],
            consensus: o.clique !== void 0 ? {
                type: "poa",
                algorithm: "clique",
                clique: {
                    period: (n = o.clique.period) !== null && n !== void 0 ? n : o.clique.blockperiodseconds,
                    epoch: (r = o.clique.epoch) !== null && r !== void 0 ? r : o.clique.epochlength
                }
            } : {
                type: "pow",
                algorithm: "ethash",
                ethash: {}
            }
        },
        g = {
            [Ge.Homestead]: {
                name: "homesteadBlock"
            },
            [Ge.Dao]: {
                name: "daoForkBlock"
            },
            [Ge.TangerineWhistle]: {
                name: "eip150Block"
            },
            [Ge.SpuriousDragon]: {
                name: "eip155Block"
            },
            [Ge.Byzantium]: {
                name: "byzantiumBlock"
            },
            [Ge.Constantinople]: {
                name: "constantinopleBlock"
            },
            [Ge.Petersburg]: {
                name: "petersburgBlock"
            },
            [Ge.Istanbul]: {
                name: "istanbulBlock"
            },
            [Ge.MuirGlacier]: {
                name: "muirGlacierBlock"
            },
            [Ge.Berlin]: {
                name: "berlinBlock"
            },
            [Ge.London]: {
                name: "londonBlock"
            },
            [Ge.MergeForkIdTransition]: {
                name: "mergeForkBlock",
                postMerge: t
            },
            [Ge.Shanghai]: {
                name: "shanghaiTime",
                postMerge: !0,
                isTimestamp: !0
            },
            [Ge.ShardingForkDev]: {
                name: "shardingForkTime",
                postMerge: !0,
                isTimestamp: !0
            }
        },
        b = Object.keys(g).reduce((w, x) => (w[g[x].name] = x, w), {}),
        v = Object.keys(o).filter(w => b[w] !== void 0 && o[w] !== void 0 && o[w] !== null);
    if (y.hardforks = v.map(w => ({
            name: b[w],
            block: g[b[w]].isTimestamp === !0 || typeof o[w] != "number" ? null : o[w],
            timestamp: g[b[w]].isTimestamp === !0 && typeof o[w] == "number" ? o[w] : void 0
        })).filter(w => w.block !== null || w.timestamp !== void 0), y.hardforks.sort((w, x) => {
            var T, _;
            return ((T = w.block) !== null && T !== void 0 ? T : 1 / 0) - ((_ = x.block) !== null && _ !== void 0 ? _ : 1 / 0)
        }), y.hardforks.sort((w, x) => {
            var T, _;
            return ((T = w.timestamp) !== null && T !== void 0 ? T : m) - ((_ = x.timestamp) !== null && _ !== void 0 ? _ : m)
        }), o.terminalTotalDifficulty !== void 0) {
        const w = {
                name: Ge.Merge,
                ttd: o.terminalTotalDifficulty,
                block: null
            },
            x = y.hardforks.findIndex(T => {
                var _;
                return ((_ = g[T.name]) === null || _ === void 0 ? void 0 : _.postMerge) === !0
            });
        x !== -1 ? y.hardforks.splice(x, 0, w) : y.hardforks.push(w)
    }
    const A = y.hardforks.length > 0 ? y.hardforks.slice(-1)[0] : void 0;
    return y.hardfork = A == null ? void 0 : A.name, y.hardforks.unshift({
        name: Ge.Chainstart,
        block: 0
    }), y
}

function iJ(e, t, n) {
    try {
        if (["config", "difficulty", "gasLimit", "alloc"].some(r => !(r in e))) throw new Error("Invalid format, expected geth genesis fields missing");
        return t !== void 0 && (e.name = t), rJ(e, n)
    } catch (r) {
        throw new Error(`Error parsing parameters file: ${r.message}`)
    }
}

function KD(e) {
    let t = e;
    if (typeof t != "string") throw new Error(`[padToEven] value must be type 'string', received ${typeof t}`);
    return t.length % 2 && (t = `0${t}`), t
}
const oJ = function(e) {
        const t = qD(e);
        return Ke(`0x${KD(t.slice(2))}`)
    },
    tt = function(e) {
        var t;
        if (e == null) return new Uint8Array;
        if (e instanceof Uint8Array) return e;
        if (((t = e == null ? void 0 : e.constructor) === null || t === void 0 ? void 0 : t.name) === "Uint8Array" || Array.isArray(e)) return Uint8Array.from(e);
        if (typeof e == "string") {
            if (!tD(e)) throw new Error(`Cannot convert string to Uint8Array. only supports 0x-prefixed hex strings and this string was given: ${e}`);
            return Ke(KD(GD(e)))
        }
        if (typeof e == "number") return tt(Nt(e));
        if (typeof e == "bigint") {
            if (e < BigInt(0)) throw new Error(`Cannot convert negative bigint to Uint8Array. Given: ${e}`);
            let n = e.toString(16);
            return n.length % 2 && (n = `0${n}`), tt(`0x${n}`)
        }
        if (e.toArray) return Uint8Array.from(e.toArray());
        throw new Error("invalid type")
    };

function ze(e) {
    const t = Ee(e);
    return BigInt(t === "0x" ? 0 : t)
}

function aJ(e) {
    return tt(`0x${e.toString(16)}`)
}
const QD = function(e) {
        return new Uint8Array(e).fill(0)
    },
    sJ = function(e, t, n) {
        const r = QD(t);
        return e.length < t ? (r.set(e, t - e.length), r) : e.subarray(-t)
    };

function e_(e) {
    if (!ma(e)) {
        const t = `This method only supports Uint8Array but input was: ${e}`;
        throw new Error(t)
    }
}
const QO = function(e, t) {
    return e_(e), sJ(e, t)
};

function uJ(e) {
    let t = e[0];
    for (; e.length > 0 && t.toString() === "0";) e = e.slice(1), t = e[0];
    return e
}
const pg = function(e) {
        return e_(e), uJ(e)
    },
    nt = e => `0x${e.toString(16)}`;

function Oe(e) {
    return pg(aJ(e))
}

function lJ(e, t) {
    return e === BigInt(0) || e === BigInt(1) ? e : t === void 0 ? e - BigInt(27) : e - (t * BigInt(2) + BigInt(35))
}

function cJ(e) {
    return e === BigInt(0) || e === BigInt(1)
}
const t_ = function(e, t, n, r, i) {
    const o = lJ(t, i);
    if (!cJ(o)) throw new Error("Invalid signature v value");
    return new po.Signature(ze(n), ze(r)).addRecoveryBit(Number(o)).recoverPublicKey(e).toRawBytes(!1).slice(1)
};

function Ws(e, t) {
    if (e === null) return null;
    if (e === void 0) return;
    if (typeof e == "string" && !tD(e)) throw new Error(`A string must be provided with a 0x-prefix, given: ${e}`);
    if (typeof e == "number" && !Number.isSafeInteger(e)) throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
    const n = tt(e);
    switch (t) {
        case or.Uint8Array:
            return n;
        case or.BigInt:
            return ze(n);
        case or.Number:
            {
                const r = ze(n);
                if (r > BigInt(Number.MAX_SAFE_INTEGER)) throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
                return Number(r)
            }
        case or.PrefixedHexString:
            return Ee(n);
        default:
            throw new Error("unknown outputType")
    }
}
var Bi = {};
Object.defineProperty(Bi, "__esModule", {
    value: !0
});
var $n = Bi.RLP = Bi.utils = Bi.decode = Bi.encode = void 0;

function n_(e) {
    if (Array.isArray(e)) {
        const n = [];
        let r = 0;
        for (let i = 0; i < e.length; i++) {
            const o = n_(e[i]);
            n.push(o), r += o.length
        }
        return $x(XO(r, 192), ...n)
    }
    const t = t$(e);
    return t.length === 1 && t[0] < 128 ? t : $x(XO(t.length, 128), t)
}
Bi.encode = n_;

function Gs(e, t, n) {
    if (n > e.length) throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
    return e.slice(t, n)
}

function YO(e) {
    if (e[0] === 0) throw new Error("invalid RLP: extra zeros");
    return ZD(XD(e))
}

function XO(e, t) {
    if (e < 56) return Uint8Array.from([e + t]);
    const n = Lx(e),
        r = n.length / 2,
        i = Lx(t + 55 + r);
    return Uint8Array.from(mg(i + n))
}

function YD(e, t = !1) {
    if (typeof e > "u" || e === null || e.length === 0) return Uint8Array.from([]);
    const n = t$(e),
        r = Dx(n);
    if (t) return r;
    if (r.remainder.length !== 0) throw new Error("invalid RLP: remainder must be zero");
    return r.data
}
Bi.decode = YD;

function Dx(e) {
    let t, n, r, i, o;
    const a = [],
        s = e[0];
    if (s <= 127) return {
        data: e.slice(0, 1),
        remainder: e.slice(1)
    };
    if (s <= 183) {
        if (t = s - 127, s === 128 ? r = Uint8Array.from([]) : r = Gs(e, 1, t), t === 2 && r[0] < 128) throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
        return {
            data: r,
            remainder: e.slice(t)
        }
    } else if (s <= 191) {
        if (n = s - 182, e.length - 1 < n) throw new Error("invalid RLP: not enough bytes for string length");
        if (t = YO(Gs(e, 1, n)), t <= 55) throw new Error("invalid RLP: expected string length to be greater than 55");
        return r = Gs(e, n, t + n), {
            data: r,
            remainder: e.slice(t + n)
        }
    } else if (s <= 247) {
        for (t = s - 191, i = Gs(e, 1, t); i.length;) o = Dx(i), a.push(o.data), i = o.remainder;
        return {
            data: a,
            remainder: e.slice(t)
        }
    } else {
        if (n = s - 246, t = YO(Gs(e, 1, n)), t < 56) throw new Error("invalid RLP: encoded list too short");
        const u = n + t;
        if (u > e.length) throw new Error("invalid RLP: total length is larger than the data");
        for (i = Gs(e, n, u); i.length;) o = Dx(i), a.push(o.data), i = o.remainder;
        return {
            data: a,
            remainder: e.slice(u)
        }
    }
}
const fJ = Array.from({
    length: 256
}, (e, t) => t.toString(16).padStart(2, "0"));

function XD(e) {
    let t = "";
    for (let n = 0; n < e.length; n++) t += fJ[e[n]];
    return t
}

function ZD(e) {
    const t = Number.parseInt(e, 16);
    if (Number.isNaN(t)) throw new Error("Invalid byte sequence");
    return t
}

function mg(e) {
    if (typeof e != "string") throw new TypeError("hexToBytes: expected string, got " + typeof e);
    if (e.length % 2) throw new Error("hexToBytes: received invalid unpadded hex");
    const t = new Uint8Array(e.length / 2);
    for (let n = 0; n < t.length; n++) {
        const r = n * 2;
        t[n] = ZD(e.slice(r, r + 2))
    }
    return t
}

function $x(...e) {
    if (e.length === 1) return e[0];
    const t = e.reduce((r, i) => r + i.length, 0),
        n = new Uint8Array(t);
    for (let r = 0, i = 0; r < e.length; r++) {
        const o = e[r];
        n.set(o, i), i += o.length
    }
    return n
}

function JD(e) {
    return new TextEncoder().encode(e)
}

function Lx(e) {
    if (e < 0) throw new Error("Invalid integer as argument, must be unsigned!");
    const t = e.toString(16);
    return t.length % 2 ? `0${t}` : t
}

function dJ(e) {
    return e.length % 2 ? `0${e}` : e
}

function e$(e) {
    return e.length >= 2 && e[0] === "0" && e[1] === "x"
}

function hJ(e) {
    return typeof e != "string" ? e : e$(e) ? e.slice(2) : e
}

function t$(e) {
    if (e instanceof Uint8Array) return e;
    if (typeof e == "string") return e$(e) ? mg(dJ(hJ(e))) : JD(e);
    if (typeof e == "number" || typeof e == "bigint") return e ? mg(Lx(e)) : Uint8Array.from([]);
    if (e == null) return Uint8Array.from([]);
    throw new Error("toBytes: received unsupported type " + typeof e)
}
Bi.utils = {
    bytesToHex: XD,
    concatBytes: $x,
    hexToBytes: mg,
    utf8ToBytes: JD
};
$n = Bi.RLP = {
    encode: n_,
    decode: YD
};
var n$ = {}; /*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
(function(e) {
    (function(t) {
        t(typeof DO_NOT_EXPORT_CRC > "u" ? e : {})
    })(function(t) {
        t.version = "1.2.2";

        function n() {
            for (var _ = 0, O = new Array(256), k = 0; k != 256; ++k) _ = k, _ = _ & 1 ? -306674912 ^ _ >>> 1 : _ >>> 1, _ = _ & 1 ? -306674912 ^ _ >>> 1 : _ >>> 1, _ = _ & 1 ? -306674912 ^ _ >>> 1 : _ >>> 1, _ = _ & 1 ? -306674912 ^ _ >>> 1 : _ >>> 1, _ = _ & 1 ? -306674912 ^ _ >>> 1 : _ >>> 1, _ = _ & 1 ? -306674912 ^ _ >>> 1 : _ >>> 1, _ = _ & 1 ? -306674912 ^ _ >>> 1 : _ >>> 1, _ = _ & 1 ? -306674912 ^ _ >>> 1 : _ >>> 1, O[k] = _;
            return typeof Int32Array < "u" ? new Int32Array(O) : O
        }
        var r = n();

        function i(_) {
            var O = 0,
                k = 0,
                I = 0,
                M = typeof Int32Array < "u" ? new Int32Array(4096) : new Array(4096);
            for (I = 0; I != 256; ++I) M[I] = _[I];
            for (I = 0; I != 256; ++I)
                for (k = _[I], O = 256 + I; O < 4096; O += 256) k = M[O] = k >>> 8 ^ _[k & 255];
            var B = [];
            for (I = 1; I != 16; ++I) B[I - 1] = typeof Int32Array < "u" ? M.subarray(I * 256, I * 256 + 256) : M.slice(I * 256, I * 256 + 256);
            return B
        }
        var o = i(r),
            a = o[0],
            s = o[1],
            u = o[2],
            l = o[3],
            c = o[4],
            f = o[5],
            d = o[6],
            h = o[7],
            m = o[8],
            p = o[9],
            y = o[10],
            g = o[11],
            b = o[12],
            v = o[13],
            A = o[14];

        function w(_, O) {
            for (var k = O ^ -1, I = 0, M = _.length; I < M;) k = k >>> 8 ^ r[(k ^ _.charCodeAt(I++)) & 255];
            return ~k
        }

        function x(_, O) {
            for (var k = O ^ -1, I = _.length - 15, M = 0; M < I;) k = A[_[M++] ^ k & 255] ^ v[_[M++] ^ k >> 8 & 255] ^ b[_[M++] ^ k >> 16 & 255] ^ g[_[M++] ^ k >>> 24] ^ y[_[M++]] ^ p[_[M++]] ^ m[_[M++]] ^ h[_[M++]] ^ d[_[M++]] ^ f[_[M++]] ^ c[_[M++]] ^ l[_[M++]] ^ u[_[M++]] ^ s[_[M++]] ^ a[_[M++]] ^ r[_[M++]];
            for (I += 15; M < I;) k = k >>> 8 ^ r[(k ^ _[M++]) & 255];
            return ~k
        }

        function T(_, O) {
            for (var k = O ^ -1, I = 0, M = _.length, B = 0, L = 0; I < M;) B = _.charCodeAt(I++), B < 128 ? k = k >>> 8 ^ r[(k ^ B) & 255] : B < 2048 ? (k = k >>> 8 ^ r[(k ^ (192 | B >> 6 & 31)) & 255], k = k >>> 8 ^ r[(k ^ (128 | B & 63)) & 255]) : B >= 55296 && B < 57344 ? (B = (B & 1023) + 64, L = _.charCodeAt(I++) & 1023, k = k >>> 8 ^ r[(k ^ (240 | B >> 8 & 7)) & 255], k = k >>> 8 ^ r[(k ^ (128 | B >> 2 & 63)) & 255], k = k >>> 8 ^ r[(k ^ (128 | L >> 6 & 15 | (B & 3) << 4)) & 255], k = k >>> 8 ^ r[(k ^ (128 | L & 63)) & 255]) : (k = k >>> 8 ^ r[(k ^ (224 | B >> 12 & 15)) & 255], k = k >>> 8 ^ r[(k ^ (128 | B >> 6 & 63)) & 255], k = k >>> 8 ^ r[(k ^ (128 | B & 63)) & 255]);
            return ~k
        }
        t.table = r, t.bstr = w, t.buf = x, t.str = T
    })
})(n$);
const pJ = Fe(n$),
    mJ = {
        name: "goerli",
        chainId: 5,
        networkId: 5,
        defaultHardfork: "merge",
        consensus: {
            type: "poa",
            algorithm: "clique",
            clique: {
                period: 15,
                epoch: 3e4
            }
        },
        comment: "Cross-client PoA test network",
        url: "https://github.com/goerli/testnet",
        genesis: {
            timestamp: "0x5c51a607",
            gasLimit: 10485760,
            difficulty: 1,
            nonce: "0x0000000000000000",
            extraData: "0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        },
        hardforks: [{
            name: "chainstart",
            block: 0,
            forkHash: "0xa3f5ab08"
        }, {
            name: "homestead",
            block: 0,
            forkHash: "0xa3f5ab08"
        }, {
            name: "tangerineWhistle",
            block: 0,
            forkHash: "0xa3f5ab08"
        }, {
            name: "spuriousDragon",
            block: 0,
            forkHash: "0xa3f5ab08"
        }, {
            name: "byzantium",
            block: 0,
            forkHash: "0xa3f5ab08"
        }, {
            name: "constantinople",
            block: 0,
            forkHash: "0xa3f5ab08"
        }, {
            name: "petersburg",
            block: 0,
            forkHash: "0xa3f5ab08"
        }, {
            name: "istanbul",
            block: 1561651,
            forkHash: "0xc25efa5c"
        }, {
            name: "berlin",
            block: 4460644,
            forkHash: "0x757a1c47"
        }, {
            name: "london",
            block: 5062605,
            forkHash: "0xb8c6299d"
        }, {
            "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818",
            name: "merge",
            ttd: "10790000",
            block: 7382819,
            forkHash: "0xb8c6299d"
        }, {
            name: "mergeForkIdTransition",
            block: null,
            forkHash: null
        }, {
            name: "shanghai",
            block: null,
            forkHash: null
        }],
        bootstrapNodes: [],
        dnsNetworks: ["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net"]
    },
    gJ = {
        name: "mainnet",
        chainId: 1,
        networkId: 1,
        defaultHardfork: "merge",
        consensus: {
            type: "pow",
            algorithm: "ethash",
            ethash: {}
        },
        comment: "The Ethereum main chain",
        url: "https://ethstats.net/",
        genesis: {
            gasLimit: 5e3,
            difficulty: 17179869184,
            nonce: "0x0000000000000042",
            extraData: "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"
        },
        hardforks: [{
            name: "chainstart",
            block: 0,
            forkHash: "0xfc64ec04"
        }, {
            name: "homestead",
            block: 115e4,
            forkHash: "0x97c2c34c"
        }, {
            name: "dao",
            block: 192e4,
            forkHash: "0x91d1f948"
        }, {
            name: "tangerineWhistle",
            block: 2463e3,
            forkHash: "0x7a64da13"
        }, {
            name: "spuriousDragon",
            block: 2675e3,
            forkHash: "0x3edd5b10"
        }, {
            name: "byzantium",
            block: 437e4,
            forkHash: "0xa00bc324"
        }, {
            name: "constantinople",
            block: 728e4,
            forkHash: "0x668db0af"
        }, {
            name: "petersburg",
            block: 728e4,
            forkHash: "0x668db0af"
        }, {
            name: "istanbul",
            block: 9069e3,
            forkHash: "0x879d6e30"
        }, {
            name: "muirGlacier",
            block: 92e5,
            forkHash: "0xe029e991"
        }, {
            name: "berlin",
            block: 12244e3,
            forkHash: "0x0eb440f6"
        }, {
            name: "london",
            block: 12965e3,
            forkHash: "0xb715077d"
        }, {
            name: "arrowGlacier",
            block: 13773e3,
            forkHash: "0x20c327fc"
        }, {
            name: "grayGlacier",
            block: 1505e4,
            forkHash: "0xf0afd0e3"
        }, {
            "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393",
            name: "merge",
            ttd: "58750000000000000000000",
            block: 15537394,
            forkHash: "0xf0afd0e3"
        }, {
            name: "mergeForkIdTransition",
            block: null,
            forkHash: null
        }, {
            name: "shanghai",
            block: null,
            forkHash: null
        }],
        bootstrapNodes: [],
        dnsNetworks: ["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net"]
    },
    yJ = {
        name: "sepolia",
        chainId: 11155111,
        networkId: 11155111,
        defaultHardfork: "merge",
        consensus: {
            type: "pow",
            algorithm: "ethash",
            ethash: {}
        },
        comment: "PoW test network to replace Ropsten",
        url: "https://github.com/ethereum/go-ethereum/pull/23730",
        genesis: {
            timestamp: "0x6159af19",
            gasLimit: 3e7,
            difficulty: 131072,
            nonce: "0x0000000000000000",
            extraData: "0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521"
        },
        hardforks: [{
            name: "chainstart",
            block: 0,
            forkHash: "0xfe3366e7"
        }, {
            name: "homestead",
            block: 0,
            forkHash: "0xfe3366e7"
        }, {
            name: "tangerineWhistle",
            block: 0,
            forkHash: "0xfe3366e7"
        }, {
            name: "spuriousDragon",
            block: 0,
            forkHash: "0xfe3366e7"
        }, {
            name: "byzantium",
            block: 0,
            forkHash: "0xfe3366e7"
        }, {
            name: "constantinople",
            block: 0,
            forkHash: "0xfe3366e7"
        }, {
            name: "petersburg",
            block: 0,
            forkHash: "0xfe3366e7"
        }, {
            name: "istanbul",
            block: 0,
            forkHash: "0xfe3366e7"
        }, {
            name: "muirGlacier",
            block: 0,
            forkHash: "0xfe3366e7"
        }, {
            name: "berlin",
            block: 0,
            forkHash: "0xfe3366e7"
        }, {
            name: "london",
            block: 0,
            forkHash: "0xfe3366e7"
        }, {
            "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408",
            name: "merge",
            ttd: "17000000000000000",
            block: 1450409,
            forkHash: "0xfe3366e7"
        }, {
            name: "mergeForkIdTransition",
            block: 1735371,
            forkHash: "0xb96cbd13"
        }, {
            name: "shanghai",
            block: null,
            timestamp: "1677557088",
            forkHash: "0xf7f9bc08"
        }],
        bootstrapNodes: [],
        dnsNetworks: ["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net"]
    },
    vJ = {
        name: "EIP-1153",
        number: 1153,
        comment: "Transient Storage",
        url: "https://eips.ethereum.org/EIPS/eip-1153",
        status: "Review",
        minimumHardfork: "chainstart",
        requiredEIPs: [],
        gasConfig: {},
        gasPrices: {
            tstore: {
                v: 100,
                d: "Base fee of the TSTORE opcode"
            },
            tload: {
                v: 100,
                d: "Base fee of the TLOAD opcode"
            }
        },
        vm: {},
        pow: {}
    },
    bJ = {
        name: "EIP-1559",
        number: 1559,
        comment: "Fee market change for ETH 1.0 chain",
        url: "https://eips.ethereum.org/EIPS/eip-1559",
        status: "Final",
        minimumHardfork: "berlin",
        requiredEIPs: [2930],
        gasConfig: {
            baseFeeMaxChangeDenominator: {
                v: 8,
                d: "Maximum base fee change denominator"
            },
            elasticityMultiplier: {
                v: 2,
                d: "Maximum block gas target elasticity"
            },
            initialBaseFee: {
                v: 1e9,
                d: "Initial base fee on first EIP1559 block"
            }
        },
        gasPrices: {},
        vm: {},
        pow: {}
    },
    wJ = {
        name: "EIP-2315",
        number: 2315,
        comment: "Simple subroutines for the EVM",
        url: "https://eips.ethereum.org/EIPS/eip-2315",
        status: "Draft",
        minimumHardfork: "istanbul",
        gasConfig: {},
        gasPrices: {
            beginsub: {
                v: 2,
                d: "Base fee of the BEGINSUB opcode"
            },
            returnsub: {
                v: 5,
                d: "Base fee of the RETURNSUB opcode"
            },
            jumpsub: {
                v: 10,
                d: "Base fee of the JUMPSUB opcode"
            }
        },
        vm: {},
        pow: {}
    },
    xJ = {
        name: "EIP-2537",
        number: 2537,
        comment: "BLS12-381 precompiles",
        url: "https://eips.ethereum.org/EIPS/eip-2537",
        status: "Draft",
        minimumHardfork: "chainstart",
        gasConfig: {},
        gasPrices: {
            Bls12381G1AddGas: {
                v: 600,
                d: "Gas cost of a single BLS12-381 G1 addition precompile-call"
            },
            Bls12381G1MulGas: {
                v: 12e3,
                d: "Gas cost of a single BLS12-381 G1 multiplication precompile-call"
            },
            Bls12381G2AddGas: {
                v: 4500,
                d: "Gas cost of a single BLS12-381 G2 addition precompile-call"
            },
            Bls12381G2MulGas: {
                v: 55e3,
                d: "Gas cost of a single BLS12-381 G2 multiplication precompile-call"
            },
            Bls12381PairingBaseGas: {
                v: 115e3,
                d: "Base gas cost of BLS12-381 pairing check"
            },
            Bls12381PairingPerPairGas: {
                v: 23e3,
                d: "Per-pair gas cost of BLS12-381 pairing check"
            },
            Bls12381MapG1Gas: {
                v: 5500,
                d: "Gas cost of BLS12-381 map field element to G1"
            },
            Bls12381MapG2Gas: {
                v: 11e4,
                d: "Gas cost of BLS12-381 map field element to G2"
            },
            Bls12381MultiExpGasDiscount: {
                v: [
                    [1, 1200],
                    [2, 888],
                    [3, 764],
                    [4, 641],
                    [5, 594],
                    [6, 547],
                    [7, 500],
                    [8, 453],
                    [9, 438],
                    [10, 423],
                    [11, 408],
                    [12, 394],
                    [13, 379],
                    [14, 364],
                    [15, 349],
                    [16, 334],
                    [17, 330],
                    [18, 326],
                    [19, 322],
                    [20, 318],
                    [21, 314],
                    [22, 310],
                    [23, 306],
                    [24, 302],
                    [25, 298],
                    [26, 294],
                    [27, 289],
                    [28, 285],
                    [29, 281],
                    [30, 277],
                    [31, 273],
                    [32, 269],
                    [33, 268],
                    [34, 266],
                    [35, 265],
                    [36, 263],
                    [37, 262],
                    [38, 260],
                    [39, 259],
                    [40, 257],
                    [41, 256],
                    [42, 254],
                    [43, 253],
                    [44, 251],
                    [45, 250],
                    [46, 248],
                    [47, 247],
                    [48, 245],
                    [49, 244],
                    [50, 242],
                    [51, 241],
                    [52, 239],
                    [53, 238],
                    [54, 236],
                    [55, 235],
                    [56, 233],
                    [57, 232],
                    [58, 231],
                    [59, 229],
                    [60, 228],
                    [61, 226],
                    [62, 225],
                    [63, 223],
                    [64, 222],
                    [65, 221],
                    [66, 220],
                    [67, 219],
                    [68, 219],
                    [69, 218],
                    [70, 217],
                    [71, 216],
                    [72, 216],
                    [73, 215],
                    [74, 214],
                    [75, 213],
                    [76, 213],
                    [77, 212],
                    [78, 211],
                    [79, 211],
                    [80, 210],
                    [81, 209],
                    [82, 208],
                    [83, 208],
                    [84, 207],
                    [85, 206],
                    [86, 205],
                    [87, 205],
                    [88, 204],
                    [89, 203],
                    [90, 202],
                    [91, 202],
                    [92, 201],
                    [93, 200],
                    [94, 199],
                    [95, 199],
                    [96, 198],
                    [97, 197],
                    [98, 196],
                    [99, 196],
                    [100, 195],
                    [101, 194],
                    [102, 193],
                    [103, 193],
                    [104, 192],
                    [105, 191],
                    [106, 191],
                    [107, 190],
                    [108, 189],
                    [109, 188],
                    [110, 188],
                    [111, 187],
                    [112, 186],
                    [113, 185],
                    [114, 185],
                    [115, 184],
                    [116, 183],
                    [117, 182],
                    [118, 182],
                    [119, 181],
                    [120, 180],
                    [121, 179],
                    [122, 179],
                    [123, 178],
                    [124, 177],
                    [125, 176],
                    [126, 176],
                    [127, 175],
                    [128, 174]
                ],
                d: "Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair"
            }
        },
        vm: {},
        pow: {}
    },
    AJ = {
        name: "EIP-2565",
        number: 2565,
        comment: "ModExp gas cost",
        url: "https://eips.ethereum.org/EIPS/eip-2565",
        status: "Final",
        minimumHardfork: "byzantium",
        gasConfig: {},
        gasPrices: {
            modexpGquaddivisor: {
                v: 3,
                d: "Gquaddivisor from modexp precompile for gas calculation"
            }
        },
        vm: {},
        pow: {}
    },
    EJ = {
        name: "EIP-2718",
        comment: "Typed Transaction Envelope",
        url: "https://eips.ethereum.org/EIPS/eip-2718",
        status: "Final",
        minimumHardfork: "chainstart",
        gasConfig: {},
        gasPrices: {},
        vm: {},
        pow: {}
    },
    SJ = {
        name: "EIP-2929",
        comment: "Gas cost increases for state access opcodes",
        url: "https://eips.ethereum.org/EIPS/eip-2929",
        status: "Final",
        minimumHardfork: "chainstart",
        gasConfig: {},
        gasPrices: {
            coldsload: {
                v: 2100,
                d: "Gas cost of the first read of storage from a given location (per transaction)"
            },
            coldaccountaccess: {
                v: 2600,
                d: "Gas cost of the first read of a given address (per transaction)"
            },
            warmstorageread: {
                v: 100,
                d: "Gas cost of reading storage locations which have already loaded 'cold'"
            },
            sstoreCleanGasEIP2200: {
                v: 2900,
                d: "Once per SSTORE operation from clean non-zero to something else"
            },
            sstoreNoopGasEIP2200: {
                v: 100,
                d: "Once per SSTORE operation if the value doesn't change"
            },
            sstoreDirtyGasEIP2200: {
                v: 100,
                d: "Once per SSTORE operation if a dirty value is changed"
            },
            sstoreInitRefundEIP2200: {
                v: 19900,
                d: "Once per SSTORE operation for resetting to the original zero value"
            },
            sstoreCleanRefundEIP2200: {
                v: 4900,
                d: "Once per SSTORE operation for resetting to the original non-zero value"
            },
            call: {
                v: 0,
                d: "Base fee of the CALL opcode"
            },
            callcode: {
                v: 0,
                d: "Base fee of the CALLCODE opcode"
            },
            delegatecall: {
                v: 0,
                d: "Base fee of the DELEGATECALL opcode"
            },
            staticcall: {
                v: 0,
                d: "Base fee of the STATICCALL opcode"
            },
            balance: {
                v: 0,
                d: "Base fee of the BALANCE opcode"
            },
            extcodesize: {
                v: 0,
                d: "Base fee of the EXTCODESIZE opcode"
            },
            extcodecopy: {
                v: 0,
                d: "Base fee of the EXTCODECOPY opcode"
            },
            extcodehash: {
                v: 0,
                d: "Base fee of the EXTCODEHASH opcode"
            },
            sload: {
                v: 0,
                d: "Base fee of the SLOAD opcode"
            },
            sstore: {
                v: 0,
                d: "Base fee of the SSTORE opcode"
            }
        },
        vm: {},
        pow: {}
    },
    _J = {
        name: "EIP-2930",
        comment: "Optional access lists",
        url: "https://eips.ethereum.org/EIPS/eip-2930",
        status: "Final",
        minimumHardfork: "istanbul",
        requiredEIPs: [2718, 2929],
        gasConfig: {},
        gasPrices: {
            accessListStorageKeyCost: {
                v: 1900,
                d: "Gas cost per storage key in an Access List transaction"
            },
            accessListAddressCost: {
                v: 2400,
                d: "Gas cost per storage key in an Access List transaction"
            }
        },
        vm: {},
        pow: {}
    },
    TJ = {
        name: "EIP-3198",
        number: 3198,
        comment: "BASEFEE opcode",
        url: "https://eips.ethereum.org/EIPS/eip-3198",
        status: "Final",
        minimumHardfork: "london",
        gasConfig: {},
        gasPrices: {
            basefee: {
                v: 2,
                d: "Gas cost of the BASEFEE opcode"
            }
        },
        vm: {},
        pow: {}
    },
    PJ = {
        name: "EIP-3529",
        comment: "Reduction in refunds",
        url: "https://eips.ethereum.org/EIPS/eip-3529",
        status: "Final",
        minimumHardfork: "berlin",
        requiredEIPs: [2929],
        gasConfig: {
            maxRefundQuotient: {
                v: 5,
                d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
            }
        },
        gasPrices: {
            selfdestructRefund: {
                v: 0,
                d: "Refunded following a selfdestruct operation"
            },
            sstoreClearRefundEIP2200: {
                v: 4800,
                d: "Once per SSTORE operation for clearing an originally existing storage slot"
            }
        },
        vm: {},
        pow: {}
    },
    OJ = {
        name: "EIP-3540",
        number: 3540,
        comment: "EVM Object Format (EOF) v1",
        url: "https://eips.ethereum.org/EIPS/eip-3540",
        status: "Review",
        minimumHardfork: "london",
        requiredEIPs: [3541],
        gasConfig: {},
        gasPrices: {},
        vm: {},
        pow: {}
    },
    kJ = {
        name: "EIP-3541",
        comment: "Reject new contracts starting with the 0xEF byte",
        url: "https://eips.ethereum.org/EIPS/eip-3541",
        status: "Final",
        minimumHardfork: "berlin",
        requiredEIPs: [],
        gasConfig: {},
        gasPrices: {},
        vm: {},
        pow: {}
    },
    CJ = {
        name: "EIP-3554",
        comment: "Reduction in refunds",
        url: "Difficulty Bomb Delay to December 1st 2021",
        status: "Final",
        minimumHardfork: "muirGlacier",
        requiredEIPs: [],
        gasConfig: {},
        gasPrices: {},
        vm: {},
        pow: {
            difficultyBombDelay: {
                v: 95e5,
                d: "the amount of blocks to delay the difficulty bomb with"
            }
        }
    },
    IJ = {
        name: "EIP-3607",
        number: 3607,
        comment: "Reject transactions from senders with deployed code",
        url: "https://eips.ethereum.org/EIPS/eip-3607",
        status: "Final",
        minimumHardfork: "chainstart",
        requiredEIPs: [],
        gasConfig: {},
        gasPrices: {},
        vm: {},
        pow: {}
    },
    MJ = {
        name: "EIP-3651",
        number: 3198,
        comment: "Warm COINBASE",
        url: "https://eips.ethereum.org/EIPS/eip-3651",
        status: "Review",
        minimumHardfork: "london",
        requiredEIPs: [2929],
        gasConfig: {},
        gasPrices: {},
        vm: {},
        pow: {}
    },
    NJ = {
        name: "EIP-3670",
        number: 3670,
        comment: "EOF - Code Validation",
        url: "https://eips.ethereum.org/EIPS/eip-3670",
        status: "Review",
        minimumHardfork: "london",
        requiredEIPs: [3540],
        gasConfig: {},
        gasPrices: {},
        vm: {},
        pow: {}
    },
    RJ = {
        name: "EIP-3675",
        number: 3675,
        comment: "Upgrade consensus to Proof-of-Stake",
        url: "https://eips.ethereum.org/EIPS/eip-3675",
        status: "Final",
        minimumHardfork: "london",
        requiredEIPs: [],
        gasConfig: {},
        gasPrices: {},
        vm: {},
        pow: {}
    },
    jJ = {
        name: "EIP-3855",
        number: 3855,
        comment: "PUSH0 instruction",
        url: "https://eips.ethereum.org/EIPS/eip-3855",
        status: "Review",
        minimumHardfork: "chainstart",
        requiredEIPs: [],
        gasConfig: {},
        gasPrices: {
            push0: {
                v: 2,
                d: "Base fee of the PUSH0 opcode"
            }
        },
        vm: {},
        pow: {}
    },
    BJ = {
        name: "EIP-3860",
        number: 3860,
        comment: "Limit and meter initcode",
        url: "https://eips.ethereum.org/EIPS/eip-3860",
        status: "Review",
        minimumHardfork: "spuriousDragon",
        requiredEIPs: [],
        gasConfig: {},
        gasPrices: {
            initCodeWordCost: {
                v: 2,
                d: "Gas to pay for each word (32 bytes) of initcode when creating a contract"
            }
        },
        vm: {
            maxInitCodeSize: {
                v: 49152,
                d: "Maximum length of initialization code when creating a contract"
            }
        },
        pow: {}
    },
    DJ = {
        name: "EIP-4345",
        number: 4345,
        comment: "Difficulty Bomb Delay to June 2022",
        url: "https://eips.ethereum.org/EIPS/eip-4345",
        status: "Final",
        minimumHardfork: "london",
        gasConfig: {},
        gasPrices: {},
        vm: {},
        pow: {
            difficultyBombDelay: {
                v: 107e5,
                d: "the amount of blocks to delay the difficulty bomb with"
            }
        }
    },
    $J = {
        name: "EIP-4399",
        number: 4399,
        comment: "Supplant DIFFICULTY opcode with PREVRANDAO",
        url: "https://eips.ethereum.org/EIPS/eip-4399",
        status: "Review",
        minimumHardfork: "london",
        requiredEIPs: [],
        gasConfig: {},
        gasPrices: {},
        vm: {},
        pow: {}
    },
    LJ = {
        name: "EIP-5133",
        number: 5133,
        comment: "Delaying Difficulty Bomb to mid-September 2022",
        url: "https://eips.ethereum.org/EIPS/eip-5133",
        status: "Draft",
        minimumHardfork: "grayGlacier",
        gasConfig: {},
        gasPrices: {},
        vm: {},
        pow: {
            difficultyBombDelay: {
                v: 114e5,
                d: "the amount of blocks to delay the difficulty bomb with"
            }
        }
    },
    qs = {
        1153: vJ,
        1559: bJ,
        2315: wJ,
        2537: xJ,
        2565: AJ,
        2718: EJ,
        2929: SJ,
        2930: _J,
        3198: TJ,
        3529: PJ,
        3540: OJ,
        3541: kJ,
        3554: CJ,
        3607: IJ,
        3651: MJ,
        3670: NJ,
        3675: RJ,
        3855: jJ,
        3860: BJ,
        4345: DJ,
        4399: $J,
        5133: LJ
    },
    FJ = {
        name: "chainstart",
        comment: "Start of the Ethereum main chain",
        url: "",
        status: "",
        gasConfig: {
            minGasLimit: {
                v: 5e3,
                d: "Minimum the gas limit may ever be"
            },
            gasLimitBoundDivisor: {
                v: 1024,
                d: "The bound divisor of the gas limit, used in update calculations"
            },
            maxRefundQuotient: {
                v: 2,
                d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
            }
        },
        gasPrices: {
            base: {
                v: 2,
                d: "Gas base cost, used e.g. for ChainID opcode (Istanbul)"
            },
            tierStep: {
                v: [0, 2, 3, 5, 8, 10, 20],
                d: "Once per operation, for a selection of them"
            },
            exp: {
                v: 10,
                d: "Base fee of the EXP opcode"
            },
            expByte: {
                v: 10,
                d: "Times ceil(log256(exponent)) for the EXP instruction"
            },
            sha3: {
                v: 30,
                d: "Base fee of the SHA3 opcode"
            },
            sha3Word: {
                v: 6,
                d: "Once per word of the SHA3 operation's data"
            },
            sload: {
                v: 50,
                d: "Base fee of the SLOAD opcode"
            },
            sstoreSet: {
                v: 2e4,
                d: "Once per SSTORE operation if the zeroness changes from zero"
            },
            sstoreReset: {
                v: 5e3,
                d: "Once per SSTORE operation if the zeroness does not change from zero"
            },
            sstoreRefund: {
                v: 15e3,
                d: "Once per SSTORE operation if the zeroness changes to zero"
            },
            jumpdest: {
                v: 1,
                d: "Base fee of the JUMPDEST opcode"
            },
            log: {
                v: 375,
                d: "Base fee of the LOG opcode"
            },
            logData: {
                v: 8,
                d: "Per byte in a LOG* operation's data"
            },
            logTopic: {
                v: 375,
                d: "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"
            },
            create: {
                v: 32e3,
                d: "Base fee of the CREATE opcode"
            },
            call: {
                v: 40,
                d: "Base fee of the CALL opcode"
            },
            callStipend: {
                v: 2300,
                d: "Free gas given at beginning of call"
            },
            callValueTransfer: {
                v: 9e3,
                d: "Paid for CALL when the value transfor is non-zero"
            },
            callNewAccount: {
                v: 25e3,
                d: "Paid for CALL when the destination address didn't exist prior"
            },
            selfdestructRefund: {
                v: 24e3,
                d: "Refunded following a selfdestruct operation"
            },
            memory: {
                v: 3,
                d: "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"
            },
            quadCoeffDiv: {
                v: 512,
                d: "Divisor for the quadratic particle of the memory cost equation"
            },
            createData: {
                v: 200,
                d: ""
            },
            tx: {
                v: 21e3,
                d: "Per transaction. NOTE: Not payable on data of calls between transactions"
            },
            txCreation: {
                v: 32e3,
                d: "The cost of creating a contract via tx"
            },
            txDataZero: {
                v: 4,
                d: "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"
            },
            txDataNonZero: {
                v: 68,
                d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
            },
            copy: {
                v: 3,
                d: "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"
            },
            ecRecover: {
                v: 3e3,
                d: ""
            },
            sha256: {
                v: 60,
                d: ""
            },
            sha256Word: {
                v: 12,
                d: ""
            },
            ripemd160: {
                v: 600,
                d: ""
            },
            ripemd160Word: {
                v: 120,
                d: ""
            },
            identity: {
                v: 15,
                d: ""
            },
            identityWord: {
                v: 3,
                d: ""
            },
            stop: {
                v: 0,
                d: "Base fee of the STOP opcode"
            },
            add: {
                v: 3,
                d: "Base fee of the ADD opcode"
            },
            mul: {
                v: 5,
                d: "Base fee of the MUL opcode"
            },
            sub: {
                v: 3,
                d: "Base fee of the SUB opcode"
            },
            div: {
                v: 5,
                d: "Base fee of the DIV opcode"
            },
            sdiv: {
                v: 5,
                d: "Base fee of the SDIV opcode"
            },
            mod: {
                v: 5,
                d: "Base fee of the MOD opcode"
            },
            smod: {
                v: 5,
                d: "Base fee of the SMOD opcode"
            },
            addmod: {
                v: 8,
                d: "Base fee of the ADDMOD opcode"
            },
            mulmod: {
                v: 8,
                d: "Base fee of the MULMOD opcode"
            },
            signextend: {
                v: 5,
                d: "Base fee of the SIGNEXTEND opcode"
            },
            lt: {
                v: 3,
                d: "Base fee of the LT opcode"
            },
            gt: {
                v: 3,
                d: "Base fee of the GT opcode"
            },
            slt: {
                v: 3,
                d: "Base fee of the SLT opcode"
            },
            sgt: {
                v: 3,
                d: "Base fee of the SGT opcode"
            },
            eq: {
                v: 3,
                d: "Base fee of the EQ opcode"
            },
            iszero: {
                v: 3,
                d: "Base fee of the ISZERO opcode"
            },
            and: {
                v: 3,
                d: "Base fee of the AND opcode"
            },
            or: {
                v: 3,
                d: "Base fee of the OR opcode"
            },
            xor: {
                v: 3,
                d: "Base fee of the XOR opcode"
            },
            not: {
                v: 3,
                d: "Base fee of the NOT opcode"
            },
            byte: {
                v: 3,
                d: "Base fee of the BYTE opcode"
            },
            address: {
                v: 2,
                d: "Base fee of the ADDRESS opcode"
            },
            balance: {
                v: 20,
                d: "Base fee of the BALANCE opcode"
            },
            origin: {
                v: 2,
                d: "Base fee of the ORIGIN opcode"
            },
            caller: {
                v: 2,
                d: "Base fee of the CALLER opcode"
            },
            callvalue: {
                v: 2,
                d: "Base fee of the CALLVALUE opcode"
            },
            calldataload: {
                v: 3,
                d: "Base fee of the CALLDATALOAD opcode"
            },
            calldatasize: {
                v: 2,
                d: "Base fee of the CALLDATASIZE opcode"
            },
            calldatacopy: {
                v: 3,
                d: "Base fee of the CALLDATACOPY opcode"
            },
            codesize: {
                v: 2,
                d: "Base fee of the CODESIZE opcode"
            },
            codecopy: {
                v: 3,
                d: "Base fee of the CODECOPY opcode"
            },
            gasprice: {
                v: 2,
                d: "Base fee of the GASPRICE opcode"
            },
            extcodesize: {
                v: 20,
                d: "Base fee of the EXTCODESIZE opcode"
            },
            extcodecopy: {
                v: 20,
                d: "Base fee of the EXTCODECOPY opcode"
            },
            blockhash: {
                v: 20,
                d: "Base fee of the BLOCKHASH opcode"
            },
            coinbase: {
                v: 2,
                d: "Base fee of the COINBASE opcode"
            },
            timestamp: {
                v: 2,
                d: "Base fee of the TIMESTAMP opcode"
            },
            number: {
                v: 2,
                d: "Base fee of the NUMBER opcode"
            },
            difficulty: {
                v: 2,
                d: "Base fee of the DIFFICULTY opcode"
            },
            gaslimit: {
                v: 2,
                d: "Base fee of the GASLIMIT opcode"
            },
            pop: {
                v: 2,
                d: "Base fee of the POP opcode"
            },
            mload: {
                v: 3,
                d: "Base fee of the MLOAD opcode"
            },
            mstore: {
                v: 3,
                d: "Base fee of the MSTORE opcode"
            },
            mstore8: {
                v: 3,
                d: "Base fee of the MSTORE8 opcode"
            },
            sstore: {
                v: 0,
                d: "Base fee of the SSTORE opcode"
            },
            jump: {
                v: 8,
                d: "Base fee of the JUMP opcode"
            },
            jumpi: {
                v: 10,
                d: "Base fee of the JUMPI opcode"
            },
            pc: {
                v: 2,
                d: "Base fee of the PC opcode"
            },
            msize: {
                v: 2,
                d: "Base fee of the MSIZE opcode"
            },
            gas: {
                v: 2,
                d: "Base fee of the GAS opcode"
            },
            push: {
                v: 3,
                d: "Base fee of the PUSH opcode"
            },
            dup: {
                v: 3,
                d: "Base fee of the DUP opcode"
            },
            swap: {
                v: 3,
                d: "Base fee of the SWAP opcode"
            },
            callcode: {
                v: 40,
                d: "Base fee of the CALLCODE opcode"
            },
            return: {
                v: 0,
                d: "Base fee of the RETURN opcode"
            },
            invalid: {
                v: 0,
                d: "Base fee of the INVALID opcode"
            },
            selfdestruct: {
                v: 0,
                d: "Base fee of the SELFDESTRUCT opcode"
            }
        },
        vm: {
            stackLimit: {
                v: 1024,
                d: "Maximum size of VM stack allowed"
            },
            callCreateDepth: {
                v: 1024,
                d: "Maximum depth of call/create stack"
            },
            maxExtraDataSize: {
                v: 32,
                d: "Maximum size extra data may be after Genesis"
            }
        },
        pow: {
            minimumDifficulty: {
                v: 131072,
                d: "The minimum that the difficulty may ever be"
            },
            difficultyBoundDivisor: {
                v: 2048,
                d: "The bound divisor of the difficulty, used in the update calculations"
            },
            durationLimit: {
                v: 13,
                d: "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"
            },
            epochDuration: {
                v: 3e4,
                d: "Duration between proof-of-work epochs"
            },
            timebombPeriod: {
                v: 1e5,
                d: "Exponential difficulty timebomb period"
            },
            minerReward: {
                v: "5000000000000000000",
                d: "the amount a miner get rewarded for mining a block"
            },
            difficultyBombDelay: {
                v: 0,
                d: "the amount of blocks to delay the difficulty bomb with"
            }
        }
    },
    UJ = {
        name: "dao",
        comment: "DAO rescue hardfork",
        url: "https://eips.ethereum.org/EIPS/eip-779",
        status: "Final",
        gasConfig: {},
        gasPrices: {},
        vm: {},
        pow: {}
    },
    HJ = {
        name: "homestead",
        comment: "Homestead hardfork with protocol and network changes",
        url: "https://eips.ethereum.org/EIPS/eip-606",
        status: "Final",
        gasConfig: {},
        gasPrices: {
            delegatecall: {
                v: 40,
                d: "Base fee of the DELEGATECALL opcode"
            }
        },
        vm: {},
        pow: {}
    },
    VJ = {
        name: "tangerineWhistle",
        comment: "Hardfork with gas cost changes for IO-heavy operations",
        url: "https://eips.ethereum.org/EIPS/eip-608",
        status: "Final",
        gasConfig: {},
        gasPrices: {
            sload: {
                v: 200,
                d: "Once per SLOAD operation"
            },
            call: {
                v: 700,
                d: "Once per CALL operation & message call transaction"
            },
            extcodesize: {
                v: 700,
                d: "Base fee of the EXTCODESIZE opcode"
            },
            extcodecopy: {
                v: 700,
                d: "Base fee of the EXTCODECOPY opcode"
            },
            balance: {
                v: 400,
                d: "Base fee of the BALANCE opcode"
            },
            delegatecall: {
                v: 700,
                d: "Base fee of the DELEGATECALL opcode"
            },
            callcode: {
                v: 700,
                d: "Base fee of the CALLCODE opcode"
            },
            selfdestruct: {
                v: 5e3,
                d: "Base fee of the SELFDESTRUCT opcode"
            }
        },
        vm: {},
        pow: {}
    },
    zJ = {
        name: "spuriousDragon",
        comment: "HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",
        url: "https://eips.ethereum.org/EIPS/eip-607",
        status: "Final",
        gasConfig: {},
        gasPrices: {
            expByte: {
                v: 50,
                d: "Times ceil(log256(exponent)) for the EXP instruction"
            }
        },
        vm: {
            maxCodeSize: {
                v: 24576,
                d: "Maximum length of contract code"
            }
        },
        pow: {}
    },
    WJ = {
        name: "byzantium",
        comment: "Hardfork with new precompiles, instructions and other protocol changes",
        url: "https://eips.ethereum.org/EIPS/eip-609",
        status: "Final",
        gasConfig: {},
        gasPrices: {
            modexpGquaddivisor: {
                v: 20,
                d: "Gquaddivisor from modexp precompile for gas calculation"
            },
            ecAdd: {
                v: 500,
                d: "Gas costs for curve addition precompile"
            },
            ecMul: {
                v: 4e4,
                d: "Gas costs for curve multiplication precompile"
            },
            ecPairing: {
                v: 1e5,
                d: "Base gas costs for curve pairing precompile"
            },
            ecPairingWord: {
                v: 8e4,
                d: "Gas costs regarding curve pairing precompile input length"
            },
            revert: {
                v: 0,
                d: "Base fee of the REVERT opcode"
            },
            staticcall: {
                v: 700,
                d: "Base fee of the STATICCALL opcode"
            },
            returndatasize: {
                v: 2,
                d: "Base fee of the RETURNDATASIZE opcode"
            },
            returndatacopy: {
                v: 3,
                d: "Base fee of the RETURNDATACOPY opcode"
            }
        },
        vm: {},
        pow: {
            minerReward: {
                v: "3000000000000000000",
                d: "the amount a miner get rewarded for mining a block"
            },
            difficultyBombDelay: {
                v: 3e6,
                d: "the amount of blocks to delay the difficulty bomb with"
            }
        }
    },
    GJ = {
        name: "constantinople",
        comment: "Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",
        url: "https://eips.ethereum.org/EIPS/eip-1013",
        status: "Final",
        gasConfig: {},
        gasPrices: {
            netSstoreNoopGas: {
                v: 200,
                d: "Once per SSTORE operation if the value doesn't change"
            },
            netSstoreInitGas: {
                v: 2e4,
                d: "Once per SSTORE operation from clean zero"
            },
            netSstoreCleanGas: {
                v: 5e3,
                d: "Once per SSTORE operation from clean non-zero"
            },
            netSstoreDirtyGas: {
                v: 200,
                d: "Once per SSTORE operation from dirty"
            },
            netSstoreClearRefund: {
                v: 15e3,
                d: "Once per SSTORE operation for clearing an originally existing storage slot"
            },
            netSstoreResetRefund: {
                v: 4800,
                d: "Once per SSTORE operation for resetting to the original non-zero value"
            },
            netSstoreResetClearRefund: {
                v: 19800,
                d: "Once per SSTORE operation for resetting to the original zero value"
            },
            shl: {
                v: 3,
                d: "Base fee of the SHL opcode"
            },
            shr: {
                v: 3,
                d: "Base fee of the SHR opcode"
            },
            sar: {
                v: 3,
                d: "Base fee of the SAR opcode"
            },
            extcodehash: {
                v: 400,
                d: "Base fee of the EXTCODEHASH opcode"
            },
            create2: {
                v: 32e3,
                d: "Base fee of the CREATE2 opcode"
            }
        },
        vm: {},
        pow: {
            minerReward: {
                v: "2000000000000000000",
                d: "The amount a miner gets rewarded for mining a block"
            },
            difficultyBombDelay: {
                v: 5e6,
                d: "the amount of blocks to delay the difficulty bomb with"
            }
        }
    },
    qJ = {
        name: "petersburg",
        comment: "Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",
        url: "https://eips.ethereum.org/EIPS/eip-1716",
        status: "Final",
        gasConfig: {},
        gasPrices: {
            netSstoreNoopGas: {
                v: null,
                d: "Removed along EIP-1283"
            },
            netSstoreInitGas: {
                v: null,
                d: "Removed along EIP-1283"
            },
            netSstoreCleanGas: {
                v: null,
                d: "Removed along EIP-1283"
            },
            netSstoreDirtyGas: {
                v: null,
                d: "Removed along EIP-1283"
            },
            netSstoreClearRefund: {
                v: null,
                d: "Removed along EIP-1283"
            },
            netSstoreResetRefund: {
                v: null,
                d: "Removed along EIP-1283"
            },
            netSstoreResetClearRefund: {
                v: null,
                d: "Removed along EIP-1283"
            }
        },
        vm: {},
        pow: {}
    },
    KJ = {
        name: "istanbul",
        comment: "HF targeted for December 2019 following the Constantinople/Petersburg HF",
        url: "https://eips.ethereum.org/EIPS/eip-1679",
        status: "Final",
        gasConfig: {},
        gasPrices: {
            blake2Round: {
                v: 1,
                d: "Gas cost per round for the Blake2 F precompile"
            },
            ecAdd: {
                v: 150,
                d: "Gas costs for curve addition precompile"
            },
            ecMul: {
                v: 6e3,
                d: "Gas costs for curve multiplication precompile"
            },
            ecPairing: {
                v: 45e3,
                d: "Base gas costs for curve pairing precompile"
            },
            ecPairingWord: {
                v: 34e3,
                d: "Gas costs regarding curve pairing precompile input length"
            },
            txDataNonZero: {
                v: 16,
                d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
            },
            sstoreSentryGasEIP2200: {
                v: 2300,
                d: "Minimum gas required to be present for an SSTORE call, not consumed"
            },
            sstoreNoopGasEIP2200: {
                v: 800,
                d: "Once per SSTORE operation if the value doesn't change"
            },
            sstoreDirtyGasEIP2200: {
                v: 800,
                d: "Once per SSTORE operation if a dirty value is changed"
            },
            sstoreInitGasEIP2200: {
                v: 2e4,
                d: "Once per SSTORE operation from clean zero to non-zero"
            },
            sstoreInitRefundEIP2200: {
                v: 19200,
                d: "Once per SSTORE operation for resetting to the original zero value"
            },
            sstoreCleanGasEIP2200: {
                v: 5e3,
                d: "Once per SSTORE operation from clean non-zero to something else"
            },
            sstoreCleanRefundEIP2200: {
                v: 4200,
                d: "Once per SSTORE operation for resetting to the original non-zero value"
            },
            sstoreClearRefundEIP2200: {
                v: 15e3,
                d: "Once per SSTORE operation for clearing an originally existing storage slot"
            },
            balance: {
                v: 700,
                d: "Base fee of the BALANCE opcode"
            },
            extcodehash: {
                v: 700,
                d: "Base fee of the EXTCODEHASH opcode"
            },
            chainid: {
                v: 2,
                d: "Base fee of the CHAINID opcode"
            },
            selfbalance: {
                v: 5,
                d: "Base fee of the SELFBALANCE opcode"
            },
            sload: {
                v: 800,
                d: "Base fee of the SLOAD opcode"
            }
        },
        vm: {},
        pow: {}
    },
    QJ = {
        name: "muirGlacier",
        comment: "HF to delay the difficulty bomb",
        url: "https://eips.ethereum.org/EIPS/eip-2384",
        status: "Final",
        gasConfig: {},
        gasPrices: {},
        vm: {},
        pow: {
            difficultyBombDelay: {
                v: 9e6,
                d: "the amount of blocks to delay the difficulty bomb with"
            }
        }
    },
    YJ = {
        name: "berlin",
        comment: "HF targeted for July 2020 following the Muir Glacier HF",
        url: "https://eips.ethereum.org/EIPS/eip-2070",
        status: "Final",
        eips: [2565, 2929, 2718, 2930]
    },
    XJ = {
        name: "london",
        comment: "HF targeted for July 2021 following the Berlin fork",
        url: "https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md",
        status: "Final",
        eips: [1559, 3198, 3529, 3541]
    },
    ZJ = {
        name: "shanghai",
        comment: "Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode",
        url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md",
        status: "Final",
        eips: [3651, 3855, 3860, 4895]
    },
    JJ = {
        name: "arrowGlacier",
        comment: "HF to delay the difficulty bomb",
        url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md",
        status: "Final",
        eips: [4345],
        gasConfig: {},
        gasPrices: {},
        vm: {},
        pow: {}
    },
    eee = {
        name: "grayGlacier",
        comment: "Delaying the difficulty bomb to Mid September 2022",
        url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md",
        status: "Draft",
        eips: [5133],
        gasConfig: {},
        gasPrices: {},
        vm: {},
        pow: {}
    },
    tee = {
        name: "mergeForkIdTransition",
        comment: "Pre-merge hardfork to fork off non-upgraded clients",
        url: "https://eips.ethereum.org/EIPS/eip-3675",
        status: "Draft",
        eips: []
    },
    nee = {
        name: "merge",
        comment: "Hardfork to upgrade the consensus mechanism to Proof-of-Stake",
        url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md",
        status: "Final",
        consensus: {
            type: "pos",
            algorithm: "casper",
            casper: {}
        },
        eips: [3675, 4399]
    },
    ree = {
        chainstart: FJ,
        homestead: HJ,
        dao: UJ,
        tangerineWhistle: VJ,
        spuriousDragon: zJ,
        byzantium: WJ,
        constantinople: GJ,
        petersburg: qJ,
        istanbul: KJ,
        muirGlacier: QJ,
        berlin: YJ,
        london: XJ,
        shanghai: ZJ,
        arrowGlacier: JJ,
        grayGlacier: eee,
        mergeForkIdTransition: tee,
        merge: nee
    },
    {
        buf: iee
    } = pJ;
class Ct extends DS {
    static custom(t, n = {}) {
        var r;
        const i = (r = n.baseChain) !== null && r !== void 0 ? r : "mainnet",
            o = Object.assign({}, Ct._getChainParams(i));
        if (o.name = "custom-chain", typeof t != "string") return new Ct(Object.assign({
            chain: Object.assign(Object.assign({}, o), t)
        }, n));
        if (t === Zt.PolygonMainnet) return Ct.custom({
            name: Zt.PolygonMainnet,
            chainId: 137,
            networkId: 137
        }, n);
        if (t === Zt.PolygonMumbai) return Ct.custom({
            name: Zt.PolygonMumbai,
            chainId: 80001,
            networkId: 80001
        }, n);
        if (t === Zt.ArbitrumRinkebyTestnet) return Ct.custom({
            name: Zt.ArbitrumRinkebyTestnet,
            chainId: 421611,
            networkId: 421611
        }, n);
        if (t === Zt.ArbitrumOne) return Ct.custom({
            name: Zt.ArbitrumOne,
            chainId: 42161,
            networkId: 42161
        }, n);
        if (t === Zt.xDaiChain) return Ct.custom({
            name: Zt.xDaiChain,
            chainId: 100,
            networkId: 100
        }, n);
        if (t === Zt.OptimisticKovan) return Ct.custom({
            name: Zt.OptimisticKovan,
            chainId: 69,
            networkId: 69
        }, Object.assign({
            hardfork: Ge.Berlin
        }, n));
        if (t === Zt.OptimisticEthereum) return Ct.custom({
            name: Zt.OptimisticEthereum,
            chainId: 10,
            networkId: 10
        }, Object.assign({
            hardfork: Ge.Berlin
        }, n));
        throw new Error(`Custom chain ${t} not supported`)
    }
    static fromGethGenesis(t, {
        chain: n,
        eips: r,
        genesisHash: i,
        hardfork: o,
        mergeForkIdPostMerge: a
    }) {
        var s;
        const u = iJ(t, n, a),
            l = new Ct({
                chain: (s = u.name) !== null && s !== void 0 ? s : "custom",
                customChains: [u],
                eips: r,
                hardfork: o ? ? u.hardfork
            });
        return i !== void 0 && l.setForkHashes(i), l
    }
    static isSupportedChainId(t) {
        return !!this._getInitializedChains().names[t.toString()]
    }
    static _getChainParams(t, n) {
        let r = t;
        const i = this._getInitializedChains(n);
        if (typeof r == "number" || typeof r == "bigint") {
            if (r = r.toString(), i.names[r]) {
                const o = i.names[r];
                return i[o]
            }
            throw new Error(`Chain with ID ${r} not supported`)
        }
        if (i[r] !== void 0) return i[r];
        throw new Error(`Chain with name ${r} not supported`)
    }
    constructor(t) {
        var n, r;
        super(), this._eips = [], this._customChains = (n = t.customChains) !== null && n !== void 0 ? n : [], this._chainParams = this.setChain(t.chain), this.DEFAULT_HARDFORK = (r = this._chainParams.defaultHardfork) !== null && r !== void 0 ? r : Ge.Merge, this.HARDFORK_CHANGES = this.hardforks().map(i => [i.name, ree[i.name]]), this._hardfork = this.DEFAULT_HARDFORK, t.hardfork !== void 0 && this.setHardfork(t.hardfork), t.eips && this.setEIPs(t.eips)
    }
    setChain(t) {
        if (typeof t == "number" || typeof t == "bigint" || typeof t == "string") this._chainParams = Ct._getChainParams(t, this._customChains);
        else if (typeof t == "object") {
            if (this._customChains.length > 0) throw new Error("Chain must be a string, number, or bigint when initialized with customChains passed in");
            const n = ["networkId", "genesis", "hardforks", "bootstrapNodes"];
            for (const r of n)
                if (!(r in t)) throw new Error(`Missing required chain parameter: ${r}`);
            this._chainParams = t
        } else throw new Error("Wrong input format");
        for (const n of this.hardforks())
            if (n.block === void 0) throw new Error("Hardfork cannot have undefined block number");
        return this._chainParams
    }
    setHardfork(t) {
        let n = !1;
        for (const r of this.HARDFORK_CHANGES) r[0] === t && (this._hardfork !== t && (this._hardfork = t, this.emit("hardforkChanged", t)), n = !0);
        if (!n) throw new Error(`Hardfork with name ${t} not supported`)
    }
    getHardforkByBlockNumber(t, n, r) {
        const i = Ws(t, or.BigInt),
            o = Ws(n, or.BigInt),
            a = Ws(r, or.Number),
            s = this.hardforks().filter(h => h.block !== null || h.ttd !== null && h.ttd !== void 0 || h.timestamp !== void 0),
            u = s.findIndex(h => h.ttd !== null && h.ttd !== void 0);
        if (s.slice(u + 1).findIndex(h => h.ttd !== null && h.ttd !== void 0) >= 0) throw Error("More than one merge hardforks found with ttd specified");
        let c = s.findIndex(h => h.block !== null && h.block > i || a !== void 0 && Number(h.timestamp) > a);
        if (c === -1) c = s.length;
        else if (c === 0) throw Error("Must have at least one hardfork at block 0");
        if (a === void 0) {
            const h = s.slice(0, c).reverse().findIndex(m => m.block !== null || m.ttd !== void 0);
            c -= h
        }
        if (c -= 1, s[c].block === null && s[c].timestamp === void 0)(o == null || BigInt(s[c].ttd) > o) && (c -= 1);
        else if (u >= 0 && o !== void 0 && o !== null) {
            if (c >= u && BigInt(s[u].ttd) > o) throw Error("Maximum HF determined by total difficulty is lower than the block number HF");
            if (c < u && BigInt(s[u].ttd) <= o) throw Error("HF determined by block number is lower than the minimum total difficulty HF")
        }
        const f = c;
        for (; c < s.length - 1 && !(s[c].block !== s[c + 1].block || s[c].timestamp !== s[c + 1].timestamp); c += 1);
        if (a) {
            if (s.slice(0, f).reduce((p, y) => {
                    var g;
                    return Math.max(Number((g = y.timestamp) !== null && g !== void 0 ? g : "0"), p)
                }, 0) > a) throw Error("Maximum HF determined by timestamp is lower than the block number/ttd HF");
            if (s.slice(c + 1).reduce((p, y) => {
                    var g;
                    return Math.min(Number((g = y.timestamp) !== null && g !== void 0 ? g : a), p)
                }, a) < a) throw Error("Maximum HF determined by block number/ttd is lower than timestamp HF")
        }
        return s[c].name
    }
    setHardforkByBlockNumber(t, n, r) {
        const i = this.getHardforkByBlockNumber(t, n, r);
        return this.setHardfork(i), i
    }
    _getHardfork(t) {
        const n = this.hardforks();
        for (const r of n)
            if (r.name === t) return r;
        return null
    }
    setEIPs(t = []) {
        for (const n of t) {
            if (!(n in qs)) throw new Error(`${n} not supported`);
            const r = this.gteHardfork(qs[n].minimumHardfork);
            if (!r) throw new Error(`${n} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${r}`);
            if (qs[n].requiredEIPs !== void 0) {
                for (const i of qs[n].requiredEIPs)
                    if (!(t.includes(i) || this.isActivatedEIP(i))) throw new Error(`${n} requires EIP ${i}, but is not included in the EIP list`)
            }
        }
        this._eips = t
    }
    param(t, n) {
        let r;
        for (const i of this._eips)
            if (r = this.paramByEIP(t, n, i), r !== void 0) return r;
        return this.paramByHardfork(t, n, this._hardfork)
    }
    paramByHardfork(t, n, r) {
        let i = null;
        for (const o of this.HARDFORK_CHANGES) {
            if ("eips" in o[1]) {
                const a = o[1].eips;
                for (const s of a) {
                    const u = this.paramByEIP(t, n, s);
                    i = typeof u == "bigint" ? u : i
                }
            } else {
                if (o[1][t] === void 0) throw new Error(`Topic ${t} not defined`);
                o[1][t][n] !== void 0 && (i = o[1][t][n].v)
            }
            if (o[0] === r) break
        }
        return BigInt(i ? ? 0)
    }
    paramByEIP(t, n, r) {
        if (!(r in qs)) throw new Error(`${r} not supported`);
        const i = qs[r];
        if (!(t in i)) throw new Error(`Topic ${t} not defined`);
        if (i[t][n] === void 0) return;
        const o = i[t][n].v;
        return BigInt(o)
    }
    paramByBlock(t, n, r, i, o) {
        const a = this.getHardforkByBlockNumber(r, i, o);
        return this.paramByHardfork(t, n, a)
    }
    isActivatedEIP(t) {
        if (this.eips().includes(t)) return !0;
        for (const n of this.HARDFORK_CHANGES) {
            const r = n[1];
            if (this.gteHardfork(r.name) && "eips" in r && r.eips.includes(t)) return !0
        }
        return !1
    }
    hardforkIsActiveOnBlock(t, n) {
        const r = Ws(n, or.BigInt),
            i = t ? ? this._hardfork,
            o = this.hardforkBlock(i);
        return typeof o == "bigint" && o !== BigInt(0) && r >= o
    }
    activeOnBlock(t) {
        return this.hardforkIsActiveOnBlock(null, t)
    }
    hardforkGteHardfork(t, n) {
        const r = t ? ? this._hardfork,
            i = this.hardforks();
        let o = -1,
            a = -1,
            s = 0;
        for (const u of i) u.name === r && (o = s), u.name === n && (a = s), s += 1;
        return o >= a && a !== -1
    }
    gteHardfork(t) {
        return this.hardforkGteHardfork(null, t)
    }
    hardforkBlock(t) {
        var n;
        const r = t ? ? this._hardfork,
            i = (n = this._getHardfork(r)) === null || n === void 0 ? void 0 : n.block;
        return i == null ? null : BigInt(i)
    }
    hardforkTimestamp(t) {
        var n;
        const r = t ? ? this._hardfork,
            i = (n = this._getHardfork(r)) === null || n === void 0 ? void 0 : n.timestamp;
        return i == null ? null : BigInt(i)
    }
    eipBlock(t) {
        for (const n of this.HARDFORK_CHANGES) {
            const r = n[1];
            if ("eips" in r && r.eips.includes(t)) return this.hardforkBlock(typeof n[0] == "number" ? String(n[0]) : n[0])
        }
        return null
    }
    hardforkTTD(t) {
        var n;
        const r = t ? ? this._hardfork,
            i = (n = this._getHardfork(r)) === null || n === void 0 ? void 0 : n.ttd;
        return i == null ? null : BigInt(i)
    }
    isHardforkBlock(t, n) {
        const r = Ws(t, or.BigInt),
            i = n ? ? this._hardfork,
            o = this.hardforkBlock(i);
        return typeof o == "bigint" && o !== BigInt(0) ? o === r : !1
    }
    nextHardforkBlockOrTimestamp(t) {
        var n, r, i;
        const o = (n = t) !== null && n !== void 0 ? n : this._hardfork,
            a = this.hardforks();
        let s = a.findIndex(f => f.name === o);
        if (o === Ge.Merge && (s -= 1), s < 0) return null;
        let u = (r = a[s].timestamp) !== null && r !== void 0 ? r : a[s].block;
        u = u != null ? Number(u) : null;
        const l = a.slice(s + 1).find(f => {
            var d;
            let h = (d = f.timestamp) !== null && d !== void 0 ? d : f.block;
            return h = h != null ? Number(h) : null, f.name !== Ge.Merge && h !== null && h !== void 0 && h !== u
        });
        if (l === void 0) return null;
        const c = (i = l.timestamp) !== null && i !== void 0 ? i : l.block;
        return c == null ? null : BigInt(c)
    }
    nextHardforkBlock(t) {
        var n;
        const r = (n = t) !== null && n !== void 0 ? n : this._hardfork;
        let i = this.hardforkBlock(r);
        if (i === null && r === Ge.Merge) {
            const a = this.hardforks(),
                s = a.findIndex(u => u.ttd !== null && u.ttd !== void 0);
            if (s < 0) throw Error("Merge hardfork should have been found");
            i = this.hardforkBlock(a[s - 1].name)
        }
        return i === null ? null : this.hardforks().reduce((a, s) => {
            const u = BigInt(s.block === null || s.ttd !== void 0 && s.ttd !== null ? 0 : s.block);
            return u > i && a === null ? u : a
        }, null)
    }
    isNextHardforkBlock(t, n) {
        const r = Ws(t, or.BigInt),
            i = n ? ? this._hardfork,
            o = this.nextHardforkBlock(i);
        return o === null ? !1 : o === r
    }
    _calcForkHash(t, n) {
        let r = new Uint8Array,
            i = 0;
        for (const s of this.hardforks()) {
            const {
                block: u,
                timestamp: l,
                name: c
            } = s;
            let f = l ? ? u;
            if (f = f !== null ? Number(f) : null, typeof f == "number" && f !== 0 && f !== i && c !== Ge.Merge) {
                const d = Ke(f.toString(16).padStart(16, "0"));
                r = bn(r, d), i = f
            }
            if (s.name === t) break
        }
        const o = bn(n, r);
        return Ee(oJ(iee(o) >>> 0))
    }
    forkHash(t, n) {
        const r = t ? ? this._hardfork,
            i = this._getHardfork(r);
        if (i === null || (i == null ? void 0 : i.block) === null && (i == null ? void 0 : i.timestamp) === void 0 && (i == null ? void 0 : i.ttd) === void 0) {
            const o = "No fork hash calculation possible for future hardfork";
            throw new Error(o)
        }
        if ((i == null ? void 0 : i.forkHash) !== null && (i == null ? void 0 : i.forkHash) !== void 0) return i.forkHash;
        if (!n) throw new Error("genesisHash required for forkHash calculation");
        return this._calcForkHash(r, n)
    }
    hardforkForForkHash(t) {
        const n = this.hardforks().filter(r => r.forkHash === t);
        return n.length >= 1 ? n[n.length - 1] : null
    }
    setForkHashes(t) {
        var n;
        for (const r of this.hardforks()) {
            const i = (n = r.timestamp) !== null && n !== void 0 ? n : r.block;
            (r.forkHash === null || r.forkHash === void 0) && (i != null || typeof r.ttd < "u") && (r.forkHash = this.forkHash(r.name, t))
        }
    }
    genesis() {
        return this._chainParams.genesis
    }
    hardforks() {
        return this._chainParams.hardforks
    }
    bootstrapNodes() {
        return this._chainParams.bootstrapNodes
    }
    dnsNetworks() {
        return this._chainParams.dnsNetworks
    }
    hardfork() {
        return this._hardfork
    }
    chainId() {
        return BigInt(this._chainParams.chainId)
    }
    chainName() {
        return this._chainParams.name
    }
    networkId() {
        return BigInt(this._chainParams.networkId)
    }
    eips() {
        return this._eips
    }
    consensusType() {
        const t = this.hardfork();
        let n;
        for (const r of this.HARDFORK_CHANGES)
            if ("consensus" in r[1] && (n = r[1].consensus.type), r[0] === t) break;
        return n ? ? this._chainParams.consensus.type
    }
    consensusAlgorithm() {
        const t = this.hardfork();
        let n;
        for (const r of this.HARDFORK_CHANGES)
            if ("consensus" in r[1] && (n = r[1].consensus.algorithm), r[0] === t) break;
        return n ? ? this._chainParams.consensus.algorithm
    }
    consensusConfig() {
        var t;
        const n = this.hardfork();
        let r;
        for (const i of this.HARDFORK_CHANGES)
            if ("consensus" in i[1] && (r = i[1].consensus[i[1].consensus.algorithm]), i[0] === n) break;
        return (t = r ? ? this._chainParams.consensus[this.consensusAlgorithm()]) !== null && t !== void 0 ? t : {}
    }
    copy() {
        const t = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
        return t.removeAllListeners(), t
    }
    static _getInitializedChains(t) {
        const n = {};
        for (const [i, o] of Object.entries(hg)) n[o] = i.toLowerCase();
        const r = {
            mainnet: gJ,
            goerli: mJ,
            sepolia: yJ
        };
        if (t)
            for (const i of t) {
                const {
                    name: o
                } = i;
                n[i.chainId.toString()] = o, r[o] = i
            }
        return r.names = n, r
    }
}
var ei;
(function(e) {
    e[e.EIP155ReplayProtection = 155] = "EIP155ReplayProtection", e[e.EIP1559FeeMarket = 1559] = "EIP1559FeeMarket", e[e.EIP2718TypedTransaction = 2718] = "EIP2718TypedTransaction", e[e.EIP2930AccessLists = 2930] = "EIP2930AccessLists"
})(ei || (ei = {}));

function oee(e) {
    if (e.length === 0) return !0;
    const t = e[0];
    return !!Array.isArray(t)
}

function aee(e) {
    return !oee(e)
}
class ju {
    constructor(t) {
        if (t.length !== 20) throw new Error("Invalid address length");
        this.buf = t
    }
    static zero() {
        return new ju(QD(20))
    }
    equals(t) {
        return lv(this.buf, t.buf)
    }
    isZero() {
        return this.equals(ju.zero())
    }
    toString() {
        return Ee(this.buf)
    }
    toArray() {
        return this.buf
    }
    static publicToAddress(t, n = !1) {
        let r = t;
        if (e_(r), n && r.length !== 64 && (r = po.ProjectivePoint.fromHex(r).toRawBytes(!1).slice(1)), r.length !== 64) throw new Error("Expected pubKey to be of length 64");
        return dn(r).slice(-20)
    }
}
const see = (e, t) => {
        const n = e.param("vm", "maxInitCodeSize");
        if (n && BigInt(t) > n) throw new Error(`the initcode size of this transaction is too large: it is ${t} while the max is ${e.param("vm","maxInitCodeSize")}`)
    },
    r$ = e => {
        let t, n;
        if (aee(e)) {
            t = e;
            const r = [];
            for (let i = 0; i < e.length; i += 1) {
                const o = e[i],
                    a = tt(o.address),
                    s = [];
                for (let u = 0; u < o.storageKeys.length; u += 1) s.push(tt(o.storageKeys[u]));
                r.push([a, s])
            }
            n = r
        } else {
            n = e ? ? [];
            const r = [];
            for (let i = 0; i < n.length; i += 1) {
                const o = n[i],
                    a = Ee(o[0]),
                    s = [];
                for (let l = 0; l < o[1].length; l += 1) s.push(Ee(o[1][l]));
                const u = {
                    address: a,
                    storageKeys: s
                };
                r.push(u)
            }
            t = r
        }
        return {
            AccessListJSON: t,
            accessList: n
        }
    },
    i$ = e => {
        for (let t = 0; t < e.length; t += 1) {
            const n = e[t],
                r = n[0],
                i = n[1];
            if (n[2] !== void 0) throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");
            if (r.length !== 20) throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");
            for (let o = 0; o < i.length; o += 1)
                if (i[o].length !== 32) throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes")
        }
    },
    o$ = e => {
        const t = [];
        for (let n = 0; n < e.length; n += 1) {
            const r = e[n],
                i = {
                    address: Ee(QO(r[0], 20)),
                    storageKeys: []
                },
                o = r && r[1];
            for (let a = 0; a < o.length; a += 1) {
                const s = o[a];
                i.storageKeys.push(Ee(QO(s, 32)))
            }
            t.push(i)
        }
        return t
    },
    a$ = (e, t) => {
        const n = t.param("gasPrices", "accessListStorageKeyCost"),
            r = t.param("gasPrices", "accessListAddressCost");
        let i = 0;
        for (let a = 0; a < e.length; a += 1) {
            const u = e[a][1];
            i += u.length
        }
        return e.length * Number(r) + i * Number(n)
    };
class ll {
    constructor(t, n) {
        var r, i;
        this.cache = {
            hash: void 0,
            dataFee: void 0
        }, this.activeCapabilities = [], this.DEFAULT_CHAIN = hg.Mainnet, this.DEFAULT_HARDFORK = Ge.Merge;
        const {
            nonce: o,
            gasLimit: a,
            to: s,
            value: u,
            data: l,
            v: c,
            r: f,
            s: d,
            type: h
        } = t;
        this._type = Number(ze(tt(h))), this.txOptions = n;
        const m = tt(s === "" ? "0x" : s),
            p = tt(c === "" ? "0x" : c),
            y = tt(f === "" ? "0x" : f),
            g = tt(d === "" ? "0x" : d);
        this.nonce = ze(tt(o === "" ? "0x" : o)), this.gasLimit = ze(tt(a === "" ? "0x" : a)), this.to = m.length > 0 ? new ju(m) : void 0, this.value = ze(tt(u === "" ? "0x" : u)), this.data = tt(l === "" ? "0x" : l), this.v = p.length > 0 ? ze(p) : void 0, this.r = y.length > 0 ? ze(y) : void 0, this.s = g.length > 0 ? ze(g) : void 0, this._validateCannotExceedMaxInteger({
            value: this.value,
            r: this.r,
            s: this.s
        }), this._validateCannotExceedMaxInteger({
            gasLimit: this.gasLimit
        }, 64), this._validateCannotExceedMaxInteger({
            nonce: this.nonce
        }, 64, !0);
        const b = this.to === void 0 || this.to === null,
            v = (r = n.allowUnlimitedInitCodeSize) !== null && r !== void 0 ? r : !1,
            A = (i = n.common) !== null && i !== void 0 ? i : this._getCommon();
        b && A.isActivatedEIP(3860) && !v && see(A, this.data.length)
    }
    get type() {
        return this._type
    }
    supports(t) {
        return this.activeCapabilities.includes(t)
    }
    validate(t = !1) {
        const n = [];
        return this.getBaseFee() > this.gasLimit && n.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`), this.isSigned() && !this.verifySignature() && n.push("Invalid Signature"), t ? n : n.length === 0
    }
    _validateYParity() {
        const {
            v: t
        } = this;
        if (t !== void 0 && t !== BigInt(0) && t !== BigInt(1)) {
            const n = this._errorMsg("The y-parity of the transaction should either be 0 or 1");
            throw new Error(n)
        }
    }
    _validateHighS() {
        const {
            s: t
        } = this;
        if (this.common.gteHardfork("homestead") && t !== void 0 && t > eJ) {
            const n = this._errorMsg("Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");
            throw new Error(n)
        }
    }
    getBaseFee() {
        const t = this.common.param("gasPrices", "tx");
        let n = this.getDataFee();
        if (t && (n += t), this.common.gteHardfork("homestead") && this.toCreationAddress()) {
            const r = this.common.param("gasPrices", "txCreation");
            r && (n += r)
        }
        return n
    }
    getDataFee() {
        const t = this.common.param("gasPrices", "txDataZero"),
            n = this.common.param("gasPrices", "txDataNonZero");
        let r = BigInt(0);
        for (let i = 0; i < this.data.length; i += 1) this.data[i] === 0 ? r += t : r += n;
        if ((this.to === void 0 || this.to === null) && this.common.isActivatedEIP(3860)) {
            const i = BigInt(Math.ceil(this.data.length / 32)),
                o = this.common.param("gasPrices", "initCodeWordCost") * i;
            r += o
        }
        return r
    }
    toCreationAddress() {
        return this.to === void 0 || this.to.buf.length === 0
    }
    isSigned() {
        const {
            v: t,
            r: n,
            s: r
        } = this;
        return !(t === void 0 || n === void 0 || r === void 0)
    }
    verifySignature() {
        try {
            const t = this.getSenderPublicKey();
            return pg(t).length !== 0
        } catch {
            return !1
        }
    }
    getSenderAddress() {
        return new ju(ju.publicToAddress(this.getSenderPublicKey()))
    }
    sign(t) {
        if (t.length !== 32) {
            const u = this._errorMsg("Private key must be 32 bytes in length.");
            throw new Error(u)
        }
        let n = !1;
        this.type === 0 && this.common.gteHardfork("spuriousDragon") && !this.supports(ei.EIP155ReplayProtection) && (this.activeCapabilities.push(ei.EIP155ReplayProtection), n = !0);
        const r = this.getMessageToSign(!0),
            {
                v: i,
                r: o,
                s: a
            } = this._ecsign(r, t),
            s = this._processSignature(i, o, a);
        if (n) {
            const u = this.activeCapabilities.indexOf(ei.EIP155ReplayProtection);
            u > -1 && this.activeCapabilities.splice(u, 1)
        }
        return s
    }
    _getCommon(t, n) {
        var r, i, o, a;
        if (n !== void 0) {
            const s = ze(tt(n));
            if (t) {
                if (t.chainId() !== s) {
                    const u = this._errorMsg("The chain ID does not match the chain ID of Common");
                    throw new Error(u)
                }
                return t.copy()
            }
            return Ct.isSupportedChainId(s) ? new Ct({
                chain: s,
                hardfork: this.DEFAULT_HARDFORK
            }) : Ct.custom({
                name: "custom-chain",
                networkId: s,
                chainId: s
            }, {
                baseChain: this.DEFAULT_CHAIN,
                hardfork: this.DEFAULT_HARDFORK
            })
        }
        if (t != null && t.copy && typeof(t == null ? void 0 : t.copy) == "function") return t.copy();
        if (t) {
            const s = typeof t.hardfork == "function" ? t.hardfork() : t.hardfork;
            return Ct.custom({
                name: "custom-chain",
                networkId: t.networkId ? t.networkId() : (i = BigInt((r = t.customChain) === null || r === void 0 ? void 0 : r.networkId)) !== null && i !== void 0 ? i : void 0,
                chainId: t.chainId ? t.chainId() : (a = BigInt((o = t.customChain) === null || o === void 0 ? void 0 : o.chainId)) !== null && a !== void 0 ? a : void 0
            }, {
                baseChain: this.DEFAULT_CHAIN,
                hardfork: s || this.DEFAULT_HARDFORK
            })
        }
        return new Ct({
            chain: this.DEFAULT_CHAIN,
            hardfork: this.DEFAULT_HARDFORK
        })
    }
    _validateCannotExceedMaxInteger(t, n = 256, r = !1) {
        for (const [i, o] of Object.entries(t)) switch (n) {
            case 64:
                if (r) {
                    if (o !== void 0 && o >= GO) {
                        const a = this._errorMsg(`${i} cannot equal or exceed MAX_UINT64 (2^64-1), given ${o}`);
                        throw new Error(a)
                    }
                } else if (o !== void 0 && o > GO) {
                    const a = this._errorMsg(`${i} cannot exceed MAX_UINT64 (2^64-1), given ${o}`);
                    throw new Error(a)
                }
                break;
            case 256:
                if (r) {
                    if (o !== void 0 && o >= fd) {
                        const a = this._errorMsg(`${i} cannot equal or exceed MAX_INTEGER (2^256-1), given ${o}`);
                        throw new Error(a)
                    }
                } else if (o !== void 0 && o > fd) {
                    const a = this._errorMsg(`${i} cannot exceed MAX_INTEGER (2^256-1), given ${o}`);
                    throw new Error(a)
                }
                break;
            default:
                {
                    const a = this._errorMsg("unimplemented bits value");
                    throw new Error(a)
                }
        }
    }
    static _validateNotArray(t) {
        const n = ["nonce", "gasPrice", "gasLimit", "to", "value", "data", "v", "r", "s", "type", "baseFee", "maxFeePerGas", "chainId"];
        for (const [r, i] of Object.entries(t))
            if (n.includes(r) && Array.isArray(i)) throw new Error(`${r} cannot be an array`)
    }
    _getSharedErrorPostfix() {
        let t = "";
        try {
            t = this.isSigned() ? Ee(this.hash()) : "not available (unsigned)"
        } catch {
            t = "error"
        }
        let n = "";
        try {
            n = this.isSigned().toString()
        } catch {
            t = "error"
        }
        let r = "";
        try {
            r = this.common.hardfork()
        } catch {
            r = "error"
        }
        let i = `tx type=${this.type} hash=${t} nonce=${this.nonce} value=${this.value} `;
        return i += `signed=${n} hf=${r}`, i
    }
    _ecsign(t, n, r) {
        const i = po.sign(t, n),
            o = i.toCompactRawBytes(),
            a = o.subarray(0, 32),
            s = o.subarray(32, 64),
            u = r === void 0 ? BigInt(i.recovery + 27) : BigInt(i.recovery + 35) + BigInt(r) * BigInt(2);
        return {
            r: a,
            s,
            v: u
        }
    }
    static fromSerializedTx(t, n = {}) {}
    static fromTxData(t, n = {}) {}
}
const Fx = 2,
    wb = Ke(Fx.toString(16).padStart(2, "0"));
class Va extends ll {
    static fromTxData(t, n = {}) {
        return new Va(t, n)
    }
    static fromSerializedTx(t, n = {}) {
        if (!lv(t.subarray(0, 1), wb)) throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${Fx}, received: ${Ee(t.subarray(0,1))}`);
        const r = $n.decode(t.subarray(1));
        if (!Array.isArray(r)) throw new Error("Invalid serialized tx input: must be array");
        return Va.fromValuesArray(r, n)
    }
    static fromValuesArray(t, n = {}) {
        if (t.length !== 9 && t.length !== 12) throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");
        const [r, i, o, a, s, u, l, c, f, d, h, m] = t;
        return this._validateNotArray({
            chainId: r,
            v: d
        }), NS({
            nonce: i,
            maxPriorityFeePerGas: o,
            maxFeePerGas: a,
            gasLimit: s,
            value: l,
            v: d,
            r: h,
            s: m
        }), new Va({
            chainId: ze(r),
            nonce: i,
            maxPriorityFeePerGas: o,
            maxFeePerGas: a,
            gasLimit: s,
            to: u,
            value: l,
            data: c,
            accessList: f ? ? [],
            v: d !== void 0 ? ze(d) : void 0,
            r: h,
            s: m
        }, n)
    }
    constructor(t, n = {}) {
        var r;
        super(Object.assign(Object.assign({}, t), {
            type: Fx
        }), n), this.DEFAULT_HARDFORK = "london";
        const {
            chainId: i,
            accessList: o,
            maxFeePerGas: a,
            maxPriorityFeePerGas: s
        } = t;
        if (this.common = this._getCommon(n.common, i), this.chainId = this.common.chainId(), !this.common.isActivatedEIP(1559)) throw new Error("EIP-1559 not enabled on Common");
        this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);
        const u = r$(o ? ? []);
        if (this.accessList = u.accessList, this.AccessListJSON = u.AccessListJSON, i$(this.accessList), this.maxFeePerGas = ze(tt(a === "" ? "0x" : a)), this.maxPriorityFeePerGas = ze(tt(s === "" ? "0x" : s)), this._validateCannotExceedMaxInteger({
                maxFeePerGas: this.maxFeePerGas,
                maxPriorityFeePerGas: this.maxPriorityFeePerGas
            }), ll._validateNotArray(t), this.gasLimit * this.maxFeePerGas > fd) {
            const c = this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");
            throw new Error(c)
        }
        if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
            const c = this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");
            throw new Error(c)
        }
        this._validateYParity(), this._validateHighS(), ((r = n == null ? void 0 : n.freeze) !== null && r !== void 0 ? r : !0) && Object.freeze(this)
    }
    getDataFee() {
        if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) return this.cache.dataFee.value;
        let t = super.getDataFee();
        return t += BigInt(a$(this.accessList, this.common)), Object.isFrozen(this) && (this.cache.dataFee = {
            value: t,
            hardfork: this.common.hardfork()
        }), t
    }
    getUpfrontCost(t = BigInt(0)) {
        const n = this.maxPriorityFeePerGas,
            r = this.maxFeePerGas - t,
            o = (n < r ? n : r) + t;
        return this.gasLimit * o + this.value
    }
    raw() {
        return [Oe(this.chainId), Oe(this.nonce), Oe(this.maxPriorityFeePerGas), Oe(this.maxFeePerGas), Oe(this.gasLimit), this.to !== void 0 ? this.to.buf : Uint8Array.from([]), Oe(this.value), this.data, this.accessList, this.v !== void 0 ? Oe(this.v) : Uint8Array.from([]), this.r !== void 0 ? Oe(this.r) : Uint8Array.from([]), this.s !== void 0 ? Oe(this.s) : Uint8Array.from([])]
    }
    serialize() {
        const t = this.raw();
        return bn(wb, $n.encode(t))
    }
    getMessageToSign(t = !0) {
        const n = this.raw().slice(0, 9),
            r = bn(wb, $n.encode(n));
        return t ? dn(r) : r
    }
    hash() {
        if (!this.isSigned()) {
            const t = this._errorMsg("Cannot call hash method if transaction is not signed");
            throw new Error(t)
        }
        return Object.isFrozen(this) ? (this.cache.hash || (this.cache.hash = dn(this.serialize())), this.cache.hash) : dn(this.serialize())
    }
    getMessageToVerifySignature() {
        return this.getMessageToSign()
    }
    getSenderPublicKey() {
        if (!this.isSigned()) {
            const o = this._errorMsg("Cannot call this method if transaction is not signed");
            throw new Error(o)
        }
        const t = this.getMessageToVerifySignature(),
            {
                v: n,
                r,
                s: i
            } = this;
        this._validateHighS();
        try {
            return t_(t, n + BigInt(27), Oe(r), Oe(i))
        } catch {
            const a = this._errorMsg("Invalid Signature");
            throw new Error(a)
        }
    }
    _processSignature(t, n, r) {
        const i = Object.assign(Object.assign({}, this.txOptions), {
            common: this.common
        });
        return Va.fromTxData({
            chainId: this.chainId,
            nonce: this.nonce,
            maxPriorityFeePerGas: this.maxPriorityFeePerGas,
            maxFeePerGas: this.maxFeePerGas,
            gasLimit: this.gasLimit,
            to: this.to,
            value: this.value,
            data: this.data,
            accessList: this.accessList,
            v: t - BigInt(27),
            r: ze(n),
            s: ze(r)
        }, i)
    }
    toJSON() {
        const t = o$(this.accessList);
        return {
            chainId: nt(this.chainId),
            nonce: nt(this.nonce),
            maxPriorityFeePerGas: nt(this.maxPriorityFeePerGas),
            maxFeePerGas: nt(this.maxFeePerGas),
            gasLimit: nt(this.gasLimit),
            to: this.to !== void 0 ? this.to.toString() : void 0,
            value: nt(this.value),
            data: Ee(this.data),
            accessList: t,
            v: this.v !== void 0 ? nt(this.v) : void 0,
            r: this.r !== void 0 ? nt(this.r) : void 0,
            s: this.s !== void 0 ? nt(this.s) : void 0
        }
    }
    errorStr() {
        let t = this._getSharedErrorPostfix();
        return t += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`, t
    }
    _errorMsg(t) {
        return `${t} (${this.errorStr()})`
    }
}
const Ux = 1,
    xb = Ke(Ux.toString(16).padStart(2, "0"));
class za extends ll {
    static fromTxData(t, n = {}) {
        return new za(t, n)
    }
    static fromSerializedTx(t, n = {}) {
        if (!lv(t.subarray(0, 1), xb)) throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${Ux}, received: ${Ee(t.subarray(0,1))}`);
        const r = $n.decode(Uint8Array.from(t.subarray(1)));
        if (!Array.isArray(r)) throw new Error("Invalid serialized tx input: must be array");
        return za.fromValuesArray(r, n)
    }
    static fromValuesArray(t, n = {}) {
        if (t.length !== 8 && t.length !== 11) throw new Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");
        const [r, i, o, a, s, u, l, c, f, d, h] = t;
        this._validateNotArray({
            chainId: r,
            v: f
        }), NS({
            nonce: i,
            gasPrice: o,
            gasLimit: a,
            value: u,
            v: f,
            r: d,
            s: h
        });
        const m = [];
        return new za({
            chainId: ze(r),
            nonce: i,
            gasPrice: o,
            gasLimit: a,
            to: s,
            value: u,
            data: l,
            accessList: c ? ? m,
            v: f !== void 0 ? ze(f) : void 0,
            r: d,
            s: h
        }, n)
    }
    constructor(t, n = {}) {
        var r;
        super(Object.assign(Object.assign({}, t), {
            type: Ux
        }), n), this.DEFAULT_HARDFORK = "berlin";
        const {
            chainId: i,
            accessList: o,
            gasPrice: a
        } = t;
        if (this.common = this._getCommon(n.common, i), this.chainId = this.common.chainId(), !this.common.isActivatedEIP(2930)) throw new Error("EIP-2930 not enabled on Common");
        this.activeCapabilities = this.activeCapabilities.concat([2718, 2930]);
        const s = r$(o ? ? []);
        if (this.accessList = s.accessList, this.AccessListJSON = s.AccessListJSON, i$(this.accessList), this.gasPrice = ze(tt(a === "" ? "0x" : a)), this._validateCannotExceedMaxInteger({
                gasPrice: this.gasPrice
            }), ll._validateNotArray(t), this.gasPrice * this.gasLimit > fd) {
            const l = this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");
            throw new Error(l)
        }
        this._validateYParity(), this._validateHighS(), ((r = n == null ? void 0 : n.freeze) !== null && r !== void 0 ? r : !0) && Object.freeze(this)
    }
    getDataFee() {
        if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) return this.cache.dataFee.value;
        let t = super.getDataFee();
        return t += BigInt(a$(this.accessList, this.common)), Object.isFrozen(this) && (this.cache.dataFee = {
            value: t,
            hardfork: this.common.hardfork()
        }), t
    }
    getUpfrontCost() {
        return this.gasLimit * this.gasPrice + this.value
    }
    raw() {
        return [Oe(this.chainId), Oe(this.nonce), Oe(this.gasPrice), Oe(this.gasLimit), this.to !== void 0 ? this.to.buf : Uint8Array.from([]), Oe(this.value), this.data, this.accessList, this.v !== void 0 ? Oe(this.v) : Uint8Array.from([]), this.r !== void 0 ? Oe(this.r) : Uint8Array.from([]), this.s !== void 0 ? Oe(this.s) : Uint8Array.from([])]
    }
    serialize() {
        const t = this.raw();
        return bn(xb, $n.encode(t))
    }
    getMessageToSign(t = !0) {
        const n = this.raw().slice(0, 8),
            r = bn(xb, $n.encode(n));
        return t ? dn(r) : r
    }
    hash() {
        if (!this.isSigned()) {
            const t = this._errorMsg("Cannot call hash method if transaction is not signed");
            throw new Error(t)
        }
        return Object.isFrozen(this) ? (this.cache.hash || (this.cache.hash = dn(this.serialize())), this.cache.hash) : dn(this.serialize())
    }
    getMessageToVerifySignature() {
        return this.getMessageToSign()
    }
    getSenderPublicKey() {
        if (!this.isSigned()) {
            const o = this._errorMsg("Cannot call this method if transaction is not signed");
            throw new Error(o)
        }
        const t = this.getMessageToVerifySignature(),
            {
                v: n,
                r,
                s: i
            } = this;
        this._validateHighS();
        try {
            return t_(t, n + BigInt(27), Oe(r), Oe(i))
        } catch {
            const a = this._errorMsg("Invalid Signature");
            throw new Error(a)
        }
    }
    _processSignature(t, n, r) {
        const i = Object.assign(Object.assign({}, this.txOptions), {
            common: this.common
        });
        return za.fromTxData({
            chainId: this.chainId,
            nonce: this.nonce,
            gasPrice: this.gasPrice,
            gasLimit: this.gasLimit,
            to: this.to,
            value: this.value,
            data: this.data,
            accessList: this.accessList,
            v: t - BigInt(27),
            r: ze(n),
            s: ze(r)
        }, i)
    }
    toJSON() {
        const t = o$(this.accessList);
        return {
            chainId: nt(this.chainId),
            nonce: nt(this.nonce),
            gasPrice: nt(this.gasPrice),
            gasLimit: nt(this.gasLimit),
            to: this.to !== void 0 ? this.to.toString() : void 0,
            value: nt(this.value),
            data: Ee(this.data),
            accessList: t,
            v: this.v !== void 0 ? nt(this.v) : void 0,
            r: this.r !== void 0 ? nt(this.r) : void 0,
            s: this.s !== void 0 ? nt(this.s) : void 0
        }
    }
    errorStr() {
        var t, n;
        let r = this._getSharedErrorPostfix();
        return r += ` gasPrice=${this.gasPrice} accessListCount=${(n=(t=this.accessList)===null||t===void 0?void 0:t.length)!==null&&n!==void 0?n:0}`, r
    }
    _errorMsg(t) {
        return `${t} (${this.errorStr()})`
    }
}
const uee = 0;

function ZO(e, t) {
    const n = Number(e),
        r = Number(t) * 2;
    return n === r + 35 || n === r + 36
}
class Lo extends ll {
    static fromTxData(t, n = {}) {
        return new Lo(t, n)
    }
    static fromSerializedTx(t, n = {}) {
        const r = $n.decode(t);
        if (!Array.isArray(r)) throw new Error("Invalid serialized tx input. Must be array");
        return this.fromValuesArray(r, n)
    }
    static fromValuesArray(t, n = {}) {
        if (t.length !== 6 && t.length !== 9) throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");
        const [r, i, o, a, s, u, l, c, f] = t;
        return NS({
            nonce: r,
            gasPrice: i,
            gasLimit: o,
            value: s,
            v: l,
            r: c,
            s: f
        }), new Lo({
            nonce: r,
            gasPrice: i,
            gasLimit: o,
            to: a,
            value: s,
            data: u,
            v: l,
            r: c,
            s: f
        }, n)
    }
    constructor(t, n = {}) {
        var r;
        if (super(Object.assign(Object.assign({}, t), {
                type: uee
            }), n), this.common = this._validateTxV(this.v, n.common), this.gasPrice = ze(tt(t.gasPrice === "" ? "0x" : t.gasPrice)), this.gasPrice * this.gasLimit > fd) {
            const o = this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");
            throw new Error(o)
        }
        this._validateCannotExceedMaxInteger({
            gasPrice: this.gasPrice
        }), ll._validateNotArray(t), this.common.gteHardfork("spuriousDragon") && (this.isSigned() ? ZO(this.v, this.common.chainId()) && this.activeCapabilities.push(ei.EIP155ReplayProtection) : this.activeCapabilities.push(ei.EIP155ReplayProtection)), ((r = n == null ? void 0 : n.freeze) !== null && r !== void 0 ? r : !0) && Object.freeze(this)
    }
    raw() {
        return [Oe(this.nonce), Oe(this.gasPrice), Oe(this.gasLimit), this.to !== void 0 ? this.to.buf : Uint8Array.from([]), Oe(this.value), this.data, this.v !== void 0 ? Oe(this.v) : Uint8Array.from([]), this.r !== void 0 ? Oe(this.r) : Uint8Array.from([]), this.s !== void 0 ? Oe(this.s) : Uint8Array.from([])]
    }
    serialize() {
        return $n.encode(this.raw())
    }
    _getMessageToSign() {
        const t = [Oe(this.nonce), Oe(this.gasPrice), Oe(this.gasLimit), this.to !== void 0 ? this.to.buf : Uint8Array.from([]), Oe(this.value), this.data];
        return this.supports(ei.EIP155ReplayProtection) && (t.push(tt(this.common.chainId())), t.push(pg(tt(0))), t.push(pg(tt(0)))), t
    }
    getMessageToSign(t = !0) {
        const n = this._getMessageToSign();
        return t ? dn($n.encode(n)) : n
    }
    getDataFee() {
        return this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork() ? this.cache.dataFee.value : (Object.isFrozen(this) && (this.cache.dataFee = {
            value: super.getDataFee(),
            hardfork: this.common.hardfork()
        }), super.getDataFee())
    }
    getUpfrontCost() {
        return this.gasLimit * this.gasPrice + this.value
    }
    hash() {
        if (!this.isSigned()) {
            const t = this._errorMsg("Cannot call hash method if transaction is not signed");
            throw new Error(t)
        }
        return Object.isFrozen(this) ? (this.cache.hash || (this.cache.hash = dn($n.encode(this.raw()))), this.cache.hash) : dn($n.encode(this.raw()))
    }
    getMessageToVerifySignature() {
        if (!this.isSigned()) {
            const n = this._errorMsg("This transaction is not signed");
            throw new Error(n)
        }
        const t = this._getMessageToSign();
        return dn($n.encode(t))
    }
    getSenderPublicKey() {
        const t = this.getMessageToVerifySignature(),
            {
                v: n,
                r,
                s: i
            } = this;
        this._validateHighS();
        try {
            return t_(t, n, Oe(r), Oe(i), this.supports(ei.EIP155ReplayProtection) ? this.common.chainId() : void 0)
        } catch {
            const a = this._errorMsg("Invalid Signature");
            throw new Error(a)
        }
    }
    _processSignature(t, n, r) {
        let i = t;
        this.supports(ei.EIP155ReplayProtection) && (i += this.common.chainId() * BigInt(2) + BigInt(8));
        const o = Object.assign(Object.assign({}, this.txOptions), {
            common: this.common
        });
        return Lo.fromTxData({
            nonce: this.nonce,
            gasPrice: this.gasPrice,
            gasLimit: this.gasLimit,
            to: this.to,
            value: this.value,
            data: this.data,
            v: i,
            r: ze(n),
            s: ze(r)
        }, o)
    }
    toJSON() {
        return {
            nonce: nt(this.nonce),
            gasPrice: nt(this.gasPrice),
            gasLimit: nt(this.gasLimit),
            to: this.to !== void 0 ? this.to.toString() : void 0,
            value: nt(this.value),
            data: Ee(this.data),
            v: this.v !== void 0 ? nt(this.v) : void 0,
            r: this.r !== void 0 ? nt(this.r) : void 0,
            s: this.s !== void 0 ? nt(this.s) : void 0
        }
    }
    _validateTxV(t, n) {
        let r;
        const i = t !== void 0 ? Number(t) : void 0;
        if (i !== void 0 && i < 37 && i !== 27 && i !== 28) throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${i}`);
        if (i !== void 0 && i !== 0 && (!n || n.gteHardfork("spuriousDragon")) && i !== 27 && i !== 28)
            if (n) {
                if (!ZO(BigInt(i), n.chainId())) throw new Error(`Incompatible EIP155-based V ${i} and chain id ${n.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`)
            } else {
                let o;
                (i - 35) % 2 === 0 ? o = 35 : o = 36, r = BigInt(i - o) / BigInt(2)
            }
        return this._getCommon(n, r)
    }
    errorStr() {
        let t = this._getSharedErrorPostfix();
        return t += ` gasPrice=${this.gasPrice}`, t
    }
    _errorMsg(t) {
        return `${t} (${this.errorStr()})`
    }
}
const Ab = new Map;
class Ps {
    constructor() {}
    static typeToInt(t) {
        return Number(ze(tt(t)))
    }
    static registerTransactionType(t, n) {
        const r = Ps.typeToInt(t);
        Ab.set(r, n)
    }
    static fromTxData(t, n = {}) {
        if (!("type" in t) || t.type === void 0) return Lo.fromTxData(t, n);
        const r = Ps.typeToInt(t.type);
        if (r === 0) return Lo.fromTxData(t, n);
        if (r === 1) return za.fromTxData(t, n);
        if (r === 2) return Va.fromTxData(t, n);
        const i = Ab.get(r);
        if (i != null && i.fromTxData) return i.fromTxData(t, n);
        throw new Error(`Tx instantiation with type ${r} not supported`)
    }
    static fromSerializedData(t, n = {}) {
        if (t[0] <= 127) switch (t[0]) {
            case 1:
                return za.fromSerializedTx(t, n);
            case 2:
                return Va.fromSerializedTx(t, n);
            default:
                {
                    const r = Ab.get(Number(t[0]));
                    if (r != null && r.fromSerializedTx) return r.fromSerializedTx(t, n);
                    throw new Error(`TypedTransaction with ID ${t[0]} unknown`)
                }
        } else return Lo.fromSerializedTx(t, n)
    }
    static fromBlockBodyData(t, n = {}) {
        if (ma(t)) return this.fromSerializedData(t, n);
        if (Array.isArray(t)) return Lo.fromValuesArray(t, n);
        throw new Error("Cannot decode transaction: unknown type input")
    }
}
var bv = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
const Wl = (e, t) => {
        let n;
        if (!t && typeof e == "string" && Re(e) && e.length !== 66) throw new hO;
        try {
            n = ma(e) ? e : mi(e)
        } catch {
            throw new DK
        }
        if (!t && n.byteLength !== 32) throw new hO;
        return n
    },
    r_ = (e, t = !1) => {
        const n = Re(e) ? e : Fr(e),
            r = Ke(n),
            i = Ke(sD(`Ethereum Signed Message:
${r.byteLength}`)),
            o = t ? r : bn(i, r);
        return Wn(o)
    },
    lee = (e, t) => {
        const n = Wl(t),
            r = po.sign(e.substring(2), n),
            i = r.toCompactRawBytes(),
            o = r.r.toString(16).padStart(64, "0"),
            a = r.s.toString(16).padStart(64, "0"),
            s = r.recovery + 27;
        return {
            messageHash: e,
            v: Nt(s),
            r: `0x${o}`,
            s: `0x${a}`,
            signature: `${Ee(i)}${s.toString(16)}`
        }
    },
    s$ = (e, t) => {
        const n = r_(e),
            {
                messageHash: r,
                v: i,
                r: o,
                s: a,
                signature: s
            } = lee(n, t);
        return {
            message: e,
            messageHash: r,
            v: i,
            r: o,
            s: a,
            signature: s
        }
    },
    cee = (e, t) => bv(void 0, void 0, void 0, function*() {
        const n = e.sign(Ke(t));
        if (F(n.v) || F(n.r) || F(n.s)) throw new Sx("Signer Error");
        const r = n.validate(!0);
        if (r.length > 0) {
            let a = "Signer Error ";
            for (const s of r) a += `${a} ${s}.`;
            throw new Sx(a)
        }
        const i = Ee(n.serialize()),
            o = Wn(i);
        return {
            messageHash: Ee(n.getMessageToSign(!0)),
            v: `0x${n.v.toString(16)}`,
            r: `0x${n.r.toString(16).padStart(64,"0")}`,
            s: `0x${n.s.toString(16).padStart(64,"0")}`,
            rawTransaction: i,
            transactionHash: Ee(o)
        }
    }),
    fee = e => {
        if (F(e)) throw new eQ;
        const t = Ps.fromSerializedData(Ke(e));
        return vi(t.getSenderAddress().toString())
    },
    Hx = (e, t, n, r, i) => {
        if (typeof e == "object") {
            const f = `${e.r}${e.s.slice(2)}${e.v.slice(2)}`;
            return Hx(e.messageHash, f, n)
        }
        if (typeof t == "string" && typeof n == "string" && !F(r)) {
            const f = `${n}${r.slice(2)}${t.slice(2)}`;
            return Hx(e, f, i)
        }
        if (F(t)) throw new $K("signature string undefined");
        const o = 130,
            a = n ? e : r_(e);
        let s = parseInt(t.substring(o), 16);
        s > 26 && (s -= 27);
        const u = po.Signature.fromCompact(t.slice(2, o)).addRecoveryBit(s).recoverPublicKey(a.replace("0x", "")).toRawBytes(!1),
            l = Wn(u.subarray(1));
        return vi(`0x${l.slice(-40)}`)
    },
    wv = e => {
        const t = Wl(e),
            n = po.getPublicKey(t, !1),
            i = Wn(n.slice(1)).slice(-40);
        return vi(`0x${i}`)
    },
    dee = (e, t) => {
        const n = Wl(e);
        return `0x${Ee(po.getPublicKey(n,t)).slice(4)}`
    },
    u$ = (e, t, n) => bv(void 0, void 0, void 0, function*() {
        var r, i, o, a, s, u, l;
        const c = Wl(e);
        let f;
        if (n != null && n.salt ? f = typeof n.salt == "string" ? Ke(n.salt) : n.salt : f = ud(32), !(IS(t) || ma(t))) throw new UK;
        const d = typeof t == "string" ? Ke(Fr(t)) : t;
        let h;
        if (n != null && n.iv) {
            if (h = typeof n.iv == "string" ? Ke(n.iv) : n.iv, h.length !== 16) throw new HK
        } else h = ud(16);
        const m = (r = n == null ? void 0 : n.kdf) !== null && r !== void 0 ? r : "scrypt";
        let p, y;
        if (m === "pbkdf2") {
            if (y = {
                    dklen: (i = n == null ? void 0 : n.dklen) !== null && i !== void 0 ? i : 32,
                    salt: Ee(f).replace("0x", ""),
                    c: (o = n == null ? void 0 : n.c) !== null && o !== void 0 ? o : 262144,
                    prf: "hmac-sha256"
                }, y.c < 1e3) throw new VK;
            p = BD(d, f, y.c, y.dklen, "sha256")
        } else if (m === "scrypt") y = {
            n: (a = n == null ? void 0 : n.n) !== null && a !== void 0 ? a : 8192,
            r: (s = n == null ? void 0 : n.r) !== null && s !== void 0 ? s : 8,
            p: (u = n == null ? void 0 : n.p) !== null && u !== void 0 ? u : 1,
            dklen: (l = n == null ? void 0 : n.dklen) !== null && l !== void 0 ? l : 32,
            salt: Ee(f).replace("0x", "")
        }, p = DD(d, f, y.n, y.p, y.r, y.dklen);
        else throw new _3;
        const g = yield GS(c, p.slice(0, 16), h, "aes-128-ctr"), b = Ee(g).slice(2), v = Wn(bn(p.slice(16, 32), g)).replace("0x", "");
        return {
            version: 3,
            id: US(),
            address: wv(c).toLowerCase().replace("0x", ""),
            crypto: {
                ciphertext: b,
                cipherparams: {
                    iv: Ee(h).replace("0x", "")
                },
                cipher: "aes-128-ctr",
                kdf: m,
                kdfparams: y,
                mac: v
            }
        }
    }),
    i_ = (e, t) => {
        const n = Wl(e, t);
        return {
            address: wv(n),
            privateKey: Ee(n),
            signTransaction: r => {
                throw new Sx("Do not have network access to sign the transaction")
            },
            sign: r => s$(typeof r == "string" ? r : JSON.stringify(r), n),
            encrypt: (r, i) => bv(void 0, void 0, void 0, function*() {
                return u$(n, r, i)
            })
        }
    },
    hee = () => {
        const e = po.utils.randomPrivateKey();
        return i_(`${Ee(e)}`)
    },
    pee = (e, t, n) => bv(void 0, void 0, void 0, function*() {
        const r = typeof e == "object" ? e : JSON.parse(n ? e.toLowerCase() : e);
        if (oe.validateJSONSchema(tJ, r), r.version !== 3) throw new FK;
        const i = typeof t == "string" ? Ke(Fr(t)) : t;
        oe.validate(["bytes"], [i]);
        let o;
        if (r.crypto.kdf === "scrypt") {
            const l = r.crypto.kdfparams,
                c = typeof l.salt == "string" ? Ke(l.salt) : l.salt;
            o = DD(i, c, l.n, l.p, l.r, l.dklen)
        } else if (r.crypto.kdf === "pbkdf2") {
            const l = r.crypto.kdfparams,
                c = typeof l.salt == "string" ? Ke(l.salt) : l.salt;
            o = BD(i, c, l.c, l.dklen, "sha256")
        } else throw new _3;
        const a = Ke(r.crypto.ciphertext);
        if (Wn(bn(o.slice(16, 32), a)).replace("0x", "") !== r.crypto.mac) throw new LK;
        const u = yield uZ(Ke(r.crypto.ciphertext), o.slice(0, 16), Ke(r.crypto.cipherparams.iv));
        return i_(u)
    });
var JO = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
const mee = 1e3;
class gee {
    constructor(t) {
        this._requestManager = t, this._requests = new Map
    }
    get requests() {
        return [...this._requests.values()].map(t => t.payload)
    }
    add(t) {
        const n = Ss(t),
            r = new lg;
        return this._requests.set(n.id, {
            payload: n,
            promise: r
        }), r
    }
    execute(t) {
        return JO(this, void 0, void 0, function*() {
            var n;
            if (this.requests.length === 0) return Promise.resolve([]);
            const r = new lg({
                timeout: (n = t == null ? void 0 : t.timeout) !== null && n !== void 0 ? n : mee,
                eagerStart: !0,
                timeoutMessage: "Batch request timeout"
            });
            return this._processBatchRequest(r).catch(i => r.reject(i)), r.catch(i => {
                i instanceof T3 && this._abortAllRequests("Batch request timeout"), r.reject(i)
            }), r
        })
    }
    _processBatchRequest(t) {
        return JO(this, void 0, void 0, function*() {
            var n, r;
            const i = yield this._requestManager.sendBatch([...this._requests.values()].map(s => s.payload));
            if (i.length !== this._requests.size) throw this._abortAllRequests("Invalid batch response"), new Jr(i, `Batch request size mismatch the results size. Requests: ${this._requests.size}, Responses: ${i.length}`);
            const o = this.requests.map(s => s.id).map(Number).sort((s, u) => s - u),
                a = i.map(s => s.id).map(Number).sort((s, u) => s - u);
            if (JSON.stringify(o) !== JSON.stringify(a)) throw this._abortAllRequests("Invalid batch response"), new Jr(i, `Batch request mismatch the results. Requests: [${o.join()}], Responses: [${a.join()}]`);
            for (const s of i) Yo(s) ? (n = this._requests.get(s.id)) === null || n === void 0 || n.promise.resolve(s.result) : Xo(s) && ((r = this._requests.get(s.id)) === null || r === void 0 || r.promise.reject(s.error));
            t.resolve(i)
        })
    }
    _abortAllRequests(t) {
        for (const {
                promise: n
            } of this._requests.values()) n.reject(new YK(t))
    }
}
var yee = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, [])).next())
    })
};
let lr = class l$ extends tZ {
    constructor(t) {
        var n;
        if (super(), this.providers = is.providers, le(t) || typeof t == "string" && t.trim() !== "" || cg(t)) {
            this._requestManager = new is(t), this._subscriptionManager = new fg(this._requestManager, {});
            return
        }
        const {
            config: r,
            provider: i,
            requestManager: o,
            subscriptionManager: a,
            registeredSubscriptions: s,
            accountProvider: u,
            wallet: l,
            requestManagerMiddleware: c
        } = t;
        this.setConfig(r ? ? {}), this._requestManager = o ? ? new is(i, (n = r == null ? void 0 : r.enableExperimentalFeatures) === null || n === void 0 ? void 0 : n.useSubscriptionWhenCheckingBlockTimeout, c), a ? this._subscriptionManager = a : this._subscriptionManager = new fg(this.requestManager, s ? ? {}), u && (this._accountProvider = u), l && (this._wallet = l)
    }
    get requestManager() {
        return this._requestManager
    }
    get subscriptionManager() {
        return this._subscriptionManager
    }
    get wallet() {
        return this._wallet
    }
    get accountProvider() {
        return this._accountProvider
    }
    static fromContextObject(...t) {
        return new this(...t.reverse())
    }
    getContextObject() {
        var t;
        return {
            config: this.config,
            provider: this.provider,
            requestManager: this.requestManager,
            subscriptionManager: this.subscriptionManager,
            registeredSubscriptions: (t = this.subscriptionManager) === null || t === void 0 ? void 0 : t.registeredSubscriptions,
            providers: this.providers,
            wallet: this.wallet,
            accountProvider: this.accountProvider
        }
    }
    use(t, ...n) {
        const r = new t(...n, this.getContextObject());
        return this.on(_s.CONFIG_CHANGE, i => {
            r.setConfig({
                [i.name]: i.newValue
            })
        }), this[t.name] = r, r
    }
    link(t) {
        this.setConfig(t.config), this._requestManager = t.requestManager, this.provider = t.provider, this._subscriptionManager = t.subscriptionManager, this._wallet = t.wallet, this._accountProvider = t._accountProvider, t.on(_s.CONFIG_CHANGE, n => {
            this.setConfig({
                [n.name]: n.newValue
            })
        })
    }
    registerPlugin(t) {
        if (this[t.pluginNamespace] !== void 0) throw new XK(t.pluginNamespace);
        const n = {
            [t.pluginNamespace]: t
        };
        n[t.pluginNamespace].link(this), Object.assign(this, n)
    }
    get provider() {
        return this.currentProvider
    }
    set provider(t) {
        this.requestManager.setProvider(t)
    }
    get currentProvider() {
        return this.requestManager.provider
    }
    set currentProvider(t) {
        this.requestManager.setProvider(t)
    }
    get givenProvider() {
        return l$.givenProvider
    }
    setProvider(t) {
        return this.provider = t, !0
    }
    setRequestManagerMiddleware(t) {
        this.requestManager.setMiddleware(t)
    }
    get BatchRequest() {
        return gee.bind(void 0, this._requestManager)
    }
    extend(t) {
        var n;
        return t.property && !this[t.property] && (this[t.property] = {}), (n = t.methods) === null || n === void 0 || n.forEach(r => {
            const i = (...o) => yee(this, void 0, void 0, function*() {
                return this.requestManager.send({
                    method: r.call,
                    params: o
                })
            });
            t.property ? this[t.property][r.name] = i : this[r.name] = i
        }), this
    }
};
lr.providers = is.providers;
class Tt {
    constructor(t) {
        if (this.toAddress = () => {
                if (this.isDirect()) {
                    const n = this._iban.slice(4),
                        r = Tt._parseInt(n, 36),
                        i = ad(r, 40);
                    return vi(i)
                }
                throw new Error("Iban is indirect and cannot be converted. Must be length of 34 or 35")
            }, Tt.isIndirect(t) || Tt.isDirect(t)) this._iban = t;
        else throw new Error("Invalid IBAN was provided")
    }
    static isDirect(t) {
        return t.length === 34 || t.length === 35
    }
    isDirect() {
        return Tt.isDirect(this._iban)
    }
    static isIndirect(t) {
        return t.length === 20
    }
    isIndirect() {
        return Tt.isIndirect(this._iban)
    }
    static isValid(t) {
        return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(t) && Tt._mod9710(Tt._iso13616Prepare(t)) === 1
    }
    isValid() {
        return Tt.isValid(this._iban)
    }
    static fromBban(t) {
        const n = "XE",
            i = `0${(98-this._mod9710(this._iso13616Prepare(`${n}00${t}`))).toString()}`.slice(-2);
        return new Tt(`${n}${i}${t}`)
    }
    static createIndirect(t) {
        return Tt.fromBban(`ETH${t.institution}${t.identifier}`)
    }
    static fromAddress(t) {
        if (!zn(t)) throw new _S(t);
        const r = BigInt(gh(t)).toString(36),
            i = ad(r, 15);
        return Tt.fromBban(i.toUpperCase())
    }
    static toIban(t) {
        return Tt.fromAddress(t).toString()
    }
    client() {
        return this.isIndirect() ? this._iban.slice(11) : ""
    }
    checksum() {
        return this._iban.slice(2, 4)
    }
    institution() {
        return this.isIndirect() ? this._iban.slice(7, 11) : ""
    }
    toString() {
        return this._iban
    }
}
Tt._iso13616Prepare = e => {
    const r = e.toUpperCase();
    return `${r.slice(4)}${r.slice(0,4)}`.split("").map(o => {
        const a = o.charCodeAt(0);
        return a >= 65 && a <= 90 ? a - 65 + 10 : o
    }).join("")
};
Tt._parseInt = (e, t) => [...e].reduce((n, r) => BigInt(parseInt(r, t)) + BigInt(t) * n, BigInt(0));
Tt._mod9710 = e => {
    let t = e,
        n;
    for (; t.length > 2;) n = t.slice(0, 9), t = `${(parseInt(n,10)%97).toString()}${t.slice(n.length)}`;
    return parseInt(t, 10) % 97
};
Tt.toAddress = e => new Tt(e).toAddress();
var Eb = function(e, t, n, r) {
        function i(o) {
            return o instanceof n ? o : new n(function(a) {
                a(o)
            })
        }
        return new(n || (n = Promise))(function(o, a) {
            function s(c) {
                try {
                    l(r.next(c))
                } catch (f) {
                    a(f)
                }
            }

            function u(c) {
                try {
                    l(r.throw(c))
                } catch (f) {
                    a(f)
                }
            }

            function l(c) {
                c.done ? o(c.value) : i(c.value).then(s, u)
            }
            l((r = r.apply(e, t || [])).next())
        })
    },
    c$;
class f$ extends mv {
    constructor(t) {
        super(), this[c$] = "Promise", this._promise = new Promise(t)
    }
    then(t, n) {
        return Eb(this, void 0, void 0, function*() {
            return this._promise.then(t, n)
        })
    } catch (t) {
        return Eb(this, void 0, void 0, function*() {
            return this._promise.catch(t)
        })
    } finally(t) {
        return Eb(this, void 0, void 0, function*() {
            return this._promise.finally(t)
        })
    }
    on(t, n) {
        return super.on(t, n), this
    }
    once(t, n) {
        return super.once(t, n), this
    }
}
c$ = Symbol.toStringTag;

function vee(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
var d$ = {
        exports: {}
    },
    Et = d$.exports = {},
    Kr, Qr;

function Vx() {
    throw new Error("setTimeout has not been defined")
}

function zx() {
    throw new Error("clearTimeout has not been defined")
}(function() {
    try {
        typeof setTimeout == "function" ? Kr = setTimeout : Kr = Vx
    } catch {
        Kr = Vx
    }
    try {
        typeof clearTimeout == "function" ? Qr = clearTimeout : Qr = zx
    } catch {
        Qr = zx
    }
})();

function h$(e) {
    if (Kr === setTimeout) return setTimeout(e, 0);
    if ((Kr === Vx || !Kr) && setTimeout) return Kr = setTimeout, setTimeout(e, 0);
    try {
        return Kr(e, 0)
    } catch {
        try {
            return Kr.call(null, e, 0)
        } catch {
            return Kr.call(this, e, 0)
        }
    }
}

function bee(e) {
    if (Qr === clearTimeout) return clearTimeout(e);
    if ((Qr === zx || !Qr) && clearTimeout) return Qr = clearTimeout, clearTimeout(e);
    try {
        return Qr(e)
    } catch {
        try {
            return Qr.call(null, e)
        } catch {
            return Qr.call(this, e)
        }
    }
}
var Di = [],
    Bu = !1,
    Wa, Qp = -1;

function wee() {
    !Bu || !Wa || (Bu = !1, Wa.length ? Di = Wa.concat(Di) : Qp = -1, Di.length && p$())
}

function p$() {
    if (!Bu) {
        var e = h$(wee);
        Bu = !0;
        for (var t = Di.length; t;) {
            for (Wa = Di, Di = []; ++Qp < t;) Wa && Wa[Qp].run();
            Qp = -1, t = Di.length
        }
        Wa = null, Bu = !1, bee(e)
    }
}
Et.nextTick = function(e) {
    var t = new Array(arguments.length - 1);
    if (arguments.length > 1)
        for (var n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
    Di.push(new m$(e, t)), Di.length === 1 && !Bu && h$(p$)
};

function m$(e, t) {
    this.fun = e, this.array = t
}
m$.prototype.run = function() {
    this.fun.apply(null, this.array)
};
Et.title = "browser";
Et.browser = !0;
Et.env = {};
Et.argv = [];
Et.version = "";
Et.versions = {};

function mo() {}
Et.on = mo;
Et.addListener = mo;
Et.once = mo;
Et.off = mo;
Et.removeListener = mo;
Et.removeAllListeners = mo;
Et.emit = mo;
Et.prependListener = mo;
Et.prependOnceListener = mo;
Et.listeners = function(e) {
    return []
};
Et.binding = function(e) {
    throw new Error("process.binding is not supported")
};
Et.cwd = function() {
    return "/"
};
Et.chdir = function(e) {
    throw new Error("process.chdir is not supported")
};
Et.umask = function() {
    return 0
};
var xee = d$.exports;
const Aee = vee(xee);
(function(e, t) {
    if (e.setImmediate) return;
    var n = 1,
        r = {},
        i = !1,
        o = e.document,
        a;

    function s(b) {
        typeof b != "function" && (b = new Function("" + b));
        for (var v = new Array(arguments.length - 1), A = 0; A < v.length; A++) v[A] = arguments[A + 1];
        var w = {
            callback: b,
            args: v
        };
        return r[n] = w, a(n), n++
    }

    function u(b) {
        delete r[b]
    }

    function l(b) {
        var v = b.callback,
            A = b.args;
        switch (A.length) {
            case 0:
                v();
                break;
            case 1:
                v(A[0]);
                break;
            case 2:
                v(A[0], A[1]);
                break;
            case 3:
                v(A[0], A[1], A[2]);
                break;
            default:
                v.apply(t, A);
                break
        }
    }

    function c(b) {
        if (i) setTimeout(c, 0, b);
        else {
            var v = r[b];
            if (v) {
                i = !0;
                try {
                    l(v)
                } finally {
                    u(b), i = !1
                }
            }
        }
    }

    function f() {
        a = function(b) {
            Aee.nextTick(function() {
                c(b)
            })
        }
    }

    function d() {
        if (e.postMessage && !e.importScripts) {
            var b = !0,
                v = e.onmessage;
            return e.onmessage = function() {
                b = !1
            }, e.postMessage("", "*"), e.onmessage = v, b
        }
    }

    function h() {
        var b = "setImmediate$" + Math.random() + "$",
            v = function(A) {
                A.source === e && typeof A.data == "string" && A.data.indexOf(b) === 0 && c(+A.data.slice(b.length))
            };
        e.addEventListener ? e.addEventListener("message", v, !1) : e.attachEvent("onmessage", v), a = function(A) {
            e.postMessage(b + A, "*")
        }
    }

    function m() {
        var b = new MessageChannel;
        b.port1.onmessage = function(v) {
            var A = v.data;
            c(A)
        }, a = function(v) {
            b.port2.postMessage(v)
        }
    }

    function p() {
        var b = o.documentElement;
        a = function(v) {
            var A = o.createElement("script");
            A.onreadystatechange = function() {
                c(v), A.onreadystatechange = null, b.removeChild(A), A = null
            }, b.appendChild(A)
        }
    }

    function y() {
        a = function(b) {
            setTimeout(c, 0, b)
        }
    }
    var g = Object.getPrototypeOf && Object.getPrototypeOf(e);
    g = g && g.setTimeout ? g : e, {}.toString.call(e.process) === "[object process]" ? f() : d() ? h() : e.MessageChannel ? m() : o && "onreadystatechange" in o.createElement("script") ? p() : y(), g.setImmediate = s, g.clearImmediate = u
})(typeof self > "u" ? typeof globalThis > "u" ? void 0 : globalThis : self);
var de = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};

function Eee(e) {
    return de(this, void 0, void 0, function*() {
        return e.send({
            method: "eth_protocolVersion",
            params: []
        })
    })
}

function g$(e) {
    return de(this, void 0, void 0, function*() {
        return e.send({
            method: "eth_syncing",
            params: []
        })
    })
}

function See(e) {
    return de(this, void 0, void 0, function*() {
        return e.send({
            method: "eth_coinbase",
            params: []
        })
    })
}

function _ee(e) {
    return de(this, void 0, void 0, function*() {
        return e.send({
            method: "eth_mining",
            params: []
        })
    })
}

function Tee(e) {
    return de(this, void 0, void 0, function*() {
        return e.send({
            method: "eth_hashrate",
            params: []
        })
    })
}

function Pee(e) {
    return de(this, void 0, void 0, function*() {
        return e.send({
            method: "eth_gasPrice",
            params: []
        })
    })
}

function Oee(e) {
    return de(this, void 0, void 0, function*() {
        return e.send({
            method: "eth_maxPriorityFeePerGas",
            params: []
        })
    })
}

function kee(e) {
    return de(this, void 0, void 0, function*() {
        return e.send({
            method: "eth_accounts",
            params: []
        })
    })
}

function Cee(e) {
    return de(this, void 0, void 0, function*() {
        return e.send({
            method: "eth_blockNumber",
            params: []
        })
    })
}

function Iee(e, t, n) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["address", "blockNumberOrTag"], [t, n]), e.send({
            method: "eth_getBalance",
            params: [t, n]
        })
    })
}

function Mee(e, t, n, r) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["address", "hex", "blockNumberOrTag"], [t, n, r]), e.send({
            method: "eth_getStorageAt",
            params: [t, n, r]
        })
    })
}

function Nee(e, t, n) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["address", "blockNumberOrTag"], [t, n]), e.send({
            method: "eth_getTransactionCount",
            params: [t, n]
        })
    })
}

function Ree(e, t) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["bytes32"], [t]), e.send({
            method: "eth_getBlockTransactionCountByHash",
            params: [t]
        })
    })
}

function jee(e, t) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["blockNumberOrTag"], [t]), e.send({
            method: "eth_getBlockTransactionCountByNumber",
            params: [t]
        })
    })
}

function Bee(e, t) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["bytes32"], [t]), e.send({
            method: "eth_getUncleCountByBlockHash",
            params: [t]
        })
    })
}

function Dee(e, t) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["blockNumberOrTag"], [t]), e.send({
            method: "eth_getUncleCountByBlockNumber",
            params: [t]
        })
    })
}

function $ee(e, t, n) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["address", "blockNumberOrTag"], [t, n]), e.send({
            method: "eth_getCode",
            params: [t, n]
        })
    })
}

function Lee(e, t, n) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["address", "hex"], [t, n]), e.send({
            method: "eth_sign",
            params: [t, n]
        })
    })
}

function Fee(e, t) {
    return de(this, void 0, void 0, function*() {
        return e.send({
            method: "eth_signTransaction",
            params: [t]
        })
    })
}

function Uee(e, t) {
    return de(this, void 0, void 0, function*() {
        return e.send({
            method: "eth_sendTransaction",
            params: [t]
        })
    })
}

function y$(e, t) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["hex"], [t]), e.send({
            method: "eth_sendRawTransaction",
            params: [t]
        })
    })
}

function Hee(e, t, n) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["blockNumberOrTag"], [n]), e.send({
            method: "eth_call",
            params: [t, n]
        })
    })
}

function Vee(e, t, n) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["blockNumberOrTag"], [n]), e.send({
            method: "eth_estimateGas",
            params: [t, n]
        })
    })
}

function zee(e, t, n) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["bytes32", "bool"], [t, n]), e.send({
            method: "eth_getBlockByHash",
            params: [t, n]
        })
    })
}

function v$(e, t, n) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["blockNumberOrTag", "bool"], [t, n]), e.send({
            method: "eth_getBlockByNumber",
            params: [t, n]
        })
    })
}

function Wee(e, t) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["bytes32"], [t]), e.send({
            method: "eth_getTransactionByHash",
            params: [t]
        })
    })
}

function Gee(e, t, n) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["bytes32", "hex"], [t, n]), e.send({
            method: "eth_getTransactionByBlockHashAndIndex",
            params: [t, n]
        })
    })
}

function qee(e, t, n) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["blockNumberOrTag", "hex"], [t, n]), e.send({
            method: "eth_getTransactionByBlockNumberAndIndex",
            params: [t, n]
        })
    })
}

function Kee(e, t) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["bytes32"], [t]), e.send({
            method: "eth_getTransactionReceipt",
            params: [t]
        })
    })
}

function Qee(e, t, n) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["bytes32", "hex"], [t, n]), e.send({
            method: "eth_getUncleByBlockHashAndIndex",
            params: [t, n]
        })
    })
}

function Yee(e, t, n) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["blockNumberOrTag", "hex"], [t, n]), e.send({
            method: "eth_getUncleByBlockNumberAndIndex",
            params: [t, n]
        })
    })
}

function Xee(e, t) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["filter"], [t]), e.send({
            method: "eth_newFilter",
            params: [t]
        })
    })
}

function Zee(e) {
    return de(this, void 0, void 0, function*() {
        return e.send({
            method: "eth_newBlockFilter",
            params: []
        })
    })
}

function Jee(e) {
    return de(this, void 0, void 0, function*() {
        return e.send({
            method: "eth_newPendingTransactionFilter",
            params: []
        })
    })
}

function ete(e, t) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["hex"], [t]), e.send({
            method: "eth_uninstallFilter",
            params: [t]
        })
    })
}

function tte(e, t) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["hex"], [t]), e.send({
            method: "eth_getFilterChanges",
            params: [t]
        })
    })
}

function nte(e, t) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["hex"], [t]), e.send({
            method: "eth_getFilterLogs",
            params: [t]
        })
    })
}

function rte(e, t) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["filter"], [t]), e.send({
            method: "eth_getLogs",
            params: [t]
        })
    })
}

function ite(e) {
    return de(this, void 0, void 0, function*() {
        return e.send({
            method: "eth_getWork",
            params: []
        })
    })
}

function ote(e, t, n, r) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["bytes8", "bytes32", "bytes32"], [t, n, r]), e.send({
            method: "eth_submitWork",
            params: [t, n, r]
        })
    })
}

function ate(e, t, n, r) {
    return de(this, void 0, void 0, function*() {
        oe.validate(["hex", "blockNumberOrTag"], [t, n]);
        for (const i of r) oe.validate(["number"], [i]);
        return e.send({
            method: "eth_feeHistory",
            params: [t, n, r]
        })
    })
}

function ste(e) {
    return de(this, void 0, void 0, function*() {
        return e.send({
            method: "eth_pendingTransactions",
            params: []
        })
    })
}

function ute(e) {
    return de(this, void 0, void 0, function*() {
        return e.send({
            method: "eth_requestAccounts",
            params: []
        })
    })
}

function lte(e) {
    return de(this, void 0, void 0, function*() {
        return e.send({
            method: "eth_chainId",
            params: []
        })
    })
}

function cte(e, t, n, r) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["address", "bytes32[]", "blockNumberOrTag"], [t, n, r]), e.send({
            method: "eth_getProof",
            params: [t, n, r]
        })
    })
}

function fte(e) {
    return de(this, void 0, void 0, function*() {
        return e.send({
            method: "web3_clientVersion",
            params: []
        })
    })
}

function dte(e, t, n) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["blockNumberOrTag"], [n]), e.send({
            method: "eth_createAccessList",
            params: [t, n]
        })
    })
}

function hte(e, t, n, r = !1) {
    return de(this, void 0, void 0, function*() {
        return oe.validate(["address"], [t]), e.send({
            method: `eth_signTypedData${r?"":"_v4"}`,
            params: [t, n]
        })
    })
}
var o_ = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};

function pte(e) {
    return o_(this, void 0, void 0, function*() {
        return e.send({
            method: "net_version",
            params: []
        })
    })
}

function mte(e) {
    return o_(this, void 0, void 0, function*() {
        return e.send({
            method: "net_peerCount",
            params: []
        })
    })
}

function gte(e) {
    return o_(this, void 0, void 0, function*() {
        return e.send({
            method: "net_listening",
            params: []
        })
    })
}
var go = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
const yte = e => go(void 0, void 0, void 0, function*() {
        return e.send({
            method: "personal_listAccounts",
            params: []
        })
    }),
    vte = (e, t) => go(void 0, void 0, void 0, function*() {
        return e.send({
            method: "personal_newAccount",
            params: [t]
        })
    }),
    bte = (e, t, n, r) => go(void 0, void 0, void 0, function*() {
        return e.send({
            method: "personal_unlockAccount",
            params: [t, n, r]
        })
    }),
    wte = (e, t) => go(void 0, void 0, void 0, function*() {
        return e.send({
            method: "personal_lockAccount",
            params: [t]
        })
    }),
    xte = (e, t, n) => go(void 0, void 0, void 0, function*() {
        return e.send({
            method: "personal_importRawKey",
            params: [t, n]
        })
    }),
    Ate = (e, t, n) => go(void 0, void 0, void 0, function*() {
        return e.send({
            method: "personal_sendTransaction",
            params: [t, n]
        })
    }),
    Ete = (e, t, n) => go(void 0, void 0, void 0, function*() {
        return e.send({
            method: "personal_signTransaction",
            params: [t, n]
        })
    }),
    Ste = (e, t, n, r) => go(void 0, void 0, void 0, function*() {
        return e.send({
            method: "personal_sign",
            params: [t, n, r]
        })
    }),
    _te = (e, t, n) => go(void 0, void 0, void 0, function*() {
        return e.send({
            method: "personal_ecRecover",
            params: [t, n]
        })
    }),
    ek = {
        type: "object",
        properties: {
            accessList: {
                type: "null"
            },
            maxFeePerGas: {
                type: "null"
            },
            maxPriorityFeePerGas: {
                type: "null"
            }
        }
    },
    tk = {
        type: "object",
        properties: {
            maxFeePerGas: {
                type: "null"
            },
            maxPriorityFeePerGas: {
                type: "null"
            }
        }
    },
    nk = {
        type: "object",
        properties: {
            gasPrice: {
                type: "null"
            }
        }
    },
    rp = (e, t, n) => {
        try {
            oe.validateJSONSchema(e, t)
        } catch (r) {
            throw r instanceof tl ? new SQ(r.errors, n) : r
        }
    },
    Tte = e => {
        var t, n;
        const r = e;
        if (!F(r.type)) {
            let o;
            switch (r.type) {
                case "0x0":
                    o = ek;
                    break;
                case "0x1":
                    o = tk;
                    break;
                case "0x2":
                    o = nk;
                    break;
                default:
                    return W({
                        format: "uint"
                    }, r.type, pe)
            }
            return rp(o, r, r.type), W({
                format: "uint"
            }, r.type, pe)
        }
        if (!F(r.maxFeePerGas) || !F(r.maxPriorityFeePerGas)) return rp(nk, r, "0x2"), "0x2";
        if (!F(r.accessList)) return rp(tk, r, "0x1"), "0x1";
        const i = (t = r.hardfork) !== null && t !== void 0 ? t : (n = r.common) === null || n === void 0 ? void 0 : n.hardfork;
        if (!F(i)) {
            const o = Object.keys(lf).indexOf(i);
            if (o >= Object.keys(lf).indexOf("london")) return F(r.gasPrice) ? "0x2" : "0x0";
            if (o === Object.keys(lf).indexOf("berlin")) return "0x0"
        }
        if (!F(r.gasPrice)) return rp(ek, r, "0x0"), "0x0"
    },
    Pte = (e, t) => {
        var n;
        return ((n = t == null ? void 0 : t.transactionTypeParser) !== null && n !== void 0 ? n : Tte)(e)
    },
    Ote = e => e[0] > 127 ? "0x0" : ro(e[0]),
    kte = {
        type: "object",
        properties: {
            address: {
                format: "address"
            },
            storageKeys: {
                type: "array",
                items: {
                    format: "bytes32"
                }
            }
        }
    },
    a_ = {
        type: "array",
        items: Object.assign({}, kte)
    },
    Cte = {
        type: "object",
        properties: {
            accessList: Object.assign({}, a_),
            gasUsed: {
                type: "string"
            }
        }
    },
    rk = {
        type: "string",
        enum: ["goerli", "kovan", "mainnet", "rinkeby", "ropsten", "sepolia"]
    },
    ik = {
        type: "string",
        enum: ["arrowGlacier", "berlin", "byzantium", "chainstart", "constantinople", "dao", "homestead", "istanbul", "london", "merge", "muirGlacier", "petersburg", "shanghai", "spuriousDragon", "tangerineWhistle"]
    },
    Ite = {
        type: "object",
        properties: {
            name: {
                format: "string"
            },
            networkId: {
                format: "uint"
            },
            chainId: {
                format: "uint"
            }
        }
    },
    b$ = {
        type: "object",
        properties: {
            from: {
                format: "address"
            },
            to: {
                oneOf: [{
                    format: "address"
                }, {
                    type: "null"
                }]
            },
            value: {
                format: "uint"
            },
            gas: {
                format: "uint"
            },
            gasPrice: {
                format: "uint"
            },
            effectiveGasPrice: {
                format: "uint"
            },
            type: {
                format: "uint"
            },
            maxFeePerGas: {
                format: "uint"
            },
            maxPriorityFeePerGas: {
                format: "uint"
            },
            accessList: Object.assign({}, a_),
            data: {
                format: "bytes"
            },
            input: {
                format: "bytes"
            },
            nonce: {
                format: "uint"
            },
            chain: Object.assign({}, rk),
            hardfork: Object.assign({}, ik),
            chainId: {
                format: "uint"
            },
            networkId: {
                format: "uint"
            },
            common: {
                type: "object",
                properties: {
                    customChain: Object.assign({}, Ite),
                    baseChain: Object.assign({}, rk),
                    hardfork: Object.assign({}, ik)
                }
            },
            gasLimit: {
                format: "uint"
            },
            v: {
                format: "uint"
            },
            r: {
                format: "bytes32"
            },
            s: {
                format: "bytes32"
            }
        }
    },
    Wx = {
        type: "object",
        properties: Object.assign(Object.assign({}, b$.properties), {
            blockHash: {
                format: "bytes32"
            },
            blockNumber: {
                format: "uint"
            },
            hash: {
                format: "bytes32"
            },
            transactionIndex: {
                format: "uint"
            },
            from: {
                format: "address"
            },
            to: {
                oneOf: [{
                    format: "address"
                }, {
                    type: "null"
                }]
            },
            value: {
                format: "uint"
            },
            gas: {
                format: "uint"
            },
            gasPrice: {
                format: "uint"
            },
            effectiveGasPrice: {
                format: "uint"
            },
            type: {
                format: "uint"
            },
            maxFeePerGas: {
                format: "uint"
            },
            maxPriorityFeePerGas: {
                format: "uint"
            },
            accessList: Object.assign({}, a_),
            data: {
                format: "bytes"
            },
            input: {
                format: "bytes"
            },
            nonce: {
                format: "uint"
            },
            gasLimit: {
                format: "uint"
            },
            v: {
                format: "uint"
            },
            r: {
                format: "bytes32"
            },
            s: {
                format: "bytes32"
            }
        })
    },
    w$ = {
        type: "object",
        properties: {
            index: {
                format: "uint"
            },
            validatorIndex: {
                format: "uint"
            },
            address: {
                format: "address"
            },
            amount: {
                format: "uint"
            }
        }
    },
    gg = {
        type: "object",
        properties: {
            baseFeePerGas: {
                format: "uint"
            },
            blobGasUsed: {
                format: "uint"
            },
            difficulty: {
                format: "uint"
            },
            excessBlobGas: {
                format: "uint"
            },
            extraData: {
                format: "bytes"
            },
            gasLimit: {
                format: "uint"
            },
            gasUsed: {
                format: "uint"
            },
            hash: {
                format: "bytes32"
            },
            logsBloom: {
                format: "bytes256"
            },
            miner: {
                format: "bytes"
            },
            mixHash: {
                format: "bytes32"
            },
            nonce: {
                format: "uint"
            },
            number: {
                format: "uint"
            },
            parentBeaconBlockRoot: {
                format: "bytes32"
            },
            parentHash: {
                format: "bytes32"
            },
            receiptsRoot: {
                format: "bytes32"
            },
            sha3Uncles: {
                format: "bytes32"
            },
            size: {
                format: "uint"
            },
            stateRoot: {
                format: "bytes32"
            },
            timestamp: {
                format: "uint"
            },
            totalDifficulty: {
                format: "uint"
            },
            transactions: {
                oneOf: [{
                    type: "array",
                    items: Object.assign({}, Wx)
                }, {
                    type: "array",
                    items: {
                        format: "bytes32"
                    }
                }]
            },
            transactionsRoot: {
                format: "bytes32"
            },
            uncles: {
                type: "array",
                items: {
                    format: "bytes32"
                }
            },
            withdrawals: {
                type: "array",
                items: Object.assign({}, w$)
            },
            withdrawalsRoot: {
                format: "bytes32"
            }
        }
    },
    Mte = {
        type: "object",
        properties: {
            author: {
                format: "bytes32"
            },
            excessDataGas: {
                format: "uint"
            },
            baseFeePerGas: {
                format: "uint"
            },
            blobGasUsed: {
                format: "uint"
            },
            difficulty: {
                format: "uint"
            },
            excessBlobGas: {
                format: "uint"
            },
            extraData: {
                format: "bytes"
            },
            gasLimit: {
                format: "uint"
            },
            gasUsed: {
                format: "uint"
            },
            hash: {
                format: "bytes32"
            },
            logsBloom: {
                format: "bytes256"
            },
            miner: {
                format: "bytes"
            },
            mixHash: {
                format: "bytes32"
            },
            nonce: {
                format: "uint"
            },
            number: {
                format: "uint"
            },
            parentBeaconBlockRoot: {
                format: "bytes32"
            },
            parentHash: {
                format: "bytes32"
            },
            receiptsRoot: {
                format: "bytes32"
            },
            sha3Uncles: {
                format: "bytes32"
            },
            size: {
                format: "uint"
            },
            stateRoot: {
                format: "bytes32"
            },
            timestamp: {
                format: "uint"
            },
            totalDifficulty: {
                format: "uint"
            },
            transactions: {
                type: "array",
                items: {
                    format: "bytes32"
                }
            },
            transactionsRoot: {
                format: "bytes32"
            },
            uncles: {
                type: "array",
                items: {
                    format: "bytes32"
                }
            },
            withdrawals: {
                type: "array",
                items: Object.assign({}, w$)
            },
            withdrawalsRoot: {
                format: "bytes32"
            }
        }
    },
    Gl = {
        type: "object",
        properties: {
            removed: {
                format: "bool"
            },
            logIndex: {
                format: "uint"
            },
            transactionIndex: {
                format: "uint"
            },
            transactionHash: {
                format: "bytes32"
            },
            blockHash: {
                format: "bytes32"
            },
            blockNumber: {
                format: "uint"
            },
            address: {
                format: "address"
            },
            data: {
                format: "bytes"
            },
            topics: {
                type: "array",
                items: {
                    format: "bytes32"
                }
            }
        }
    },
    Nte = {
        type: "object",
        properties: {
            startingBlock: {
                format: "string"
            },
            currentBlock: {
                format: "string"
            },
            highestBlock: {
                format: "string"
            },
            knownStates: {
                format: "string"
            },
            pulledStates: {
                format: "string"
            }
        }
    },
    ql = {
        type: "object",
        properties: {
            transactionHash: {
                format: "bytes32"
            },
            transactionIndex: {
                format: "uint"
            },
            blockHash: {
                format: "bytes32"
            },
            blockNumber: {
                format: "uint"
            },
            from: {
                format: "address"
            },
            to: {
                format: "address"
            },
            cumulativeGasUsed: {
                format: "uint"
            },
            gasUsed: {
                format: "uint"
            },
            effectiveGasPrice: {
                format: "uint"
            },
            contractAddress: {
                format: "address"
            },
            logs: {
                type: "array",
                items: Object.assign({}, Gl)
            },
            logsBloom: {
                format: "bytes"
            },
            root: {
                format: "bytes"
            },
            status: {
                format: "uint"
            },
            type: {
                format: "uint"
            }
        }
    },
    Rte = {
        type: "object",
        properties: {
            messageHash: {
                format: "bytes"
            },
            r: {
                format: "bytes32"
            },
            s: {
                format: "bytes32"
            },
            v: {
                format: "bytes"
            },
            message: {
                format: "bytes"
            },
            signature: {
                format: "bytes"
            }
        }
    },
    jte = {
        type: "object",
        properties: {
            oldestBlock: {
                format: "uint"
            },
            baseFeePerGas: {
                type: "array",
                items: {
                    format: "uint"
                }
            },
            reward: {
                type: "array",
                items: {
                    type: "array",
                    items: {
                        format: "uint"
                    }
                }
            },
            gasUsedRatio: {
                type: "array",
                items: {
                    type: "number"
                }
            }
        }
    },
    Bte = {
        type: "object",
        properties: {
            key: {
                format: "bytes32"
            },
            value: {
                format: "uint"
            },
            proof: {
                type: "array",
                items: {
                    format: "bytes32"
                }
            }
        }
    },
    Dte = {
        type: "object",
        properties: {
            balance: {
                format: "uint"
            },
            codeHash: {
                format: "bytes32"
            },
            nonce: {
                format: "uint"
            },
            storageHash: {
                format: "bytes32"
            },
            accountProof: {
                type: "array",
                items: {
                    format: "bytes32"
                }
            },
            storageProof: {
                type: "array",
                items: Object.assign({}, Bte)
            }
        }
    };

function Nn(e, t = mn, n = {
    transactionSchema: Wx,
    fillInputAndData: !1
}) {
    var r, i;
    let o = ga({}, e);
    if (F(e == null ? void 0 : e.common) || (o.common = Object.assign({}, e.common), F((r = e.common) === null || r === void 0 ? void 0 : r.customChain) || (o.common.customChain = Object.assign({}, e.common.customChain))), o = W((i = n.transactionSchema) !== null && i !== void 0 ? i : Wx, o, t), !F(o.data) && !F(o.input) && ro(o.data) !== ro(o.input)) throw new C3({
        data: Ee(o.data),
        input: Ee(o.input)
    });
    return n.fillInputAndData && (F(o.data) ? F(o.input) || (o.data = o.input) : o.input = o.data), F(o.gasLimit) || (o.gas = o.gasLimit, delete o.gasLimit), o
}

function $te(e, t, n = {
    fillInputAndData: !1
}) {
    return {
        raw: W({
            format: "bytes"
        }, e, t),
        tx: Nn(Object.assign(Object.assign({}, Ps.fromSerializedData(Ke(e)).toJSON()), {
            hash: Ee(il(Ke(e))),
            type: Ote(Ke(e))
        }), t, {
            fillInputAndData: n.fillInputAndData,
            transactionSchema: n.transactionSchema
        })
    }
}
var s_ = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};

function u_(e, t) {
    return s_(this, void 0, void 0, function*() {
        const n = yield pte(e.requestManager);
        return W({
            format: "uint"
        }, n, t)
    })
}

function Lte(e, t) {
    return s_(this, void 0, void 0, function*() {
        const n = yield mte(e.requestManager);
        return W({
            format: "uint"
        }, n, t)
    })
}
const Fte = e => s_(void 0, void 0, void 0, function*() {
    return gte(e.requestManager)
});
var Sb = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
class x$ extends lr {
    getId(t = this.defaultReturnFormat) {
        return Sb(this, void 0, void 0, function*() {
            return u_(this, t)
        })
    }
    getPeerCount(t = this.defaultReturnFormat) {
        return Sb(this, void 0, void 0, function*() {
            return Lte(this, t)
        })
    }
    isListening() {
        return Sb(this, void 0, void 0, function*() {
            return Fte(this)
        })
    }
}
const cl = "ALLEVENTS",
    Gx = {
        name: cl,
        signature: "",
        type: "event",
        inputs: []
    },
    xv = {
        bytes: eo.HEX,
        number: ur.NUMBER
    };
var A$ = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};

function Ute(e, t, n) {
    return A$(this, void 0, void 0, function*() {
        var r, i, o, a;
        const s = yield X$(t, t.defaultBlock, !1, pe);
        if (F(s.baseFeePerGas)) throw new wQ;
        let u;
        if (F(e.gasPrice) && BigInt(s.baseFeePerGas) === BigInt(0) && (u = yield y_(t, n)), !F(e.gasPrice) || !F(u)) {
            const l = W({
                format: "uint"
            }, (r = e.gasPrice) !== null && r !== void 0 ? r : u, n);
            return {
                maxPriorityFeePerGas: l,
                maxFeePerGas: l
            }
        }
        return {
            maxPriorityFeePerGas: W({
                format: "uint"
            }, (i = e.maxPriorityFeePerGas) !== null && i !== void 0 ? i : t.defaultMaxPriorityFeePerGas, n),
            maxFeePerGas: W({
                format: "uint"
            }, (o = e.maxFeePerGas) !== null && o !== void 0 ? o : BigInt(s.baseFeePerGas) * BigInt(2) + BigInt((a = e.maxPriorityFeePerGas) !== null && a !== void 0 ? a : t.defaultMaxPriorityFeePerGas), n)
        }
    })
}

function E$(e, t, n) {
    return A$(this, void 0, void 0, function*() {
        const r = S$(e, t);
        if (!F(r)) {
            if (r.startsWith("-")) throw new yO(r);
            if (Number(r) < 0 || Number(r) > 127) throw new yO(r);
            if (F(e.gasPrice) && (r === "0x0" || r === "0x1")) return {
                gasPrice: yield y_(t, n), maxPriorityFeePerGas: void 0, maxFeePerGas: void 0
            };
            if (r === "0x2") return Object.assign({
                gasPrice: void 0
            }, yield Ute(e, t, n))
        }
    })
}
var l_ = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
const qx = (e, t, n, r) => {
        if (n !== void 0 && e in n && n[e] !== void 0) {
            if (typeof n[e] == "string" && zn(n[e])) return n[e];
            if (!Re(n[e]) && oD(n[e])) {
                if (t.wallet) {
                    const i = t.wallet.get(W({
                        format: "uint"
                    }, n[e], xv));
                    if (!F(i)) return i.address;
                    throw new vO
                }
                throw new vO
            } else throw e === "from" ? new tQ(n.from) : new nQ(n.to)
        }
        if (e === "from") {
            if (!F(r)) return wv(r);
            if (!F(t.defaultAccount)) return t.defaultAccount
        }
    },
    Hte = (e, t, ...n) => l_(void 0, [e, t, ...n], void 0, function*(r, i, o = r.defaultReturnFormat) {
        if (F(i)) throw new bQ;
        return J$(r, i, r.defaultBlock, o)
    }),
    S$ = (e, t) => {
        const n = Pte(e, t);
        if (!F(n)) return n;
        if (!F(t.defaultTransactionType)) return W({
            format: "uint"
        }, t.defaultTransactionType, pe)
    };

function Vte(e) {
    return l_(this, void 0, void 0, function*() {
        var t, n;
        let r = W(b$, e.transaction, e.web3Context.defaultReturnFormat);
        if (F(r.from) && (r.from = qx("from", e.web3Context, void 0, e.privateKey)), F(r.nonce) && (r.nonce = yield Hte(e.web3Context, r.from, pe)), F(r.value) && (r.value = "0x0"), F(r.data)) F(r.input) ? r.input = "0x" : r.input.startsWith("0x") || (r.input = `0x${r.input}`);
        else {
            if (!F(r.input) && r.data !== r.input) throw new C3({
                data: Ee(r.data),
                input: Ee(r.input)
            });
            r.data.startsWith("0x") || (r.data = `0x${r.data}`)
        }
        if (F(r.common)) {
            if (e.web3Context.defaultCommon) {
                const i = e.web3Context.defaultCommon,
                    o = i.customChain.chainId,
                    a = i.customChain.networkId,
                    s = i.customChain.name;
                r.common = Object.assign(Object.assign({}, i), {
                    customChain: {
                        chainId: o,
                        networkId: a,
                        name: s
                    }
                })
            }
            F(r.chain) && (r.chain = e.web3Context.defaultChain), F(r.hardfork) && (r.hardfork = e.web3Context.defaultHardfork)
        }
        if (F(r.chainId) && F((t = r.common) === null || t === void 0 ? void 0 : t.customChain.chainId) && (r.chainId = yield tL(e.web3Context, pe)), F(r.networkId) && (r.networkId = (n = e.web3Context.defaultNetworkId) !== null && n !== void 0 ? n : yield u_(e.web3Context, pe)), F(r.gasLimit) && !F(r.gas) && (r.gasLimit = r.gas), r.type = S$(r, e.web3Context), F(r.accessList) && (r.type === "0x1" || r.type === "0x2") && (r.accessList = []), e.fillGasPrice && (r = Object.assign(Object.assign({}, r), yield E$(r, e.web3Context, pe))), F(r.gas) && F(r.gasLimit) && e.fillGasLimit) {
            const i = yield w_(e.web3Context, r, "latest", pe);
            r = Object.assign(Object.assign({}, r), {
                gas: W({
                    format: "uint"
                }, i, pe)
            })
        }
        return r
    })
}
const zte = e => l_(void 0, void 0, void 0, function*() {
    var t;
    return ((t = e.web3Context.transactionBuilder) !== null && t !== void 0 ? t : Vte)(Object.assign(Object.assign({}, e), {
        transaction: e.transaction
    }))
});
var c_ = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};

function Kx(e, t, n) {
    const r = e.transactionPollingInterval,
        [i, o] = wD(() => c_(this, void 0, void 0, function*() {
            let s;
            try {
                s = yield v_(e, xv)
            } catch (l) {
                console.warn("An error happen while trying to get the block number", l);
                return
            }
            const u = s - t;
            if (u >= e.transactionBlockTimeout) return new N3({
                starterBlockNumber: t,
                numberOfBlocks: u,
                transactionHash: n
            })
        }), r);
    return [o, {
        clean: () => {
            clearInterval(i)
        }
    }]
}

function Wte(e, t, n) {
    return c_(this, void 0, void 0, function*() {
        var r;
        let i = !0,
            o, a;

        function s(l, c) {
            c && console.warn("error happened at subscription. So revert to polling...", c), a.clean(), i = !1;
            const [f, d] = Kx(e, t, n);
            a.clean = d.clean, f.catch(h => l(h))
        }
        try {
            o = yield(r = e.subscriptionManager) === null || r === void 0 ? void 0 : r.subscribe("newHeads"), a = {
                clean: () => {
                    var l;
                    o.id && ((l = e.subscriptionManager) === null || l === void 0 || l.removeSubscription(o).then(() => {}).catch(() => {}))
                }
            }
        } catch {
            return Kx(e, t, n)
        }
        return [new Promise((l, c) => {
            try {
                o.on("data", f => {
                    if (i = !1, !(f != null && f.number)) return;
                    const d = Number(BigInt(f.number) - BigInt(t));
                    d >= e.transactionBlockTimeout && c(new N3({
                        starterBlockNumber: t,
                        numberOfBlocks: d,
                        transactionHash: n
                    }))
                }), o.on("error", f => {
                    s(c, f)
                })
            } catch (f) {
                s(c, f)
            }
            setTimeout(() => {
                i && s(c)
            }, e.blockHeaderTimeout * 1e3)
        }), a]
    })
}

function _$(e, t) {
    return c_(this, void 0, void 0, function*() {
        var n, r;
        const {
            provider: i
        } = e.requestManager;
        let o;
        const a = yield v_(e, xv);
        return !((r = (n = i).supportsSubscriptions) === null || r === void 0) && r.call(n) && e.enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout ? o = yield Wte(e, a, t): o = Kx(e, a, t), o
    })
}
var Gte = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};

function Qx(e, t, n) {
    return Gte(this, void 0, void 0, function*() {
        const [r, i] = FS(e.transactionSendTimeout, new xQ({
            numberOfSeconds: e.transactionSendTimeout / 1e3,
            transactionHash: n
        })), [o, a] = yield _$(e, n);
        try {
            return yield Promise.race([t(), i, o])
        } finally {
            clearTimeout(r), a.clean()
        }
    })
}
var ok = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};

function T$(e, t, n, r) {
    return ok(this, void 0, void 0, function*() {
        var i;
        const o = (i = e.transactionReceiptPollingInterval) !== null && i !== void 0 ? i : e.transactionPollingInterval,
            [a, s] = LS(() => ok(this, void 0, void 0, function*() {
                try {
                    return (r ? ? Z$)(e, t, n)
                } catch (d) {
                    console.warn("An error happen while trying to get the transaction receipt", d);
                    return
                }
            }), o),
            [u, l] = FS(e.transactionPollingTimeout, new M3({
                numberOfSeconds: e.transactionPollingTimeout / 1e3,
                transactionHash: t
            })),
            [c, f] = yield _$(e, t);
        try {
            return yield Promise.race([a, l, c])
        } finally {
            u && clearTimeout(u), s && clearInterval(s), f.clean()
        }
    })
}
var qte = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
const Yp = ({
    web3Context: e,
    transactionReceipt: t,
    transactionPromiEvent: n,
    customTransactionReceiptSchema: r,
    returnFormat: i
}) => {
    var o;
    let a = 1;
    const s = setInterval(() => {
        qte(void 0, void 0, void 0, function*() {
            if (a >= e.transactionConfirmationBlocks) {
                clearInterval(s);
                return
            }
            const u = yield v$(e.requestManager, Nt(BigInt(t.blockNumber) + BigInt(a)), !1);
            u != null && u.hash && (a += 1, n.emit("confirmation", {
                confirmations: W({
                    format: "uint"
                }, a, i),
                receipt: W(r ? ? ql, t, i),
                latestBlockHash: W({
                    format: "bytes32"
                }, u.hash, i)
            }))
        })
    }, (o = e.transactionReceiptPollingInterval) !== null && o !== void 0 ? o : e.transactionPollingInterval)
};
var ak = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
const Kte = ({
    web3Context: e,
    transactionReceipt: t,
    transactionPromiEvent: n,
    customTransactionReceiptSchema: r,
    returnFormat: i
}) => {
    let o = !0,
        a;
    setImmediate(() => {
        var s;
        (s = e.subscriptionManager) === null || s === void 0 || s.subscribe("newHeads").then(u => {
            u.on("data", l => ak(void 0, void 0, void 0, function*() {
                var c;
                if (o = !1, !(l != null && l.number) || a === (l == null ? void 0 : l.parentHash)) return;
                a = l == null ? void 0 : l.parentHash;
                const f = BigInt(l.number) - BigInt(t.blockNumber) + BigInt(1);
                n.emit("confirmation", {
                    confirmations: W({
                        format: "uint"
                    }, f, i),
                    receipt: W(r ? ? ql, t, i),
                    latestBlockHash: W({
                        format: "bytes32"
                    }, l.parentHash, i)
                }), f >= e.transactionConfirmationBlocks && (yield(c = e.subscriptionManager) === null || c === void 0 ? void 0 : c.removeSubscription(u))
            })), u.on("error", () => ak(void 0, void 0, void 0, function*() {
                var l;
                yield(l = e.subscriptionManager) === null || l === void 0 ? void 0 : l.removeSubscription(u), o = !1, Yp({
                    web3Context: e,
                    transactionReceipt: t,
                    transactionPromiEvent: n,
                    customTransactionReceiptSchema: r,
                    returnFormat: i
                })
            }))
        }).catch(() => {
            o = !1, Yp({
                web3Context: e,
                transactionReceipt: t,
                customTransactionReceiptSchema: r,
                transactionPromiEvent: n,
                returnFormat: i
            })
        })
    }), setTimeout(() => {
        o && Yp({
            web3Context: e,
            transactionReceipt: t,
            transactionPromiEvent: n,
            returnFormat: i
        })
    }, e.blockHeaderTimeout * 1e3)
};

function Qte(e, t, n, r, i, o) {
    if (F(n) || F(n.blockHash)) throw new AQ({
        receipt: n,
        blockHash: W({
            format: "bytes32"
        }, n == null ? void 0 : n.blockHash, i),
        transactionHash: W({
            format: "bytes32"
        }, r, i)
    });
    if (!n.blockNumber) throw new EQ({
        receipt: n
    });
    t.emit("confirmation", {
        confirmations: W({
            format: "uint"
        }, 1, i),
        receipt: W(o ? ? ql, n, i),
        latestBlockHash: W({
            format: "bytes32"
        }, n.blockHash, i)
    });
    const a = e.requestManager.provider;
    a && "supportsSubscriptions" in a && a.supportsSubscriptions() ? Kte({
        web3Context: e,
        transactionReceipt: n,
        transactionPromiEvent: t,
        customTransactionReceiptSchema: o,
        returnFormat: i
    }) : Yp({
        web3Context: e,
        transactionReceipt: n,
        transactionPromiEvent: t,
        customTransactionReceiptSchema: o,
        returnFormat: i
    })
}
const Av = e => !le(e) && typeof e == "object" && !le(e.type) && e.type === "error",
    f_ = e => !le(e) && typeof e == "object" && !le(e.type) && e.type === "event",
    Ev = e => !le(e) && typeof e == "object" && !le(e.type) && e.type === "function",
    Yte = e => !le(e) && typeof e == "object" && !le(e.type) && e.type === "constructor",
    Xte = e => typeof e == "object" && typeof e.components > "u" && typeof e.name > "u",
    P$ = e => e.includes("[]") ? {
        type: "tuple[]",
        name: e.slice(0, -2)
    } : {
        type: "tuple",
        name: e
    },
    O$ = e => {
        const t = [];
        for (const n of Object.keys(e)) {
            const r = e[n];
            typeof r == "object" ? t.push(Object.assign(Object.assign({}, P$(n)), {
                components: O$(r)
            })) : t.push({
                name: n,
                type: e[n]
            })
        }
        return t
    },
    Yx = (e, t) => {
        const n = [];
        return t.forEach(r => {
            if (typeof r.components == "object") {
                if (!r.type.startsWith("tuple")) throw new Te(`Invalid value given "${r.type}". Error: components found but type is not tuple.`);
                const i = r.type.indexOf("["),
                    o = i >= 0 ? r.type.substring(i) : "",
                    a = Yx(e, r.components);
                n.push(`(${a.join(",")})${o}`)
            } else n.push(r.type)
        }), n
    },
    Wi = e => {
        var t, n, r, i;
        return Av(e) || f_(e) || Ev(e) ? !((t = e.name) === null || t === void 0) && t.includes("(") ? e.name : `${(n=e.name)!==null&&n!==void 0?n:""}(${Yx(!1,(r=e.inputs)!==null&&r!==void 0?r:[]).join(",")})` : `(${Yx(!1,(i=e.inputs)!==null&&i!==void 0?i:[]).join(",")})`
    },
    Zte = e => {
        if (typeof e != "string" && !Av(e)) throw new Te("Invalid parameter value in encodeErrorSignature");
        let t;
        return e && (typeof e == "function" || typeof e == "object") ? t = Wi(e) : t = e, Wn(t)
    },
    d_ = e => {
        if (typeof e != "string" && !f_(e)) throw new Te("Invalid parameter value in encodeEventSignature");
        let t;
        return e && (typeof e == "function" || typeof e == "object") ? t = Wi(e) : t = e, Wn(t)
    };

function h_(e, t) {
    const n = e.exec(t);
    return n == null ? void 0 : n.groups
}
var k$ = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
    C$ = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,
    I$ = /^\(.+?\).*?$/,
    Jte = Object.defineProperty,
    ene = (e, t, n) => t in e ? Jte(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n,
    Ec = (e, t, n) => (ene(e, typeof t != "symbol" ? t + "" : t, n), n),
    tne = "abitype",
    nne = "0.7.1",
    Tn = class extends Error {
        constructor(e, t = {}) {
            var o;
            const n = t.cause instanceof Tn ? t.cause.details : (o = t.cause) != null && o.message ? t.cause.message : t.details,
                r = t.cause instanceof Tn && t.cause.docsPath || t.docsPath,
                i = [e || "An error occurred.", "", ...t.metaMessages ? [...t.metaMessages, ""] : [], ...r ? [`Docs: https://abitype.dev${r}`] : [], ...n ? [`Details: ${n}`] : [], `Version: ${tne}@${nne}`].join(`
`);
            super(i), Ec(this, "details"), Ec(this, "docsPath"), Ec(this, "metaMessages"), Ec(this, "shortMessage"), Ec(this, "name", "AbiTypeError"), t.cause && (this.cause = t.cause), this.details = n, this.docsPath = r, this.metaMessages = t.metaMessages, this.shortMessage = e
        }
    },
    M$ = /^struct (?<name>[a-zA-Z0-9_]+) \{(?<properties>.*?)\}$/;

function N$(e) {
    return M$.test(e)
}

function rne(e) {
    return h_(M$, e)
}
var sk = new Set(["memory", "indexed", "storage", "calldata"]),
    ine = new Set(["calldata", "memory", "storage"]);

function one(e, t) {
    return t ? `${t}:${e}` : e
}
var _b = new Map([
        ["address", {
            type: "address"
        }],
        ["bool", {
            type: "bool"
        }],
        ["bytes", {
            type: "bytes"
        }],
        ["bytes32", {
            type: "bytes32"
        }],
        ["int", {
            type: "int256"
        }],
        ["int256", {
            type: "int256"
        }],
        ["string", {
            type: "string"
        }],
        ["uint", {
            type: "uint256"
        }],
        ["uint8", {
            type: "uint8"
        }],
        ["uint16", {
            type: "uint16"
        }],
        ["uint24", {
            type: "uint24"
        }],
        ["uint32", {
            type: "uint32"
        }],
        ["uint64", {
            type: "uint64"
        }],
        ["uint96", {
            type: "uint96"
        }],
        ["uint112", {
            type: "uint112"
        }],
        ["uint160", {
            type: "uint160"
        }],
        ["uint192", {
            type: "uint192"
        }],
        ["uint256", {
            type: "uint256"
        }],
        ["address owner", {
            type: "address",
            name: "owner"
        }],
        ["address to", {
            type: "address",
            name: "to"
        }],
        ["bool approved", {
            type: "bool",
            name: "approved"
        }],
        ["bytes _data", {
            type: "bytes",
            name: "_data"
        }],
        ["bytes data", {
            type: "bytes",
            name: "data"
        }],
        ["bytes signature", {
            type: "bytes",
            name: "signature"
        }],
        ["bytes32 hash", {
            type: "bytes32",
            name: "hash"
        }],
        ["bytes32 r", {
            type: "bytes32",
            name: "r"
        }],
        ["bytes32 root", {
            type: "bytes32",
            name: "root"
        }],
        ["bytes32 s", {
            type: "bytes32",
            name: "s"
        }],
        ["string name", {
            type: "string",
            name: "name"
        }],
        ["string symbol", {
            type: "string",
            name: "symbol"
        }],
        ["string tokenURI", {
            type: "string",
            name: "tokenURI"
        }],
        ["uint tokenId", {
            type: "uint256",
            name: "tokenId"
        }],
        ["uint8 v", {
            type: "uint8",
            name: "v"
        }],
        ["uint256 balance", {
            type: "uint256",
            name: "balance"
        }],
        ["uint256 tokenId", {
            type: "uint256",
            name: "tokenId"
        }],
        ["uint256 value", {
            type: "uint256",
            name: "value"
        }],
        ["event:address indexed from", {
            type: "address",
            name: "from",
            indexed: !0
        }],
        ["event:address indexed to", {
            type: "address",
            name: "to",
            indexed: !0
        }],
        ["event:uint indexed tokenId", {
            type: "uint256",
            name: "tokenId",
            indexed: !0
        }],
        ["event:uint256 indexed tokenId", {
            type: "uint256",
            name: "tokenId",
            indexed: !0
        }]
    ]),
    ane = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/,
    sne = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/,
    une = /^u?int$/;

function yg(e, t) {
    var f, d;
    const n = one(e, t == null ? void 0 : t.type);
    if (_b.has(n)) return _b.get(n);
    const r = I$.test(e),
        i = h_(r ? sne : ane, e);
    if (!i) throw new Tn("Invalid ABI parameter.", {
        details: e
    });
    if (i.name && cne(i.name)) throw new Tn("Invalid ABI parameter.", {
        details: e,
        metaMessages: [`"${i.name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`]
    });
    const o = i.name ? {
            name: i.name
        } : {},
        a = i.modifier === "indexed" ? {
            indexed: !0
        } : {},
        s = (t == null ? void 0 : t.structs) ? ? {};
    let u, l = {};
    if (r) {
        u = "tuple";
        const h = tu(i.type),
            m = [],
            p = h.length;
        for (let y = 0; y < p; y++) m.push(yg(h[y], {
            structs: s
        }));
        l = {
            components: m
        }
    } else if (i.type in s) u = "tuple", l = {
        components: s[i.type]
    };
    else if (une.test(i.type)) u = `${i.type}256`;
    else if (u = i.type, (t == null ? void 0 : t.type) !== "struct" && !R$(u)) throw new Tn("Unknown type.", {
        metaMessages: [`Type "${u}" is not a valid ABI type.`]
    });
    if (i.modifier) {
        if (!((d = (f = t == null ? void 0 : t.modifiers) == null ? void 0 : f.has) != null && d.call(f, i.modifier))) throw new Tn("Invalid ABI parameter.", {
            details: e,
            metaMessages: [`Modifier "${i.modifier}" not allowed${t!=null&&t.type?` in "${t.type}" type`:""}.`]
        });
        if (ine.has(i.modifier) && !fne(u, !!i.array)) throw new Tn("Invalid ABI parameter.", {
            details: e,
            metaMessages: [`Modifier "${i.modifier}" not allowed${t!=null&&t.type?` in "${t.type}" type`:""}.`, `Data location can only be specified for array, struct, or mapping types, but "${i.modifier}" was given.`]
        })
    }
    const c = {
        type: `${u}${i.array??""}`,
        ...o,
        ...a,
        ...l
    };
    return _b.set(n, c), c
}

function tu(e, t = [], n = "", r = 0) {
    if (e === "") {
        if (n === "") return t;
        if (r !== 0) throw new Tn("Unbalanced parentheses.", {
            metaMessages: [`"${n.trim()}" has too many ${r>0?"opening":"closing"} parentheses.`],
            details: `Depth "${r}"`
        });
        return [...t, n.trim()]
    }
    const i = e.length;
    for (let o = 0; o < i; o++) {
        const a = e[o],
            s = e.slice(o + 1);
        switch (a) {
            case ",":
                return r === 0 ? tu(s, [...t, n.trim()]) : tu(s, t, `${n}${a}`, r);
            case "(":
                return tu(s, t, `${n}${a}`, r + 1);
            case ")":
                return tu(s, t, `${n}${a}`, r - 1);
            default:
                return tu(s, t, `${n}${a}`, r)
        }
    }
    return []
}

function R$(e) {
    return e === "address" || e === "bool" || e === "function" || e === "string" || k$.test(e) || C$.test(e)
}
var lne = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;

function cne(e) {
    return e === "address" || e === "bool" || e === "function" || e === "string" || e === "tuple" || k$.test(e) || C$.test(e) || lne.test(e)
}

function fne(e, t) {
    return t || e === "bytes" || e === "string" || e === "tuple"
}

function dne(e) {
    const t = {},
        n = e.length;
    for (let a = 0; a < n; a++) {
        const s = e[a];
        if (!N$(s)) continue;
        const u = rne(s);
        if (!u) throw new Tn("Invalid struct signature.", {
            details: s
        });
        const l = u.properties.split(";"),
            c = [],
            f = l.length;
        for (let d = 0; d < f; d++) {
            const m = l[d].trim();
            if (!m) continue;
            const p = yg(m, {
                type: "struct"
            });
            c.push(p)
        }
        if (!c.length) throw new Tn("Invalid struct signature.", {
            details: s,
            metaMessages: ["No properties exist."]
        });
        t[u.name] = c
    }
    const r = {},
        i = Object.entries(t),
        o = i.length;
    for (let a = 0; a < o; a++) {
        const [s, u] = i[a];
        r[s] = j$(u, t)
    }
    return r
}
var hne = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?$/;

function j$(e, t, n = new Set) {
    const r = [],
        i = e.length;
    for (let o = 0; o < i; o++) {
        const a = e[o];
        if (I$.test(a.type)) r.push(a);
        else {
            const u = h_(hne, a.type);
            if (!(u != null && u.type)) throw new Tn("Invalid ABI parameter.", {
                details: JSON.stringify(a, null, 2),
                metaMessages: ["ABI parameter type is invalid."]
            });
            const {
                array: l,
                type: c
            } = u;
            if (c in t) {
                if (n.has(c)) throw new Tn("Circular reference detected.", {
                    metaMessages: [`Struct "${c}" is a circular reference.`]
                });
                r.push({ ...a,
                    type: `tuple${l??""}`,
                    components: j$(t[c] ? ? [], t, new Set([...n, c]))
                })
            } else if (R$(c)) r.push(a);
            else throw new Tn("Unknown type.", {
                metaMessages: [`Type "${c}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`]
            })
        }
    }
    return r
}

function pne(e) {
    let t;
    if (typeof e == "string") t = yg(e, {
        modifiers: sk
    });
    else {
        const n = dne(e),
            r = e.length;
        for (let i = 0; i < r; i++) {
            const o = e[i];
            if (!N$(o)) {
                t = yg(o, {
                    modifiers: sk,
                    structs: n
                });
                break
            }
        }
    }
    if (!t) throw new Tn("Failed to parse ABI parameter.", {
        details: `parseAbiParameter(${JSON.stringify(e,null,2)})`,
        docsPath: "/api/human.html#parseabiparameter-1"
    });
    return t
}
const bt = 32;

function Xx(e = 0) {
    var t;
    if (((t = globalThis.Buffer) === null || t === void 0 ? void 0 : t.alloc) !== void 0) {
        const n = globalThis.Buffer.alloc(e);
        return new Uint8Array(n.buffer, n.byteOffset, n.byteLength)
    }
    return new Uint8Array(e)
}

function B$(e) {
    var t, n;
    return Object.assign(Object.assign({}, e), {
        name: (t = e.name) !== null && t !== void 0 ? t : "",
        components: (n = e.components) === null || n === void 0 ? void 0 : n.map(r => B$(r))
    })
}

function mne(e) {
    return !le(e) && typeof e == "object" && !le(e.type) && typeof e.type == "string"
}

function D$(e) {
    return e.map(t => {
        var n;
        if (mne(t)) return t;
        if (typeof t == "string") return B$(pne(t.replace(/tuple/, "")));
        if (Xte(t)) {
            const r = Object.keys(t)[0],
                i = P$(r);
            return i.name = (n = i.name) !== null && n !== void 0 ? n : "", Object.assign(Object.assign({}, i), {
                components: O$(t[r])
            })
        }
        throw new Te("Invalid abi")
    })
}

function p_(e) {
    const t = e.type.lastIndexOf("["),
        n = e.type.substring(0, t),
        r = e.type.substring(t);
    let i = -1;
    if (r !== "[]" && (i = Number(r.slice(1, -1)), isNaN(i))) throw new Te("Invalid fixed array size", {
        size: r
    });
    return {
        param: {
            type: n,
            name: "",
            components: e.components
        },
        size: i
    }
}

function vg(e) {
    var t, n;
    return e.type === "string" || e.type === "bytes" || e.type.endsWith("[]") ? !0 : e.type === "tuple" ? (n = (t = e.components) === null || t === void 0 ? void 0 : t.some(vg)) !== null && n !== void 0 ? n : !1 : e.type.endsWith("]") ? vg(p_(e).param) : !1
}
const $$ = 20,
    L$ = bt - $$;

function gne(e, t) {
    if (typeof t != "string") throw new Te("address type expects string as input type", {
        value: t,
        name: e.name,
        type: e.type
    });
    let n = t.toLowerCase();
    if (n.startsWith("0x") || (n = `0x${n}`), !zn(n)) throw new Te("provided input is not valid address", {
        value: t,
        name: e.name,
        type: e.type
    });
    const r = Ds(n),
        i = Xx(bt);
    return i.set(r, L$), {
        dynamic: !1,
        encoded: i
    }
}

function yne(e, t) {
    const n = t.subarray(L$, bt);
    if (n.length !== $$) throw new Te("Invalid decoding input, not enough bytes to decode address", {
        bytes: t
    });
    const r = ho(n);
    return {
        result: vi(r),
        encoded: t.subarray(bt),
        consumed: bt
    }
}
const ua = new Map;
let ip = BigInt(256);
for (let e = 8; e <= 256; e += 8) ua.set(`uint${e}`, {
    min: BigInt(0),
    max: ip - BigInt(1)
}), ua.set(`int${e}`, {
    min: -ip / BigInt(2),
    max: ip / BigInt(2) - BigInt(1)
}), ip *= BigInt(256);
ua.set("int", ua.get("int256"));
ua.set("uint", ua.get("uint256"));
const F$ = BigInt(1) << BigInt(256);

function vne(e, t = bt) {
    let n;
    return e < 0 ? n = (F$ + e).toString(16) : n = e.toString(16), n = rl(n, t * 2), Ds(n)
}

function bne(e, t) {
    const n = ho(e),
        r = BigInt(n);
    return r <= t ? r : r - F$
}

function xh(e, t) {
    let n;
    try {
        n = Ua(t)
    } catch {
        throw new Te("provided input is not number value", {
            type: e.type,
            value: t,
            name: e.name
        })
    }
    const r = ua.get(e.type);
    if (!r) throw new Te("provided abi contains invalid number datatype", {
        type: e.type
    });
    if (n < r.min) throw new Te("provided input is less then minimum for given type", {
        type: e.type,
        value: t,
        name: e.name,
        minimum: r.min.toString()
    });
    if (n > r.max) throw new Te("provided input is greater then maximum for given type", {
        type: e.type,
        value: t,
        name: e.name,
        maximum: r.max.toString()
    });
    return {
        dynamic: !1,
        encoded: vne(n)
    }
}

function fl(e, t) {
    if (t.length < bt) throw new Te("Not enough bytes left to decode", {
        param: e,
        bytesLeft: t.length
    });
    const n = t.subarray(0, bt),
        r = ua.get(e.type);
    if (!r) throw new Te("provided abi contains invalid number datatype", {
        type: e.type
    });
    const i = bne(n, r.max);
    if (i < r.min) throw new Te("decoded value is less then minimum for given type", {
        type: e.type,
        value: i,
        name: e.name,
        minimum: r.min.toString()
    });
    if (i > r.max) throw new Te("decoded value is greater then maximum for given type", {
        type: e.type,
        value: i,
        name: e.name,
        maximum: r.max.toString()
    });
    return {
        result: i,
        encoded: t.subarray(bt),
        consumed: bt
    }
}

function wne(e, t) {
    let n;
    try {
        n = cD(t)
    } catch (r) {
        if (r instanceof TS) throw new Te("provided input is not valid boolean value", {
            type: e.type,
            value: t,
            name: e.name
        })
    }
    return xh({
        type: "uint8",
        name: ""
    }, Number(n))
}

function xne(e, t) {
    const n = fl({
        type: "uint8",
        name: ""
    }, t);
    if (n.result > 1 || n.result < 0) throw new Te("Invalid boolean value encoded", {
        boolBytes: t.subarray(0, bt),
        numberResult: n
    });
    return {
        result: n.result === BigInt(1),
        encoded: n.encoded,
        consumed: bt
    }
}
const Ane = 32;

function U$(e, t) {
    if (typeof t == "string" && t.length % 2 !== 0 && (t += "0"), !pa(t)) throw new Te("provided input is not valid bytes value", {
        type: e.type,
        value: t,
        name: e.name
    });
    const n = mi(t),
        [, r] = e.type.split("bytes");
    if (r) {
        if (Number(r) > Ane || Number(r) < 1) throw new Te("invalid bytes type. Static byte type can have between 1 and 32 bytes", {
            type: e.type
        });
        if (Number(r) < n.length) throw new Te("provided input size is different than type size", {
            type: e.type,
            value: t,
            name: e.name
        });
        const a = Xx(bt);
        return a.set(n), {
            dynamic: !1,
            encoded: a
        }
    }
    const i = Math.ceil(n.length / bt),
        o = Xx(bt + i * bt);
    return o.set(xh({
        type: "uint32",
        name: ""
    }, n.length).encoded), o.set(n, bt), {
        dynamic: !0,
        encoded: o
    }
}

function H$(e, t) {
    const [, n] = e.type.split("bytes");
    let r = Number(n),
        i = t,
        o = 1,
        a = 0;
    if (!r) {
        const s = fl({
            type: "uint32",
            name: ""
        }, i);
        r = Number(s.result), a += s.consumed, i = s.encoded, o = Math.ceil(r / bt)
    }
    if (r > t.length) throw new Te("there is not enough data to decode", {
        type: e.type,
        encoded: t,
        size: r
    });
    return {
        result: Ee(i.subarray(0, r)),
        encoded: i.subarray(o * bt),
        consumed: a + o * bt
    }
}

function Ene(e, t) {
    if (typeof t != "string") throw new Te("invalid input, should be string", {
        input: t
    });
    const n = BS(t);
    return U$({
        type: "bytes",
        name: ""
    }, n)
}

function Sne(e, t) {
    const n = H$({
        type: "bytes"
    }, t);
    return {
        result: fv(n.result),
        encoded: n.encoded,
        consumed: n.consumed
    }
}

function V$(e) {
    let t = 0,
        n = 0;
    const r = [],
        i = [];
    for (const o of e) o.dynamic ? t += bt : t += o.encoded.length;
    for (const o of e) o.dynamic ? (r.push(xh({
        type: "uint256",
        name: ""
    }, t + n)), i.push(o), n += o.encoded.length) : r.push(o);
    return bn(...r.map(o => o.encoded), ...i.map(o => o.encoded))
}

function _ne(e, t) {
    if (!Array.isArray(t)) throw new Te("Expected value to be array", {
        abi: e,
        values: t
    });
    const {
        size: n,
        param: r
    } = p_(e), i = t.map(s => Zx(r, s)), o = n === -1, a = i.length > 0 && i[0].dynamic;
    if (!o && t.length !== n) throw new Te("Given arguments count doesn't match array length", {
        arrayLength: n,
        argumentsLength: t.length
    });
    if (o || a) {
        const s = V$(i);
        if (o) {
            const u = xh({
                type: "uint256",
                name: ""
            }, i.length).encoded;
            return {
                dynamic: !0,
                encoded: i.length > 0 ? bn(u, s) : u
            }
        }
        return {
            dynamic: !0,
            encoded: s
        }
    }
    return {
        dynamic: !1,
        encoded: bn(...i.map(s => s.encoded))
    }
}

function Tne(e, t) {
    let {
        size: n,
        param: r
    } = p_(e);
    const i = n === -1;
    let o = 0;
    const a = [];
    let s = t;
    if (i) {
        const l = fl({
            type: "uint32",
            name: ""
        }, t);
        n = Number(l.result), o = l.consumed, s = l.encoded
    }
    if (vg(r)) {
        for (let l = 0; l < n; l += 1) {
            const c = fl({
                type: "uint32",
                name: ""
            }, s.subarray(l * bt));
            o += c.consumed;
            const f = bg(r, s.subarray(Number(c.result)));
            o += f.consumed, a.push(f.result)
        }
        return {
            result: a,
            encoded: s.subarray(o),
            consumed: o
        }
    }
    for (let l = 0; l < n; l += 1) {
        const c = bg(r, t.subarray(o));
        o += c.consumed, a.push(c.result)
    }
    return {
        result: a,
        encoded: t.subarray(o),
        consumed: o
    }
}

function Zx(e, t) {
    if (e.type === "string") return Ene(e, t);
    if (e.type === "bool") return wne(e, t);
    if (e.type === "address") return gne(e, t);
    if (e.type === "tuple") return m_(e, t);
    if (e.type.endsWith("]")) return _ne(e, t);
    if (e.type.startsWith("bytes")) return U$(e, t);
    if (e.type.startsWith("uint") || e.type.startsWith("int")) return xh(e, t);
    throw new Te("Unsupported", {
        param: e,
        value: t
    })
}

function bg(e, t) {
    if (e.type === "string") return Sne(e, t);
    if (e.type === "bool") return xne(e, t);
    if (e.type === "address") return yne(e, t);
    if (e.type === "tuple") return z$(e, t);
    if (e.type.endsWith("]")) return Tne(e, t);
    if (e.type.startsWith("bytes")) return H$(e, t);
    if (e.type.startsWith("uint") || e.type.startsWith("int")) return fl(e, t);
    throw new Te("Unsupported", {
        param: e,
        bytes: t
    })
}

function m_(e, t) {
    var n, r, i;
    let o = !1;
    if (!Array.isArray(t) && typeof t != "object") throw new Te("param must be either Array or Object", {
        param: e,
        input: t
    });
    const a = t,
        s = [];
    for (let u = 0; u < ((r = (n = e.components) === null || n === void 0 ? void 0 : n.length) !== null && r !== void 0 ? r : 0); u += 1) {
        const l = e.components[u];
        let c;
        if (Array.isArray(a)) {
            if (u >= a.length) throw new Te("input param length missmatch", {
                param: e,
                input: t
            });
            c = Zx(l, a[u])
        } else {
            const f = a[(i = l.name) !== null && i !== void 0 ? i : ""];
            if (f == null) throw new Te("missing input defined in abi", {
                param: e,
                input: t,
                paramName: l.name
            });
            c = Zx(l, f)
        }
        c.dynamic && (o = !0), s.push(c)
    }
    return o ? {
        dynamic: !0,
        encoded: V$(s)
    } : {
        dynamic: !1,
        encoded: bn(...s.map(u => u.encoded))
    }
}

function z$(e, t) {
    const n = {
        __length__: 0
    };
    let r = 0;
    if (!e.components) return {
        result: n,
        encoded: t,
        consumed: r
    };
    let i = 0;
    for (const [o, a] of e.components.entries()) {
        let s;
        if (vg(a)) {
            const u = fl({
                type: "uint32",
                name: ""
            }, t.subarray(r));
            s = bg(a, t.subarray(Number(u.result))), r += u.consumed, i += s.consumed
        } else s = bg(a, t.subarray(r)), r += s.consumed;
        n.__length__ += 1, n[o] = s.result, a.name && a.name !== "" && (n[a.name] = s.result)
    }
    return {
        encoded: t.subarray(r + i),
        result: n,
        consumed: r + i
    }
}

function Pne(e, t, n) {
    const r = D$(e),
        i = Ds(t);
    return z$({
        components: r
    }, i).result
}

function W$(e) {
    const t = [];
    return e.forEach(n => {
        if (Array.isArray(n)) {
            const r = W$(n);
            t.push({
                type: "tuple",
                components: r,
                name: ""
            })
        } else t.push({
            type: ro(n, !0)
        })
    }), t
}

function Sv(e, t) {
    if ((e == null ? void 0 : e.length) !== t.length) throw new Te("Invalid number of values received for given ABI", {
        expected: e == null ? void 0 : e.length,
        received: t.length
    });
    const n = D$(e);
    return ho(m_({
        type: "tuple",
        name: "",
        components: n
    }, t).encoded)
}

function One(e) {
    try {
        const t = W$(e);
        return ho(m_({
            type: "tuple",
            name: "",
            components: t
        }, e).encoded)
    } catch {
        throw new Te("Could not infer types from given params", {
            params: e
        })
    }
}
const Jx = (e, t) => Sv([e], [t]),
    G$ = (e, t, n) => {
        try {
            if (e.length > 0 && (!t || t === "0x" || t === "0X")) throw new Te("Returned values aren't valid, did it run Out of Gas? You might also see this error if you are not using the correct ABI for the contract you are retrieving data from, requesting data from a block number that does not exist, or querying a node which is not fully synced.");
            return Pne(e, `0x${t.replace(/0x/i,"")}`, n)
        } catch (r) {
            throw new Te(`Parameter decoding error: ${r.message}`, {
                internalErr: r
            })
        }
    },
    as = (e, t) => G$(e, t, !1),
    q$ = (e, t) => as([e], t)[0],
    dd = e => {
        if (typeof e != "string" && !Ev(e)) throw new Te("Invalid parameter value in encodeFunctionSignature");
        let t;
        return e && (typeof e == "function" || typeof e == "object") ? t = Wi(e) : t = e, Wn(t).slice(0, 10)
    },
    kne = (e, t) => {
        var n;
        if (!Ev(e)) throw new Te("Invalid parameter value in encodeFunctionCall");
        return `${dd(e)}${Sv((n=e.inputs)!==null&&n!==void 0?n:[],t??[]).replace("0x","")}`
    },
    e1 = (e, t, n = !0) => {
        const r = n && t && t.length >= 10 && t.startsWith("0x") ? t.slice(10) : t;
        if (!e.inputs) throw new gn("No inputs found in the ABI");
        const i = as([...e.inputs], r);
        return Object.assign(Object.assign({}, i), {
            __method__: Wi(e)
        })
    },
    Cne = (e, t) => {
        if (e.type === "constructor") return t;
        if (!t) return null;
        const n = t.length >= 2 ? t.slice(2) : t;
        if (!e.outputs) return null;
        const r = as([...e.outputs], n);
        return r.__length__ === 1 ? r[0] : r
    },
    Ine = ["bool", "string", "int", "uint", "address", "fixed", "ufixed"],
    Mne = (e, t) => e === "string" ? t : q$(e, t),
    K$ = (e, t, n) => {
        const r = Array.isArray(n) ? n : [n],
            i = {},
            o = {};
        for (const [d, h] of e.entries()) h.indexed ? i[d] = h : o[d] = h;
        const a = t ? G$(Object.values(o), t, !0) : {
                __length__: 0
            },
            s = r.length - Object.keys(i).length,
            u = Object.values(i).map((d, h) => Ine.some(m => d.type.startsWith(m)) ? Mne(d.type, r[h + s]) : r[h + s]),
            l = {
                __length__: 0
            };
        let c = 0,
            f = 0;
        for (const [d, h] of e.entries()) l[d] = h.type === "string" ? "" : void 0, i[d] && (l[d] = u[c], c += 1), o[d] && (l[d] = a[String(f)], f += 1), h.name && (l[h.name] = l[d]), l.__length__ += 1;
        return l
    },
    Xp = (e, t) => {
        if (t != null && t.data) {
            let n, r, i;
            try {
                const o = t.data.slice(0, 10),
                    a = e.find(s => Zte(s).startsWith(o));
                a != null && a.inputs ? (n = a.name, r = Wi(a), i = as([...a.inputs], t.data.substring(10))) : t.data.startsWith("0x08c379a0") ? (n = "Error", r = "Error(string)", i = as([{
                    name: "message",
                    type: "string"
                }], t.data.substring(10))) : t.data.startsWith("0x4e487b71") ? (n = "Panic", r = "Panic(uint256)", i = as([{
                    name: "code",
                    type: "uint256"
                }], t.data.substring(10))) : console.error("No matching error abi found for error data", t.data)
            } catch (o) {
                console.error(o)
            }
            n && t.setDecodedProperties(n, r, i)
        }
    };
var Nne = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
const Rne = (e, t) => {
    var n, r, i, o, a;
    if (e instanceof ns && e.cause instanceof nv) {
        if (t !== void 0) {
            const s = t.filter(u => Av(u));
            return Xp(s, e.cause), {
                reason: e.cause.message,
                signature: (n = e.cause.data) === null || n === void 0 ? void 0 : n.slice(0, 10),
                data: (r = e.cause.data) === null || r === void 0 ? void 0 : r.substring(10),
                customErrorName: e.cause.errorName,
                customErrorDecodedSignature: e.cause.errorSignature,
                customErrorArguments: e.cause.errorArgs
            }
        }
        return {
            reason: e.cause.message,
            signature: (i = e.cause.data) === null || i === void 0 ? void 0 : i.slice(0, 10),
            data: (o = e.cause.data) === null || o === void 0 ? void 0 : o.substring(10)
        }
    }
    if (e instanceof rv && !Array.isArray((a = e.cause) === null || a === void 0 ? void 0 : a.errors) && e.cause !== void 0) return e.cause.message;
    throw e
};

function Q$(e, t, n) {
    return Nne(this, arguments, void 0, function*(r, i, o, a = r.defaultReturnFormat) {
        try {
            yield b_(r, i, r.defaultBlock, a);
            return
        } catch (s) {
            return Rne(s, o)
        }
    })
}
var jne = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};

function Tb(e, t, n, r, i, o) {
    return jne(this, void 0, void 0, function*() {
        let a = o;
        a === void 0 && e.handleRevert && t !== void 0 && (a = yield Q$(e, t, i));
        let s;
        if (a === void 0) s = new O3(n);
        else if (typeof a == "string") s = new zm(a, void 0, n);
        else if (a.customErrorName !== void 0 && a.customErrorDecodedSignature !== void 0 && a.customErrorArguments !== void 0) {
            const u = a;
            s = new P3(u.reason, u.customErrorName, u.customErrorDecodedSignature, u.customErrorArguments, u.signature, n, u.data)
        } else s = new zm(a.reason, a.signature, n, a.data);
        return s
    })
}
const g_ = (e, t, n, r = mn) => {
    var i, o, a, s, u, l;
    let c = Object.assign({}, e);
    const f = W(Gl, t, r);
    if ([cl, "allEvents"].includes(c.name)) {
        const h = n.find(m => m.signature === t.topics[0]);
        h ? c = h : c = {
            anonymous: !0
        }
    }
    if (c.inputs = (o = (i = c.inputs) !== null && i !== void 0 ? i : e.inputs) !== null && o !== void 0 ? o : [], !c.anonymous) {
        let h = 0;
        ((a = c.inputs) !== null && a !== void 0 ? a : []).forEach(m => {
            m.indexed && (h += 1)
        }), h > 0 && (t != null && t.topics) && (t == null ? void 0 : t.topics.length) !== h + 1 && (c = Object.assign(Object.assign({}, c), {
            anonymous: !0,
            inputs: []
        }))
    }
    const d = c.anonymous ? t.topics : ((s = t.topics) !== null && s !== void 0 ? s : []).slice(1);
    return Object.assign(Object.assign({}, f), {
        returnValues: K$([...(u = c.inputs) !== null && u !== void 0 ? u : []], t.data, d),
        event: c.name,
        signature: !c.anonymous && ((l = t.topics) === null || l === void 0 ? void 0 : l.length) > 0 && t.topics[0] ? t.topics[0] : void 0,
        raw: {
            data: t.data,
            topics: t.topics
        }
    })
};
var Sa = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
class Y$ {
    constructor({
        options: t,
        web3Context: n,
        promiEvent: r,
        returnFormat: i
    }) {
        this.options = {
            checkRevertBeforeSending: !0
        }, this.options = t, this.web3Context = n, this.promiEvent = r, this.returnFormat = i
    }
    getReceiptWithEvents(t) {
        var n, r;
        const i = Object.assign({}, t ? ? {});
        if (!((n = this.options) === null || n === void 0) && n.contractAbi && i.logs && i.logs.length > 0) {
            i.events = {};
            for (const o of i.logs) {
                const a = g_(Gx, o, (r = this.options) === null || r === void 0 ? void 0 : r.contractAbi, this.returnFormat);
                a.event && (i.events[a.event] = a)
            }
        }
        return i
    }
    checkRevertBeforeSending(t) {
        return Sa(this, void 0, void 0, function*() {
            if (this.options.checkRevertBeforeSending !== !1) {
                let n = t;
                F(t.data) && F(t.input) && F(t.gas) && (n = Object.assign(Object.assign({}, t), {
                    gas: 21e3
                }));
                const r = yield Q$(this.web3Context, n, this.options.contractAbi);
                if (r !== void 0) throw yield Tb(this.web3Context, t, void 0, void 0, this.options.contractAbi, r)
            }
        })
    }
    emitSending(t) {
        this.promiEvent.listenerCount("sending") > 0 && this.promiEvent.emit("sending", t)
    }
    populateGasPrice(t) {
        return Sa(this, arguments, void 0, function*({
            transactionFormatted: n,
            transaction: r
        }) {
            var i;
            let o = n;
            return !this.web3Context.config.ignoreGasPricing && !(!((i = this.options) === null || i === void 0) && i.ignoreGasPricing) && F(n.gasPrice) && (F(r.maxPriorityFeePerGas) || F(r.maxFeePerGas)) && (o = Object.assign(Object.assign({}, n), yield E$(n, this.web3Context, pe))), o
        })
    }
    signAndSend(t) {
        return Sa(this, arguments, void 0, function*({
            wallet: n,
            tx: r
        }) {
            if (n) {
                const i = yield n.signTransaction(r);
                return Qx(this.web3Context, () => Sa(this, void 0, void 0, function*() {
                    return y$(this.web3Context.requestManager, i.rawTransaction)
                }), i.transactionHash)
            }
            return Qx(this.web3Context, () => Sa(this, void 0, void 0, function*() {
                return Uee(this.web3Context.requestManager, r)
            }))
        })
    }
    emitSent(t) {
        this.promiEvent.listenerCount("sent") > 0 && this.promiEvent.emit("sent", t)
    }
    emitTransactionHash(t) {
        this.promiEvent.listenerCount("transactionHash") > 0 && this.promiEvent.emit("transactionHash", t)
    }
    emitReceipt(t) {
        this.promiEvent.listenerCount("receipt") > 0 && this.promiEvent.emit("receipt", t)
    }
    handleError(t) {
        return Sa(this, arguments, void 0, function*({
            error: n,
            tx: r
        }) {
            var i;
            let o = n;
            return o instanceof ns && this.web3Context.handleRevert && (o = yield Tb(this.web3Context, r, void 0, void 0, (i = this.options) === null || i === void 0 ? void 0 : i.contractAbi)), (o instanceof rv || o instanceof ns || o instanceof P3 || o instanceof O3 || o instanceof zm || o instanceof M3) && this.promiEvent.listenerCount("error") > 0 && this.promiEvent.emit("error", o), o
        })
    }
    emitConfirmation({
        receipt: t,
        transactionHash: n,
        customTransactionReceiptSchema: r
    }) {
        this.promiEvent.listenerCount("confirmation") > 0 && Qte(this.web3Context, this.promiEvent, t, n, this.returnFormat, r)
    }
    handleResolve(t) {
        return Sa(this, arguments, void 0, function*({
            receipt: n,
            tx: r
        }) {
            var i, o, a;
            if (!((i = this.options) === null || i === void 0) && i.transactionResolver) return (o = this.options) === null || o === void 0 ? void 0 : o.transactionResolver(n);
            if (n.status === BigInt(0)) {
                const s = yield Tb(this.web3Context, r, n, void 0, (a = this.options) === null || a === void 0 ? void 0 : a.contractAbi);
                throw this.promiEvent.listenerCount("error") > 0 && this.promiEvent.emit("error", s), s
            } else return n
        })
    }
}
var Be = function(e, t, n, r) {
        function i(o) {
            return o instanceof n ? o : new n(function(a) {
                a(o)
            })
        }
        return new(n || (n = Promise))(function(o, a) {
            function s(c) {
                try {
                    l(r.next(c))
                } catch (f) {
                    a(f)
                }
            }

            function u(c) {
                try {
                    l(r.throw(c))
                } catch (f) {
                    a(f)
                }
            }

            function l(c) {
                c.done ? o(c.value) : i(c.value).then(s, u)
            }
            l((r = r.apply(e, t || [])).next())
        })
    },
    Bne = function(e, t) {
        var n = {};
        for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
        if (e != null && typeof Object.getOwnPropertySymbols == "function")
            for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++) t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
        return n
    };
const Dne = e => Be(void 0, void 0, void 0, function*() {
    return g$(e.requestManager)
});

function $ne(e, t) {
    return Be(this, void 0, void 0, function*() {
        const n = yield Tee(e.requestManager);
        return W({
            format: "uint"
        }, n, t ? ? e.defaultReturnFormat)
    })
}

function y_(e, t) {
    return Be(this, void 0, void 0, function*() {
        const n = yield Pee(e.requestManager);
        return W({
            format: "uint"
        }, n, t ? ? e.defaultReturnFormat)
    })
}

function Lne(e, t) {
    return Be(this, void 0, void 0, function*() {
        const n = yield Oee(e.requestManager);
        return W({
            format: "uint"
        }, n, t ? ? e.defaultReturnFormat)
    })
}

function v_(e, t) {
    return Be(this, void 0, void 0, function*() {
        const n = yield Cee(e.requestManager);
        return W({
            format: "uint"
        }, n, t ? ? e.defaultReturnFormat)
    })
}

function Fne(e, t) {
    return Be(this, arguments, void 0, function*(n, r, i = n.defaultBlock, o) {
        const a = Ut(i) ? i : W({
                format: "uint"
            }, i, pe),
            s = yield Iee(n.requestManager, r, a);
        return W({
            format: "uint"
        }, s, o ? ? n.defaultReturnFormat)
    })
}

function Une(e, t, n) {
    return Be(this, arguments, void 0, function*(r, i, o, a = r.defaultBlock, s) {
        const u = W({
                format: "uint"
            }, o, pe),
            l = Ut(a) ? a : W({
                format: "uint"
            }, a, pe),
            c = yield Mee(r.requestManager, i, u, l);
        return W({
            format: "bytes"
        }, c, s ? ? r.defaultReturnFormat)
    })
}

function Hne(e, t) {
    return Be(this, arguments, void 0, function*(n, r, i = n.defaultBlock, o) {
        const a = Ut(i) ? i : W({
                format: "uint"
            }, i, pe),
            s = yield $ee(n.requestManager, r, a);
        return W({
            format: "bytes"
        }, s, o ? ? n.defaultReturnFormat)
    })
}

function X$(e) {
    return Be(this, arguments, void 0, function*(t, n = t.defaultBlock, r = !1, i) {
        var o;
        let a;
        if (pa(n)) {
            const u = W({
                format: "bytes32"
            }, n, pe);
            a = yield zee(t.requestManager, u, r)
        } else {
            const u = Ut(n) ? n : W({
                format: "uint"
            }, n, pe);
            a = yield v$(t.requestManager, u, r)
        }
        const s = W(gg, a, i ? ? t.defaultReturnFormat);
        return F(s) ? s : Object.assign(Object.assign({}, s), {
            transactions: (o = s.transactions) !== null && o !== void 0 ? o : []
        })
    })
}

function Vne(e) {
    return Be(this, arguments, void 0, function*(t, n = t.defaultBlock, r) {
        let i;
        if (pa(n)) {
            const o = W({
                format: "bytes32"
            }, n, pe);
            i = yield Ree(t.requestManager, o)
        } else {
            const o = Ut(n) ? n : W({
                format: "uint"
            }, n, pe);
            i = yield jee(t.requestManager, o)
        }
        return W({
            format: "uint"
        }, i, r ? ? t.defaultReturnFormat)
    })
}

function zne(e) {
    return Be(this, arguments, void 0, function*(t, n = t.defaultBlock, r) {
        let i;
        if (pa(n)) {
            const o = W({
                format: "bytes32"
            }, n, pe);
            i = yield Bee(t.requestManager, o)
        } else {
            const o = Ut(n) ? n : W({
                format: "uint"
            }, n, pe);
            i = yield Dee(t.requestManager, o)
        }
        return W({
            format: "uint"
        }, i, r ? ? t.defaultReturnFormat)
    })
}

function Wne(e) {
    return Be(this, arguments, void 0, function*(t, n = t.defaultBlock, r, i) {
        const o = W({
            format: "uint"
        }, r, pe);
        let a;
        if (pa(n)) {
            const s = W({
                format: "bytes32"
            }, n, pe);
            a = yield Qee(t.requestManager, s, o)
        } else {
            const s = Ut(n) ? n : W({
                format: "uint"
            }, n, pe);
            a = yield Yee(t.requestManager, s, o)
        }
        return W(gg, a, i ? ? t.defaultReturnFormat)
    })
}

function Gne(e, t) {
    return Be(this, arguments, void 0, function*(n, r, i = n.defaultReturnFormat) {
        const o = W({
                format: "bytes32"
            }, r, mn),
            a = yield Wee(n.requestManager, o);
        return F(a) ? a : Nn(a, i, {
            transactionSchema: n.config.customTransactionSchema,
            fillInputAndData: !0
        })
    })
}

function qne(e, t) {
    return Be(this, void 0, void 0, function*() {
        return (yield ste(e.requestManager)).map(r => Nn(r, t ? ? e.defaultReturnFormat, {
            transactionSchema: e.config.customTransactionSchema,
            fillInputAndData: !0
        }))
    })
}

function Kne(e) {
    return Be(this, arguments, void 0, function*(t, n = t.defaultBlock, r, i) {
        const o = W({
            format: "uint"
        }, r, pe);
        let a;
        if (pa(n)) {
            const s = W({
                format: "bytes32"
            }, n, pe);
            a = yield Gee(t.requestManager, s, o)
        } else {
            const s = Ut(n) ? n : W({
                format: "uint"
            }, n, pe);
            a = yield qee(t.requestManager, s, o)
        }
        return F(a) ? a : Nn(a, i ? ? t.defaultReturnFormat, {
            transactionSchema: t.config.customTransactionSchema,
            fillInputAndData: !0
        })
    })
}

function Z$(e, t, n) {
    return Be(this, void 0, void 0, function*() {
        const r = W({
            format: "bytes32"
        }, t, mn);
        let i;
        try {
            i = yield Kee(e.requestManager, r)
        } catch (o) {
            if (typeof o == "object" && !F(o) && "message" in o && o.message === "transaction indexing is in progress") console.warn("Transaction indexing is in progress.");
            else throw o
        }
        return F(i) ? i : W(ql, i, n ? ? e.defaultReturnFormat)
    })
}

function J$(e, t) {
    return Be(this, arguments, void 0, function*(n, r, i = n.defaultBlock, o) {
        const a = Ut(i) ? i : W({
                format: "uint"
            }, i, pe),
            s = yield Nee(n.requestManager, r, a);
        return W({
            format: "uint"
        }, s, o ? ? n.defaultReturnFormat)
    })
}

function hd(e, t, n, r = {
    checkRevertBeforeSending: !0
}, i) {
    const o = new f$((a, s) => {
        setImmediate(() => {
            Be(this, void 0, void 0, function*() {
                const u = new Y$({
                    web3Context: e,
                    promiEvent: o,
                    options: r,
                    returnFormat: n
                });
                let l = Object.assign({}, t);
                F(i) || (l = yield i.processTransaction(l));
                let c = Nn(Object.assign(Object.assign({}, l), {
                    from: qx("from", e, l),
                    to: qx("to", e, l)
                }), pe, {
                    transactionSchema: e.config.customTransactionSchema
                });
                try {
                    c = yield u.populateGasPrice({
                        transaction: l,
                        transactionFormatted: c
                    }), yield u.checkRevertBeforeSending(c), u.emitSending(c);
                    let f;
                    e.wallet && !F(c.from) && (f = e.wallet.get(c.from));
                    const d = yield u.signAndSend({
                        wallet: f,
                        tx: c
                    }), h = W({
                        format: "bytes32"
                    }, d, n ? ? e.defaultReturnFormat);
                    u.emitSent(c), u.emitTransactionHash(h);
                    const m = yield T$(e, d, n ? ? e.defaultReturnFormat), p = u.getReceiptWithEvents(W(ql, m, n ? ? e.defaultReturnFormat));
                    u.emitReceipt(p), a(yield u.handleResolve({
                        receipt: p,
                        tx: c
                    })), u.emitConfirmation({
                        receipt: p,
                        transactionHash: d
                    })
                } catch (f) {
                    s(yield u.handleError({
                        error: f,
                        tx: c
                    }))
                }
            })
        })
    });
    return o
}

function Qne(e, t, n, r = {
    checkRevertBeforeSending: !0
}) {
    const i = new f$((o, a) => {
        setImmediate(() => {
            Be(this, void 0, void 0, function*() {
                const s = new Y$({
                        web3Context: e,
                        promiEvent: i,
                        options: r,
                        returnFormat: n
                    }),
                    u = W({
                        format: "bytes"
                    }, t, pe),
                    l = Ps.fromSerializedData(mi(Ke(u))),
                    c = Object.assign(Object.assign({}, l.toJSON()), {
                        from: l.getSenderAddress().toString()
                    });
                try {
                    const {
                        v: f,
                        r: d,
                        s: h
                    } = c, m = Bne(c, ["v", "r", "s"]);
                    yield s.checkRevertBeforeSending(m), s.emitSending(u);
                    const p = yield Qx(e, () => Be(this, void 0, void 0, function*() {
                        return y$(e.requestManager, u)
                    }));
                    s.emitSent(u);
                    const y = W({
                        format: "bytes32"
                    }, p, n ? ? e.defaultReturnFormat);
                    s.emitTransactionHash(y);
                    const g = yield T$(e, p, n ? ? e.defaultReturnFormat), b = s.getReceiptWithEvents(W(ql, g, n ? ? e.defaultReturnFormat));
                    s.emitReceipt(b), o(yield s.handleResolve({
                        receipt: b,
                        tx: c
                    })), s.emitConfirmation({
                        receipt: b,
                        transactionHash: p
                    })
                } catch (f) {
                    a(yield s.handleError({
                        error: f,
                        tx: c
                    }))
                }
            })
        })
    });
    return i
}

function Yne(e, t, n) {
    return Be(this, arguments, void 0, function*(r, i, o, a = r.defaultReturnFormat) {
        var s;
        const u = W({
            format: "bytes"
        }, i, mn);
        if (!((s = r.wallet) === null || s === void 0) && s.get(o)) {
            const f = r.wallet.get(o).sign(u);
            return W(Rte, f, a)
        }
        if (typeof o == "number") throw new JK(i, 'RPC method "eth_sign" does not support index signatures');
        const l = yield Lee(r.requestManager, o, u);
        return W({
            format: "bytes"
        }, l, a)
    })
}

function Xne(e, t) {
    return Be(this, arguments, void 0, function*(n, r, i = n.defaultReturnFormat) {
        const o = yield Fee(n.requestManager, Nn(r, pe, {
            transactionSchema: n.config.customTransactionSchema
        }));
        return IS(o) ? $te(o, i, {
            fillInputAndData: !0
        }) : {
            raw: W({
                format: "bytes"
            }, o.raw, i),
            tx: Nn(o.tx, i, {
                transactionSchema: n.config.customTransactionSchema,
                fillInputAndData: !0
            })
        }
    })
}

function b_(e, t) {
    return Be(this, arguments, void 0, function*(n, r, i = n.defaultBlock, o = n.defaultReturnFormat) {
        const a = Ut(i) ? i : W({
                format: "uint"
            }, i, pe),
            s = yield Hee(n.requestManager, Nn(r, pe, {
                transactionSchema: n.config.customTransactionSchema
            }), a);
        return W({
            format: "bytes"
        }, s, o)
    })
}

function w_(e, t) {
    return Be(this, arguments, void 0, function*(n, r, i = n.defaultBlock, o) {
        const a = Nn(r, pe, {
                transactionSchema: n.config.customTransactionSchema
            }),
            s = Ut(i) ? i : W({
                format: "uint"
            }, i, pe),
            u = yield Vee(n.requestManager, a, s);
        return W({
            format: "uint"
        }, u, o ? ? n.defaultReturnFormat)
    })
}

function eL(e, t, n) {
    return Be(this, void 0, void 0, function*() {
        let {
            toBlock: r,
            fromBlock: i
        } = t;
        F(r) || (typeof r == "number" || typeof r == "bigint") && (r = Nt(r)), F(i) || (typeof i == "number" || typeof i == "bigint") && (i = Nt(i));
        const o = Object.assign(Object.assign({}, t), {
            fromBlock: i,
            toBlock: r
        });
        return (yield rte(e.requestManager, o)).map(u => typeof u == "string" ? u : W(Gl, u, n ? ? e.defaultReturnFormat))
    })
}

function tL(e, t) {
    return Be(this, void 0, void 0, function*() {
        const n = yield lte(e.requestManager);
        return W({
            format: "uint"
        }, n, t ? ? e.defaultReturnFormat)
    })
}

function Zne(e, t, n) {
    return Be(this, arguments, void 0, function*(r, i, o, a = r.defaultBlock, s) {
        const u = o.map(f => W({
                format: "bytes"
            }, f, pe)),
            l = Ut(a) ? a : W({
                format: "uint"
            }, a, pe),
            c = yield cte(r.requestManager, i, u, l);
        return W(Dte, c, s ? ? r.defaultReturnFormat)
    })
}

function Jne(e, t) {
    return Be(this, arguments, void 0, function*(n, r, i = n.defaultBlock, o, a) {
        const s = W({
                format: "uint"
            }, r, pe),
            u = Ut(i) ? i : W({
                format: "uint"
            }, i, pe),
            l = W({
                type: "array",
                items: {
                    format: "uint"
                }
            }, o, xv),
            c = yield ate(n.requestManager, s, u, l);
        return W(jte, c, a ? ? n.defaultReturnFormat)
    })
}

function nL(e, t) {
    return Be(this, arguments, void 0, function*(n, r, i = n.defaultBlock, o) {
        const a = Ut(i) ? i : W({
                format: "uint"
            }, i, pe),
            s = yield dte(n.requestManager, Nn(r, pe, {
                transactionSchema: n.config.customTransactionSchema
            }), a);
        return W(Cte, s, o ? ? n.defaultReturnFormat)
    })
}

function ere(e, t, n, r, i) {
    return Be(this, void 0, void 0, function*() {
        const o = yield hte(e.requestManager, t, n, r);
        return W({
            format: "bytes"
        }, o, i ? ? e.defaultReturnFormat)
    })
}
var Kl = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};

function tre(e, t) {
    return Kl(this, void 0, void 0, function*() {
        const n = yield Jee(e.requestManager);
        return W({
            format: "uint"
        }, n, t ? ? e.defaultReturnFormat)
    })
}

function nre(e, t, n) {
    return Kl(this, void 0, void 0, function*() {
        let {
            toBlock: r,
            fromBlock: i
        } = t;
        F(r) || (typeof r == "number" || typeof r == "bigint") && (r = Nt(r)), F(i) || (typeof i == "number" || typeof i == "bigint") && (i = Nt(i));
        const o = Object.assign(Object.assign({}, t), {
                fromBlock: i,
                toBlock: r
            }),
            a = yield Xee(e.requestManager, o);
        return W({
            format: "uint"
        }, a, n ? ? e.defaultReturnFormat)
    })
}

function rre(e, t) {
    return Kl(this, void 0, void 0, function*() {
        const n = yield Zee(e.requestManager);
        return W({
            format: "uint"
        }, n, t ? ? e.defaultReturnFormat)
    })
}

function ire(e, t) {
    return Kl(this, void 0, void 0, function*() {
        return yield ete(e.requestManager, Nt(t))
    })
}

function ore(e, t, n) {
    return Kl(this, void 0, void 0, function*() {
        return (yield tte(e.requestManager, Nt(t))).map(o => typeof o == "string" ? o : W(Gl, o, n ? ? e.defaultReturnFormat))
    })
}

function are(e, t, n) {
    return Kl(this, void 0, void 0, function*() {
        return (yield nte(e.requestManager, Nt(t))).map(o => typeof o == "string" ? o : W(Gl, o, n ? ? e.defaultReturnFormat))
    })
}
class rL extends vh {
    _buildSubscriptionParams() {
        return ["logs", this.args]
    }
    formatSubscriptionResult(t) {
        return W(Gl, t, super.returnFormat)
    }
}
class uk extends vh {
    _buildSubscriptionParams() {
        return ["newPendingTransactions"]
    }
    formatSubscriptionResult(t) {
        return W({
            format: "string"
        }, t, super.returnFormat)
    }
}
class wg extends vh {
    _buildSubscriptionParams() {
        return ["newHeads"]
    }
    formatSubscriptionResult(t) {
        return W(Mte, t, super.returnFormat)
    }
}
class iL extends vh {
    _buildSubscriptionParams() {
        return ["syncing"]
    }
    _processSubscriptionResult(t) {
        if (typeof t == "boolean") this.emit("changed", t);
        else {
            const n = Object.fromEntries(Object.entries((t == null ? void 0 : t.status) || t).map(([r, i]) => [r.charAt(0).toLowerCase() + r.substring(1), i]));
            this.emit("changed", t.syncing), this.emit("data", W(Nte, n, super.returnFormat))
        }
    }
}
var ge = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
const t1 = {
    logs: rL,
    newPendingTransactions: uk,
    newHeads: wg,
    syncing: iL,
    pendingTransactions: uk,
    newBlockHeaders: wg
};
class _v extends lr {
    constructor(t) {
        if (typeof t == "string" || cg(t)) {
            super({
                provider: t,
                registeredSubscriptions: t1
            });
            return
        }
        if (t.registeredSubscriptions) {
            super(t);
            return
        }
        super(Object.assign(Object.assign({}, t), {
            registeredSubscriptions: t1
        })), this.getFeeData = this.calculateFeeData
    }
    setTransactionMiddleware(t) {
        this.transactionMiddleware = t
    }
    getTransactionMiddleware() {
        return this.transactionMiddleware
    }
    getProtocolVersion() {
        return ge(this, void 0, void 0, function*() {
            return Eee(this.requestManager)
        })
    }
    isSyncing() {
        return ge(this, void 0, void 0, function*() {
            return g$(this.requestManager)
        })
    }
    getCoinbase() {
        return ge(this, void 0, void 0, function*() {
            return See(this.requestManager)
        })
    }
    isMining() {
        return ge(this, void 0, void 0, function*() {
            return _ee(this.requestManager)
        })
    }
    getHashrate(t) {
        return ge(this, void 0, void 0, function*() {
            var n;
            return t === void 0 && (t = (n = this.defaultReturnFormat) !== null && n !== void 0 ? n : mn), this.getHashRate(t)
        })
    }
    getHashRate() {
        return ge(this, arguments, void 0, function*(t = this.defaultReturnFormat) {
            return $ne(this, t)
        })
    }
    getGasPrice() {
        return ge(this, arguments, void 0, function*(t = this.defaultReturnFormat) {
            return y_(this, t)
        })
    }
    getMaxPriorityFeePerGas() {
        return ge(this, arguments, void 0, function*(t = this.defaultReturnFormat) {
            return Lne(this, t)
        })
    }
    calculateFeeData() {
        return ge(this, arguments, void 0, function*(t = BigInt(2), n = cv.Gwei) {
            var r;
            const i = yield this.getBlock(void 0, !1), o = (r = i == null ? void 0 : i.baseFeePerGas) !== null && r !== void 0 ? r : void 0;
            let a;
            try {
                a = yield this.getGasPrice()
            } catch {}
            let s;
            try {
                s = yield this.getMaxPriorityFeePerGas()
            } catch {}
            let u;
            if (o) {
                s = s ? ? n;
                let l;
                typeof t == "number" ? l = BigInt(Math.floor(t * 1e3)) / BigInt(1e3) : l = t, u = o * l + s
            }
            return {
                gasPrice: a,
                maxFeePerGas: u,
                maxPriorityFeePerGas: s,
                baseFeePerGas: o
            }
        })
    }
    getAccounts() {
        return ge(this, void 0, void 0, function*() {
            var t;
            return ((t = yield kee(this.requestManager)) !== null && t !== void 0 ? t : []).map(r => vi(r))
        })
    }
    getBlockNumber() {
        return ge(this, arguments, void 0, function*(t = this.defaultReturnFormat) {
            return v_(this, t)
        })
    }
    getBalance(t) {
        return ge(this, arguments, void 0, function*(n, r = this.defaultBlock, i = this.defaultReturnFormat) {
            return Fne(this, n, r, i)
        })
    }
    getStorageAt(t, n) {
        return ge(this, arguments, void 0, function*(r, i, o = this.defaultBlock, a = this.defaultReturnFormat) {
            return Une(this, r, i, o, a)
        })
    }
    getCode(t) {
        return ge(this, arguments, void 0, function*(n, r = this.defaultBlock, i = this.defaultReturnFormat) {
            return Hne(this, n, r, i)
        })
    }
    getBlock() {
        return ge(this, arguments, void 0, function*(t = this.defaultBlock, n = !1, r = this.defaultReturnFormat) {
            return X$(this, t, n, r)
        })
    }
    getBlockTransactionCount() {
        return ge(this, arguments, void 0, function*(t = this.defaultBlock, n = this.defaultReturnFormat) {
            return Vne(this, t, n)
        })
    }
    getBlockUncleCount() {
        return ge(this, arguments, void 0, function*(t = this.defaultBlock, n = this.defaultReturnFormat) {
            return zne(this, t, n)
        })
    }
    getUncle() {
        return ge(this, arguments, void 0, function*(t = this.defaultBlock, n, r = this.defaultReturnFormat) {
            return Wne(this, t, n, r)
        })
    }
    getTransaction(t) {
        return ge(this, arguments, void 0, function*(n, r = this.defaultReturnFormat) {
            const i = yield Gne(this, n, r);
            if (!i) throw new gO;
            return i
        })
    }
    getPendingTransactions() {
        return ge(this, arguments, void 0, function*(t = this.defaultReturnFormat) {
            return qne(this, t)
        })
    }
    getTransactionFromBlock() {
        return ge(this, arguments, void 0, function*(t = this.defaultBlock, n, r = this.defaultReturnFormat) {
            return Kne(this, t, n, r)
        })
    }
    getTransactionReceipt(t) {
        return ge(this, arguments, void 0, function*(n, r = this.defaultReturnFormat) {
            const i = yield Z$(this, n, r);
            if (!i) throw new gO;
            return i
        })
    }
    getTransactionCount(t) {
        return ge(this, arguments, void 0, function*(n, r = this.defaultBlock, i = this.defaultReturnFormat) {
            return J$(this, n, r, i)
        })
    }
    sendTransaction(t, n = this.defaultReturnFormat, r) {
        return hd(this, t, n, r, this.transactionMiddleware)
    }
    sendSignedTransaction(t, n = this.defaultReturnFormat, r) {
        return Qne(this, t, n, r)
    }
    sign(t, n) {
        return ge(this, arguments, void 0, function*(r, i, o = this.defaultReturnFormat) {
            return Yne(this, r, i, o)
        })
    }
    signTransaction(t) {
        return ge(this, arguments, void 0, function*(n, r = this.defaultReturnFormat) {
            return Xne(this, n, r)
        })
    }
    call(t) {
        return ge(this, arguments, void 0, function*(n, r = this.defaultBlock, i = this.defaultReturnFormat) {
            return b_(this, n, r, i)
        })
    }
    estimateGas(t) {
        return ge(this, arguments, void 0, function*(n, r = this.defaultBlock, i = this.defaultReturnFormat) {
            return w_(this, n, r, i)
        })
    }
    getPastLogs(t) {
        return ge(this, arguments, void 0, function*(n, r = this.defaultReturnFormat) {
            return eL(this, n, r)
        })
    }
    getWork() {
        return ge(this, void 0, void 0, function*() {
            return ite(this.requestManager)
        })
    }
    submitWork(t, n, r) {
        return ge(this, void 0, void 0, function*() {
            return ote(this.requestManager, t, n, r)
        })
    }
    requestAccounts() {
        return ge(this, void 0, void 0, function*() {
            return ute(this.requestManager)
        })
    }
    getChainId() {
        return ge(this, arguments, void 0, function*(t = this.defaultReturnFormat) {
            return tL(this, t)
        })
    }
    getNodeInfo() {
        return ge(this, void 0, void 0, function*() {
            return fte(this.requestManager)
        })
    }
    getProof(t, n) {
        return ge(this, arguments, void 0, function*(r, i, o = this.defaultBlock, a = this.defaultReturnFormat) {
            return Zne(this, r, i, o, a)
        })
    }
    getFeeHistory(t) {
        return ge(this, arguments, void 0, function*(n, r = this.defaultBlock, i, o = this.defaultReturnFormat) {
            return Jne(this, n, r, i, o)
        })
    }
    createAccessList(t) {
        return ge(this, arguments, void 0, function*(n, r = this.defaultBlock, i = this.defaultReturnFormat) {
            return nL(this, n, r, i)
        })
    }
    signTypedData(t, n, r, i) {
        return ge(this, void 0, void 0, function*() {
            var o;
            return r === void 0 && (r = !1), i === void 0 && (i = (o = this.defaultReturnFormat) !== null && o !== void 0 ? o : mn), ere(this, t, n, r, i)
        })
    }
    subscribe(t, n, r) {
        return ge(this, void 0, void 0, function*() {
            var i, o;
            r === void 0 && (r = (i = this.defaultReturnFormat) !== null && i !== void 0 ? i : mn);
            const a = yield(o = this.subscriptionManager) === null || o === void 0 ? void 0 : o.subscribe(t, n, r);
            return a instanceof rL && t === "logs" && typeof n == "object" && !le(n.fromBlock) && Number.isFinite(Number(n.fromBlock)) && setImmediate(() => {
                this.getPastLogs(n).then(s => {
                    for (const u of s) a._processSubscriptionResult(u)
                }).catch(s => {
                    a._processSubscriptionError(s)
                })
            }), a
        })
    }
    static shouldClearSubscription({
        sub: t
    }) {
        return !(t instanceof iL)
    }
    clearSubscriptions(t = !1) {
        var n;
        return (n = this.subscriptionManager) === null || n === void 0 ? void 0 : n.unsubscribe(t ? _v.shouldClearSubscription : void 0)
    }
    createNewPendingTransactionFilter() {
        return ge(this, arguments, void 0, function*(t = this.defaultReturnFormat) {
            return tre(this, t)
        })
    }
    createNewFilter(t) {
        return ge(this, arguments, void 0, function*(n, r = this.defaultReturnFormat) {
            return nre(this, n, r)
        })
    }
    createNewBlockFilter() {
        return ge(this, arguments, void 0, function*(t = this.defaultReturnFormat) {
            return rre(this, t)
        })
    }
    uninstallFilter(t) {
        return ge(this, void 0, void 0, function*() {
            return ire(this, t)
        })
    }
    getFilterChanges(t) {
        return ge(this, arguments, void 0, function*(n, r = this.defaultReturnFormat) {
            return ore(this, n, r)
        })
    }
    getFilterLogs(t) {
        return ge(this, arguments, void 0, function*(n, r = this.defaultReturnFormat) {
            return are(this, n, r)
        })
    }
}
const sre = e => {
        if (!F(e.common)) {
            if (F(e.common.customChain)) throw new rQ;
            if (F(e.common.customChain.chainId)) throw new iQ;
            if (!F(e.chainId) && e.chainId !== e.common.customChain.chainId) throw new oQ({
                txChainId: e.chainId,
                customChainId: e.common.customChain.chainId
            })
        }
    },
    ure = e => {
        if (!F(e.common) && !F(e.chain) && !F(e.hardfork)) throw new uQ;
        if (!F(e.chain) && F(e.hardfork) || !F(e.hardfork) && F(e.chain)) throw new lQ({
            chain: e.chain,
            hardfork: e.hardfork
        })
    },
    lre = e => {
        if (!F(e.common) && !F(e.common.baseChain) && !F(e.chain) && e.chain !== e.common.baseChain) throw new aQ({
            txChain: e.chain,
            baseChain: e.common.baseChain
        })
    },
    cre = e => {
        if (!F(e.common) && !F(e.common.hardfork) && !F(e.hardfork) && e.hardfork !== e.common.hardfork) throw new sQ({
            txHardfork: e.hardfork,
            commonHardfork: e.common.hardfork
        })
    },
    lk = e => {
        if (F(e.gas) || !no(e.gas) || F(e.gasPrice) || !no(e.gasPrice)) throw new pQ({
            gas: e.gas,
            gasPrice: e.gasPrice
        });
        if (!F(e.maxFeePerGas) || !F(e.maxPriorityFeePerGas)) throw new k3({
            maxFeePerGas: e.maxFeePerGas,
            maxPriorityFeePerGas: e.maxPriorityFeePerGas
        })
    },
    ck = e => {
        if (!F(e.gasPrice) && e.type === "0x2") throw new gQ(e.gasPrice);
        if (e.type === "0x0" || e.type === "0x1") throw new k3({
            maxFeePerGas: e.maxFeePerGas,
            maxPriorityFeePerGas: e.maxPriorityFeePerGas
        });
        if (F(e.maxFeePerGas) || !no(e.maxFeePerGas) || F(e.maxPriorityFeePerGas) || !no(e.maxPriorityFeePerGas)) throw new mQ({
            maxPriorityFeePerGas: e.maxPriorityFeePerGas,
            maxFeePerGas: e.maxFeePerGas
        })
    },
    fre = e => {
        const t = !F(e.gas) || !F(e.gasLimit),
            n = t && !F(e.gasPrice),
            r = t && !F(e.maxPriorityFeePerGas) && !F(e.maxFeePerGas);
        if (!n && !r) throw new fQ({
            gas: e.gas,
            gasPrice: e.gasPrice,
            maxPriorityFeePerGas: e.maxPriorityFeePerGas,
            maxFeePerGas: e.maxFeePerGas
        });
        if (n && r) throw new hQ({
            gas: e.gas,
            gasPrice: e.gasPrice,
            maxPriorityFeePerGas: e.maxPriorityFeePerGas,
            maxFeePerGas: e.maxFeePerGas
        });
        (n ? lk : ck)(e), (!F(e.type) && e.type > "0x1" ? ck : lk)(e)
    },
    dre = (e, t, n = {
        transactionSchema: void 0
    }) => {
        if (!F(t)) {
            t(e);
            return
        }
        if (typeof e != "object" || F(e)) throw new yQ(e);
        sre(e), ure(e), lre(e), cre(e);
        const r = Nn(e, pe, {
            transactionSchema: n.transactionSchema
        });
        if (fre(r), F(r.nonce) || F(r.chainId) || r.nonce.startsWith("-") || r.chainId.startsWith("-")) throw new vQ({
            nonce: e.nonce,
            chainId: e.chainId
        })
    };
var hre = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
const pre = e => {
        var t, n;
        return Object.assign(Object.assign({}, e), {
            nonce: e.nonce,
            gasPrice: e.gasPrice,
            gasLimit: (t = e.gasLimit) !== null && t !== void 0 ? t : e.gas,
            to: e.to,
            value: e.value,
            data: (n = e.data) !== null && n !== void 0 ? n : e.input,
            type: e.type,
            chainId: e.chainId,
            accessList: e.accessList,
            maxPriorityFeePerGas: e.maxPriorityFeePerGas,
            maxFeePerGas: e.maxFeePerGas
        })
    },
    mre = (e, t) => {
        var n, r, i, o, a, s, u, l, c, f, d, h, m, p, y, g, b, v;
        const A = !F(e.chain) && !F(e.hardfork) || !F(e.common);
        let w;
        if (!A) t.defaultCommon ? (w = Object.assign({}, t.defaultCommon), F(w.hardfork) && (w.hardfork = (n = e.hardfork) !== null && n !== void 0 ? n : t.defaultHardfork), F(w.baseChain) && (w.baseChain = t.defaultChain)) : w = Ct.custom({
            name: "custom-network",
            chainId: On(e.chainId),
            networkId: F(e.networkId) ? void 0 : On(e.networkId),
            defaultHardfork: (r = e.hardfork) !== null && r !== void 0 ? r : t.defaultHardfork
        }, {
            baseChain: t.defaultChain
        });
        else {
            const x = (s = (a = (o = (i = e == null ? void 0 : e.common) === null || i === void 0 ? void 0 : i.customChain) === null || o === void 0 ? void 0 : o.name) !== null && a !== void 0 ? a : e.chain) !== null && s !== void 0 ? s : "custom-network",
                T = On((c = (l = (u = e == null ? void 0 : e.common) === null || u === void 0 ? void 0 : u.customChain) === null || l === void 0 ? void 0 : l.chainId) !== null && c !== void 0 ? c : e == null ? void 0 : e.chainId),
                _ = On((h = (d = (f = e == null ? void 0 : e.common) === null || f === void 0 ? void 0 : f.customChain) === null || d === void 0 ? void 0 : d.networkId) !== null && h !== void 0 ? h : e == null ? void 0 : e.networkId),
                O = (y = (p = (m = e == null ? void 0 : e.common) === null || m === void 0 ? void 0 : m.hardfork) !== null && p !== void 0 ? p : e == null ? void 0 : e.hardfork) !== null && y !== void 0 ? y : t.defaultHardfork,
                k = (v = (b = (g = e.common) === null || g === void 0 ? void 0 : g.baseChain) !== null && b !== void 0 ? b : e.chain) !== null && v !== void 0 ? v : t.defaultChain;
            T && _ && x && (w = Ct.custom({
                name: x,
                chainId: T,
                networkId: _,
                defaultHardfork: O
            }, {
                baseChain: k
            }))
        }
        return {
            common: w
        }
    },
    gre = (e, t, n, ...r) => hre(void 0, [e, t, n, ...r], void 0, function*(i, o, a, s = !1, u = !0) {
        const l = yield zte({
            transaction: i,
            web3Context: o,
            privateKey: a,
            fillGasPrice: s,
            fillGasLimit: u
        }), c = Nn(l, pe, {
            transactionSchema: o.config.customTransactionSchema
        });
        return dre(c, void 0, {
            transactionSchema: o.config.customTransactionSchema
        }), Ps.fromTxData(pre(c), mre(c, o))
    }),
    fk = ({
        address: e
    }, t, n) => {
        var r, i;
        const o = n == null ? void 0 : n.topics,
            a = (r = n == null ? void 0 : n.filter) !== null && r !== void 0 ? r : {},
            s = {};
        if (le(n == null ? void 0 : n.fromBlock) || (s.fromBlock = W(gg.properties.number, n == null ? void 0 : n.fromBlock, {
                number: ur.HEX,
                bytes: eo.HEX
            })), le(n == null ? void 0 : n.toBlock) || (s.toBlock = W(gg.properties.number, n == null ? void 0 : n.toBlock, {
                number: ur.HEX,
                bytes: eo.HEX
            })), o && Array.isArray(o)) s.topics = [...o];
        else if (s.topics = [], t && !t.anonymous && ![cl, "allEvents"].includes(t.name) && s.topics.push((i = t.signature) !== null && i !== void 0 ? i : d_(Wi(t))), ![cl, "allEvents"].includes(t.name) && t.inputs)
            for (const u of t.inputs) {
                if (!u.indexed) continue;
                const l = a[u.name];
                if (!l) {
                    s.topics.push(null);
                    continue
                }
                Array.isArray(l) ? s.topics.push(l.map(c => Jx(u.type, c))) : u.type === "string" ? s.topics.push(il(l)) : s.topics.push(Jx(u.type, l))
            }
        return s.topics.length || delete s.topics, e && (s.address = e.toLowerCase()), s
    },
    df = (e, t, n) => {
        const r = Array.isArray(e.inputs) ? e.inputs.length : 0;
        if (e.inputs && r !== t.length) throw new gn(`The number of arguments is not matching the methods required number. You need to pass ${r} arguments.`);
        let i;
        if (e.inputs ? i = Sv(Array.isArray(e.inputs) ? e.inputs : [], t).replace("0x", "") : i = One(t).replace("0x", ""), Yte(e)) {
            if (!n) throw new gn("The contract has no contract data option set. This is necessary to append the constructor parameters.");
            return n.startsWith("0x") ? `${n}${i}` : `0x${n}${i}`
        }
        return `${dd(e)}${i}`
    };
class oL extends vh {
    constructor(t, n) {
        super(t, n), this.address = t.address, this.topics = t.topics, this.abi = t.abi, this.jsonInterface = t.jsonInterface
    }
    _buildSubscriptionParams() {
        return ["logs", {
            address: this.address,
            topics: this.topics
        }]
    }
    formatSubscriptionResult(t) {
        return g_(this.abi, t, this.jsonInterface, super.returnFormat)
    }
}
Array.from({
    length: 256
}, (e, t) => t.toString(16).padStart(2, "0"));
const Tv = (e, t, n, r) => {
        var i, o;
        const a = {};
        return (!le(e.data) || r === "both") && (a.data = df(t, n, (i = e.data) !== null && i !== void 0 ? i : e.input)), (!le(e.input) || r === "both") && (a.input = df(t, n, (o = e.input) !== null && o !== void 0 ? o : e.data)), le(a.input) && le(a.data) && (a[r] = df(t, n)), {
            data: a.data,
            input: a.input
        }
    },
    n1 = ({
        abi: e,
        params: t,
        options: n,
        contractOptions: r
    }) => {
        var i, o, a;
        if (!((a = (o = (i = n == null ? void 0 : n.input) !== null && i !== void 0 ? i : n == null ? void 0 : n.data) !== null && o !== void 0 ? o : r.input) !== null && a !== void 0 ? a : r.data) && !(n != null && n.to) && !r.address) throw new gn("Contract address not specified");
        if (!(n != null && n.from) && !r.from) throw new gn('Contract "from" address not specified');
        let u = ga({
            to: r.address,
            gas: r.gas,
            gasPrice: r.gasPrice,
            from: r.from,
            input: r.input,
            maxPriorityFeePerGas: r.maxPriorityFeePerGas,
            maxFeePerGas: r.maxFeePerGas,
            data: r.data
        }, n);
        const l = Tv(u, e, t, n == null ? void 0 : n.dataInputFill);
        return u = Object.assign(Object.assign({}, u), {
            data: l.data,
            input: l.input
        }), u
    },
    yre = ({
        abi: e,
        params: t,
        options: n,
        contractOptions: r
    }) => {
        if (!(n != null && n.to) && !r.address) throw new gn("Contract address not specified");
        let i = ga({
            to: r.address,
            gas: r.gas,
            gasPrice: r.gasPrice,
            from: r.from,
            input: r.input,
            maxPriorityFeePerGas: r.maxPriorityFeePerGas,
            maxFeePerGas: r.maxFeePerGas,
            data: r.data
        }, n);
        const o = Tv(i, e, t, n == null ? void 0 : n.dataInputFill);
        return i = Object.assign(Object.assign({}, i), {
            data: o.data,
            input: o.input
        }), i
    },
    vre = ({
        abi: e,
        params: t,
        options: n,
        contractOptions: r
    }) => {
        let i = ga({
            to: r.address,
            gas: r.gas,
            gasPrice: r.gasPrice,
            from: r.from,
            input: r.input,
            data: r.data
        }, n);
        const o = Tv(i, e, t, n == null ? void 0 : n.dataInputFill);
        return i = Object.assign(Object.assign({}, i), {
            data: o.data,
            input: o.input
        }), i
    },
    dk = e => typeof e == "object" && !le(e) && Object.keys(e).length !== 0 && !$o(e),
    bre = ({
        abi: e,
        params: t,
        options: n,
        contractOptions: r
    }) => {
        if (!(n != null && n.to) && !r.address) throw new gn("Contract address not specified");
        if (!(n != null && n.from) && !r.from) throw new gn('Contract "from" address not specified');
        let i = ga({
            to: r.address,
            gas: r.gas,
            gasPrice: r.gasPrice,
            from: r.from,
            input: r.input,
            maxPriorityFeePerGas: r.maxPriorityFeePerGas,
            maxFeePerGas: r.maxFeePerGas,
            data: r.data
        }, n);
        const o = Tv(i, e, t, n == null ? void 0 : n.dataInputFill);
        return i = Object.assign(Object.assign({}, i), {
            data: o.data,
            input: o.input
        }), i
    };
var wre = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
class xre {
    _contractMethodDeploySend(t) {
        const n = {
            transactionResolver: r => {
                if (r.status === BigInt(0)) throw new gn("code couldn't be stored", r);
                const i = this.parent.clone();
                return i.options.address = r.contractAddress, i
            },
            contractAbi: this.parent.options.jsonInterface,
            checkRevertBeforeSending: !1
        };
        return F(this.parent.getTransactionMiddleware()) ? hd(this.parent, t, this.parent.defaultReturnFormat, n) : hd(this.parent, t, this.parent.defaultReturnFormat, n, this.parent.getTransactionMiddleware())
    }
    constructor(t, n) {
        this.parent = t, this.deployOptions = n;
        const {
            args: r,
            abi: i,
            contractOptions: o,
            deployData: a
        } = this.calculateDeployParams();
        this.args = r, this.constructorAbi = i, this.contractOptions = o, this.deployData = a
    }
    send(t) {
        const n = Object.assign({}, t),
            r = this.populateTransaction(n);
        return this._contractMethodDeploySend(r)
    }
    populateTransaction(t) {
        var n, r;
        const i = Object.assign(Object.assign({}, this.contractOptions), {
                from: (r = (n = this.contractOptions.from) !== null && n !== void 0 ? n : this.parent.defaultAccount) !== null && r !== void 0 ? r : void 0
            }),
            o = n1({
                abi: this.constructorAbi,
                params: this.args,
                options: Object.assign(Object.assign({}, t), {
                    dataInputFill: this.parent.contractDataInputFill
                }),
                contractOptions: i
            });
        return o.dataInputFill && delete o.dataInputFill, o
    }
    calculateDeployParams() {
        var t, n, r, i, o, a;
        let s = this.parent.options.jsonInterface.find(h => h.type === "constructor");
        s || (s = {
            type: "constructor",
            stateMutability: ""
        });
        const u = W({
                format: "bytes"
            }, (n = (t = this.deployOptions) === null || t === void 0 ? void 0 : t.input) !== null && n !== void 0 ? n : this.parent.options.input, mn),
            l = W({
                format: "bytes"
            }, (i = (r = this.deployOptions) === null || r === void 0 ? void 0 : r.data) !== null && i !== void 0 ? i : this.parent.options.data, mn);
        if ((!u || u.trim() === "0x") && (!l || l.trim() === "0x")) throw new gn("contract creation without any data provided.");
        const c = (a = (o = this.deployOptions) === null || o === void 0 ? void 0 : o.arguments) !== null && a !== void 0 ? a : [],
            f = Object.assign(Object.assign({}, this.parent.options), {
                input: u,
                data: l
            });
        return {
            args: c,
            abi: s,
            contractOptions: f,
            deployData: u ? ? l
        }
    }
    estimateGas(t) {
        return wre(this, arguments, void 0, function*(n, r = this.parent.defaultReturnFormat) {
            const i = Object.assign({}, n);
            return this.parent.contractMethodEstimateGas({
                abi: this.constructorAbi,
                params: this.args,
                returnFormat: r,
                options: i,
                contractOptions: this.contractOptions
            })
        })
    }
    encodeABI() {
        return df(this.constructorAbi, this.args, W({
            format: "bytes"
        }, this.deployData, this.parent.defaultReturnFormat))
    }
    decodeData(t) {
        return Object.assign(Object.assign({}, e1(this.constructorAbi, t.replace(this.deployData, ""), !1)), {
            __method__: this.constructorAbi.type
        })
    }
}
var Are = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
class Ere extends fg {
    constructor(t, n) {
        super(t.requestManager, t.registeredSubscriptions), this.parentContract = n
    }
    subscribe(t, n) {
        const r = Object.create(null, {
            subscribe: {
                get: () => super.subscribe
            }
        });
        return Are(this, arguments, void 0, function*(i, o, a = mn) {
            return r.subscribe.call(this, i, o ? ? this.parentContract.options, a)
        })
    }
}
var _a = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
const Sre = {
    logs: oL,
    newHeads: wg,
    newBlockHeaders: wg
};
class ss extends lr {
    get subscriptionManager() {
        return this._subscriptionManager
    }
    constructor(t, n, r, i, o) {
        var a, s, u;
        const l = $o(n) ? n : $o(r) ? r : void 0;
        let c;
        dk(n) ? c = n : dk(r) ? c = r : c = i;
        let f;
        if (typeof n == "object" && "provider" in n ? f = n.provider : typeof r == "object" && "provider" in r ? f = r.provider : typeof i == "object" && "provider" in i ? f = i.provider : f = ss.givenProvider, super(Object.assign(Object.assign({}, c), {
                provider: f,
                registeredSubscriptions: Sre
            })), this.syncWithContext = !1, this._functions = {}, this._subscriptionManager = new Ere(super.subscriptionManager, this), c != null && c.wallet && (this._wallet = c.wallet), c != null && c.accountProvider && (this._accountProvider = c.accountProvider), !F(l) && !F(l.data) && !F(l.input) && this.config.contractDataInputFill !== "both") throw new qK({
            data: l.data,
            input: l.input
        });
        this._overloadedMethodAbis = new Map;
        const d = Ii(i) ? i : Ii(r) ? r : o ? ? this.defaultReturnFormat,
            h = typeof n == "string" ? n : void 0;
        this.config.contractDataInputFill = (a = l == null ? void 0 : l.dataInputFill) !== null && a !== void 0 ? a : this.config.contractDataInputFill, this._parseAndSetJsonInterface(t, d), this.defaultReturnFormat !== d && (this.defaultReturnFormat = d), F(h) || this._parseAndSetAddress(h, d), this.options = {
            address: h,
            jsonInterface: this._jsonInterface,
            gas: (s = l == null ? void 0 : l.gas) !== null && s !== void 0 ? s : l == null ? void 0 : l.gasLimit,
            gasPrice: l == null ? void 0 : l.gasPrice,
            from: l == null ? void 0 : l.from,
            input: l == null ? void 0 : l.input,
            data: l == null ? void 0 : l.data
        }, this.syncWithContext = (u = l == null ? void 0 : l.syncWithContext) !== null && u !== void 0 ? u : !1, c instanceof lr && this.subscribeToContextEvents(c), Object.defineProperty(this.options, "address", {
            set: m => this._parseAndSetAddress(m, d),
            get: () => this._address
        }), Object.defineProperty(this.options, "jsonInterface", {
            set: m => this._parseAndSetJsonInterface(m, d),
            get: () => this._jsonInterface
        }), c instanceof lr && c.on(_s.CONFIG_CHANGE, m => {
            this.setConfig({
                [m.name]: m.newValue
            })
        })
    }
    setTransactionMiddleware(t) {
        this.transactionMiddleware = t
    }
    getTransactionMiddleware() {
        return this.transactionMiddleware
    }
    get events() {
        return this._events
    }
    get methods() {
        return this._methods
    }
    clone() {
        let t;
        return this.options.address ? t = new ss([...this._jsonInterface, ...this._errorsInterface], this.options.address, {
            gas: this.options.gas,
            gasPrice: this.options.gasPrice,
            from: this.options.from,
            input: this.options.input,
            data: this.options.data,
            provider: this.currentProvider,
            syncWithContext: this.syncWithContext,
            dataInputFill: this.config.contractDataInputFill
        }, this.getContextObject()) : t = new ss([...this._jsonInterface, ...this._errorsInterface], {
            gas: this.options.gas,
            gasPrice: this.options.gasPrice,
            from: this.options.from,
            input: this.options.input,
            data: this.options.data,
            provider: this.currentProvider,
            syncWithContext: this.syncWithContext,
            dataInputFill: this.config.contractDataInputFill
        }, this.getContextObject()), this.context && t.subscribeToContextEvents(this.context), t
    }
    deploy(t) {
        return new xre(this, t)
    }
    getPastEvents(t, n, r) {
        return _a(this, void 0, void 0, function*() {
            var i;
            const o = typeof t == "string" ? t : cl,
                a = typeof t != "string" && !Ii(t) ? t : Ii(n) ? {} : n,
                s = Ii(t) ? t : Ii(n) ? n : r ? ? this.defaultReturnFormat,
                u = o === "allEvents" || o === cl ? Gx : this._jsonInterface.find(g => "name" in g && g.name === o);
            if (!u) throw new gn(`Event ${String(o)} not found.`);
            const {
                fromBlock: l,
                toBlock: c,
                topics: f,
                address: d
            } = fk(this.options, u, a ? ? {}), h = yield eL(this, {
                fromBlock: l,
                toBlock: c,
                topics: f,
                address: d
            }, s), m = h ? h.map(g => typeof g == "string" ? g : g_(u, g, this._jsonInterface, s)) : [], p = (i = a == null ? void 0 : a.filter) !== null && i !== void 0 ? i : {}, y = Object.keys(p);
            return y.length > 0 ? m.filter(g => typeof g == "string" ? !0 : y.every(b => {
                var v;
                if (Array.isArray(p[b])) return p[b].some(w => String(g.returnValues[b]).toUpperCase() === String(w).toUpperCase());
                const A = (v = u.inputs) === null || v === void 0 ? void 0 : v.filter(w => w.name === b)[0];
                return A != null && A.indexed && A.type === "string" && il(p[b]) === String(g.returnValues[b]) ? !0 : String(g.returnValues[b]).toUpperCase() === String(p[b]).toUpperCase()
            })) : m
        })
    }
    _parseAndSetAddress(t, n = this.defaultReturnFormat) {
        this._address = t && vi(W({
            format: "address"
        }, t, n))
    }
    decodeMethodData(t) {
        const n = t.slice(0, 10),
            i = this._jsonInterface.filter(o => o.type !== "error").find(o => n === dd(Wi(o)));
        if (!i) throw new gn(`The ABI for the provided method signature ${n} was not found.`);
        return e1(i, t)
    }
    _parseAndSetJsonInterface(t, n = this.defaultReturnFormat) {
        var r, i;
        this._functions = {}, this._methods = {}, this._events = {};
        let o = [];
        const a = t.filter(u => u.type !== "error"),
            s = t.filter(u => Av(u));
        for (const u of a) {
            const l = Object.assign(Object.assign({}, u), {
                signature: ""
            });
            if (Ev(l)) {
                const c = Wi(l),
                    f = dd(c);
                l.methodNameWithInputs = c, l.signature = f, l.constant = l.stateMutability === "view" || l.stateMutability === "pure" || l.constant, l.payable = l.stateMutability === "payable" || l.payable, this._overloadedMethodAbis.set(l.name, [...(r = this._overloadedMethodAbis.get(l.name)) !== null && r !== void 0 ? r : [], l]);
                const d = (i = this._overloadedMethodAbis.get(l.name)) !== null && i !== void 0 ? i : [],
                    h = this._createContractMethod(d, s),
                    m = this._createContractMethod(d, s, !0);
                this._functions[c] = {
                    signature: f,
                    method: m
                }, this._methods[l.name] = h, this._methods[c] = m, this._methods[f] = m
            } else if (f_(l)) {
                const c = Wi(l),
                    f = d_(c),
                    d = this._createContractEvent(l, n);
                l.signature = f, (!(c in this._events) || l.name === "bound") && (this._events[c] = d), this._events[l.name] = d, this._events[f] = d
            }
            o = [...o, l]
        }
        this._events.allEvents = this._createContractEvent(Gx, n), this._jsonInterface = [...o], this._errorsInterface = s
    }
    _getAbiParams(t, n) {
        var r;
        try {
            return ff((r = t.inputs) !== null && r !== void 0 ? r : [], n)
        } catch (i) {
            throw new gn(`Invalid parameters for method ${t.name}: ${i.message}`)
        }
    }
    _createContractMethod(t, n, r = !1) {
        const i = t[t.length - 1];
        return (...o) => {
            var a, s, u;
            let l;
            const c = (s = r ? (a = this._overloadedMethodAbis.get(i.name)) === null || a === void 0 ? void 0 : a.filter(p => p.signature === i.signature) : this._overloadedMethodAbis.get(i.name)) !== null && s !== void 0 ? s : [];
            let f = c[0];
            const d = n,
                h = c.filter(p => {
                    var y;
                    return ((y = p.inputs) !== null && y !== void 0 ? y : []).length === o.length
                });
            if (c.length === 1 || h.length === 0) l = this._getAbiParams(f, o), oe.validate((u = i.inputs) !== null && u !== void 0 ? u : [], l);
            else {
                const p = [],
                    y = [];
                for (const g of h) try {
                    l = this._getAbiParams(g, o), oe.validate(g.inputs, l), y.push(g)
                } catch (b) {
                    p.push(b)
                }
                if (y.length === 1 ? [f] = y : y.length > 1 && ([f] = y, console.warn(`Multiple methods found that is compatible with the given inputs.
	Found ${y.length} compatible methods: ${JSON.stringify(y.map(g=>`${g.methodNameWithInputs} (signature: ${g.signature})`))} 
	The first one will be used: ${f.methodNameWithInputs}`)), p.length === h.length) throw new tl(p)
            }
            const m = {
                arguments: l,
                call: (p, y) => _a(this, void 0, void 0, function*() {
                    return this._contractMethodCall(f, l, d, p, y)
                }),
                send: p => this._contractMethodSend(f, l, d, p),
                populateTransaction: (p, y) => {
                    var g, b;
                    let v = y ? ? this.options;
                    v = Object.assign(Object.assign({}, v), {
                        input: void 0,
                        from: (b = (g = v == null ? void 0 : v.from) !== null && g !== void 0 ? g : this.defaultAccount) !== null && b !== void 0 ? b : void 0
                    });
                    const A = n1({
                        abi: i,
                        params: o,
                        options: Object.assign(Object.assign({}, p), {
                            dataInputFill: this.config.contractDataInputFill
                        }),
                        contractOptions: v
                    });
                    return A.dataInputFill && delete A.dataInputFill, A
                },
                estimateGas: (p, ...y) => _a(this, [p, ...y], void 0, function*(g, b = this.defaultReturnFormat) {
                    return this.contractMethodEstimateGas({
                        abi: f,
                        params: l,
                        returnFormat: b,
                        options: g
                    })
                }),
                encodeABI: () => df(f, l),
                decodeData: p => e1(f, p),
                createAccessList: (p, y) => _a(this, void 0, void 0, function*() {
                    return this._contractMethodCreateAccessList(f, l, d, p, y)
                })
            };
            return f.stateMutability === "payable", m
        }
    }
    _contractMethodCall(t, n, r, i, o) {
        return _a(this, void 0, void 0, function*() {
            var a;
            const s = yre({
                abi: t,
                params: n,
                options: Object.assign(Object.assign({}, i), {
                    dataInputFill: this.config.contractDataInputFill
                }),
                contractOptions: Object.assign(Object.assign({}, this.options), {
                    from: (a = this.options.from) !== null && a !== void 0 ? a : this.config.defaultAccount
                })
            });
            try {
                const u = yield b_(this, s, o, this.defaultReturnFormat);
                return Cne(t, u)
            } catch (u) {
                throw u instanceof ns && Xp(r, u.cause), u
            }
        })
    }
    _contractMethodCreateAccessList(t, n, r, i, o) {
        return _a(this, void 0, void 0, function*() {
            var a;
            const s = bre({
                abi: t,
                params: n,
                options: Object.assign(Object.assign({}, i), {
                    dataInputFill: this.config.contractDataInputFill
                }),
                contractOptions: Object.assign(Object.assign({}, this.options), {
                    from: (a = this.options.from) !== null && a !== void 0 ? a : this.config.defaultAccount
                })
            });
            try {
                return nL(this, s, o, this.defaultReturnFormat)
            } catch (u) {
                throw u instanceof ns && Xp(r, u.cause), u
            }
        })
    }
    _contractMethodSend(t, n, r, i, o) {
        var a, s;
        let u = o ? ? this.options;
        u = Object.assign(Object.assign({}, u), {
            input: void 0,
            from: (s = (a = u.from) !== null && a !== void 0 ? a : this.defaultAccount) !== null && s !== void 0 ? s : void 0
        });
        const l = n1({
                abi: t,
                params: n,
                options: Object.assign(Object.assign({}, i), {
                    dataInputFill: this.config.contractDataInputFill
                }),
                contractOptions: u
            }),
            c = F(this.transactionMiddleware) ? hd(this, l, this.defaultReturnFormat, {
                checkRevertBeforeSending: !1,
                contractAbi: this._jsonInterface
            }) : hd(this, l, this.defaultReturnFormat, {
                checkRevertBeforeSending: !1,
                contractAbi: this._jsonInterface
            }, this.transactionMiddleware);
        return c.on("error", f => {
            f instanceof ns && Xp(r, f.cause)
        }), c
    }
    contractMethodEstimateGas(t) {
        return _a(this, arguments, void 0, function*({
            abi: n,
            params: r,
            returnFormat: i,
            options: o,
            contractOptions: a
        }) {
            const s = vre({
                abi: n,
                params: r,
                options: Object.assign(Object.assign({}, o), {
                    dataInputFill: this.config.contractDataInputFill
                }),
                contractOptions: a ? ? this.options
            });
            return w_(this, s, Mi.LATEST, i ? ? this.defaultReturnFormat)
        })
    }
    _createContractEvent(t, n = this.defaultReturnFormat) {
        return (...r) => {
            var i;
            const {
                topics: o,
                fromBlock: a
            } = fk(this.options, t, r[0]), s = new oL({
                address: this.options.address,
                topics: o,
                abi: t,
                jsonInterface: this._jsonInterface
            }, {
                subscriptionManager: this.subscriptionManager,
                returnFormat: n
            });
            return F(a) || this.getPastEvents(t.name, {
                fromBlock: a,
                topics: o
            }, n).then(u => {
                u && u.forEach(l => s.emit("data", l))
            }).catch(u => {
                s.emit("error", new ki("Failed to get past events.", u))
            }), (i = this.subscriptionManager) === null || i === void 0 || i.addSubscription(s).catch(u => {
                s.emit("error", new ki("Failed to subscribe.", u))
            }), s
        }
    }
    subscribeToContextEvents(t) {
        const n = this;
        this.context = t, n.syncWithContext && t.on(_s.CONFIG_CHANGE, r => {
            n.setConfig({
                [r.name]: r.newValue
            })
        })
    }
}
const hk = {
        addr: "0x3b3b57de",
        name: "0x691f3431",
        abi: "0x2203ab56",
        pubkey: "0xc8690233",
        text: "0x59d1d43c",
        contenthash: "0xbc1c58d1"
    },
    Ks = {
        setAddr: "addr",
        addr: "addr",
        pubkey: "pubkey",
        contenthash: "contenthash",
        text: "text",
        name: "name"
    },
    xg = {
        main: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        goerli: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    _re = {
        "0x1": "main",
        "0x5": "goerli"
    },
    Tre = [{
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            indexed: !0,
            internalType: "bytes32",
            name: "label",
            type: "bytes32"
        }, {
            indexed: !1,
            internalType: "address",
            name: "owner",
            type: "address"
        }],
        name: "NewOwner",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            indexed: !1,
            internalType: "address",
            name: "resolver",
            type: "address"
        }],
        name: "NewResolver",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            indexed: !1,
            internalType: "address",
            name: "owner",
            type: "address"
        }],
        name: "Transfer",
        type: "event"
    }, {
        inputs: [{
            internalType: "address",
            name: "owner",
            type: "address"
        }, {
            internalType: "address",
            name: "operator",
            type: "address"
        }],
        name: "isApprovedForAll",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }],
        name: "owner",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }],
        name: "recordExists",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }],
        name: "resolver",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }],
        name: "ttl",
        outputs: [{
            internalType: "uint64",
            name: "",
            type: "uint64"
        }],
        stateMutability: "view",
        type: "function"
    }],
    Pre = [{
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            indexed: !1,
            internalType: "address",
            name: "a",
            type: "address"
        }],
        name: "AddrChanged",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "coinType",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "bytes",
            name: "newAddress",
            type: "bytes"
        }],
        name: "AddressChanged",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "operator",
            type: "address"
        }, {
            indexed: !1,
            internalType: "bool",
            name: "approved",
            type: "bool"
        }],
        name: "ApprovalForAll",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            indexed: !1,
            internalType: "bytes",
            name: "hash",
            type: "bytes"
        }],
        name: "ContenthashChanged",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            indexed: !1,
            internalType: "bytes",
            name: "name",
            type: "bytes"
        }, {
            indexed: !1,
            internalType: "uint16",
            name: "resource",
            type: "uint16"
        }, {
            indexed: !1,
            internalType: "bytes",
            name: "record",
            type: "bytes"
        }],
        name: "DNSRecordChanged",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            indexed: !1,
            internalType: "bytes",
            name: "name",
            type: "bytes"
        }, {
            indexed: !1,
            internalType: "uint16",
            name: "resource",
            type: "uint16"
        }],
        name: "DNSRecordDeleted",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }],
        name: "DNSZoneCleared",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            indexed: !1,
            internalType: "bytes",
            name: "lastzonehash",
            type: "bytes"
        }, {
            indexed: !1,
            internalType: "bytes",
            name: "zonehash",
            type: "bytes"
        }],
        name: "DNSZonehashChanged",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            indexed: !0,
            internalType: "bytes4",
            name: "interfaceID",
            type: "bytes4"
        }, {
            indexed: !1,
            internalType: "address",
            name: "implementer",
            type: "address"
        }],
        name: "InterfaceChanged",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            indexed: !1,
            internalType: "string",
            name: "name",
            type: "string"
        }],
        name: "NameChanged",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            indexed: !1,
            internalType: "bytes32",
            name: "x",
            type: "bytes32"
        }, {
            indexed: !1,
            internalType: "bytes32",
            name: "y",
            type: "bytes32"
        }],
        name: "PubkeyChanged",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            indexed: !0,
            internalType: "string",
            name: "indexedKey",
            type: "string"
        }, {
            indexed: !1,
            internalType: "string",
            name: "key",
            type: "string"
        }],
        name: "TextChanged",
        type: "event"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            internalType: "uint256",
            name: "contentTypes",
            type: "uint256"
        }],
        name: "ABI",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }, {
            internalType: "bytes",
            name: "",
            type: "bytes"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }],
        name: "addr",
        outputs: [{
            internalType: "address payable",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            internalType: "uint256",
            name: "coinType",
            type: "uint256"
        }],
        name: "addr",
        outputs: [{
            internalType: "bytes",
            name: "",
            type: "bytes"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }],
        name: "contenthash",
        outputs: [{
            internalType: "bytes",
            name: "",
            type: "bytes"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            internalType: "bytes32",
            name: "name",
            type: "bytes32"
        }, {
            internalType: "uint16",
            name: "resource",
            type: "uint16"
        }],
        name: "dnsRecord",
        outputs: [{
            internalType: "bytes",
            name: "",
            type: "bytes"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            internalType: "bytes32",
            name: "name",
            type: "bytes32"
        }],
        name: "hasDNSRecords",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            internalType: "bytes4",
            name: "interfaceID",
            type: "bytes4"
        }],
        name: "interfaceImplementer",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "account",
            type: "address"
        }, {
            internalType: "address",
            name: "operator",
            type: "address"
        }],
        name: "isApprovedForAll",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }],
        name: "name",
        outputs: [{
            internalType: "string",
            name: "",
            type: "string"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }],
        name: "pubkey",
        outputs: [{
            internalType: "bytes32",
            name: "x",
            type: "bytes32"
        }, {
            internalType: "bytes32",
            name: "y",
            type: "bytes32"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes4",
            name: "interfaceID",
            type: "bytes4"
        }],
        name: "supportsInterface",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            internalType: "string",
            name: "key",
            type: "string"
        }],
        name: "text",
        outputs: [{
            internalType: "string",
            name: "",
            type: "string"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }],
        name: "zonehash",
        outputs: [{
            internalType: "bytes",
            name: "",
            type: "bytes"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "node",
            type: "bytes32"
        }, {
            internalType: "address",
            name: "a",
            type: "address"
        }],
        name: "setAddr",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }];
var Ore = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
const pk = new Map([
        [8217, "apostrophe"],
        [8260, "fraction slash"],
        [12539, "middle dot"]
    ]),
    mk = 4;

function kre(e) {
    let t = 0;

    function n() {
        return e[t++] << 8 | e[t++]
    }
    let r = n(),
        i = 1,
        o = [0, 1];
    for (let w = 1; w < r; w++) o.push(i += n());
    let a = n(),
        s = t;
    t += a;
    let u = 0,
        l = 0;

    function c() {
        return u == 0 && (l = l << 8 | e[t++], u = 8), l >> --u & 1
    }
    const f = 31,
        d = 2 ** f,
        h = d >>> 1,
        m = h >> 1,
        p = d - 1;
    let y = 0;
    for (let w = 0; w < f; w++) y = y << 1 | c();
    let g = [],
        b = 0,
        v = d;
    for (;;) {
        let w = Math.floor(((y - b + 1) * i - 1) / v),
            x = 0,
            T = r;
        for (; T - x > 1;) {
            let k = x + T >>> 1;
            w < o[k] ? T = k : x = k
        }
        if (x == 0) break;
        g.push(x);
        let _ = b + Math.floor(v * o[x] / i),
            O = b + Math.floor(v * o[x + 1] / i) - 1;
        for (; !((_ ^ O) & h);) y = y << 1 & p | c(), _ = _ << 1 & p, O = O << 1 & p | 1;
        for (; _ & ~O & m;) y = y & h | y << 1 & p >>> 1 | c(), _ = _ << 1 ^ h, O = (O ^ h) << 1 | h | 1;
        b = _, v = 1 + O - _
    }
    let A = r - 4;
    return g.map(w => {
        switch (w - A) {
            case 3:
                return A + 65792 + (e[s++] << 16 | e[s++] << 8 | e[s++]);
            case 2:
                return A + 256 + (e[s++] << 8 | e[s++]);
            case 1:
                return A + e[s++];
            default:
                return w - 1
        }
    })
}

function Cre(e) {
    let t = 0;
    return () => e[t++]
}

function aL(e) {
    return Cre(kre(Ire(e)))
}

function Ire(e) {
    let t = [];
    [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((i, o) => t[i.charCodeAt(0)] = o);
    let n = e.length,
        r = new Uint8Array(6 * n >> 3);
    for (let i = 0, o = 0, a = 0, s = 0; i < n; i++) s = s << 6 | t[e.charCodeAt(i)], a += 6, a >= 8 && (r[o++] = s >> (a -= 8));
    return r
}

function Mre(e) {
    return e & 1 ? ~e >> 1 : e >> 1
}

function Nre(e, t) {
    let n = Array(e);
    for (let r = 0, i = 0; r < e; r++) n[r] = i += Mre(t());
    return n
}

function pd(e, t = 0) {
    let n = [];
    for (;;) {
        let r = e(),
            i = e();
        if (!i) break;
        t += r;
        for (let o = 0; o < i; o++) n.push(t + o);
        t += i + 1
    }
    return n
}

function sL(e) {
    return md(() => {
        let t = pd(e);
        if (t.length) return t
    })
}

function uL(e) {
    let t = [];
    for (;;) {
        let n = e();
        if (n == 0) break;
        t.push(Rre(n, e))
    }
    for (;;) {
        let n = e() - 1;
        if (n < 0) break;
        t.push(jre(n, e))
    }
    return t.flat()
}

function md(e) {
    let t = [];
    for (;;) {
        let n = e(t.length);
        if (!n) break;
        t.push(n)
    }
    return t
}

function lL(e, t, n) {
    let r = Array(e).fill().map(() => []);
    for (let i = 0; i < t; i++) Nre(e, n).forEach((o, a) => r[a].push(o));
    return r
}

function Rre(e, t) {
    let n = 1 + t(),
        r = t(),
        i = md(t);
    return lL(i.length, 1 + e, t).flatMap((a, s) => {
        let [u, ...l] = a;
        return Array(i[s]).fill().map((c, f) => {
            let d = f * r;
            return [u + f * n, l.map(h => h + d)]
        })
    })
}

function jre(e, t) {
    let n = 1 + t();
    return lL(n, 1 + e, t).map(i => [i[0], i.slice(1)])
}

function Bre(e) {
    let t = [],
        n = pd(e);
    return i(r([]), []), t;

    function r(o) {
        let a = e(),
            s = md(() => {
                let u = pd(e).map(l => n[l]);
                if (u.length) return r(u)
            });
        return {
            S: a,
            B: s,
            Q: o
        }
    }

    function i({
        S: o,
        B: a
    }, s, u) {
        if (!(o & 4 && u === s[s.length - 1])) {
            o & 2 && (u = s[s.length - 1]), o & 1 && t.push(s);
            for (let l of a)
                for (let c of l.Q) i(l, [...s, c], u)
        }
    }
}

function Dre(e) {
    return e.toString(16).toUpperCase().padStart(2, "0")
}

function cL(e) {
    return `{${Dre(e)}}`
}

function $re(e) {
    let t = [];
    for (let n = 0, r = e.length; n < r;) {
        let i = e.codePointAt(n);
        n += i < 65536 ? 1 : 2, t.push(i)
    }
    return t
}

function dl(e) {
    let n = e.length;
    if (n < 4096) return String.fromCodePoint(...e);
    let r = [];
    for (let i = 0; i < n;) r.push(String.fromCodePoint(...e.slice(i, i += 4096)));
    return r.join("")
}

function Lre(e, t) {
    let n = e.length,
        r = n - t.length;
    for (let i = 0; r == 0 && i < n; i++) r = e[i] - t[i];
    return r
}
var Fre = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
const gd = 44032,
    Ag = 4352,
    Eg = 4449,
    Sg = 4519,
    fL = 19,
    dL = 21,
    hl = 28,
    _g = dL * hl,
    Ure = fL * _g,
    Hre = gd + Ure,
    Vre = Ag + fL,
    zre = Eg + dL,
    Wre = Sg + hl;

function Gc(e) {
    return e >> 24 & 255
}

function hL(e) {
    return e & 16777215
}
let r1, gk, i1, Zp;

function Gre() {
    let e = aL(Fre);
    r1 = new Map(sL(e).flatMap((t, n) => t.map(r => [r, n + 1 << 24]))), gk = new Set(pd(e)), i1 = new Map, Zp = new Map;
    for (let [t, n] of uL(e)) {
        if (!gk.has(t) && n.length == 2) {
            let [r, i] = n, o = Zp.get(r);
            o || (o = new Map, Zp.set(r, o)), o.set(i, t)
        }
        i1.set(t, n.reverse())
    }
}

function pL(e) {
    return e >= gd && e < Hre
}

function qre(e, t) {
    if (e >= Ag && e < Vre && t >= Eg && t < zre) return gd + (e - Ag) * _g + (t - Eg) * hl;
    if (pL(e) && t > Sg && t < Wre && (e - gd) % hl == 0) return e + (t - Sg); {
        let n = Zp.get(e);
        return n && (n = n.get(t), n) ? n : -1
    }
}

function mL(e) {
    r1 || Gre();
    let t = [],
        n = [],
        r = !1;

    function i(o) {
        let a = r1.get(o);
        a && (r = !0, o |= a), t.push(o)
    }
    for (let o of e)
        for (;;) {
            if (o < 128) t.push(o);
            else if (pL(o)) {
                let a = o - gd,
                    s = a / _g | 0,
                    u = a % _g / hl | 0,
                    l = a % hl;
                i(Ag + s), i(Eg + u), l > 0 && i(Sg + l)
            } else {
                let a = i1.get(o);
                a ? n.push(...a) : i(o)
            }
            if (!n.length) break;
            o = n.pop()
        }
    if (r && t.length > 1) {
        let o = Gc(t[0]);
        for (let a = 1; a < t.length; a++) {
            let s = Gc(t[a]);
            if (s == 0 || o <= s) {
                o = s;
                continue
            }
            let u = a - 1;
            for (;;) {
                let l = t[u + 1];
                if (t[u + 1] = t[u], t[u] = l, !u || (o = Gc(t[--u]), o <= s)) break
            }
            o = Gc(t[a])
        }
    }
    return t
}

function Kre(e) {
    let t = [],
        n = [],
        r = -1,
        i = 0;
    for (let o of e) {
        let a = Gc(o),
            s = hL(o);
        if (r == -1) a == 0 ? r = s : t.push(s);
        else if (i > 0 && i >= a) a == 0 ? (t.push(r, ...n), n.length = 0, r = s) : n.push(s), i = a;
        else {
            let u = qre(r, s);
            u >= 0 ? r = u : i == 0 && a == 0 ? (t.push(r), r = s) : (n.push(s), i = a)
        }
    }
    return r >= 0 && t.push(r, ...n), t
}

function gL(e) {
    return mL(e).map(hL)
}

function Qre(e) {
    return Kre(mL(e))
}
const yk = 45,
    yL = ".",
    vL = 65039,
    bL = 1,
    Eu = e => Array.from(e);

function yd(e, t) {
    return e.P.has(t) || e.Q.has(t)
}
class Yre extends Array {
    get is_emoji() {
        return !0
    }
}
let o1, wL, Ga, a1, xL, Du, Pb, nu, AL, vk, s1;

function x_() {
    if (o1) return;
    let e = aL(Ore);
    const t = () => pd(e),
        n = () => new Set(t());
    o1 = new Map(uL(e)), wL = n(), Ga = t(), a1 = new Set(t().map(c => Ga[c])), Ga = new Set(Ga), xL = n(), n();
    let r = sL(e),
        i = e();
    const o = () => new Set(t().flatMap(c => r[c]).concat(t()));
    Du = md(c => {
        let f = md(e).map(d => d + 96);
        if (f.length) {
            let d = c >= i;
            f[0] -= 32, f = dl(f), d && (f = `Restricted[${f}]`);
            let h = o(),
                m = o(),
                p = !e();
            return {
                N: f,
                P: h,
                Q: m,
                M: p,
                R: d
            }
        }
    }), Pb = n(), nu = new Map;
    let a = t().concat(Eu(Pb)).sort((c, f) => c - f);
    a.forEach((c, f) => {
        let d = e(),
            h = a[f] = d ? a[f - d] : {
                V: [],
                M: new Map
            };
        h.V.push(c), Pb.has(c) || nu.set(c, h)
    });
    for (let {
            V: c,
            M: f
        } of new Set(nu.values())) {
        let d = [];
        for (let m of c) {
            let p = Du.filter(g => yd(g, m)),
                y = d.find(({
                    G: g
                }) => p.some(b => g.has(b)));
            y || (y = {
                G: new Set,
                V: []
            }, d.push(y)), y.V.push(m), p.forEach(g => y.G.add(g))
        }
        let h = d.flatMap(m => Eu(m.G));
        for (let {
                G: m,
                V: p
            } of d) {
            let y = new Set(h.filter(g => !m.has(g)));
            for (let g of p) f.set(g, y)
        }
    }
    let s = new Set,
        u = new Set;
    const l = c => s.has(c) ? u.add(c) : s.add(c);
    for (let c of Du) {
        for (let f of c.P) l(f);
        for (let f of c.Q) l(f)
    }
    for (let c of s) !nu.has(c) && !u.has(c) && nu.set(c, bL);
    AL = new Set(Eu(s).concat(Eu(gL(s)))), vk = Bre(e).map(c => Yre.from(c)).sort(Lre), s1 = new Map;
    for (let c of vk) {
        let f = [s1];
        for (let d of c) {
            let h = f.map(m => {
                let p = m.get(d);
                return p || (p = new Map, m.set(d, p)), p
            });
            d === vL ? f.push(...h) : f = h
        }
        for (let d of f) d.V = c
    }
}

function A_(e) {
    return (EL(e) ? "" : `${E_(Pv([e]))} `) + cL(e)
}

function E_(e) {
    return `"${e}"‎`
}

function Xre(e) {
    if (e.length >= 4 && e[2] == yk && e[3] == yk) throw new Error(`invalid label extension: "${dl(e.slice(0,4))}"`)
}

function Zre(e) {
    for (let n = e.lastIndexOf(95); n > 0;)
        if (e[--n] !== 95) throw new Error("underscore allowed only at start")
}

function Jre(e) {
    let t = e[0],
        n = pk.get(t);
    if (n) throw hf(`leading ${n}`);
    let r = e.length,
        i = -1;
    for (let o = 1; o < r; o++) {
        t = e[o];
        let a = pk.get(t);
        if (a) {
            if (i == o) throw hf(`${n} + ${a}`);
            i = o + 1, n = a
        }
    }
    if (i == r) throw hf(`trailing ${n}`)
}

function Pv(e, t = cL) {
    let n = [];
    eie(e[0]) && n.push("◌");
    let r = 0,
        i = e.length;
    for (let o = 0; o < i; o++) {
        let a = e[o];
        EL(a) && (n.push(dl(e.slice(r, o))), n.push(t(a)), r = o + 1)
    }
    return n.push(dl(e.slice(r, i))), n.join("")
}

function eie(e) {
    return x_(), Ga.has(e)
}

function EL(e) {
    return x_(), xL.has(e)
}

function tie(e) {
    return oie(nie(e, Qre, uie))
}

function nie(e, t, n) {
    if (!e) return [];
    x_();
    let r = 0;
    return e.split(yL).map(i => {
        let o = $re(i),
            a = {
                input: o,
                offset: r
            };
        r += o.length + 1;
        try {
            let s = a.tokens = sie(o, t, n),
                u = s.length,
                l;
            if (!u) throw new Error("empty label");
            let c = a.output = s.flat();
            if (Zre(c), !(a.emoji = u > 1 || s[0].is_emoji) && c.every(d => d < 128)) Xre(c), l = "ASCII";
            else {
                let d = s.flatMap(h => h.is_emoji ? [] : h);
                if (!d.length) l = "Emoji";
                else {
                    if (Ga.has(c[0])) throw hf("leading combining mark");
                    for (let p = 1; p < u; p++) {
                        let y = s[p];
                        if (!y.is_emoji && Ga.has(y[0])) throw hf(`emoji + combining mark: "${dl(s[p-1])} + ${Pv([y[0]])}"`)
                    }
                    Jre(c);
                    let h = Eu(new Set(d)),
                        [m] = iie(h);
                    aie(m, d), rie(m, h), l = m.N
                }
            }
            a.type = l
        } catch (s) {
            a.error = s
        }
        return a
    })
}

function rie(e, t) {
    let n, r = [];
    for (let i of t) {
        let o = nu.get(i);
        if (o === bL) return;
        if (o) {
            let a = o.M.get(i);
            if (n = n ? n.filter(s => a.has(s)) : Eu(a), !n.length) return
        } else r.push(i)
    }
    if (n) {
        for (let i of n)
            if (r.every(o => yd(i, o))) throw new Error(`whole-script confusable: ${e.N}/${i.N}`)
    }
}

function iie(e) {
    let t = Du;
    for (let n of e) {
        let r = t.filter(i => yd(i, n));
        if (!r.length) throw Du.some(i => yd(i, n)) ? _L(t[0], n) : SL(n);
        if (t = r, r.length == 1) break
    }
    return t
}

function oie(e) {
    return e.map(({
        input: t,
        error: n,
        output: r
    }) => {
        if (n) {
            let i = n.message;
            throw new Error(e.length == 1 ? i : `Invalid label ${E_(Pv(t))}: ${i}`)
        }
        return dl(r)
    }).join(yL)
}

function SL(e) {
    return new Error(`disallowed character: ${A_(e)}`)
}

function _L(e, t) {
    let n = A_(t),
        r = Du.find(i => i.P.has(t));
    return r && (n = `${r.N} ${n}`), new Error(`illegal mixture: ${e.N} + ${n}`)
}

function hf(e) {
    return new Error(`illegal placement: ${e}`)
}

function aie(e, t) {
    for (let n of t)
        if (!yd(e, n)) throw _L(e, n);
    if (e.M) {
        let n = gL(t);
        for (let r = 1, i = n.length; r < i; r++)
            if (a1.has(n[r])) {
                let o = r + 1;
                for (let a; o < i && a1.has(a = n[o]); o++)
                    for (let s = r; s < o; s++)
                        if (n[s] == a) throw new Error(`duplicate non-spacing marks: ${A_(a)}`);
                if (o - r > mk) throw new Error(`excessive non-spacing marks: ${E_(Pv(n.slice(r-1,o)))} (${o-r}/${mk})`);
                r = o
            }
    }
}

function sie(e, t, n) {
    let r = [],
        i = [];
    for (e = e.slice().reverse(); e.length;) {
        let o = lie(e);
        if (o) i.length && (r.push(t(i)), i = []), r.push(n(o));
        else {
            let a = e.pop();
            if (AL.has(a)) i.push(a);
            else {
                let s = o1.get(a);
                if (s) i.push(...s);
                else if (!wL.has(a)) throw SL(a)
            }
        }
    }
    return i.length && r.push(t(i)), r
}

function uie(e) {
    return e.filter(t => t != vL)
}

function lie(e, t) {
    let n = s1,
        r, i = e.length;
    for (; i && (n = n.get(e[--i]), !!n);) {
        let {
            V: o
        } = n;
        o && (r = o, e.length = i)
    }
    return r
}
const cie = e => tie(e),
    Xr = e => {
        let t = "";
        for (let n = 0; n < 32; n += 1) t += "00";
        if (e) {
            const r = cie(e).split(".");
            for (let i = r.length - 1; i >= 0; i -= 1) {
                const o = Wn(r[i]).slice(2);
                t = Wn(`0x${t}${o}`).slice(2)
            }
        }
        return `0x${t}`
    };
var op = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
class fie {
    constructor(t, n) {
        this.contract = new ss(Tre, n ? ? xg.main, t), this.context = t
    }
    getOwner(t) {
        return op(this, void 0, void 0, function*() {
            try {
                return this.contract.methods.owner(Xr(t)).call()
            } catch {
                throw new Error
            }
        })
    }
    getTTL(t) {
        return op(this, void 0, void 0, function*() {
            try {
                return this.contract.methods.ttl(Xr(t)).call()
            } catch {
                throw new Error
            }
        })
    }
    recordExists(t) {
        return op(this, void 0, void 0, function*() {
            try {
                return this.contract.methods.recordExists(Xr(t)).call()
            } catch {
                throw new Error
            }
        })
    }
    getResolver(t) {
        return op(this, void 0, void 0, function*() {
            try {
                return this.contract.methods.resolver(Xr(t)).call().then(n => {
                    if (typeof n == "string") return new ss(Pre, n, this.context);
                    throw new Error
                })
            } catch {
                throw new Error
            }
        })
    }
    get events() {
        return this.contract.events
    }
}
var _i = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
class die {
    constructor(t) {
        this.registry = t
    }
    getResolverContractAdapter(t) {
        return _i(this, void 0, void 0, function*() {
            return this.registry.getResolver(t)
        })
    }
    checkInterfaceSupport(t, n) {
        var r, i;
        return _i(this, void 0, void 0, function*() {
            if (le(hk[n])) throw new pO((r = t.options.address) !== null && r !== void 0 ? r : "", n);
            if (!(yield t.methods.supportsInterface(hk[n]).call())) throw new pO((i = t.options.address) !== null && i !== void 0 ? i : "", n)
        })
    }
    supportsInterface(t, n) {
        var r;
        return _i(this, void 0, void 0, function*() {
            const i = yield this.getResolverContractAdapter(t);
            let o = n;
            if (!Re(o)) {
                if (o = (r = yh(n)) !== null && r !== void 0 ? r : "", n === "") throw new Error("Invalid interface Id");
                o = o.slice(0, 10)
            }
            return i.methods.supportsInterface(o).call()
        })
    }
    getAddress(t, n = 60) {
        return _i(this, void 0, void 0, function*() {
            const r = yield this.getResolverContractAdapter(t);
            return yield this.checkInterfaceSupport(r, Ks.addr), r.methods.addr(Xr(t), n).call()
        })
    }
    getPubkey(t) {
        return _i(this, void 0, void 0, function*() {
            const n = yield this.getResolverContractAdapter(t);
            return yield this.checkInterfaceSupport(n, Ks.pubkey), n.methods.pubkey(Xr(t)).call()
        })
    }
    getContenthash(t) {
        return _i(this, void 0, void 0, function*() {
            const n = yield this.getResolverContractAdapter(t);
            return yield this.checkInterfaceSupport(n, Ks.contenthash), n.methods.contenthash(Xr(t)).call()
        })
    }
    setAddress(t, n, r) {
        return _i(this, void 0, void 0, function*() {
            const i = yield this.getResolverContractAdapter(t);
            return yield this.checkInterfaceSupport(i, Ks.setAddr), i.methods.setAddr(Xr(t), n).send(r)
        })
    }
    getText(t, n) {
        return _i(this, void 0, void 0, function*() {
            const r = yield this.getResolverContractAdapter(t);
            return yield this.checkInterfaceSupport(r, Ks.text), r.methods.text(Xr(t), n).call()
        })
    }
    getName(t, n = !0) {
        return _i(this, void 0, void 0, function*() {
            const r = `${t.toLowerCase().substring(2)}.addr.reverse`,
                i = yield this.getResolverContractAdapter(r);
            return n && (yield this.checkInterfaceSupport(i, Ks.name)), i.methods.name(Xr(r)).call()
        })
    }
}
var Zn = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, [])).next())
    })
};
class TL extends lr {
    constructor(t, n) {
        super(n ? ? ""), this.registryAddress = t ? ? xg.main, this._registry = new fie(this.getContextObject(), t), this._resolver = new die(this._registry)
    }
    getResolver(t) {
        return Zn(this, void 0, void 0, function*() {
            return this._registry.getResolver(t)
        })
    }
    recordExists(t) {
        return Zn(this, void 0, void 0, function*() {
            return this._registry.recordExists(t)
        })
    }
    getTTL(t) {
        return Zn(this, void 0, void 0, function*() {
            return this._registry.getTTL(t)
        })
    }
    getOwner(t) {
        return Zn(this, void 0, void 0, function*() {
            return this._registry.getOwner(t)
        })
    }
    getAddress(t, n = 60) {
        return Zn(this, void 0, void 0, function*() {
            return this._resolver.getAddress(t, n)
        })
    }
    getText(t, n) {
        return Zn(this, void 0, void 0, function*() {
            return zn(t) ? this._resolver.getText(yield this._resolver.getName(t, !1), n) : this._resolver.getText(t, n)
        })
    }
    getName(t, n = !0) {
        return Zn(this, void 0, void 0, function*() {
            return this._resolver.getName(t, n)
        })
    }
    getPubkey(t) {
        return Zn(this, void 0, void 0, function*() {
            return this._resolver.getPubkey(t)
        })
    }
    getContenthash(t) {
        return Zn(this, void 0, void 0, function*() {
            return this._resolver.getContenthash(t)
        })
    }
    checkNetwork() {
        return Zn(this, void 0, void 0, function*() {
            const t = Date.now() / 1e3;
            if (!this._lastSyncCheck || t - this._lastSyncCheck > 3600) {
                const i = yield Dne(this);
                if (!(typeof i == "boolean" && !i)) throw new QK;
                this._lastSyncCheck = t
            }
            if (this._detectedAddress) return this._detectedAddress;
            const n = yield u_(this, Object.assign(Object.assign({}, this.defaultReturnFormat), {
                number: ur.HEX
            })), r = xg[_re[n]];
            if (typeof r > "u") throw new KK(n);
            return this._detectedAddress = r, this._detectedAddress
        })
    }
    supportsInterface(t, n) {
        return Zn(this, void 0, void 0, function*() {
            return this._resolver.supportsInterface(t, n)
        })
    }
    get events() {
        return this._registry.events
    }
    setAddress(t, n, r) {
        return Zn(this, void 0, void 0, function*() {
            return this._resolver.setAddress(t, n, r)
        })
    }
}
var yo = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
const hie = e => yo(void 0, void 0, void 0, function*() {
        return (yield yte(e)).map(vi)
    }),
    pie = (e, t) => yo(void 0, void 0, void 0, function*() {
        oe.validate(["string"], [t]);
        const n = yield vte(e, t);
        return vi(n)
    }),
    mie = (e, t, n, r) => yo(void 0, void 0, void 0, function*() {
        return oe.validate(["address", "string", "uint"], [t, n, r]), bte(e, t, n, r)
    }),
    gie = (e, t) => yo(void 0, void 0, void 0, function*() {
        return oe.validate(["address"], [t]), wte(e, t)
    }),
    yie = (e, t, n) => yo(void 0, void 0, void 0, function*() {
        return oe.validate(["string", "string"], [t, n]), xte(e, t, n)
    }),
    vie = (e, t, n, r) => yo(void 0, void 0, void 0, function*() {
        const i = Nn(t, pe, {
            transactionSchema: r == null ? void 0 : r.customTransactionSchema
        });
        return Ate(e, i, n)
    }),
    bie = (e, t, n, r) => yo(void 0, void 0, void 0, function*() {
        const i = Nn(t, pe, {
            transactionSchema: r == null ? void 0 : r.customTransactionSchema
        });
        return Ete(e, i, n)
    }),
    wie = (e, t, n, r) => yo(void 0, void 0, void 0, function*() {
        oe.validate(["string", "address", "string"], [t, n, r]);
        const i = Re(t) ? t : Fr(t);
        return Ste(e, i, n, r)
    }),
    xie = (e, t, n) => yo(void 0, void 0, void 0, function*() {
        oe.validate(["string", "string"], [t, n]);
        const r = Re(t) ? t : Fr(t);
        return _te(e, r, n)
    });
var Ti = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
class PL extends lr {
    getAccounts() {
        return Ti(this, void 0, void 0, function*() {
            return hie(this.requestManager)
        })
    }
    newAccount(t) {
        return Ti(this, void 0, void 0, function*() {
            return pie(this.requestManager, t)
        })
    }
    unlockAccount(t, n, r) {
        return Ti(this, void 0, void 0, function*() {
            return mie(this.requestManager, t, n, r)
        })
    }
    lockAccount(t) {
        return Ti(this, void 0, void 0, function*() {
            return gie(this.requestManager, t)
        })
    }
    importRawKey(t, n) {
        return Ti(this, void 0, void 0, function*() {
            return yie(this.requestManager, t, n)
        })
    }
    sendTransaction(t, n) {
        return Ti(this, void 0, void 0, function*() {
            return vie(this.requestManager, t, n, this.config)
        })
    }
    signTransaction(t, n) {
        return Ti(this, void 0, void 0, function*() {
            return bie(this.requestManager, t, n, this.config)
        })
    }
    sign(t, n, r) {
        return Ti(this, void 0, void 0, function*() {
            return wie(this.requestManager, t, n, r)
        })
    }
    ecRecover(t, n) {
        return Ti(this, void 0, void 0, function*() {
            return xie(this.requestManager, t, n)
        })
    }
}
var ti;
(function(e) {
    e.HTTPS = "https", e.WebSocket = "wss"
})(ti || (ti = {}));
var Z;
(function(e) {
    e.ETH_MAINNET = "eth_mainnet", e.ETH_SEPOLIA = "eth_sepolia", e.ETH_HOLESKY = "eth_holesky", e.POLYGON_MAINNET = "polygon_mainnet", e.POLYGON_AMOY = "polygon_amoy", e.AVALANCHE_C_MAINNET = "avalanche_c_mainnet", e.AVALANCHE_P_MAINNET = "avalanche_p_mainnet", e.AVALANCHE_X_MAINNET = "avalanche_x_mainnet", e.ARBITRUM_MAINNET = "arbitrum_mainnet", e.ARBITRUM_SEPOLIA = "arbitrum_sepolia", e.BASE_MAINNET = "base_mainnet", e.BASE_SEPOLIA = "base_sepolia", e.OPTIMISM_MAINNET = "optimism_mainnet", e.OPTIMISM_SEPOLIA = "optimism_sepolia", e.FANTOM_MAINNET = "fantom_mainnet", e.FANTOM_TESTNET = "fantom_testnet", e.DYMENSION_MAINNET = "dymension_mainnet", e.DYMENSION_TESTNET = "dymension_testnet", e.BNB_MAINNET = "bnb_mainnet", e.BNB_TESTNET = "bnb_testnet", e.BSC_MAINNET = "bsc_mainnet", e.BSC_TESTNET = "bsc_testnet", e.ARBITRUM_ONE = "arbitrum_one", e.ARBITRUM_NOVA = "arbitrum_nova", e.AVALANCHE_FUJI_C = "avalanche_fuji_c", e.AVALANCHE_FUJI_P = "avalanche_fuji_p", e.AVALANCHE_FUJI_X = "avalanche_fuji_x", e.BLAST_MAINNET = "blast_mainnet", e.OPBNB_MAINNET = "opbnb_mainnet", e.OPBNB_TESTNET = "opbnb_testnet", e.GNOSIS_MAINNET = "gnosis_mainnet", e.GNOSIS_CHIADO = "gnosis_chiado", e.PULSECHAIN_MAINNET = "pulsechain_mainnet", e.PULSECHAIN_TESTNET = "pulsechain_testnet", e.KAVA_MAINNET = "kava_mainnet", e.CRONOS_MAINNET = "cronos_mainnet", e.MANTLE_MAINNET = "mantle_mainnet", e.CHILIZ_MAINNET = "chiliz_mainnet", e.CHILIZ_SPICY = "chiliz_spicy", e.MOONBEAM_MAINNET = "moonbeam_mainnet", e.TAIKO_MAINNET = "taiko_mainnet", e.TAIKO_HEKLA = "taiko_hekla", e.LINEA_MAINNET = "linea_mainnet", e.LINEA_SEPOLIA = "linea_sepolia", e.BAHAMUT_MAINNET = "bahamut_mainnet", e.SCROLL_MAINNET = "scroll_mainnet", e.SCROLL_SEPOLIA = "scroll_sepolia", e.TRON_MAINNET = "tron_mainnet", e.SYSCOIN_MAINNET = "syscoin_mainnet", e.SYSCOIN_TANENBAUM = "syscoin_tanenbaum", e.MOONRIVER_MAINNET = "moonriver_mainnet", e.HAQQ_MAINNET = "haqq_mainnet", e.EVMOS_MAINNET = "evmos_mainnet", e.EVMOS_TESTNET = "evmos_testnet", e.BERACHAIN_TESTNET = "berachain_testnet"
})(Z || (Z = {}));
const Aie = 1300;
class Eie extends fe {
    constructor(t) {
        super("You've reach the rate limit of free RPC calls from our Partner Quick Nodes. There are two options you can either create a paid Quick Nodes account and get 20% off for 2 months using WEB3JS referral code, or use Free public RPC endpoint.", t), this.code = Aie
    }
}
const Sie = 1301;
class bk extends fe {
    constructor(t) {
        super(`Invalid provider config options given for ${t}`), this.code = Sie
    }
}
var _ie = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
class OL extends WS {
    constructor(t, n, r, i, o) {
        if (super(), o !== void 0 && n === ti.HTTPS && !("providerOptions" in o)) throw new bk("HTTP Provider");
        if (o !== void 0 && n === ti.WebSocket && !("socketOptions" in o || "reconnectOptions" in o)) throw new bk("Websocket Provider");
        this.transport = n, n === ti.HTTPS ? this.provider = new gv(this.getRPCURL(t, n, r, i), o) : n === ti.WebSocket && (this.provider = new PD(this.getRPCURL(t, n, r, i), o == null ? void 0 : o.socketOptions, o == null ? void 0 : o.reconnectOptions))
    }
    request(t, n) {
        return _ie(this, void 0, void 0, function*() {
            return this.transport === ti.HTTPS ? yield this.provider.request(t, n): this.provider.request(t)
        })
    }
    getStatus() {
        return this.provider.getStatus()
    }
    supportsSubscriptions() {
        return this.provider.supportsSubscriptions()
    }
    once(t, n) {
        var r;
        !((r = this.provider) === null || r === void 0) && r.once && this.provider.once(t, n)
    }
    removeAllListeners(t) {
        var n;
        !((n = this.provider) === null || n === void 0) && n.removeAllListeners && this.provider.removeAllListeners(t)
    }
    connect() {
        var t;
        !((t = this.provider) === null || t === void 0) && t.connect && this.provider.connect()
    }
    disconnect(t, n) {
        var r;
        !((r = this.provider) === null || r === void 0) && r.disconnect && this.provider.disconnect(t, n)
    }
    reset() {
        var t;
        !((t = this.provider) === null || t === void 0) && t.reset && this.provider.reset()
    }
    on(t, n) {
        this.provider && this.provider.on(t, n)
    }
    removeListener(t, n) {
        this.provider && this.provider.removeListener(t, n)
    }
}
var Tie = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
const Bt = e => e !== void 0 && e.trim().length > 0;
class Pie extends OL {
    constructor(t = Z.ETH_MAINNET, n = ti.HTTPS, r = "", i = "", o) {
        super(t, n, r, i, o)
    }
    request(t, n) {
        const r = Object.create(null, {
            request: {
                get: () => super.request
            }
        });
        return Tie(this, void 0, void 0, function*() {
            try {
                return yield r.request.call(this, t, n)
            } catch (i) {
                throw i instanceof Jr && i.statusCode === 429 ? new Eie(i) : i
            }
        })
    }
    getRPCURL(t, n, r, i) {
        let o = "",
            a = "";
        switch (t) {
            case Z.ETH_MAINNET:
                o = Bt(i) ? i : "powerful-holy-bush.quiknode.pro", a = Bt(r) ? r : "3240624a343867035925ff7561eb60dfdba2a668";
                break;
            case Z.ETH_SEPOLIA:
                o = Bt(i) ? i : "dimensional-fabled-glitter.ethereum-sepolia.quiknode.pro", a = Bt(r) ? r : "382a3b5a4b938f2d6e8686c19af4b22921fde2cd";
                break;
            case Z.ETH_HOLESKY:
                o = Bt(i) ? i : "yolo-morning-card.ethereum-holesky.quiknode.pro", a = Bt(r) ? r : "481ebe70638c4dcf176af617a16d02ab866b9af9";
                break;
            case Z.ARBITRUM_MAINNET:
                o = Bt(i) ? i : "autumn-divine-dinghy.arbitrum-mainnet.quiknode.pro", a = Bt(r) ? r : "a5d7bfbf60b5ae9ce3628e53d69ef50d529e9a8c";
                break;
            case Z.ARBITRUM_SEPOLIA:
                o = Bt(i) ? i : "few-patient-pond.arbitrum-sepolia.quiknode.pro", a = Bt(r) ? r : "3be985450970628c860b959c65cd2642dcafe53c";
                break;
            case Z.BNB_MAINNET:
                o = Bt(i) ? i : "purple-empty-reel.bsc.quiknode.pro", a = Bt(r) ? r : "ebf6c532961e21f092ff2facce1ec4c89c540158";
                break;
            case Z.BNB_TESTNET:
                o = Bt(i) ? i : "floral-rough-scion.bsc-testnet.quiknode.pro", a = Bt(r) ? r : "5b297e5acff5f81f4c37ebf6f235f7299b6f9d28";
                break;
            case Z.POLYGON_MAINNET:
                o = Bt(i) ? i : "small-chaotic-moon.matic.quiknode.pro", a = Bt(r) ? r : "847569f8a017e84d985e10d0f44365d965a951f1";
                break;
            case Z.POLYGON_AMOY:
                o = Bt(i) ? i : "prettiest-side-shape.matic-amoy.quiknode.pro", a = Bt(r) ? r : "79a9476eea661d4f82de614db1d8a895b14b881c";
                break;
            default:
                throw new Error("Network info not avalible.")
        }
        return `${n}://${o}/${a}`
    }
}
const Oie = e => e !== void 0 && e.trim().length > 0,
    kie = [Z.DYMENSION_MAINNET, Z.DYMENSION_TESTNET, Z.KAVA_MAINNET, Z.CRONOS_MAINNET, Z.POLYGON_MAINNET];
class Tg extends OL {
    constructor(t = Z.ETH_MAINNET, n = ti.HTTPS, r = "", i) {
        super(t, n, "", r, i)
    }
    getRPCURL(t, n, r, i) {
        if (!Tg.networkHostMap[t]) throw new Error("Network info not avalible.");
        const o = `${Tg.networkHostMap[t]}.publicnode.com`,
            a = Oie(i) ? i : o;
        return kie.includes(t) && n === ti.WebSocket ? `${n}://${a}/websocket` : `${n}://${a}`
    }
}
Tg.networkHostMap = {
    [Z.POLYGON_AMOY]: "polygon-amoy-bor-rpc",
    [Z.DYMENSION_MAINNET]: "dymension-evm-rpc",
    [Z.DYMENSION_TESTNET]: "dymension-testnet-evm-rpc",
    [Z.BLAST_MAINNET]: "blast-rpc",
    [Z.GNOSIS_MAINNET]: "gnosis-rpc",
    [Z.PULSECHAIN_MAINNET]: "pulsechain-rpc",
    [Z.PULSECHAIN_TESTNET]: "pulsechain-testnet-rpc",
    [Z.KAVA_MAINNET]: "kava-evm-rpc",
    [Z.CRONOS_MAINNET]: "cronos-evm-rpc",
    [Z.MANTLE_MAINNET]: "mantle-rpc",
    [Z.TAIKO_MAINNET]: "taiko-rpc",
    [Z.TAIKO_HEKLA]: "taiko-hekla-rpc",
    [Z.LINEA_MAINNET]: "linea-rpc",
    [Z.LINEA_SEPOLIA]: "linea-sepolia-rpc",
    [Z.SCROLL_MAINNET]: "scroll-rpc",
    [Z.SCROLL_SEPOLIA]: "scroll-sepolia-rpc",
    [Z.SYSCOIN_MAINNET]: "syscoin-evm-rpc",
    [Z.SYSCOIN_TANENBAUM]: "syscoin-tanenbaum-evm-rpc",
    [Z.HAQQ_MAINNET]: "haqq-evm-rpc",
    [Z.EVMOS_MAINNET]: "evmos-evm-rpc",
    [Z.EVMOS_TESTNET]: "evmos-testnet-evm-rpc",
    [Z.BERACHAIN_TESTNET]: "berachain-testnet-evm-rpc",
    [Z.ETH_MAINNET]: "ethereum-rpc",
    [Z.ETH_SEPOLIA]: "ethereum-sepolia-rpc",
    [Z.ETH_HOLESKY]: "ethereum-holesky-rpc",
    [Z.BSC_MAINNET]: "bsc-rpc",
    [Z.BSC_TESTNET]: "bsc-testnet-rpc",
    [Z.POLYGON_MAINNET]: "polygon-bor-rpc",
    [Z.BASE_MAINNET]: "base-rpc",
    [Z.BASE_SEPOLIA]: "base-sepolia-rpc",
    [Z.ARBITRUM_ONE]: "arbitrum-one-rpc",
    [Z.ARBITRUM_NOVA]: "arbitrum-nova-rpc",
    [Z.ARBITRUM_SEPOLIA]: "arbitrum-sepolia-rpc",
    [Z.AVALANCHE_C_MAINNET]: "avalanche-c-chain-rpc",
    [Z.AVALANCHE_P_MAINNET]: "avalanche-p-chain-rpc",
    [Z.AVALANCHE_X_MAINNET]: "avalanche-x-chain-rpc",
    [Z.AVALANCHE_FUJI_C]: "avalanche-fuji-c-chain-rpc",
    [Z.AVALANCHE_FUJI_P]: "avalanche-fuji-p-chain-rpc",
    [Z.AVALANCHE_FUJI_X]: "avalanche-fuji-x-chain-rpc",
    [Z.OPTIMISM_MAINNET]: "optimism-rpc",
    [Z.OPTIMISM_SEPOLIA]: "optimism-sepolia-rpc",
    [Z.FANTOM_MAINNET]: "fantom-rpc",
    [Z.FANTOM_TESTNET]: "fantom-testnet-rpc",
    [Z.OPBNB_MAINNET]: "opbnb-rpc",
    [Z.OPBNB_TESTNET]: "opbnb-testnet-rpc",
    [Z.GNOSIS_CHIADO]: "gnosis-chiado-rpc",
    [Z.CHILIZ_MAINNET]: "chiliz-rpc",
    [Z.CHILIZ_SPICY]: "chiliz-spicy-rpc",
    [Z.MOONBEAM_MAINNET]: "moonbeam-rpc",
    [Z.BAHAMUT_MAINNET]: "bahamut-rpc",
    [Z.TRON_MAINNET]: "tron-evm-rpc",
    [Z.MOONRIVER_MAINNET]: "moonriver-rpc"
};
const Cie = new Pie,
    Iie = {
        encodeEventSignature: d_,
        encodeFunctionCall: kne,
        encodeFunctionSignature: dd,
        encodeParameter: Jx,
        encodeParameters: Sv,
        decodeParameter: q$,
        decodeParameters: as,
        decodeLog: K$
    };
var Sc = function(e, t, n, r) {
    function i(o) {
        return o instanceof n ? o : new n(function(a) {
            a(o)
        })
    }
    return new(n || (n = Promise))(function(o, a) {
        function s(c) {
            try {
                l(r.next(c))
            } catch (f) {
                a(f)
            }
        }

        function u(c) {
            try {
                l(r.throw(c))
            } catch (f) {
                a(f)
            }
        }

        function l(c) {
            c.done ? o(c.value) : i(c.value).then(s, u)
        }
        l((r = r.apply(e, t || [])).next())
    })
};
const Mie = e => {
        const t = (a, s) => Sc(void 0, void 0, void 0, function*() {
                const u = yield gre(a, e), l = W({
                    format: "bytes"
                }, s, pe);
                return cee(u, l)
            }),
            n = a => {
                const s = i_(a);
                return Object.assign(Object.assign({}, s), {
                    signTransaction: u => Sc(void 0, void 0, void 0, function*() {
                        return t(u, s.privateKey)
                    })
                })
            },
            r = (a, s, u) => Sc(void 0, void 0, void 0, function*() {
                var l;
                const c = yield pee(a, s, (l = u == null ? void 0 : u.nonStrict) !== null && l !== void 0 ? l : !0);
                return Object.assign(Object.assign({}, c), {
                    signTransaction: f => Sc(void 0, void 0, void 0, function*() {
                        return t(f, c.privateKey)
                    })
                })
            }),
            i = () => {
                const a = hee();
                return Object.assign(Object.assign({}, a), {
                    signTransaction: s => Sc(void 0, void 0, void 0, function*() {
                        return t(s, a.privateKey)
                    })
                })
            },
            o = new dg({
                create: i,
                privateKeyToAccount: n,
                decrypt: r
            });
        return {
            signTransaction: t,
            create: i,
            privateKeyToAccount: n,
            decrypt: r,
            recoverTransaction: fee,
            hashMessage: r_,
            sign: s$,
            recover: Hx,
            encrypt: u$,
            wallet: o,
            privateKeyToAddress: wv,
            parseAndValidatePrivateKey: Wl,
            privateKeyToPublicKey: dee
        }
    },
    Nie = {
        version: "4.16.0"
    };
var Rie = function(e, t, n, r) {
        function i(o) {
            return o instanceof n ? o : new n(function(a) {
                a(o)
            })
        }
        return new(n || (n = Promise))(function(o, a) {
            function s(c) {
                try {
                    l(r.next(c))
                } catch (f) {
                    a(f)
                }
            }

            function u(c) {
                try {
                    l(r.throw(c))
                } catch (f) {
                    a(f)
                }
            }

            function l(c) {
                c.done ? o(c.value) : i(c.value).then(s, u)
            }
            l((r = r.apply(e, t || [])).next())
        })
    },
    Pg;
(function(e) {
    e.eip6963announceProvider = "eip6963:announceProvider", e.eip6963requestProvider = "eip6963:requestProvider"
})(Pg || (Pg = {}));
const Ob = new Map,
    kL = "web3:providersMapUpdated",
    jie = () => Rie(void 0, void 0, void 0, function*() {
        return new Promise((e, t) => {
            typeof window > "u" && t(new Error("window object not available, EIP-6963 is intended to be used within a browser")), window.addEventListener(Pg.eip6963announceProvider, n => {
                Ob.set(n.detail.info.uuid, n.detail);
                const r = new CustomEvent(kL, {
                    detail: Ob
                });
                window.dispatchEvent(r), e(Ob)
            }), window.dispatchEvent(new Event(Pg.eip6963requestProvider))
        })
    }),
    Bie = e => {
        if (typeof window > "u") throw new Error("window object not available, EIP-6963 is intended to be used within a browser");
        window.addEventListener(kL, e)
    };
class Kt extends lr {
    constructor(t = Cie) {
        var n;
        (le(t) || typeof t == "string" && t.trim() === "" || typeof t != "string" && !cg(t) && !t.provider) && console.warn("NOTE: web3.js is running without provider. You need to pass a provider in order to interact with the network!");
        let r = {};
        typeof t == "string" || cg(t) ? r.provider = t : t ? r = t : r = {}, r.registeredSubscriptions = Object.assign(Object.assign({}, t1), (n = r.registeredSubscriptions) !== null && n !== void 0 ? n : {}), super(r);
        const i = Mie(this);
        this._wallet = i.wallet, this._accountProvider = i, this.utils = TD;
        const o = this;
        class a extends ss {
            constructor(l, c, f, d, h) {
                if ($o(c) && $o(f)) throw new mO("Should not provide options at both 2nd and 3rd parameters");
                let m, p = {},
                    y, g;
                if (!le(c) && typeof c != "object" && typeof c != "string") throw new mO;
                if (typeof c == "string" && (m = c), $o(c) ? p = c : $o(f) ? p = f : p = {}, c instanceof lr ? y = c : f instanceof lr ? y = f : d instanceof lr ? y = d : y = o.getContextObject(), h ? g = h : Ii(f) ? g = f : Ii(d) && (g = d), super(l, m, p, y, g), super.subscribeToContextEvents(o), !le(s)) {
                    const b = s.getTransactionMiddleware();
                    le(b) || super.setTransactionMiddleware(b)
                }
            }
        }
        const s = o.use(_v);
        this.eth = Object.assign(s, {
            ens: o.use(TL, xg.main),
            Iban: Tt,
            net: o.use(x$),
            personal: o.use(PL),
            Contract: a,
            abi: Iie,
            accounts: i
        })
    }
}
Kt.version = Nie.version;
Kt.utils = TD;
Kt.requestEIP6963Providers = jie;
Kt.onNewProviderDiscovered = Bie;
Kt.modules = {
    Web3Eth: _v,
    Iban: Tt,
    Net: x$,
    ENS: TL,
    Personal: PL
};
const Os = "0x8067b825ae7c013edacbddcb8449cabc3f07488b",
    pf = "K982IR1XF3U9PH5F4IG7XRE3TZIMUU992X",
    S_ = "https://bsc-dataseed1.binance.org",
    Die = "f3865ca0b4403ecec0f026c86d71788f",
    CL = [{
        inputs: [{
            internalType: "address",
            name: "_upline",
            type: "address"
        }],
        name: "deposit",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [],
        name: "withdraw",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "_addr",
            type: "address"
        }],
        name: "userInfo",
        outputs: [{
            internalType: "uint256",
            name: "for_withdraw",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "total_invested",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "total_withdrawn",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "total_match_bonus",
            type: "uint256"
        }, {
            internalType: "uint256[5]",
            name: "structure",
            type: "uint256[5]"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "contractInfo",
        outputs: [{
            internalType: "uint256",
            name: "_invested",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "_withdrawn",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "_match_bonus",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "addr",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "upline",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "bonus",
            type: "uint256"
        }],
        name: "Upline",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "addr",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }],
        name: "NewDeposit",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "addr",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }],
        name: "MatchPayout",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "addr",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }],
        name: "Withdraw",
        type: "event"
    }];
let kr = null,
    Og = null;
const IL = () => (kr || (kr = new Kt(S_)), kr),
    $ie = async () => {
        var e;
        if (typeof window.ethereum > "u") throw new Error("MetaMask is not installed. Please install MetaMask to continue.");
        if (!window.ethereum.isMetaMask) throw new Error("Please use MetaMask extension.");
        try {
            const t = await window.ethereum.request({
                method: "eth_requestAccounts"
            });
            if (!t || t.length === 0) throw new Error("No accounts found. Please unlock MetaMask and try again.");
            if (await window.ethereum.request({
                    method: "eth_chainId"
                }) !== "0x38") try {
                await window.ethereum.request({
                    method: "wallet_switchEthereumChain",
                    params: [{
                        chainId: "0x38"
                    }]
                })
            } catch (r) {
                if (r.code === 4902) try {
                    await window.ethereum.request({
                        method: "wallet_addEthereumChain",
                        params: [{
                            chainId: "0x38",
                            chainName: "BNB Smart Chain",
                            nativeCurrency: {
                                name: "BNB",
                                symbol: "BNB",
                                decimals: 18
                            },
                            rpcUrls: [S_],
                            blockExplorerUrls: ["https://bscscan.com/"]
                        }]
                    })
                } catch {
                    throw new Error("Failed to add BSC network to MetaMask. Please add it manually.")
                } else throw new Error("Failed to switch to BSC network. Please switch manually in MetaMask.")
            }
            kr = new Kt(window.ethereum);
            try {
                await kr.eth.getBlockNumber()
            } catch {
                throw new Error("Failed to connect to BSC network. Please check your connection.")
            }
            if (!t[0]) throw new Error("No account selected");
            return Og = t[0].toLowerCase(), Og
        } catch (t) {
            throw t.code === 4001 ? new Error("Connection rejected. Please try again.") : (console.error("MetaMask connection error:", t), (e = t.message) != null && e.includes("already processing") ? new Error("Connection already in progress. Please check MetaMask.") : new Error(t.message || "Failed to connect to MetaMask. Please try again."))
        }
    },
    Lie = async () => {
        kr != null && kr.currentProvider && kr.currentProvider.disconnect && await kr.currentProvider.disconnect(), kr = new Kt(S_), Og = null
    },
    kg = () => Og,
    Cg = () => {
        const e = IL();
        return new e.eth.Contract(CL, Os)
    },
    ML = S.createContext({
        isConnected: !1,
        account: null,
        connectWithMetaMask: async () => {},
        connectWithWalletConnect: async () => {},
        disconnect: async () => {},
        contract: null,
        withdrawAmount: "0",
        withdraw: async () => {}
    }),
    Fie = ({
        children: e
    }) => {
        const [t, n] = S.useState(!1), [r, i] = S.useState(null), [o, a] = S.useState(null), [s, u] = S.useState("0"), l = g => {
            const b = new g.eth.Contract(CL, Os);
            return a(b), b
        }, c = async (g, b) => {
            try {
                const v = await g.methods.userInfo(b).call();
                u(Kt.utils.fromWei(v.for_withdraw, "ether"))
            } catch (v) {
                console.error("Error fetching withdraw amount:", v), u("0")
            }
        }, f = async () => {
            var g, b;
            try {
                const v = await $ie(),
                    A = new Kt(window.ethereum),
                    w = l(A);
                i(v), n(!0), await c(w, v), (g = window.ethereum) == null || g.on("accountsChanged", p), (b = window.ethereum) == null || b.on("chainChanged", y)
            } catch (v) {
                throw console.error("MetaMask connection error:", v), v
            }
        }, d = async () => {
            try {
                const {
                    EthereumProvider: g
                } = await XG(async () => {
                    const {
                        EthereumProvider: T
                    } = await
                    import ("./index.es-DEzvovXy.js").then(_ => _.i);
                    return {
                        EthereumProvider: T
                    }
                }, []), b = await g.init({
                    projectId: Die,
                    chains: [56],
                    showQrModal: !0,
                    methods: ["eth_sendTransaction", "eth_signTransaction", "eth_sign", "personal_sign", "eth_signTypedData"],
                    events: ["chainChanged", "accountsChanged"],
                    rpcMap: {
                        56: "https://bsc-dataseed1.binance.org"
                    },
                    metadata: {
                        name: "XJar Protocol",
                        description: "DeFi Protocol on BNB Chain",
                        url: window.location.origin,
                        icons: [`${window.location.origin}/images/logo.svg`]
                    }
                });
                await b.enable();
                const v = new Kt(b),
                    A = l(v);
                b.on("disconnect", () => {
                    h()
                }), b.on("chainChanged", T => {
                    if (T !== 56) throw h(), new Error("Please switch to BSC network")
                }), b.on("accountsChanged", T => {
                    T.length === 0 ? h() : T[0] !== r && (i(T[0]), A && c(A, T[0]))
                });
                const w = await v.eth.getAccounts();
                if (!w || w.length === 0) throw new Error("No accounts found");
                const x = w[0].toLowerCase();
                i(x), n(!0), await c(A, x)
            } catch (g) {
                throw console.error("WalletConnect error:", g), g
            }
        }, h = async () => {
            var g, b;
            try {
                await Lie(), n(!1), i(null), a(null), u("0"), (g = window.ethereum) == null || g.removeListener("accountsChanged", p), (b = window.ethereum) == null || b.removeListener("chainChanged", y)
            } catch (v) {
                console.error("Disconnect error:", v)
            }
        }, m = async () => {
            if (!o || !r) throw new Error("Not connected");
            try {
                await o.methods.withdraw().send({
                    from: r
                }), await c(o, r)
            } catch (g) {
                throw g.code === 4001 ? new Error("Transaction rejected") : new Error("Withdrawal failed")
            }
        }, p = async g => {
            g.length === 0 ? await h() : g[0] !== r && (i(g[0]), o && await c(o, g[0]))
        }, y = async () => {
            window.location.reload()
        };
        return S.useEffect(() => () => {
            if (window.ethereum && (window.ethereum.removeListener("accountsChanged", p), window.ethereum.removeListener("chainChanged", y)), o != null && o.currentProvider) {
                const g = o.currentProvider;
                g != null && g.off && (g.off("accountsChanged"), g.off("chainChanged"), g.off("disconnect"))
            }
        }, [o]), E.jsx(ML.Provider, {
            value: {
                isConnected: t,
                account: r,
                connectWithMetaMask: f,
                connectWithWalletConnect: d,
                disconnect: h,
                contract: o,
                withdrawAmount: s,
                withdraw: m
            },
            children: e
        })
    },
    Ov = () => {
        const e = S.useContext(ML);
        if (!e) throw new Error("useWeb3 must be used within a Web3Provider");
        return e
    },
    Uie = ({
        onConnectClick: e
    }) => {
        const {
            isConnected: t,
            account: n,
            disconnect: r
        } = Ov(), [i, o] = S.useState(!1);
        return E.jsxs(Ve.nav, {
            initial: {
                opacity: 0,
                y: -20
            },
            animate: {
                opacity: 1,
                y: 0
            },
            className: "sticky top-0 z-50 bg-background/80 backdrop-blur-lg border-b border-gray-800",
            children: [E.jsx("div", {
                className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
                children: E.jsxs("div", {
                    className: "flex items-center justify-between h-16",
                    children: [E.jsxs(mt, {
                        to: "/",
                        className: "flex items-center space-x-2",
                        children: [E.jsx("img", {
                            src: "/images/logo.svg",
                            alt: "Logo",
                            className: "h-6 w-6"
                        }), E.jsx("span", {
                            className: "text-lg font-medium text-gray-300",
                            children: "xJar"
                        })]
                    }), E.jsxs("div", {
                        className: "hidden lg:flex items-center",
                        children: [E.jsx(mt, {
                            to: "/",
                            className: "px-4 py-2 text-gray-300 hover:text-white transition-colors",
                            children: "Dashboard"
                        }), E.jsx(mt, {
                            to: "/docs",
                            className: "px-4 py-2 text-gray-300 hover:text-white transition-colors",
                            children: "Documentation"
                        }), E.jsx(mt, {
                            to: "/audit",
                            className: "px-4 py-2 text-gray-300 hover:text-white transition-colors",
                            children: "Audit"
                        }), E.jsx(mt, {
                            to: "/faq",
                            className: "px-4 py-2 text-gray-300 hover:text-white transition-colors",
                            children: "FAQ"
                        }), E.jsx(mt, {
                            to: "/referral",
                            className: "px-4 py-2 text-gray-300 hover:text-white transition-colors",
                            children: "Referral"
                        })]
                    }), E.jsx("div", {
                        className: "lg:hidden flex items-center",
                        children: E.jsx("button", {
                            "data-testid": "mobile-menu-button",
                            onClick: a => {
                                a.preventDefault(), a.stopPropagation();
                                const s = !i;
                                o(s), document.body.style.overflow = s ? "hidden" : ""
                            },
                            className: "p-2 rounded-lg hover:bg-white/5 transition-colors ml-4",
                            children: i ? E.jsx(wx, {
                                className: "h-6 w-6 text-white"
                            }) : E.jsx(wG, {
                                className: "h-6 w-6 text-white"
                            })
                        })
                    }), t && n ? E.jsxs("div", {
                        className: "flex items-center space-x-2",
                        children: [E.jsx("div", {
                            className: "px-4 py-2 rounded-lg bg-background-light border border-gray-800",
                            children: E.jsxs("span", {
                                className: "text-sm text-gray-300",
                                children: [n.slice(0, 6), "...", n.slice(-4)]
                            })
                        }), E.jsx("button", {
                            onClick: r,
                            className: "p-2 rounded-lg text-gray-300 hover:text-white bg-background-light hover:bg-white/5 border border-gray-800 transition-colors",
                            children: E.jsx(wx, {
                                className: "h-5 w-5"
                            })
                        })]
                    }) : E.jsx("button", {
                        onClick: e,
                        className: "px-6 py-2.5 rounded-xl bg-gradient-to-r from-primary to-primary-light text-white hover:shadow-lg hover:shadow-primary/20 transition-all duration-300 transform hover:scale-105",
                        children: "Connect Wallet"
                    })]
                })
            }), i && E.jsx("div", {
                className: "fixed inset-0 bg-black/50 backdrop-blur-sm z-[90] lg:hidden",
                onClick: () => o(!1)
            }), E.jsx(Ve.div, {
                initial: {
                    opacity: 0,
                    y: -20
                },
                animate: {
                    opacity: i ? 1 : 0,
                    y: i ? 0 : -20
                },
                transition: {
                    duration: .2,
                    ease: "easeInOut"
                },
                className: `fixed top-16 left-0 right-0 z-[140] lg:hidden border-t border-gray-800 bg-background/95 backdrop-blur-lg shadow-lg ${i?"block":"hidden"}`,
                onClick: a => a.stopPropagation(),
                children: E.jsx("div", {
                    className: "max-w-7xl mx-auto px-4 py-3",
                    children: E.jsxs("nav", {
                        className: "flex flex-col space-y-1",
                        children: [E.jsx(mt, {
                            to: "/",
                            className: "px-4 py-3 rounded-lg text-gray-300 hover:text-white hover:bg-white/5 transition-colors",
                            onClick: () => o(!1),
                            children: "Dashboard"
                        }), E.jsx(mt, {
                            to: "/docs",
                            className: "px-4 py-3 rounded-lg text-gray-300 hover:text-white hover:bg-white/5 transition-colors",
                            onClick: () => o(!1),
                            children: "Documentation"
                        }), E.jsx(mt, {
                            to: "/audit",
                            className: "px-4 py-3 rounded-lg text-gray-300 hover:text-white hover:bg-white/5 transition-colors",
                            onClick: () => o(!1),
                            children: "Audit"
                        }), E.jsx(mt, {
                            to: "/faq",
                            className: "px-4 py-3 rounded-lg text-gray-300 hover:text-white hover:bg-white/5 transition-colors",
                            onClick: () => o(!1),
                            children: "FAQ"
                        }), E.jsx(mt, {
                            to: "/referral",
                            className: "px-4 py-3 rounded-lg text-gray-300 hover:text-white hover:bg-white/5 transition-colors",
                            onClick: () => o(!1),
                            children: "Referral"
                        })]
                    })
                })
            })]
        })
    },
    NL = ({
        className: e
    }) => E.jsxs("svg", {
        width: "32",
        height: "32",
        viewBox: "0 0 32 32",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        className: e,
        children: [E.jsx("path", {
            d: "M16 2L4 9V23L16 30L28 23V9L16 2ZM25.3333 21.6667L16 27.3333L6.66667 21.6667V10.3333L16 4.66667L25.3333 10.3333V21.6667Z",
            fill: "currentColor"
        }), E.jsx("path", {
            d: "M16 19.3333L20.6667 16.6667L16 14L11.3333 16.6667L16 19.3333ZM16 21.3333L11.3333 18.6667V23.3333L16 26L20.6667 23.3333V18.6667L16 21.3333Z",
            fill: "currentColor"
        }), E.jsx("path", {
            d: "M16 6L11.3333 8.66667V13.3333L16 16L20.6667 13.3333V8.66667L16 6Z",
            fill: "currentColor"
        })]
    }),
    RL = ({
        className: e
    }) => E.jsx("svg", {
        width: "32",
        height: "32",
        viewBox: "0 0 32 32",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        className: e,
        children: E.jsx("path", {
            d: "M16 2C8.27812 2 2 8.27812 2 16C2 23.7219 8.27812 30 16 30C23.7219 30 30 23.7219 30 16C30 8.27812 23.7219 2 16 2ZM23.4156 11.0844L20.8938 23.4156C20.7031 24.2656 20.1875 24.4781 19.4781 24.0844L15.6 21.2313L13.7219 23.0375C13.5156 23.2438 13.3406 23.4188 12.9406 23.4188L13.2188 19.4781L20.3938 13.0375C20.7094 12.7625 20.3219 12.6094 19.9063 12.8844L11.0844 18.4781L7.25938 17.2313C6.42812 16.9688 6.41250 16.3875 7.42812 16.0094L22.3406 10.1406C23.0344 9.89375 23.6438 10.3188 23.4156 11.0844Z",
            fill: "currentColor"
        })
    }),
    Hie = () => E.jsx("footer", {
        className: "bg-background border-t border-gray-800",
        children: E.jsxs("div", {
            className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8",
            children: [E.jsxs("div", {
                className: "grid grid-cols-1 md:grid-cols-4 gap-8",
                children: [E.jsxs("div", {
                    className: "col-span-1 md:col-span-2",
                    children: [E.jsxs(mt, {
                        to: "/",
                        className: "flex items-center space-x-2 mb-4",
                        children: [E.jsx("img", {
                            src: "/images/logo.svg",
                            alt: "Logo",
                            className: "h-6 w-6"
                        }), E.jsx("span", {
                            className: "text-lg font-medium text-gray-300",
                            children: "xJar"
                        })]
                    }), E.jsx("p", {
                        className: "text-gray-400 text-sm",
                        children: "Secure and transparent DeFi protocol on BNB Chain."
                    })]
                }), E.jsxs("div", {
                    children: [E.jsx("h3", {
                        className: "text-lg font-bold mb-4",
                        children: "Quick Links"
                    }), E.jsxs("ul", {
                        className: "space-y-2",
                        children: [E.jsx("li", {
                            children: E.jsx(mt, {
                                to: "/docs",
                                className: "text-gray-400 hover:text-white transition-colors",
                                children: "Documentation"
                            })
                        }), E.jsx("li", {
                            children: E.jsx(mt, {
                                to: "/audit",
                                className: "text-gray-400 hover:text-white transition-colors",
                                children: "Security Audit"
                            })
                        }), E.jsx("li", {
                            children: E.jsx(mt, {
                                to: "/faq",
                                className: "text-gray-400 hover:text-white transition-colors",
                                children: "FAQ"
                            })
                        }), E.jsx("li", {
                            children: E.jsx(mt, {
                                to: "/referral",
                                className: "text-gray-400 hover:text-white transition-colors",
                                children: "Referral Program"
                            })
                        })]
                    })]
                }), E.jsxs("div", {
                    children: [E.jsx("h3", {
                        className: "text-lg font-bold mb-4",
                        children: "Community"
                    }), E.jsxs("ul", {
                        className: "space-y-2",
                        children: [E.jsx("li", {
                            children: E.jsxs("a", {
                                href: "https://t.me/xjarprotocol",
                                target: "_blank",
                                rel: "noopener noreferrer",
                                className: "flex items-center space-x-2 text-gray-400 hover:text-white transition-colors",
                                children: [E.jsx(RL, {
                                    className: "h-5 w-5"
                                }), E.jsx("span", {
                                    children: "Telegram"
                                })]
                            })
                        }), E.jsx("li", {
                            children: E.jsxs("a", {
                                href: `https://bscscan.com/address/${Os}`,
                                target: "_blank",
                                rel: "noopener noreferrer",
                                className: "flex items-center space-x-2 text-gray-400 hover:text-white transition-colors",
                                children: [E.jsx(NL, {
                                    className: "h-5 w-5"
                                }), E.jsx("span", {
                                    children: "Contract"
                                })]
                            })
                        })]
                    })]
                })]
            }), E.jsxs("div", {
                className: "mt-8 pt-8 border-t border-gray-800 flex flex-col sm:flex-row justify-between items-center space-y-4 sm:space-y-0",
                children: [E.jsxs("p", {
                    className: "text-gray-400 text-sm",
                    children: ["© ", new Date().getFullYear(), " XJar Protocol. All rights reserved."]
                }), E.jsxs("div", {
                    className: "flex space-x-6",
                    children: [E.jsx(mt, {
                        to: "/terms",
                        className: "text-gray-400 hover:text-white text-sm transition-colors",
                        children: "Terms of Service"
                    }), E.jsx(mt, {
                        to: "/privacy",
                        className: "text-gray-400 hover:text-white text-sm transition-colors",
                        children: "Privacy Policy"
                    })]
                })]
            })]
        })
    });

function jL(e) {
    var t, n, r = "";
    if (typeof e == "string" || typeof e == "number") r += e;
    else if (typeof e == "object")
        if (Array.isArray(e)) {
            var i = e.length;
            for (t = 0; t < i; t++) e[t] && (n = jL(e[t])) && (r && (r += " "), r += n)
        } else
            for (n in e) e[n] && (r && (r += " "), r += n);
    return r
}

function Me() {
    for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)(e = arguments[n]) && (t = jL(e)) && (r && (r += " "), r += t);
    return r
}
var Vie = Array.isArray,
    Rn = Vie,
    zie = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis,
    BL = zie,
    Wie = BL,
    Gie = typeof self == "object" && self && self.Object === Object && self,
    qie = Wie || Gie || Function("return this")(),
    bi = qie,
    Kie = bi,
    Qie = Kie.Symbol,
    Ah = Qie,
    wk = Ah,
    DL = Object.prototype,
    Yie = DL.hasOwnProperty,
    Xie = DL.toString,
    _c = wk ? wk.toStringTag : void 0;

function Zie(e) {
    var t = Yie.call(e, _c),
        n = e[_c];
    try {
        e[_c] = void 0;
        var r = !0
    } catch {}
    var i = Xie.call(e);
    return r && (t ? e[_c] = n : delete e[_c]), i
}
var Jie = Zie,
    eoe = Object.prototype,
    toe = eoe.toString;

function noe(e) {
    return toe.call(e)
}
var roe = noe,
    xk = Ah,
    ioe = Jie,
    ooe = roe,
    aoe = "[object Null]",
    soe = "[object Undefined]",
    Ak = xk ? xk.toStringTag : void 0;

function uoe(e) {
    return e == null ? e === void 0 ? soe : aoe : Ak && Ak in Object(e) ? ioe(e) : ooe(e)
}
var vo = uoe;

function loe(e) {
    return e != null && typeof e == "object"
}
var bo = loe,
    coe = vo,
    foe = bo,
    doe = "[object Symbol]";

function hoe(e) {
    return typeof e == "symbol" || foe(e) && coe(e) == doe
}
var Ql = hoe,
    poe = Rn,
    moe = Ql,
    goe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    yoe = /^\w*$/;

function voe(e, t) {
    if (poe(e)) return !1;
    var n = typeof e;
    return n == "number" || n == "symbol" || n == "boolean" || e == null || moe(e) ? !0 : yoe.test(e) || !goe.test(e) || t != null && e in Object(t)
}
var __ = voe;

function boe(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function")
}
var ya = boe;
const Yl = Fe(ya);
var woe = vo,
    xoe = ya,
    Aoe = "[object AsyncFunction]",
    Eoe = "[object Function]",
    Soe = "[object GeneratorFunction]",
    _oe = "[object Proxy]";

function Toe(e) {
    if (!xoe(e)) return !1;
    var t = woe(e);
    return t == Eoe || t == Soe || t == Aoe || t == _oe
}
var T_ = Toe;
const Ae = Fe(T_);
var Poe = bi,
    Ooe = Poe["__core-js_shared__"],
    koe = Ooe,
    kb = koe,
    Ek = function() {
        var e = /[^.]+$/.exec(kb && kb.keys && kb.keys.IE_PROTO || "");
        return e ? "Symbol(src)_1." + e : ""
    }();

function Coe(e) {
    return !!Ek && Ek in e
}
var Ioe = Coe,
    Moe = Function.prototype,
    Noe = Moe.toString;

function Roe(e) {
    if (e != null) {
        try {
            return Noe.call(e)
        } catch {}
        try {
            return e + ""
        } catch {}
    }
    return ""
}
var $L = Roe,
    joe = T_,
    Boe = Ioe,
    Doe = ya,
    $oe = $L,
    Loe = /[\\^$.*+?()[\]{}|]/g,
    Foe = /^\[object .+?Constructor\]$/,
    Uoe = Function.prototype,
    Hoe = Object.prototype,
    Voe = Uoe.toString,
    zoe = Hoe.hasOwnProperty,
    Woe = RegExp("^" + Voe.call(zoe).replace(Loe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

function Goe(e) {
    if (!Doe(e) || Boe(e)) return !1;
    var t = joe(e) ? Woe : Foe;
    return t.test($oe(e))
}
var qoe = Goe;

function Koe(e, t) {
    return e == null ? void 0 : e[t]
}
var Qoe = Koe,
    Yoe = qoe,
    Xoe = Qoe;

function Zoe(e, t) {
    var n = Xoe(e, t);
    return Yoe(n) ? n : void 0
}
var $s = Zoe,
    Joe = $s,
    eae = Joe(Object, "create"),
    kv = eae,
    Sk = kv;

function tae() {
    this.__data__ = Sk ? Sk(null) : {}, this.size = 0
}
var nae = tae;

function rae(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0, t
}
var iae = rae,
    oae = kv,
    aae = "__lodash_hash_undefined__",
    sae = Object.prototype,
    uae = sae.hasOwnProperty;

function lae(e) {
    var t = this.__data__;
    if (oae) {
        var n = t[e];
        return n === aae ? void 0 : n
    }
    return uae.call(t, e) ? t[e] : void 0
}
var cae = lae,
    fae = kv,
    dae = Object.prototype,
    hae = dae.hasOwnProperty;

function pae(e) {
    var t = this.__data__;
    return fae ? t[e] !== void 0 : hae.call(t, e)
}
var mae = pae,
    gae = kv,
    yae = "__lodash_hash_undefined__";

function vae(e, t) {
    var n = this.__data__;
    return this.size += this.has(e) ? 0 : 1, n[e] = gae && t === void 0 ? yae : t, this
}
var bae = vae,
    wae = nae,
    xae = iae,
    Aae = cae,
    Eae = mae,
    Sae = bae;

function Xl(e) {
    var t = -1,
        n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n;) {
        var r = e[t];
        this.set(r[0], r[1])
    }
}
Xl.prototype.clear = wae;
Xl.prototype.delete = xae;
Xl.prototype.get = Aae;
Xl.prototype.has = Eae;
Xl.prototype.set = Sae;
var _ae = Xl;

function Tae() {
    this.__data__ = [], this.size = 0
}
var Pae = Tae;

function Oae(e, t) {
    return e === t || e !== e && t !== t
}
var P_ = Oae,
    kae = P_;

function Cae(e, t) {
    for (var n = e.length; n--;)
        if (kae(e[n][0], t)) return n;
    return -1
}
var Cv = Cae,
    Iae = Cv,
    Mae = Array.prototype,
    Nae = Mae.splice;

function Rae(e) {
    var t = this.__data__,
        n = Iae(t, e);
    if (n < 0) return !1;
    var r = t.length - 1;
    return n == r ? t.pop() : Nae.call(t, n, 1), --this.size, !0
}
var jae = Rae,
    Bae = Cv;

function Dae(e) {
    var t = this.__data__,
        n = Bae(t, e);
    return n < 0 ? void 0 : t[n][1]
}
var $ae = Dae,
    Lae = Cv;

function Fae(e) {
    return Lae(this.__data__, e) > -1
}
var Uae = Fae,
    Hae = Cv;

function Vae(e, t) {
    var n = this.__data__,
        r = Hae(n, e);
    return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this
}
var zae = Vae,
    Wae = Pae,
    Gae = jae,
    qae = $ae,
    Kae = Uae,
    Qae = zae;

function Zl(e) {
    var t = -1,
        n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n;) {
        var r = e[t];
        this.set(r[0], r[1])
    }
}
Zl.prototype.clear = Wae;
Zl.prototype.delete = Gae;
Zl.prototype.get = qae;
Zl.prototype.has = Kae;
Zl.prototype.set = Qae;
var Iv = Zl,
    Yae = $s,
    Xae = bi,
    Zae = Yae(Xae, "Map"),
    O_ = Zae,
    _k = _ae,
    Jae = Iv,
    ese = O_;

function tse() {
    this.size = 0, this.__data__ = {
        hash: new _k,
        map: new(ese || Jae),
        string: new _k
    }
}
var nse = tse;

function rse(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null
}
var ise = rse,
    ose = ise;

function ase(e, t) {
    var n = e.__data__;
    return ose(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map
}
var Mv = ase,
    sse = Mv;

function use(e) {
    var t = sse(this, e).delete(e);
    return this.size -= t ? 1 : 0, t
}
var lse = use,
    cse = Mv;

function fse(e) {
    return cse(this, e).get(e)
}
var dse = fse,
    hse = Mv;

function pse(e) {
    return hse(this, e).has(e)
}
var mse = pse,
    gse = Mv;

function yse(e, t) {
    var n = gse(this, e),
        r = n.size;
    return n.set(e, t), this.size += n.size == r ? 0 : 1, this
}
var vse = yse,
    bse = nse,
    wse = lse,
    xse = dse,
    Ase = mse,
    Ese = vse;

function Jl(e) {
    var t = -1,
        n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n;) {
        var r = e[t];
        this.set(r[0], r[1])
    }
}
Jl.prototype.clear = bse;
Jl.prototype.delete = wse;
Jl.prototype.get = xse;
Jl.prototype.has = Ase;
Jl.prototype.set = Ese;
var k_ = Jl,
    LL = k_,
    Sse = "Expected a function";

function C_(e, t) {
    if (typeof e != "function" || t != null && typeof t != "function") throw new TypeError(Sse);
    var n = function() {
        var r = arguments,
            i = t ? t.apply(this, r) : r[0],
            o = n.cache;
        if (o.has(i)) return o.get(i);
        var a = e.apply(this, r);
        return n.cache = o.set(i, a) || o, a
    };
    return n.cache = new(C_.Cache || LL), n
}
C_.Cache = LL;
var FL = C_;
const _se = Fe(FL);
var Tse = FL,
    Pse = 500;

function Ose(e) {
    var t = Tse(e, function(r) {
            return n.size === Pse && n.clear(), r
        }),
        n = t.cache;
    return t
}
var kse = Ose,
    Cse = kse,
    Ise = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
    Mse = /\\(\\)?/g,
    Nse = Cse(function(e) {
        var t = [];
        return e.charCodeAt(0) === 46 && t.push(""), e.replace(Ise, function(n, r, i, o) {
            t.push(i ? o.replace(Mse, "$1") : r || n)
        }), t
    }),
    Rse = Nse;

function jse(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length, i = Array(r); ++n < r;) i[n] = t(e[n], n, e);
    return i
}
var I_ = jse,
    Tk = Ah,
    Bse = I_,
    Dse = Rn,
    $se = Ql,
    Pk = Tk ? Tk.prototype : void 0,
    Ok = Pk ? Pk.toString : void 0;

function UL(e) {
    if (typeof e == "string") return e;
    if (Dse(e)) return Bse(e, UL) + "";
    if ($se(e)) return Ok ? Ok.call(e) : "";
    var t = e + "";
    return t == "0" && 1 / e == -1 / 0 ? "-0" : t
}
var Lse = UL,
    Fse = Lse;

function Use(e) {
    return e == null ? "" : Fse(e)
}
var HL = Use,
    Hse = Rn,
    Vse = __,
    zse = Rse,
    Wse = HL;

function Gse(e, t) {
    return Hse(e) ? e : Vse(e, t) ? [e] : zse(Wse(e))
}
var VL = Gse,
    qse = Ql;

function Kse(e) {
    if (typeof e == "string" || qse(e)) return e;
    var t = e + "";
    return t == "0" && 1 / e == -1 / 0 ? "-0" : t
}
var Nv = Kse,
    Qse = VL,
    Yse = Nv;

function Xse(e, t) {
    t = Qse(t, e);
    for (var n = 0, r = t.length; e != null && n < r;) e = e[Yse(t[n++])];
    return n && n == r ? e : void 0
}
var M_ = Xse,
    Zse = M_;

function Jse(e, t, n) {
    var r = e == null ? void 0 : Zse(e, t);
    return r === void 0 ? n : r
}
var zL = Jse;
const dr = Fe(zL);

function eue(e) {
    return e == null
}
var tue = eue;
const Pe = Fe(tue);
var nue = vo,
    rue = Rn,
    iue = bo,
    oue = "[object String]";

function aue(e) {
    return typeof e == "string" || !rue(e) && iue(e) && nue(e) == oue
}
var sue = aue;
const Eh = Fe(sue);
var WL = {
        exports: {}
    },
    Ue = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var N_ = Symbol.for("react.element"),
    R_ = Symbol.for("react.portal"),
    Rv = Symbol.for("react.fragment"),
    jv = Symbol.for("react.strict_mode"),
    Bv = Symbol.for("react.profiler"),
    Dv = Symbol.for("react.provider"),
    $v = Symbol.for("react.context"),
    uue = Symbol.for("react.server_context"),
    Lv = Symbol.for("react.forward_ref"),
    Fv = Symbol.for("react.suspense"),
    Uv = Symbol.for("react.suspense_list"),
    Hv = Symbol.for("react.memo"),
    Vv = Symbol.for("react.lazy"),
    lue = Symbol.for("react.offscreen"),
    GL;
GL = Symbol.for("react.module.reference");

function gr(e) {
    if (typeof e == "object" && e !== null) {
        var t = e.$$typeof;
        switch (t) {
            case N_:
                switch (e = e.type, e) {
                    case Rv:
                    case Bv:
                    case jv:
                    case Fv:
                    case Uv:
                        return e;
                    default:
                        switch (e = e && e.$$typeof, e) {
                            case uue:
                            case $v:
                            case Lv:
                            case Vv:
                            case Hv:
                            case Dv:
                                return e;
                            default:
                                return t
                        }
                }
            case R_:
                return t
        }
    }
}
Ue.ContextConsumer = $v;
Ue.ContextProvider = Dv;
Ue.Element = N_;
Ue.ForwardRef = Lv;
Ue.Fragment = Rv;
Ue.Lazy = Vv;
Ue.Memo = Hv;
Ue.Portal = R_;
Ue.Profiler = Bv;
Ue.StrictMode = jv;
Ue.Suspense = Fv;
Ue.SuspenseList = Uv;
Ue.isAsyncMode = function() {
    return !1
};
Ue.isConcurrentMode = function() {
    return !1
};
Ue.isContextConsumer = function(e) {
    return gr(e) === $v
};
Ue.isContextProvider = function(e) {
    return gr(e) === Dv
};
Ue.isElement = function(e) {
    return typeof e == "object" && e !== null && e.$$typeof === N_
};
Ue.isForwardRef = function(e) {
    return gr(e) === Lv
};
Ue.isFragment = function(e) {
    return gr(e) === Rv
};
Ue.isLazy = function(e) {
    return gr(e) === Vv
};
Ue.isMemo = function(e) {
    return gr(e) === Hv
};
Ue.isPortal = function(e) {
    return gr(e) === R_
};
Ue.isProfiler = function(e) {
    return gr(e) === Bv
};
Ue.isStrictMode = function(e) {
    return gr(e) === jv
};
Ue.isSuspense = function(e) {
    return gr(e) === Fv
};
Ue.isSuspenseList = function(e) {
    return gr(e) === Uv
};
Ue.isValidElementType = function(e) {
    return typeof e == "string" || typeof e == "function" || e === Rv || e === Bv || e === jv || e === Fv || e === Uv || e === lue || typeof e == "object" && e !== null && (e.$$typeof === Vv || e.$$typeof === Hv || e.$$typeof === Dv || e.$$typeof === $v || e.$$typeof === Lv || e.$$typeof === GL || e.getModuleId !== void 0)
};
Ue.typeOf = gr;
WL.exports = Ue;
var cue = WL.exports,
    fue = vo,
    due = bo,
    hue = "[object Number]";

function pue(e) {
    return typeof e == "number" || due(e) && fue(e) == hue
}
var qL = pue;
const mue = Fe(qL);
var gue = qL;

function yue(e) {
    return gue(e) && e != +e
}
var vue = yue;
const ec = Fe(vue);
var Mr = function(t) {
        return t === 0 ? 0 : t > 0 ? 1 : -1
    },
    qa = function(t) {
        return Eh(t) && t.indexOf("%") === t.length - 1
    },
    Y = function(t) {
        return mue(t) && !ec(t)
    },
    Rt = function(t) {
        return Y(t) || Eh(t)
    },
    bue = 0,
    Sh = function(t) {
        var n = ++bue;
        return "".concat(t || "").concat(n)
    },
    ks = function(t, n) {
        var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
            i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
        if (!Y(t) && !Eh(t)) return r;
        var o;
        if (qa(t)) {
            var a = t.indexOf("%");
            o = n * parseFloat(t.slice(0, a)) / 100
        } else o = +t;
        return ec(o) && (o = r), i && o > n && (o = n), o
    },
    ru = function(t) {
        if (!t) return null;
        var n = Object.keys(t);
        return n && n.length ? t[n[0]] : null
    },
    wue = function(t) {
        if (!Array.isArray(t)) return !1;
        for (var n = t.length, r = {}, i = 0; i < n; i++)
            if (!r[t[i]]) r[t[i]] = !0;
            else return !0;
        return !1
    },
    ar = function(t, n) {
        return Y(t) && Y(n) ? function(r) {
            return t + r * (n - t)
        } : function() {
            return n
        }
    };

function Ig(e, t, n) {
    return !e || !e.length ? null : e.find(function(r) {
        return r && (typeof t == "function" ? t(r) : dr(r, t)) === n
    })
}

function $u(e, t) {
    for (var n in e)
        if ({}.hasOwnProperty.call(e, n) && (!{}.hasOwnProperty.call(t, n) || e[n] !== t[n])) return !1;
    for (var r in t)
        if ({}.hasOwnProperty.call(t, r) && !{}.hasOwnProperty.call(e, r)) return !1;
    return !0
}

function u1(e) {
    "@babel/helpers - typeof";
    return u1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, u1(e)
}
var xue = ["viewBox", "children"],
    Aue = ["aria-activedescendant", "aria-atomic", "aria-autocomplete", "aria-busy", "aria-checked", "aria-colcount", "aria-colindex", "aria-colspan", "aria-controls", "aria-current", "aria-describedby", "aria-details", "aria-disabled", "aria-errormessage", "aria-expanded", "aria-flowto", "aria-haspopup", "aria-hidden", "aria-invalid", "aria-keyshortcuts", "aria-label", "aria-labelledby", "aria-level", "aria-live", "aria-modal", "aria-multiline", "aria-multiselectable", "aria-orientation", "aria-owns", "aria-placeholder", "aria-posinset", "aria-pressed", "aria-readonly", "aria-relevant", "aria-required", "aria-roledescription", "aria-rowcount", "aria-rowindex", "aria-rowspan", "aria-selected", "aria-setsize", "aria-sort", "aria-valuemax", "aria-valuemin", "aria-valuenow", "aria-valuetext", "className", "color", "height", "id", "lang", "max", "media", "method", "min", "name", "style", "target", "width", "role", "tabIndex", "accentHeight", "accumulate", "additive", "alignmentBaseline", "allowReorder", "alphabetic", "amplitude", "arabicForm", "ascent", "attributeName", "attributeType", "autoReverse", "azimuth", "baseFrequency", "baselineShift", "baseProfile", "bbox", "begin", "bias", "by", "calcMode", "capHeight", "clip", "clipPath", "clipPathUnits", "clipRule", "colorInterpolation", "colorInterpolationFilters", "colorProfile", "colorRendering", "contentScriptType", "contentStyleType", "cursor", "cx", "cy", "d", "decelerate", "descent", "diffuseConstant", "direction", "display", "divisor", "dominantBaseline", "dur", "dx", "dy", "edgeMode", "elevation", "enableBackground", "end", "exponent", "externalResourcesRequired", "fill", "fillOpacity", "fillRule", "filter", "filterRes", "filterUnits", "floodColor", "floodOpacity", "focusable", "fontFamily", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontWeight", "format", "from", "fx", "fy", "g1", "g2", "glyphName", "glyphOrientationHorizontal", "glyphOrientationVertical", "glyphRef", "gradientTransform", "gradientUnits", "hanging", "horizAdvX", "horizOriginX", "href", "ideographic", "imageRendering", "in2", "in", "intercept", "k1", "k2", "k3", "k4", "k", "kernelMatrix", "kernelUnitLength", "kerning", "keyPoints", "keySplines", "keyTimes", "lengthAdjust", "letterSpacing", "lightingColor", "limitingConeAngle", "local", "markerEnd", "markerHeight", "markerMid", "markerStart", "markerUnits", "markerWidth", "mask", "maskContentUnits", "maskUnits", "mathematical", "mode", "numOctaves", "offset", "opacity", "operator", "order", "orient", "orientation", "origin", "overflow", "overlinePosition", "overlineThickness", "paintOrder", "panose1", "pathLength", "patternContentUnits", "patternTransform", "patternUnits", "pointerEvents", "pointsAtX", "pointsAtY", "pointsAtZ", "preserveAlpha", "preserveAspectRatio", "primitiveUnits", "r", "radius", "refX", "refY", "renderingIntent", "repeatCount", "repeatDur", "requiredExtensions", "requiredFeatures", "restart", "result", "rotate", "rx", "ry", "seed", "shapeRendering", "slope", "spacing", "specularConstant", "specularExponent", "speed", "spreadMethod", "startOffset", "stdDeviation", "stemh", "stemv", "stitchTiles", "stopColor", "stopOpacity", "strikethroughPosition", "strikethroughThickness", "string", "stroke", "strokeDasharray", "strokeDashoffset", "strokeLinecap", "strokeLinejoin", "strokeMiterlimit", "strokeOpacity", "strokeWidth", "surfaceScale", "systemLanguage", "tableValues", "targetX", "targetY", "textAnchor", "textDecoration", "textLength", "textRendering", "to", "transform", "u1", "u2", "underlinePosition", "underlineThickness", "unicode", "unicodeBidi", "unicodeRange", "unitsPerEm", "vAlphabetic", "values", "vectorEffect", "version", "vertAdvY", "vertOriginX", "vertOriginY", "vHanging", "vIdeographic", "viewTarget", "visibility", "vMathematical", "widths", "wordSpacing", "writingMode", "x1", "x2", "x", "xChannelSelector", "xHeight", "xlinkActuate", "xlinkArcrole", "xlinkHref", "xlinkRole", "xlinkShow", "xlinkTitle", "xlinkType", "xmlBase", "xmlLang", "xmlns", "xmlnsXlink", "xmlSpace", "y1", "y2", "y", "yChannelSelector", "z", "zoomAndPan", "ref", "key", "angle"],
    kk = ["points", "pathLength"],
    Cb = {
        svg: xue,
        polygon: kk,
        polyline: kk
    },
    j_ = ["dangerouslySetInnerHTML", "onCopy", "onCopyCapture", "onCut", "onCutCapture", "onPaste", "onPasteCapture", "onCompositionEnd", "onCompositionEndCapture", "onCompositionStart", "onCompositionStartCapture", "onCompositionUpdate", "onCompositionUpdateCapture", "onFocus", "onFocusCapture", "onBlur", "onBlurCapture", "onChange", "onChangeCapture", "onBeforeInput", "onBeforeInputCapture", "onInput", "onInputCapture", "onReset", "onResetCapture", "onSubmit", "onSubmitCapture", "onInvalid", "onInvalidCapture", "onLoad", "onLoadCapture", "onError", "onErrorCapture", "onKeyDown", "onKeyDownCapture", "onKeyPress", "onKeyPressCapture", "onKeyUp", "onKeyUpCapture", "onAbort", "onAbortCapture", "onCanPlay", "onCanPlayCapture", "onCanPlayThrough", "onCanPlayThroughCapture", "onDurationChange", "onDurationChangeCapture", "onEmptied", "onEmptiedCapture", "onEncrypted", "onEncryptedCapture", "onEnded", "onEndedCapture", "onLoadedData", "onLoadedDataCapture", "onLoadedMetadata", "onLoadedMetadataCapture", "onLoadStart", "onLoadStartCapture", "onPause", "onPauseCapture", "onPlay", "onPlayCapture", "onPlaying", "onPlayingCapture", "onProgress", "onProgressCapture", "onRateChange", "onRateChangeCapture", "onSeeked", "onSeekedCapture", "onSeeking", "onSeekingCapture", "onStalled", "onStalledCapture", "onSuspend", "onSuspendCapture", "onTimeUpdate", "onTimeUpdateCapture", "onVolumeChange", "onVolumeChangeCapture", "onWaiting", "onWaitingCapture", "onAuxClick", "onAuxClickCapture", "onClick", "onClickCapture", "onContextMenu", "onContextMenuCapture", "onDoubleClick", "onDoubleClickCapture", "onDrag", "onDragCapture", "onDragEnd", "onDragEndCapture", "onDragEnter", "onDragEnterCapture", "onDragExit", "onDragExitCapture", "onDragLeave", "onDragLeaveCapture", "onDragOver", "onDragOverCapture", "onDragStart", "onDragStartCapture", "onDrop", "onDropCapture", "onMouseDown", "onMouseDownCapture", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseMoveCapture", "onMouseOut", "onMouseOutCapture", "onMouseOver", "onMouseOverCapture", "onMouseUp", "onMouseUpCapture", "onSelect", "onSelectCapture", "onTouchCancel", "onTouchCancelCapture", "onTouchEnd", "onTouchEndCapture", "onTouchMove", "onTouchMoveCapture", "onTouchStart", "onTouchStartCapture", "onPointerDown", "onPointerDownCapture", "onPointerMove", "onPointerMoveCapture", "onPointerUp", "onPointerUpCapture", "onPointerCancel", "onPointerCancelCapture", "onPointerEnter", "onPointerEnterCapture", "onPointerLeave", "onPointerLeaveCapture", "onPointerOver", "onPointerOverCapture", "onPointerOut", "onPointerOutCapture", "onGotPointerCapture", "onGotPointerCaptureCapture", "onLostPointerCapture", "onLostPointerCaptureCapture", "onScroll", "onScrollCapture", "onWheel", "onWheelCapture", "onAnimationStart", "onAnimationStartCapture", "onAnimationEnd", "onAnimationEndCapture", "onAnimationIteration", "onAnimationIterationCapture", "onTransitionEnd", "onTransitionEndCapture"],
    Mg = function(t, n) {
        if (!t || typeof t == "function" || typeof t == "boolean") return null;
        var r = t;
        if (S.isValidElement(t) && (r = t.props), !Yl(r)) return null;
        var i = {};
        return Object.keys(r).forEach(function(o) {
            j_.includes(o) && (i[o] = n || function(a) {
                return r[o](r, a)
            })
        }), i
    },
    Eue = function(t, n, r) {
        return function(i) {
            return t(n, r, i), null
        }
    },
    Ng = function(t, n, r) {
        if (!Yl(t) || u1(t) !== "object") return null;
        var i = null;
        return Object.keys(t).forEach(function(o) {
            var a = t[o];
            j_.includes(o) && typeof a == "function" && (i || (i = {}), i[o] = Eue(a, n, r))
        }), i
    },
    Sue = ["children"],
    _ue = ["children"];

function Ck(e, t) {
    if (e == null) return {};
    var n = Tue(e, t),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        for (i = 0; i < o.length; i++) r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
    }
    return n
}

function Tue(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
            if (t.indexOf(r) >= 0) continue;
            n[r] = e[r]
        }
    return n
}

function l1(e) {
    "@babel/helpers - typeof";
    return l1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, l1(e)
}
var Ik = {
        click: "onClick",
        mousedown: "onMouseDown",
        mouseup: "onMouseUp",
        mouseover: "onMouseOver",
        mousemove: "onMouseMove",
        mouseout: "onMouseOut",
        mouseenter: "onMouseEnter",
        mouseleave: "onMouseLeave",
        touchcancel: "onTouchCancel",
        touchend: "onTouchEnd",
        touchmove: "onTouchMove",
        touchstart: "onTouchStart",
        contextmenu: "onContextMenu",
        dblclick: "onDoubleClick"
    },
    Gi = function(t) {
        return typeof t == "string" ? t : t ? t.displayName || t.name || "Component" : ""
    },
    Mk = null,
    Ib = null,
    B_ = function e(t) {
        if (t === Mk && Array.isArray(Ib)) return Ib;
        var n = [];
        return S.Children.forEach(t, function(r) {
            Pe(r) || (cue.isFragment(r) ? n = n.concat(e(r.props.children)) : n.push(r))
        }), Ib = n, Mk = t, n
    };

function Dr(e, t) {
    var n = [],
        r = [];
    return Array.isArray(t) ? r = t.map(function(i) {
        return Gi(i)
    }) : r = [Gi(t)], B_(e).forEach(function(i) {
        var o = dr(i, "type.displayName") || dr(i, "type.name");
        r.indexOf(o) !== -1 && n.push(i)
    }), n
}

function Dn(e, t) {
    var n = Dr(e, t);
    return n && n[0]
}
var Nk = function(t) {
        if (!t || !t.props) return !1;
        var n = t.props,
            r = n.width,
            i = n.height;
        return !(!Y(r) || r <= 0 || !Y(i) || i <= 0)
    },
    Pue = ["a", "altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "circle", "clipPath", "color-profile", "cursor", "defs", "desc", "ellipse", "feBlend", "feColormatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font", "font-face", "font-face-format", "font-face-name", "font-face-url", "foreignObject", "g", "glyph", "glyphRef", "hkern", "image", "line", "lineGradient", "marker", "mask", "metadata", "missing-glyph", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "script", "set", "stop", "style", "svg", "switch", "symbol", "text", "textPath", "title", "tref", "tspan", "use", "view", "vkern"],
    Oue = function(t) {
        return t && t.type && Eh(t.type) && Pue.indexOf(t.type) >= 0
    },
    kue = function(t) {
        return t && l1(t) === "object" && "clipDot" in t
    },
    Cue = function(t, n, r, i) {
        var o, a = (o = Cb == null ? void 0 : Cb[i]) !== null && o !== void 0 ? o : [];
        return !Ae(t) && (i && a.includes(n) || Aue.includes(n)) || r && j_.includes(n)
    },
    _e = function(t, n, r) {
        if (!t || typeof t == "function" || typeof t == "boolean") return null;
        var i = t;
        if (S.isValidElement(t) && (i = t.props), !Yl(i)) return null;
        var o = {};
        return Object.keys(i).forEach(function(a) {
            var s;
            Cue((s = i) === null || s === void 0 ? void 0 : s[a], a, n, r) && (o[a] = i[a])
        }), o
    },
    c1 = function e(t, n) {
        if (t === n) return !0;
        var r = S.Children.count(t);
        if (r !== S.Children.count(n)) return !1;
        if (r === 0) return !0;
        if (r === 1) return Rk(Array.isArray(t) ? t[0] : t, Array.isArray(n) ? n[0] : n);
        for (var i = 0; i < r; i++) {
            var o = t[i],
                a = n[i];
            if (Array.isArray(o) || Array.isArray(a)) {
                if (!e(o, a)) return !1
            } else if (!Rk(o, a)) return !1
        }
        return !0
    },
    Rk = function(t, n) {
        if (Pe(t) && Pe(n)) return !0;
        if (!Pe(t) && !Pe(n)) {
            var r = t.props || {},
                i = r.children,
                o = Ck(r, Sue),
                a = n.props || {},
                s = a.children,
                u = Ck(a, _ue);
            return i && s ? $u(o, u) && c1(i, s) : !i && !s ? $u(o, u) : !1
        }
        return !1
    },
    jk = function(t, n) {
        var r = [],
            i = {};
        return B_(t).forEach(function(o, a) {
            if (Oue(o)) r.push(o);
            else if (o) {
                var s = Gi(o.type),
                    u = n[s] || {},
                    l = u.handler,
                    c = u.once;
                if (l && (!c || !i[s])) {
                    var f = l(o, s, a);
                    r.push(f), i[s] = !0
                }
            }
        }), r
    },
    Iue = function(t) {
        var n = t && t.type;
        return n && Ik[n] ? Ik[n] : null
    },
    Mue = function(t, n) {
        return B_(n).indexOf(t)
    },
    Nue = ["children", "width", "height", "viewBox", "className", "style", "title", "desc"];

function f1() {
    return f1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, f1.apply(this, arguments)
}

function Rue(e, t) {
    if (e == null) return {};
    var n = jue(e, t),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        for (i = 0; i < o.length; i++) r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
    }
    return n
}

function jue(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
            if (t.indexOf(r) >= 0) continue;
            n[r] = e[r]
        }
    return n
}

function d1(e) {
    var t = e.children,
        n = e.width,
        r = e.height,
        i = e.viewBox,
        o = e.className,
        a = e.style,
        s = e.title,
        u = e.desc,
        l = Rue(e, Nue),
        c = i || {
            width: n,
            height: r,
            x: 0,
            y: 0
        },
        f = Me("recharts-surface", o);
    return R.createElement("svg", f1({}, _e(l, !0, "svg"), {
        className: f,
        width: n,
        height: r,
        style: a,
        viewBox: "".concat(c.x, " ").concat(c.y, " ").concat(c.width, " ").concat(c.height)
    }), R.createElement("title", null, s), R.createElement("desc", null, u), t)
}
var Bue = ["children", "className"];

function h1() {
    return h1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, h1.apply(this, arguments)
}

function Due(e, t) {
    if (e == null) return {};
    var n = $ue(e, t),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        for (i = 0; i < o.length; i++) r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
    }
    return n
}

function $ue(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
            if (t.indexOf(r) >= 0) continue;
            n[r] = e[r]
        }
    return n
}
var lt = R.forwardRef(function(e, t) {
        var n = e.children,
            r = e.className,
            i = Due(e, Bue),
            o = Me("recharts-layer", r);
        return R.createElement("g", h1({
            className: o
        }, _e(i, !0), {
            ref: t
        }), n)
    }),
    us = function(t, n) {
        for (var r = arguments.length, i = new Array(r > 2 ? r - 2 : 0), o = 2; o < r; o++) i[o - 2] = arguments[o]
    };

function Lue(e, t, n) {
    var r = -1,
        i = e.length;
    t < 0 && (t = -t > i ? 0 : i + t), n = n > i ? i : n, n < 0 && (n += i), i = t > n ? 0 : n - t >>> 0, t >>>= 0;
    for (var o = Array(i); ++r < i;) o[r] = e[r + t];
    return o
}
var Fue = Lue,
    Uue = Fue;

function Hue(e, t, n) {
    var r = e.length;
    return n = n === void 0 ? r : n, !t && n >= r ? e : Uue(e, t, n)
}
var Vue = Hue,
    zue = "\\ud800-\\udfff",
    Wue = "\\u0300-\\u036f",
    Gue = "\\ufe20-\\ufe2f",
    que = "\\u20d0-\\u20ff",
    Kue = Wue + Gue + que,
    Que = "\\ufe0e\\ufe0f",
    Yue = "\\u200d",
    Xue = RegExp("[" + Yue + zue + Kue + Que + "]");

function Zue(e) {
    return Xue.test(e)
}
var KL = Zue;

function Jue(e) {
    return e.split("")
}
var ele = Jue,
    QL = "\\ud800-\\udfff",
    tle = "\\u0300-\\u036f",
    nle = "\\ufe20-\\ufe2f",
    rle = "\\u20d0-\\u20ff",
    ile = tle + nle + rle,
    ole = "\\ufe0e\\ufe0f",
    ale = "[" + QL + "]",
    p1 = "[" + ile + "]",
    m1 = "\\ud83c[\\udffb-\\udfff]",
    sle = "(?:" + p1 + "|" + m1 + ")",
    YL = "[^" + QL + "]",
    XL = "(?:\\ud83c[\\udde6-\\uddff]){2}",
    ZL = "[\\ud800-\\udbff][\\udc00-\\udfff]",
    ule = "\\u200d",
    JL = sle + "?",
    e5 = "[" + ole + "]?",
    lle = "(?:" + ule + "(?:" + [YL, XL, ZL].join("|") + ")" + e5 + JL + ")*",
    cle = e5 + JL + lle,
    fle = "(?:" + [YL + p1 + "?", p1, XL, ZL, ale].join("|") + ")",
    dle = RegExp(m1 + "(?=" + m1 + ")|" + fle + cle, "g");

function hle(e) {
    return e.match(dle) || []
}
var ple = hle,
    mle = ele,
    gle = KL,
    yle = ple;

function vle(e) {
    return gle(e) ? yle(e) : mle(e)
}
var ble = vle,
    wle = Vue,
    xle = KL,
    Ale = ble,
    Ele = HL;

function Sle(e) {
    return function(t) {
        t = Ele(t);
        var n = xle(t) ? Ale(t) : void 0,
            r = n ? n[0] : t.charAt(0),
            i = n ? wle(n, 1).join("") : t.slice(1);
        return r[e]() + i
    }
}
var _le = Sle,
    Tle = _le,
    Ple = Tle("toUpperCase"),
    Ole = Ple;
const zv = Fe(Ole);

function qe(e) {
    return function() {
        return e
    }
}
const t5 = Math.cos,
    Rg = Math.sin,
    Ur = Math.sqrt,
    jg = Math.PI,
    Wv = 2 * jg,
    g1 = Math.PI,
    y1 = 2 * g1,
    Ia = 1e-6,
    kle = y1 - Ia;

function n5(e) {
    this._ += e[0];
    for (let t = 1, n = e.length; t < n; ++t) this._ += arguments[t] + e[t]
}

function Cle(e) {
    let t = Math.floor(e);
    if (!(t >= 0)) throw new Error(`invalid digits: ${e}`);
    if (t > 15) return n5;
    const n = 10 ** t;
    return function(r) {
        this._ += r[0];
        for (let i = 1, o = r.length; i < o; ++i) this._ += Math.round(arguments[i] * n) / n + r[i]
    }
}
class Ile {
    constructor(t) {
        this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "", this._append = t == null ? n5 : Cle(t)
    }
    moveTo(t, n) {
        this._append `M${this._x0=this._x1=+t},${this._y0=this._y1=+n}`
    }
    closePath() {
        this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append `Z`)
    }
    lineTo(t, n) {
        this._append `L${this._x1=+t},${this._y1=+n}`
    }
    quadraticCurveTo(t, n, r, i) {
        this._append `Q${+t},${+n},${this._x1=+r},${this._y1=+i}`
    }
    bezierCurveTo(t, n, r, i, o, a) {
        this._append `C${+t},${+n},${+r},${+i},${this._x1=+o},${this._y1=+a}`
    }
    arcTo(t, n, r, i, o) {
        if (t = +t, n = +n, r = +r, i = +i, o = +o, o < 0) throw new Error(`negative radius: ${o}`);
        let a = this._x1,
            s = this._y1,
            u = r - t,
            l = i - n,
            c = a - t,
            f = s - n,
            d = c * c + f * f;
        if (this._x1 === null) this._append `M${this._x1=t},${this._y1=n}`;
        else if (d > Ia)
            if (!(Math.abs(f * u - l * c) > Ia) || !o) this._append `L${this._x1=t},${this._y1=n}`;
            else {
                let h = r - a,
                    m = i - s,
                    p = u * u + l * l,
                    y = h * h + m * m,
                    g = Math.sqrt(p),
                    b = Math.sqrt(d),
                    v = o * Math.tan((g1 - Math.acos((p + d - y) / (2 * g * b))) / 2),
                    A = v / b,
                    w = v / g;
                Math.abs(A - 1) > Ia && this._append `L${t+A*c},${n+A*f}`, this._append `A${o},${o},0,0,${+(f*h>c*m)},${this._x1=t+w*u},${this._y1=n+w*l}`
            }
    }
    arc(t, n, r, i, o, a) {
        if (t = +t, n = +n, r = +r, a = !!a, r < 0) throw new Error(`negative radius: ${r}`);
        let s = r * Math.cos(i),
            u = r * Math.sin(i),
            l = t + s,
            c = n + u,
            f = 1 ^ a,
            d = a ? i - o : o - i;
        this._x1 === null ? this._append `M${l},${c}` : (Math.abs(this._x1 - l) > Ia || Math.abs(this._y1 - c) > Ia) && this._append `L${l},${c}`, r && (d < 0 && (d = d % y1 + y1), d > kle ? this._append `A${r},${r},0,1,${f},${t-s},${n-u}A${r},${r},0,1,${f},${this._x1=l},${this._y1=c}` : d > Ia && this._append `A${r},${r},0,${+(d>=g1)},${f},${this._x1=t+r*Math.cos(o)},${this._y1=n+r*Math.sin(o)}`)
    }
    rect(t, n, r, i) {
        this._append `M${this._x0=this._x1=+t},${this._y0=this._y1=+n}h${r=+r}v${+i}h${-r}Z`
    }
    toString() {
        return this._
    }
}

function D_(e) {
    let t = 3;
    return e.digits = function(n) {
        if (!arguments.length) return t;
        if (n == null) t = null;
        else {
            const r = Math.floor(n);
            if (!(r >= 0)) throw new RangeError(`invalid digits: ${n}`);
            t = r
        }
        return e
    }, () => new Ile(t)
}

function $_(e) {
    return typeof e == "object" && "length" in e ? e : Array.from(e)
}

function r5(e) {
    this._context = e
}
r5.prototype = {
    areaStart: function() {
        this._line = 0
    },
    areaEnd: function() {
        this._line = NaN
    },
    lineStart: function() {
        this._point = 0
    },
    lineEnd: function() {
        (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line
    },
    point: function(e, t) {
        switch (e = +e, t = +t, this._point) {
            case 0:
                this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
                break;
            case 1:
                this._point = 2;
            default:
                this._context.lineTo(e, t);
                break
        }
    }
};

function Gv(e) {
    return new r5(e)
}

function i5(e) {
    return e[0]
}

function o5(e) {
    return e[1]
}

function a5(e, t) {
    var n = qe(!0),
        r = null,
        i = Gv,
        o = null,
        a = D_(s);
    e = typeof e == "function" ? e : e === void 0 ? i5 : qe(e), t = typeof t == "function" ? t : t === void 0 ? o5 : qe(t);

    function s(u) {
        var l, c = (u = $_(u)).length,
            f, d = !1,
            h;
        for (r == null && (o = i(h = a())), l = 0; l <= c; ++l) !(l < c && n(f = u[l], l, u)) === d && ((d = !d) ? o.lineStart() : o.lineEnd()), d && o.point(+e(f, l, u), +t(f, l, u));
        if (h) return o = null, h + "" || null
    }
    return s.x = function(u) {
        return arguments.length ? (e = typeof u == "function" ? u : qe(+u), s) : e
    }, s.y = function(u) {
        return arguments.length ? (t = typeof u == "function" ? u : qe(+u), s) : t
    }, s.defined = function(u) {
        return arguments.length ? (n = typeof u == "function" ? u : qe(!!u), s) : n
    }, s.curve = function(u) {
        return arguments.length ? (i = u, r != null && (o = i(r)), s) : i
    }, s.context = function(u) {
        return arguments.length ? (u == null ? r = o = null : o = i(r = u), s) : r
    }, s
}

function ap(e, t, n) {
    var r = null,
        i = qe(!0),
        o = null,
        a = Gv,
        s = null,
        u = D_(l);
    e = typeof e == "function" ? e : e === void 0 ? i5 : qe(+e), t = typeof t == "function" ? t : qe(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? o5 : qe(+n);

    function l(f) {
        var d, h, m, p = (f = $_(f)).length,
            y, g = !1,
            b, v = new Array(p),
            A = new Array(p);
        for (o == null && (s = a(b = u())), d = 0; d <= p; ++d) {
            if (!(d < p && i(y = f[d], d, f)) === g)
                if (g = !g) h = d, s.areaStart(), s.lineStart();
                else {
                    for (s.lineEnd(), s.lineStart(), m = d - 1; m >= h; --m) s.point(v[m], A[m]);
                    s.lineEnd(), s.areaEnd()
                }
            g && (v[d] = +e(y, d, f), A[d] = +t(y, d, f), s.point(r ? +r(y, d, f) : v[d], n ? +n(y, d, f) : A[d]))
        }
        if (b) return s = null, b + "" || null
    }

    function c() {
        return a5().defined(i).curve(a).context(o)
    }
    return l.x = function(f) {
        return arguments.length ? (e = typeof f == "function" ? f : qe(+f), r = null, l) : e
    }, l.x0 = function(f) {
        return arguments.length ? (e = typeof f == "function" ? f : qe(+f), l) : e
    }, l.x1 = function(f) {
        return arguments.length ? (r = f == null ? null : typeof f == "function" ? f : qe(+f), l) : r
    }, l.y = function(f) {
        return arguments.length ? (t = typeof f == "function" ? f : qe(+f), n = null, l) : t
    }, l.y0 = function(f) {
        return arguments.length ? (t = typeof f == "function" ? f : qe(+f), l) : t
    }, l.y1 = function(f) {
        return arguments.length ? (n = f == null ? null : typeof f == "function" ? f : qe(+f), l) : n
    }, l.lineX0 = l.lineY0 = function() {
        return c().x(e).y(t)
    }, l.lineY1 = function() {
        return c().x(e).y(n)
    }, l.lineX1 = function() {
        return c().x(r).y(t)
    }, l.defined = function(f) {
        return arguments.length ? (i = typeof f == "function" ? f : qe(!!f), l) : i
    }, l.curve = function(f) {
        return arguments.length ? (a = f, o != null && (s = a(o)), l) : a
    }, l.context = function(f) {
        return arguments.length ? (f == null ? o = s = null : s = a(o = f), l) : o
    }, l
}
class s5 {
    constructor(t, n) {
        this._context = t, this._x = n
    }
    areaStart() {
        this._line = 0
    }
    areaEnd() {
        this._line = NaN
    }
    lineStart() {
        this._point = 0
    }
    lineEnd() {
        (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line
    }
    point(t, n) {
        switch (t = +t, n = +n, this._point) {
            case 0:
                {
                    this._point = 1,
                    this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
                    break
                }
            case 1:
                this._point = 2;
            default:
                {
                    this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, n, t, n) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + n) / 2, t, this._y0, t, n);
                    break
                }
        }
        this._x0 = t, this._y0 = n
    }
}

function Mle(e) {
    return new s5(e, !0)
}

function Nle(e) {
    return new s5(e, !1)
}
const L_ = {
        draw(e, t) {
            const n = Ur(t / jg);
            e.moveTo(n, 0), e.arc(0, 0, n, 0, Wv)
        }
    },
    Rle = {
        draw(e, t) {
            const n = Ur(t / 5) / 2;
            e.moveTo(-3 * n, -n), e.lineTo(-n, -n), e.lineTo(-n, -3 * n), e.lineTo(n, -3 * n), e.lineTo(n, -n), e.lineTo(3 * n, -n), e.lineTo(3 * n, n), e.lineTo(n, n), e.lineTo(n, 3 * n), e.lineTo(-n, 3 * n), e.lineTo(-n, n), e.lineTo(-3 * n, n), e.closePath()
        }
    },
    u5 = Ur(1 / 3),
    jle = u5 * 2,
    Ble = {
        draw(e, t) {
            const n = Ur(t / jle),
                r = n * u5;
            e.moveTo(0, -n), e.lineTo(r, 0), e.lineTo(0, n), e.lineTo(-r, 0), e.closePath()
        }
    },
    Dle = {
        draw(e, t) {
            const n = Ur(t),
                r = -n / 2;
            e.rect(r, r, n, n)
        }
    },
    $le = .8908130915292852,
    l5 = Rg(jg / 10) / Rg(7 * jg / 10),
    Lle = Rg(Wv / 10) * l5,
    Fle = -t5(Wv / 10) * l5,
    Ule = {
        draw(e, t) {
            const n = Ur(t * $le),
                r = Lle * n,
                i = Fle * n;
            e.moveTo(0, -n), e.lineTo(r, i);
            for (let o = 1; o < 5; ++o) {
                const a = Wv * o / 5,
                    s = t5(a),
                    u = Rg(a);
                e.lineTo(u * n, -s * n), e.lineTo(s * r - u * i, u * r + s * i)
            }
            e.closePath()
        }
    },
    Mb = Ur(3),
    Hle = {
        draw(e, t) {
            const n = -Ur(t / (Mb * 3));
            e.moveTo(0, n * 2), e.lineTo(-Mb * n, -n), e.lineTo(Mb * n, -n), e.closePath()
        }
    },
    Jn = -.5,
    er = Ur(3) / 2,
    v1 = 1 / Ur(12),
    Vle = (v1 / 2 + 1) * 3,
    zle = {
        draw(e, t) {
            const n = Ur(t / Vle),
                r = n / 2,
                i = n * v1,
                o = r,
                a = n * v1 + n,
                s = -o,
                u = a;
            e.moveTo(r, i), e.lineTo(o, a), e.lineTo(s, u), e.lineTo(Jn * r - er * i, er * r + Jn * i), e.lineTo(Jn * o - er * a, er * o + Jn * a), e.lineTo(Jn * s - er * u, er * s + Jn * u), e.lineTo(Jn * r + er * i, Jn * i - er * r), e.lineTo(Jn * o + er * a, Jn * a - er * o), e.lineTo(Jn * s + er * u, Jn * u - er * s), e.closePath()
        }
    };

function Wle(e, t) {
    let n = null,
        r = D_(i);
    e = typeof e == "function" ? e : qe(e || L_), t = typeof t == "function" ? t : qe(t === void 0 ? 64 : +t);

    function i() {
        let o;
        if (n || (n = o = r()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), o) return n = null, o + "" || null
    }
    return i.type = function(o) {
        return arguments.length ? (e = typeof o == "function" ? o : qe(o), i) : e
    }, i.size = function(o) {
        return arguments.length ? (t = typeof o == "function" ? o : qe(+o), i) : t
    }, i.context = function(o) {
        return arguments.length ? (n = o ? ? null, i) : n
    }, i
}

function Bg() {}

function Dg(e, t, n) {
    e._context.bezierCurveTo((2 * e._x0 + e._x1) / 3, (2 * e._y0 + e._y1) / 3, (e._x0 + 2 * e._x1) / 3, (e._y0 + 2 * e._y1) / 3, (e._x0 + 4 * e._x1 + t) / 6, (e._y0 + 4 * e._y1 + n) / 6)
}

function c5(e) {
    this._context = e
}
c5.prototype = {
    areaStart: function() {
        this._line = 0
    },
    areaEnd: function() {
        this._line = NaN
    },
    lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0
    },
    lineEnd: function() {
        switch (this._point) {
            case 3:
                Dg(this, this._x1, this._y1);
            case 2:
                this._context.lineTo(this._x1, this._y1);
                break
        }(this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line
    },
    point: function(e, t) {
        switch (e = +e, t = +t, this._point) {
            case 0:
                this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
                break;
            case 1:
                this._point = 2;
                break;
            case 2:
                this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
            default:
                Dg(this, e, t);
                break
        }
        this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t
    }
};

function Gle(e) {
    return new c5(e)
}

function f5(e) {
    this._context = e
}
f5.prototype = {
    areaStart: Bg,
    areaEnd: Bg,
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0
    },
    lineEnd: function() {
        switch (this._point) {
            case 1:
                {
                    this._context.moveTo(this._x2, this._y2),
                    this._context.closePath();
                    break
                }
            case 2:
                {
                    this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3),
                    this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3),
                    this._context.closePath();
                    break
                }
            case 3:
                {
                    this.point(this._x2, this._y2),
                    this.point(this._x3, this._y3),
                    this.point(this._x4, this._y4);
                    break
                }
        }
    },
    point: function(e, t) {
        switch (e = +e, t = +t, this._point) {
            case 0:
                this._point = 1, this._x2 = e, this._y2 = t;
                break;
            case 1:
                this._point = 2, this._x3 = e, this._y3 = t;
                break;
            case 2:
                this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
                break;
            default:
                Dg(this, e, t);
                break
        }
        this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t
    }
};

function qle(e) {
    return new f5(e)
}

function d5(e) {
    this._context = e
}
d5.prototype = {
    areaStart: function() {
        this._line = 0
    },
    areaEnd: function() {
        this._line = NaN
    },
    lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0
    },
    lineEnd: function() {
        (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line
    },
    point: function(e, t) {
        switch (e = +e, t = +t, this._point) {
            case 0:
                this._point = 1;
                break;
            case 1:
                this._point = 2;
                break;
            case 2:
                this._point = 3;
                var n = (this._x0 + 4 * this._x1 + e) / 6,
                    r = (this._y0 + 4 * this._y1 + t) / 6;
                this._line ? this._context.lineTo(n, r) : this._context.moveTo(n, r);
                break;
            case 3:
                this._point = 4;
            default:
                Dg(this, e, t);
                break
        }
        this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t
    }
};

function Kle(e) {
    return new d5(e)
}

function h5(e) {
    this._context = e
}
h5.prototype = {
    areaStart: Bg,
    areaEnd: Bg,
    lineStart: function() {
        this._point = 0
    },
    lineEnd: function() {
        this._point && this._context.closePath()
    },
    point: function(e, t) {
        e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t))
    }
};

function Qle(e) {
    return new h5(e)
}

function Bk(e) {
    return e < 0 ? -1 : 1
}

function Dk(e, t, n) {
    var r = e._x1 - e._x0,
        i = t - e._x1,
        o = (e._y1 - e._y0) / (r || i < 0 && -0),
        a = (n - e._y1) / (i || r < 0 && -0),
        s = (o * i + a * r) / (r + i);
    return (Bk(o) + Bk(a)) * Math.min(Math.abs(o), Math.abs(a), .5 * Math.abs(s)) || 0
}

function $k(e, t) {
    var n = e._x1 - e._x0;
    return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t
}

function Nb(e, t, n) {
    var r = e._x0,
        i = e._y0,
        o = e._x1,
        a = e._y1,
        s = (o - r) / 3;
    e._context.bezierCurveTo(r + s, i + s * t, o - s, a - s * n, o, a)
}

function $g(e) {
    this._context = e
}
$g.prototype = {
    areaStart: function() {
        this._line = 0
    },
    areaEnd: function() {
        this._line = NaN
    },
    lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0
    },
    lineEnd: function() {
        switch (this._point) {
            case 2:
                this._context.lineTo(this._x1, this._y1);
                break;
            case 3:
                Nb(this, this._t0, $k(this, this._t0));
                break
        }(this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line
    },
    point: function(e, t) {
        var n = NaN;
        if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
            switch (this._point) {
                case 0:
                    this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
                    break;
                case 1:
                    this._point = 2;
                    break;
                case 2:
                    this._point = 3, Nb(this, $k(this, n = Dk(this, e, t)), n);
                    break;
                default:
                    Nb(this, this._t0, n = Dk(this, e, t));
                    break
            }
            this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n
        }
    }
};

function p5(e) {
    this._context = new m5(e)
}(p5.prototype = Object.create($g.prototype)).point = function(e, t) {
    $g.prototype.point.call(this, t, e)
};

function m5(e) {
    this._context = e
}
m5.prototype = {
    moveTo: function(e, t) {
        this._context.moveTo(t, e)
    },
    closePath: function() {
        this._context.closePath()
    },
    lineTo: function(e, t) {
        this._context.lineTo(t, e)
    },
    bezierCurveTo: function(e, t, n, r, i, o) {
        this._context.bezierCurveTo(t, e, r, n, o, i)
    }
};

function Yle(e) {
    return new $g(e)
}

function Xle(e) {
    return new p5(e)
}

function g5(e) {
    this._context = e
}
g5.prototype = {
    areaStart: function() {
        this._line = 0
    },
    areaEnd: function() {
        this._line = NaN
    },
    lineStart: function() {
        this._x = [], this._y = []
    },
    lineEnd: function() {
        var e = this._x,
            t = this._y,
            n = e.length;
        if (n)
            if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2) this._context.lineTo(e[1], t[1]);
            else
                for (var r = Lk(e), i = Lk(t), o = 0, a = 1; a < n; ++o, ++a) this._context.bezierCurveTo(r[0][o], i[0][o], r[1][o], i[1][o], e[a], t[a]);
        (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null
    },
    point: function(e, t) {
        this._x.push(+e), this._y.push(+t)
    }
};

function Lk(e) {
    var t, n = e.length - 1,
        r, i = new Array(n),
        o = new Array(n),
        a = new Array(n);
    for (i[0] = 0, o[0] = 2, a[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t) i[t] = 1, o[t] = 4, a[t] = 4 * e[t] + 2 * e[t + 1];
    for (i[n - 1] = 2, o[n - 1] = 7, a[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t) r = i[t] / o[t - 1], o[t] -= r, a[t] -= r * a[t - 1];
    for (i[n - 1] = a[n - 1] / o[n - 1], t = n - 2; t >= 0; --t) i[t] = (a[t] - i[t + 1]) / o[t];
    for (o[n - 1] = (e[n] + i[n - 1]) / 2, t = 0; t < n - 1; ++t) o[t] = 2 * e[t + 1] - i[t + 1];
    return [i, o]
}

function Zle(e) {
    return new g5(e)
}

function qv(e, t) {
    this._context = e, this._t = t
}
qv.prototype = {
    areaStart: function() {
        this._line = 0
    },
    areaEnd: function() {
        this._line = NaN
    },
    lineStart: function() {
        this._x = this._y = NaN, this._point = 0
    },
    lineEnd: function() {
        0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line)
    },
    point: function(e, t) {
        switch (e = +e, t = +t, this._point) {
            case 0:
                this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
                break;
            case 1:
                this._point = 2;
            default:
                {
                    if (this._t <= 0) this._context.lineTo(this._x, t),
                    this._context.lineTo(e, t);
                    else {
                        var n = this._x * (1 - this._t) + e * this._t;
                        this._context.lineTo(n, this._y), this._context.lineTo(n, t)
                    }
                    break
                }
        }
        this._x = e, this._y = t
    }
};

function Jle(e) {
    return new qv(e, .5)
}

function ece(e) {
    return new qv(e, 0)
}

function tce(e) {
    return new qv(e, 1)
}

function pl(e, t) {
    if ((a = e.length) > 1)
        for (var n = 1, r, i, o = e[t[0]], a, s = o.length; n < a; ++n)
            for (i = o, o = e[t[n]], r = 0; r < s; ++r) o[r][1] += o[r][0] = isNaN(i[r][1]) ? i[r][0] : i[r][1]
}

function b1(e) {
    for (var t = e.length, n = new Array(t); --t >= 0;) n[t] = t;
    return n
}

function nce(e, t) {
    return e[t]
}

function rce(e) {
    const t = [];
    return t.key = e, t
}

function ice() {
    var e = qe([]),
        t = b1,
        n = pl,
        r = nce;

    function i(o) {
        var a = Array.from(e.apply(this, arguments), rce),
            s, u = a.length,
            l = -1,
            c;
        for (const f of o)
            for (s = 0, ++l; s < u; ++s)(a[s][l] = [0, +r(f, a[s].key, l, o)]).data = f;
        for (s = 0, c = $_(t(a)); s < u; ++s) a[c[s]].index = s;
        return n(a, c), a
    }
    return i.keys = function(o) {
        return arguments.length ? (e = typeof o == "function" ? o : qe(Array.from(o)), i) : e
    }, i.value = function(o) {
        return arguments.length ? (r = typeof o == "function" ? o : qe(+o), i) : r
    }, i.order = function(o) {
        return arguments.length ? (t = o == null ? b1 : typeof o == "function" ? o : qe(Array.from(o)), i) : t
    }, i.offset = function(o) {
        return arguments.length ? (n = o ? ? pl, i) : n
    }, i
}

function oce(e, t) {
    if ((r = e.length) > 0) {
        for (var n, r, i = 0, o = e[0].length, a; i < o; ++i) {
            for (a = n = 0; n < r; ++n) a += e[n][i][1] || 0;
            if (a)
                for (n = 0; n < r; ++n) e[n][i][1] /= a
        }
        pl(e, t)
    }
}

function ace(e, t) {
    if ((i = e.length) > 0) {
        for (var n = 0, r = e[t[0]], i, o = r.length; n < o; ++n) {
            for (var a = 0, s = 0; a < i; ++a) s += e[a][n][1] || 0;
            r[n][1] += r[n][0] = -s / 2
        }
        pl(e, t)
    }
}

function sce(e, t) {
    if (!(!((a = e.length) > 0) || !((o = (i = e[t[0]]).length) > 0))) {
        for (var n = 0, r = 1, i, o, a; r < o; ++r) {
            for (var s = 0, u = 0, l = 0; s < a; ++s) {
                for (var c = e[t[s]], f = c[r][1] || 0, d = c[r - 1][1] || 0, h = (f - d) / 2, m = 0; m < s; ++m) {
                    var p = e[t[m]],
                        y = p[r][1] || 0,
                        g = p[r - 1][1] || 0;
                    h += y - g
                }
                u += f, l += h * f
            }
            i[r - 1][1] += i[r - 1][0] = n, u && (n -= l / u)
        }
        i[r - 1][1] += i[r - 1][0] = n, pl(e, t)
    }
}

function vd(e) {
    "@babel/helpers - typeof";
    return vd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, vd(e)
}
var uce = ["type", "size", "sizeType"];

function w1() {
    return w1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, w1.apply(this, arguments)
}

function Fk(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function Uk(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? Fk(Object(n), !0).forEach(function(r) {
            lce(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Fk(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function lce(e, t, n) {
    return t = cce(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function cce(e) {
    var t = fce(e, "string");
    return vd(t) == "symbol" ? t : t + ""
}

function fce(e, t) {
    if (vd(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (vd(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}

function dce(e, t) {
    if (e == null) return {};
    var n = hce(e, t),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        for (i = 0; i < o.length; i++) r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
    }
    return n
}

function hce(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
            if (t.indexOf(r) >= 0) continue;
            n[r] = e[r]
        }
    return n
}
var y5 = {
        symbolCircle: L_,
        symbolCross: Rle,
        symbolDiamond: Ble,
        symbolSquare: Dle,
        symbolStar: Ule,
        symbolTriangle: Hle,
        symbolWye: zle
    },
    pce = Math.PI / 180,
    mce = function(t) {
        var n = "symbol".concat(zv(t));
        return y5[n] || L_
    },
    gce = function(t, n, r) {
        if (n === "area") return t;
        switch (r) {
            case "cross":
                return 5 * t * t / 9;
            case "diamond":
                return .5 * t * t / Math.sqrt(3);
            case "square":
                return t * t;
            case "star":
                {
                    var i = 18 * pce;
                    return 1.25 * t * t * (Math.tan(i) - Math.tan(i * 2) * Math.pow(Math.tan(i), 2))
                }
            case "triangle":
                return Math.sqrt(3) * t * t / 4;
            case "wye":
                return (21 - 10 * Math.sqrt(3)) * t * t / 8;
            default:
                return Math.PI * t * t / 4
        }
    },
    yce = function(t, n) {
        y5["symbol".concat(zv(t))] = n
    },
    F_ = function(t) {
        var n = t.type,
            r = n === void 0 ? "circle" : n,
            i = t.size,
            o = i === void 0 ? 64 : i,
            a = t.sizeType,
            s = a === void 0 ? "area" : a,
            u = dce(t, uce),
            l = Uk(Uk({}, u), {}, {
                type: r,
                size: o,
                sizeType: s
            }),
            c = function() {
                var y = mce(r),
                    g = Wle().type(y).size(gce(o, s, r));
                return g()
            },
            f = l.className,
            d = l.cx,
            h = l.cy,
            m = _e(l, !0);
        return d === +d && h === +h && o === +o ? R.createElement("path", w1({}, m, {
            className: Me("recharts-symbols", f),
            transform: "translate(".concat(d, ", ").concat(h, ")"),
            d: c()
        })) : null
    };
F_.registerSymbol = yce;

function ml(e) {
    "@babel/helpers - typeof";
    return ml = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, ml(e)
}

function x1() {
    return x1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, x1.apply(this, arguments)
}

function Hk(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function vce(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? Hk(Object(n), !0).forEach(function(r) {
            bd(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Hk(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function bce(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function wce(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, b5(r.key), r)
    }
}

function xce(e, t, n) {
    return t && wce(e.prototype, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function Ace(e, t, n) {
    return t = Lg(t), Ece(e, v5() ? Reflect.construct(t, n || [], Lg(e).constructor) : t.apply(e, n))
}

function Ece(e, t) {
    if (t && (ml(t) === "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return Sce(e)
}

function Sce(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function v5() {
    try {
        var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (v5 = function() {
        return !!e
    })()
}

function Lg(e) {
    return Lg = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }, Lg(e)
}

function _ce(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(e, "prototype", {
        writable: !1
    }), t && A1(e, t)
}

function A1(e, t) {
    return A1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i, r
    }, A1(e, t)
}

function bd(e, t, n) {
    return t = b5(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function b5(e) {
    var t = Tce(e, "string");
    return ml(t) == "symbol" ? t : t + ""
}

function Tce(e, t) {
    if (ml(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (ml(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(e)
}
var wr = 32,
    U_ = function(e) {
        function t() {
            return bce(this, t), Ace(this, t, arguments)
        }
        return _ce(t, e), xce(t, [{
            key: "renderIcon",
            value: function(r) {
                var i = this.props.inactiveColor,
                    o = wr / 2,
                    a = wr / 6,
                    s = wr / 3,
                    u = r.inactive ? i : r.color;
                if (r.type === "plainline") return R.createElement("line", {
                    strokeWidth: 4,
                    fill: "none",
                    stroke: u,
                    strokeDasharray: r.payload.strokeDasharray,
                    x1: 0,
                    y1: o,
                    x2: wr,
                    y2: o,
                    className: "recharts-legend-icon"
                });
                if (r.type === "line") return R.createElement("path", {
                    strokeWidth: 4,
                    fill: "none",
                    stroke: u,
                    d: "M0,".concat(o, "h").concat(s, `
            A`).concat(a, ",").concat(a, ",0,1,1,").concat(2 * s, ",").concat(o, `
            H`).concat(wr, "M").concat(2 * s, ",").concat(o, `
            A`).concat(a, ",").concat(a, ",0,1,1,").concat(s, ",").concat(o),
                    className: "recharts-legend-icon"
                });
                if (r.type === "rect") return R.createElement("path", {
                    stroke: "none",
                    fill: u,
                    d: "M0,".concat(wr / 8, "h").concat(wr, "v").concat(wr * 3 / 4, "h").concat(-32, "z"),
                    className: "recharts-legend-icon"
                });
                if (R.isValidElement(r.legendIcon)) {
                    var l = vce({}, r);
                    return delete l.legendIcon, R.cloneElement(r.legendIcon, l)
                }
                return R.createElement(F_, {
                    fill: u,
                    cx: o,
                    cy: o,
                    size: wr,
                    sizeType: "diameter",
                    type: r.type
                })
            }
        }, {
            key: "renderItems",
            value: function() {
                var r = this,
                    i = this.props,
                    o = i.payload,
                    a = i.iconSize,
                    s = i.layout,
                    u = i.formatter,
                    l = i.inactiveColor,
                    c = {
                        x: 0,
                        y: 0,
                        width: wr,
                        height: wr
                    },
                    f = {
                        display: s === "horizontal" ? "inline-block" : "block",
                        marginRight: 10
                    },
                    d = {
                        display: "inline-block",
                        verticalAlign: "middle",
                        marginRight: 4
                    };
                return o.map(function(h, m) {
                    var p = h.formatter || u,
                        y = Me(bd(bd({
                            "recharts-legend-item": !0
                        }, "legend-item-".concat(m), !0), "inactive", h.inactive));
                    if (h.type === "none") return null;
                    var g = Ae(h.value) ? null : h.value;
                    us(!Ae(h.value), `The name property is also required when using a function for the dataKey of a chart's cartesian components. Ex: <Bar name="Name of my Data"/>`);
                    var b = h.inactive ? l : h.color;
                    return R.createElement("li", x1({
                        className: y,
                        style: f,
                        key: "legend-item-".concat(m)
                    }, Ng(r.props, h, m)), R.createElement(d1, {
                        width: a,
                        height: a,
                        viewBox: c,
                        style: d
                    }, r.renderIcon(h)), R.createElement("span", {
                        className: "recharts-legend-item-text",
                        style: {
                            color: b
                        }
                    }, p ? p(g, h, m) : g))
                })
            }
        }, {
            key: "render",
            value: function() {
                var r = this.props,
                    i = r.payload,
                    o = r.layout,
                    a = r.align;
                if (!i || !i.length) return null;
                var s = {
                    padding: 0,
                    margin: 0,
                    textAlign: o === "horizontal" ? a : "left"
                };
                return R.createElement("ul", {
                    className: "recharts-default-legend",
                    style: s
                }, this.renderItems())
            }
        }])
    }(S.PureComponent);
bd(U_, "displayName", "Legend");
bd(U_, "defaultProps", {
    iconSize: 14,
    layout: "horizontal",
    align: "center",
    verticalAlign: "middle",
    inactiveColor: "#ccc"
});
var Pce = Iv;

function Oce() {
    this.__data__ = new Pce, this.size = 0
}
var kce = Oce;

function Cce(e) {
    var t = this.__data__,
        n = t.delete(e);
    return this.size = t.size, n
}
var Ice = Cce;

function Mce(e) {
    return this.__data__.get(e)
}
var Nce = Mce;

function Rce(e) {
    return this.__data__.has(e)
}
var jce = Rce,
    Bce = Iv,
    Dce = O_,
    $ce = k_,
    Lce = 200;

function Fce(e, t) {
    var n = this.__data__;
    if (n instanceof Bce) {
        var r = n.__data__;
        if (!Dce || r.length < Lce - 1) return r.push([e, t]), this.size = ++n.size, this;
        n = this.__data__ = new $ce(r)
    }
    return n.set(e, t), this.size = n.size, this
}
var Uce = Fce,
    Hce = Iv,
    Vce = kce,
    zce = Ice,
    Wce = Nce,
    Gce = jce,
    qce = Uce;

function tc(e) {
    var t = this.__data__ = new Hce(e);
    this.size = t.size
}
tc.prototype.clear = Vce;
tc.prototype.delete = zce;
tc.prototype.get = Wce;
tc.prototype.has = Gce;
tc.prototype.set = qce;
var w5 = tc,
    Kce = "__lodash_hash_undefined__";

function Qce(e) {
    return this.__data__.set(e, Kce), this
}
var Yce = Qce;

function Xce(e) {
    return this.__data__.has(e)
}
var Zce = Xce,
    Jce = k_,
    efe = Yce,
    tfe = Zce;

function Fg(e) {
    var t = -1,
        n = e == null ? 0 : e.length;
    for (this.__data__ = new Jce; ++t < n;) this.add(e[t])
}
Fg.prototype.add = Fg.prototype.push = efe;
Fg.prototype.has = tfe;
var x5 = Fg;

function nfe(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length; ++n < r;)
        if (t(e[n], n, e)) return !0;
    return !1
}
var A5 = nfe;

function rfe(e, t) {
    return e.has(t)
}
var E5 = rfe,
    ife = x5,
    ofe = A5,
    afe = E5,
    sfe = 1,
    ufe = 2;

function lfe(e, t, n, r, i, o) {
    var a = n & sfe,
        s = e.length,
        u = t.length;
    if (s != u && !(a && u > s)) return !1;
    var l = o.get(e),
        c = o.get(t);
    if (l && c) return l == t && c == e;
    var f = -1,
        d = !0,
        h = n & ufe ? new ife : void 0;
    for (o.set(e, t), o.set(t, e); ++f < s;) {
        var m = e[f],
            p = t[f];
        if (r) var y = a ? r(p, m, f, t, e, o) : r(m, p, f, e, t, o);
        if (y !== void 0) {
            if (y) continue;
            d = !1;
            break
        }
        if (h) {
            if (!ofe(t, function(g, b) {
                    if (!afe(h, b) && (m === g || i(m, g, n, r, o))) return h.push(b)
                })) {
                d = !1;
                break
            }
        } else if (!(m === p || i(m, p, n, r, o))) {
            d = !1;
            break
        }
    }
    return o.delete(e), o.delete(t), d
}
var S5 = lfe,
    cfe = bi,
    ffe = cfe.Uint8Array,
    dfe = ffe;

function hfe(e) {
    var t = -1,
        n = Array(e.size);
    return e.forEach(function(r, i) {
        n[++t] = [i, r]
    }), n
}
var pfe = hfe;

function mfe(e) {
    var t = -1,
        n = Array(e.size);
    return e.forEach(function(r) {
        n[++t] = r
    }), n
}
var H_ = mfe,
    Vk = Ah,
    zk = dfe,
    gfe = P_,
    yfe = S5,
    vfe = pfe,
    bfe = H_,
    wfe = 1,
    xfe = 2,
    Afe = "[object Boolean]",
    Efe = "[object Date]",
    Sfe = "[object Error]",
    _fe = "[object Map]",
    Tfe = "[object Number]",
    Pfe = "[object RegExp]",
    Ofe = "[object Set]",
    kfe = "[object String]",
    Cfe = "[object Symbol]",
    Ife = "[object ArrayBuffer]",
    Mfe = "[object DataView]",
    Wk = Vk ? Vk.prototype : void 0,
    Rb = Wk ? Wk.valueOf : void 0;

function Nfe(e, t, n, r, i, o, a) {
    switch (n) {
        case Mfe:
            if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1;
            e = e.buffer, t = t.buffer;
        case Ife:
            return !(e.byteLength != t.byteLength || !o(new zk(e), new zk(t)));
        case Afe:
        case Efe:
        case Tfe:
            return gfe(+e, +t);
        case Sfe:
            return e.name == t.name && e.message == t.message;
        case Pfe:
        case kfe:
            return e == t + "";
        case _fe:
            var s = vfe;
        case Ofe:
            var u = r & wfe;
            if (s || (s = bfe), e.size != t.size && !u) return !1;
            var l = a.get(e);
            if (l) return l == t;
            r |= xfe, a.set(e, t);
            var c = yfe(s(e), s(t), r, i, o, a);
            return a.delete(e), c;
        case Cfe:
            if (Rb) return Rb.call(e) == Rb.call(t)
    }
    return !1
}
var Rfe = Nfe;

function jfe(e, t) {
    for (var n = -1, r = t.length, i = e.length; ++n < r;) e[i + n] = t[n];
    return e
}
var _5 = jfe,
    Bfe = _5,
    Dfe = Rn;

function $fe(e, t, n) {
    var r = t(e);
    return Dfe(e) ? r : Bfe(r, n(e))
}
var Lfe = $fe;

function Ffe(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length, i = 0, o = []; ++n < r;) {
        var a = e[n];
        t(a, n, e) && (o[i++] = a)
    }
    return o
}
var Ufe = Ffe;

function Hfe() {
    return []
}
var Vfe = Hfe,
    zfe = Ufe,
    Wfe = Vfe,
    Gfe = Object.prototype,
    qfe = Gfe.propertyIsEnumerable,
    Gk = Object.getOwnPropertySymbols,
    Kfe = Gk ? function(e) {
        return e == null ? [] : (e = Object(e), zfe(Gk(e), function(t) {
            return qfe.call(e, t)
        }))
    } : Wfe,
    Qfe = Kfe;

function Yfe(e, t) {
    for (var n = -1, r = Array(e); ++n < e;) r[n] = t(n);
    return r
}
var Xfe = Yfe,
    Zfe = vo,
    Jfe = bo,
    ede = "[object Arguments]";

function tde(e) {
    return Jfe(e) && Zfe(e) == ede
}
var nde = tde,
    qk = nde,
    rde = bo,
    T5 = Object.prototype,
    ide = T5.hasOwnProperty,
    ode = T5.propertyIsEnumerable,
    ade = qk(function() {
        return arguments
    }()) ? qk : function(e) {
        return rde(e) && ide.call(e, "callee") && !ode.call(e, "callee")
    },
    V_ = ade,
    Ug = {
        exports: {}
    };

function sde() {
    return !1
}
var ude = sde;
Ug.exports;
(function(e, t) {
    var n = bi,
        r = ude,
        i = t && !t.nodeType && t,
        o = i && !0 && e && !e.nodeType && e,
        a = o && o.exports === i,
        s = a ? n.Buffer : void 0,
        u = s ? s.isBuffer : void 0,
        l = u || r;
    e.exports = l
})(Ug, Ug.exports);
var P5 = Ug.exports,
    lde = 9007199254740991,
    cde = /^(?:0|[1-9]\d*)$/;

function fde(e, t) {
    var n = typeof e;
    return t = t ? ? lde, !!t && (n == "number" || n != "symbol" && cde.test(e)) && e > -1 && e % 1 == 0 && e < t
}
var z_ = fde,
    dde = 9007199254740991;

function hde(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= dde
}
var W_ = hde,
    pde = vo,
    mde = W_,
    gde = bo,
    yde = "[object Arguments]",
    vde = "[object Array]",
    bde = "[object Boolean]",
    wde = "[object Date]",
    xde = "[object Error]",
    Ade = "[object Function]",
    Ede = "[object Map]",
    Sde = "[object Number]",
    _de = "[object Object]",
    Tde = "[object RegExp]",
    Pde = "[object Set]",
    Ode = "[object String]",
    kde = "[object WeakMap]",
    Cde = "[object ArrayBuffer]",
    Ide = "[object DataView]",
    Mde = "[object Float32Array]",
    Nde = "[object Float64Array]",
    Rde = "[object Int8Array]",
    jde = "[object Int16Array]",
    Bde = "[object Int32Array]",
    Dde = "[object Uint8Array]",
    $de = "[object Uint8ClampedArray]",
    Lde = "[object Uint16Array]",
    Fde = "[object Uint32Array]",
    Ze = {};
Ze[Mde] = Ze[Nde] = Ze[Rde] = Ze[jde] = Ze[Bde] = Ze[Dde] = Ze[$de] = Ze[Lde] = Ze[Fde] = !0;
Ze[yde] = Ze[vde] = Ze[Cde] = Ze[bde] = Ze[Ide] = Ze[wde] = Ze[xde] = Ze[Ade] = Ze[Ede] = Ze[Sde] = Ze[_de] = Ze[Tde] = Ze[Pde] = Ze[Ode] = Ze[kde] = !1;

function Ude(e) {
    return gde(e) && mde(e.length) && !!Ze[pde(e)]
}
var Hde = Ude;

function Vde(e) {
    return function(t) {
        return e(t)
    }
}
var O5 = Vde,
    Hg = {
        exports: {}
    };
Hg.exports;
(function(e, t) {
    var n = BL,
        r = t && !t.nodeType && t,
        i = r && !0 && e && !e.nodeType && e,
        o = i && i.exports === r,
        a = o && n.process,
        s = function() {
            try {
                var u = i && i.require && i.require("util").types;
                return u || a && a.binding && a.binding("util")
            } catch {}
        }();
    e.exports = s
})(Hg, Hg.exports);
var zde = Hg.exports,
    Wde = Hde,
    Gde = O5,
    Kk = zde,
    Qk = Kk && Kk.isTypedArray,
    qde = Qk ? Gde(Qk) : Wde,
    k5 = qde,
    Kde = Xfe,
    Qde = V_,
    Yde = Rn,
    Xde = P5,
    Zde = z_,
    Jde = k5,
    ehe = Object.prototype,
    the = ehe.hasOwnProperty;

function nhe(e, t) {
    var n = Yde(e),
        r = !n && Qde(e),
        i = !n && !r && Xde(e),
        o = !n && !r && !i && Jde(e),
        a = n || r || i || o,
        s = a ? Kde(e.length, String) : [],
        u = s.length;
    for (var l in e)(t || the.call(e, l)) && !(a && (l == "length" || i && (l == "offset" || l == "parent") || o && (l == "buffer" || l == "byteLength" || l == "byteOffset") || Zde(l, u))) && s.push(l);
    return s
}
var rhe = nhe,
    ihe = Object.prototype;

function ohe(e) {
    var t = e && e.constructor,
        n = typeof t == "function" && t.prototype || ihe;
    return e === n
}
var ahe = ohe;

function she(e, t) {
    return function(n) {
        return e(t(n))
    }
}
var C5 = she,
    uhe = C5,
    lhe = uhe(Object.keys, Object),
    che = lhe,
    fhe = ahe,
    dhe = che,
    hhe = Object.prototype,
    phe = hhe.hasOwnProperty;

function mhe(e) {
    if (!fhe(e)) return dhe(e);
    var t = [];
    for (var n in Object(e)) phe.call(e, n) && n != "constructor" && t.push(n);
    return t
}
var ghe = mhe,
    yhe = T_,
    vhe = W_;

function bhe(e) {
    return e != null && vhe(e.length) && !yhe(e)
}
var Kv = bhe,
    whe = rhe,
    xhe = ghe,
    Ahe = Kv;

function Ehe(e) {
    return Ahe(e) ? whe(e) : xhe(e)
}
var G_ = Ehe,
    She = Lfe,
    _he = Qfe,
    The = G_;

function Phe(e) {
    return She(e, The, _he)
}
var Ohe = Phe,
    Yk = Ohe,
    khe = 1,
    Che = Object.prototype,
    Ihe = Che.hasOwnProperty;

function Mhe(e, t, n, r, i, o) {
    var a = n & khe,
        s = Yk(e),
        u = s.length,
        l = Yk(t),
        c = l.length;
    if (u != c && !a) return !1;
    for (var f = u; f--;) {
        var d = s[f];
        if (!(a ? d in t : Ihe.call(t, d))) return !1
    }
    var h = o.get(e),
        m = o.get(t);
    if (h && m) return h == t && m == e;
    var p = !0;
    o.set(e, t), o.set(t, e);
    for (var y = a; ++f < u;) {
        d = s[f];
        var g = e[d],
            b = t[d];
        if (r) var v = a ? r(b, g, d, t, e, o) : r(g, b, d, e, t, o);
        if (!(v === void 0 ? g === b || i(g, b, n, r, o) : v)) {
            p = !1;
            break
        }
        y || (y = d == "constructor")
    }
    if (p && !y) {
        var A = e.constructor,
            w = t.constructor;
        A != w && "constructor" in e && "constructor" in t && !(typeof A == "function" && A instanceof A && typeof w == "function" && w instanceof w) && (p = !1)
    }
    return o.delete(e), o.delete(t), p
}
var Nhe = Mhe,
    Rhe = $s,
    jhe = bi,
    Bhe = Rhe(jhe, "DataView"),
    Dhe = Bhe,
    $he = $s,
    Lhe = bi,
    Fhe = $he(Lhe, "Promise"),
    Uhe = Fhe,
    Hhe = $s,
    Vhe = bi,
    zhe = Hhe(Vhe, "Set"),
    I5 = zhe,
    Whe = $s,
    Ghe = bi,
    qhe = Whe(Ghe, "WeakMap"),
    Khe = qhe,
    E1 = Dhe,
    S1 = O_,
    _1 = Uhe,
    T1 = I5,
    P1 = Khe,
    M5 = vo,
    nc = $L,
    Xk = "[object Map]",
    Qhe = "[object Object]",
    Zk = "[object Promise]",
    Jk = "[object Set]",
    eC = "[object WeakMap]",
    tC = "[object DataView]",
    Yhe = nc(E1),
    Xhe = nc(S1),
    Zhe = nc(_1),
    Jhe = nc(T1),
    epe = nc(P1),
    Ma = M5;
(E1 && Ma(new E1(new ArrayBuffer(1))) != tC || S1 && Ma(new S1) != Xk || _1 && Ma(_1.resolve()) != Zk || T1 && Ma(new T1) != Jk || P1 && Ma(new P1) != eC) && (Ma = function(e) {
    var t = M5(e),
        n = t == Qhe ? e.constructor : void 0,
        r = n ? nc(n) : "";
    if (r) switch (r) {
        case Yhe:
            return tC;
        case Xhe:
            return Xk;
        case Zhe:
            return Zk;
        case Jhe:
            return Jk;
        case epe:
            return eC
    }
    return t
});
var tpe = Ma,
    jb = w5,
    npe = S5,
    rpe = Rfe,
    ipe = Nhe,
    nC = tpe,
    rC = Rn,
    iC = P5,
    ope = k5,
    ape = 1,
    oC = "[object Arguments]",
    aC = "[object Array]",
    sp = "[object Object]",
    spe = Object.prototype,
    sC = spe.hasOwnProperty;

function upe(e, t, n, r, i, o) {
    var a = rC(e),
        s = rC(t),
        u = a ? aC : nC(e),
        l = s ? aC : nC(t);
    u = u == oC ? sp : u, l = l == oC ? sp : l;
    var c = u == sp,
        f = l == sp,
        d = u == l;
    if (d && iC(e)) {
        if (!iC(t)) return !1;
        a = !0, c = !1
    }
    if (d && !c) return o || (o = new jb), a || ope(e) ? npe(e, t, n, r, i, o) : rpe(e, t, u, n, r, i, o);
    if (!(n & ape)) {
        var h = c && sC.call(e, "__wrapped__"),
            m = f && sC.call(t, "__wrapped__");
        if (h || m) {
            var p = h ? e.value() : e,
                y = m ? t.value() : t;
            return o || (o = new jb), i(p, y, n, r, o)
        }
    }
    return d ? (o || (o = new jb), ipe(e, t, n, r, i, o)) : !1
}
var lpe = upe,
    cpe = lpe,
    uC = bo;

function N5(e, t, n, r, i) {
    return e === t ? !0 : e == null || t == null || !uC(e) && !uC(t) ? e !== e && t !== t : cpe(e, t, n, r, N5, i)
}
var q_ = N5,
    fpe = w5,
    dpe = q_,
    hpe = 1,
    ppe = 2;

function mpe(e, t, n, r) {
    var i = n.length,
        o = i,
        a = !r;
    if (e == null) return !o;
    for (e = Object(e); i--;) {
        var s = n[i];
        if (a && s[2] ? s[1] !== e[s[0]] : !(s[0] in e)) return !1
    }
    for (; ++i < o;) {
        s = n[i];
        var u = s[0],
            l = e[u],
            c = s[1];
        if (a && s[2]) {
            if (l === void 0 && !(u in e)) return !1
        } else {
            var f = new fpe;
            if (r) var d = r(l, c, u, e, t, f);
            if (!(d === void 0 ? dpe(c, l, hpe | ppe, r, f) : d)) return !1
        }
    }
    return !0
}
var gpe = mpe,
    ype = ya;

function vpe(e) {
    return e === e && !ype(e)
}
var R5 = vpe,
    bpe = R5,
    wpe = G_;

function xpe(e) {
    for (var t = wpe(e), n = t.length; n--;) {
        var r = t[n],
            i = e[r];
        t[n] = [r, i, bpe(i)]
    }
    return t
}
var Ape = xpe;

function Epe(e, t) {
    return function(n) {
        return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n))
    }
}
var j5 = Epe,
    Spe = gpe,
    _pe = Ape,
    Tpe = j5;

function Ppe(e) {
    var t = _pe(e);
    return t.length == 1 && t[0][2] ? Tpe(t[0][0], t[0][1]) : function(n) {
        return n === e || Spe(n, e, t)
    }
}
var Ope = Ppe;

function kpe(e, t) {
    return e != null && t in Object(e)
}
var Cpe = kpe,
    Ipe = VL,
    Mpe = V_,
    Npe = Rn,
    Rpe = z_,
    jpe = W_,
    Bpe = Nv;

function Dpe(e, t, n) {
    t = Ipe(t, e);
    for (var r = -1, i = t.length, o = !1; ++r < i;) {
        var a = Bpe(t[r]);
        if (!(o = e != null && n(e, a))) break;
        e = e[a]
    }
    return o || ++r != i ? o : (i = e == null ? 0 : e.length, !!i && jpe(i) && Rpe(a, i) && (Npe(e) || Mpe(e)))
}
var $pe = Dpe,
    Lpe = Cpe,
    Fpe = $pe;

function Upe(e, t) {
    return e != null && Fpe(e, t, Lpe)
}
var Hpe = Upe,
    Vpe = q_,
    zpe = zL,
    Wpe = Hpe,
    Gpe = __,
    qpe = R5,
    Kpe = j5,
    Qpe = Nv,
    Ype = 1,
    Xpe = 2;

function Zpe(e, t) {
    return Gpe(e) && qpe(t) ? Kpe(Qpe(e), t) : function(n) {
        var r = zpe(n, e);
        return r === void 0 && r === t ? Wpe(n, e) : Vpe(t, r, Ype | Xpe)
    }
}
var Jpe = Zpe;

function eme(e) {
    return e
}
var rc = eme;

function tme(e) {
    return function(t) {
        return t == null ? void 0 : t[e]
    }
}
var nme = tme,
    rme = M_;

function ime(e) {
    return function(t) {
        return rme(t, e)
    }
}
var ome = ime,
    ame = nme,
    sme = ome,
    ume = __,
    lme = Nv;

function cme(e) {
    return ume(e) ? ame(lme(e)) : sme(e)
}
var fme = cme,
    dme = Ope,
    hme = Jpe,
    pme = rc,
    mme = Rn,
    gme = fme;

function yme(e) {
    return typeof e == "function" ? e : e == null ? pme : typeof e == "object" ? mme(e) ? hme(e[0], e[1]) : dme(e) : gme(e)
}
var ic = yme;

function vme(e, t, n, r) {
    for (var i = e.length, o = n + (r ? 1 : -1); r ? o-- : ++o < i;)
        if (t(e[o], o, e)) return o;
    return -1
}
var bme = vme;

function wme(e) {
    return e !== e
}
var xme = wme;

function Ame(e, t, n) {
    for (var r = n - 1, i = e.length; ++r < i;)
        if (e[r] === t) return r;
    return -1
}
var Eme = Ame,
    Sme = bme,
    _me = xme,
    Tme = Eme;

function Pme(e, t, n) {
    return t === t ? Tme(e, t, n) : Sme(e, _me, n)
}
var Ome = Pme,
    kme = Ome;

function Cme(e, t) {
    var n = e == null ? 0 : e.length;
    return !!n && kme(e, t, 0) > -1
}
var Ime = Cme;

function Mme(e, t, n) {
    for (var r = -1, i = e == null ? 0 : e.length; ++r < i;)
        if (n(t, e[r])) return !0;
    return !1
}
var Nme = Mme;

function Rme() {}
var jme = Rme,
    Bb = I5,
    Bme = jme,
    Dme = H_,
    $me = 1 / 0,
    Lme = Bb && 1 / Dme(new Bb([, -0]))[1] == $me ? function(e) {
        return new Bb(e)
    } : Bme,
    Fme = Lme,
    Ume = x5,
    Hme = Ime,
    Vme = Nme,
    zme = E5,
    Wme = Fme,
    Gme = H_,
    qme = 200;

function Kme(e, t, n) {
    var r = -1,
        i = Hme,
        o = e.length,
        a = !0,
        s = [],
        u = s;
    if (n) a = !1, i = Vme;
    else if (o >= qme) {
        var l = t ? null : Wme(e);
        if (l) return Gme(l);
        a = !1, i = zme, u = new Ume
    } else u = t ? [] : s;
    e: for (; ++r < o;) {
        var c = e[r],
            f = t ? t(c) : c;
        if (c = n || c !== 0 ? c : 0, a && f === f) {
            for (var d = u.length; d--;)
                if (u[d] === f) continue e;
            t && u.push(f), s.push(c)
        } else i(u, f, n) || (u !== s && u.push(f), s.push(c))
    }
    return s
}
var Qme = Kme,
    Yme = ic,
    Xme = Qme;

function Zme(e, t) {
    return e && e.length ? Xme(e, Yme(t)) : []
}
var Jme = Zme;
const lC = Fe(Jme);

function B5(e, t, n) {
    return t === !0 ? lC(e, n) : Ae(t) ? lC(e, t) : e
}

function gl(e) {
    "@babel/helpers - typeof";
    return gl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, gl(e)
}
var ege = ["ref"];

function cC(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function Pi(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? cC(Object(n), !0).forEach(function(r) {
            Qv(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cC(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function tge(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function fC(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, $5(r.key), r)
    }
}

function nge(e, t, n) {
    return t && fC(e.prototype, t), n && fC(e, n), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function rge(e, t, n) {
    return t = Vg(t), ige(e, D5() ? Reflect.construct(t, n || [], Vg(e).constructor) : t.apply(e, n))
}

function ige(e, t) {
    if (t && (gl(t) === "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return oge(e)
}

function oge(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function D5() {
    try {
        var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (D5 = function() {
        return !!e
    })()
}

function Vg(e) {
    return Vg = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }, Vg(e)
}

function age(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(e, "prototype", {
        writable: !1
    }), t && O1(e, t)
}

function O1(e, t) {
    return O1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i, r
    }, O1(e, t)
}

function Qv(e, t, n) {
    return t = $5(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function $5(e) {
    var t = sge(e, "string");
    return gl(t) == "symbol" ? t : t + ""
}

function sge(e, t) {
    if (gl(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (gl(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(e)
}

function uge(e, t) {
    if (e == null) return {};
    var n = lge(e, t),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        for (i = 0; i < o.length; i++) r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
    }
    return n
}

function lge(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
            if (t.indexOf(r) >= 0) continue;
            n[r] = e[r]
        }
    return n
}

function cge(e) {
    return e.value
}

function fge(e, t) {
    if (R.isValidElement(e)) return R.cloneElement(e, t);
    if (typeof e == "function") return R.createElement(e, t);
    t.ref;
    var n = uge(t, ege);
    return R.createElement(U_, n)
}
var dC = 1,
    ls = function(e) {
        function t() {
            var n;
            tge(this, t);
            for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++) i[o] = arguments[o];
            return n = rge(this, t, [].concat(i)), Qv(n, "lastBoundingBox", {
                width: -1,
                height: -1
            }), n
        }
        return age(t, e), nge(t, [{
            key: "componentDidMount",
            value: function() {
                this.updateBBox()
            }
        }, {
            key: "componentDidUpdate",
            value: function() {
                this.updateBBox()
            }
        }, {
            key: "getBBox",
            value: function() {
                if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
                    var r = this.wrapperNode.getBoundingClientRect();
                    return r.height = this.wrapperNode.offsetHeight, r.width = this.wrapperNode.offsetWidth, r
                }
                return null
            }
        }, {
            key: "updateBBox",
            value: function() {
                var r = this.props.onBBoxUpdate,
                    i = this.getBBox();
                i ? (Math.abs(i.width - this.lastBoundingBox.width) > dC || Math.abs(i.height - this.lastBoundingBox.height) > dC) && (this.lastBoundingBox.width = i.width, this.lastBoundingBox.height = i.height, r && r(i)) : (this.lastBoundingBox.width !== -1 || this.lastBoundingBox.height !== -1) && (this.lastBoundingBox.width = -1, this.lastBoundingBox.height = -1, r && r(null))
            }
        }, {
            key: "getBBoxSnapshot",
            value: function() {
                return this.lastBoundingBox.width >= 0 && this.lastBoundingBox.height >= 0 ? Pi({}, this.lastBoundingBox) : {
                    width: 0,
                    height: 0
                }
            }
        }, {
            key: "getDefaultPosition",
            value: function(r) {
                var i = this.props,
                    o = i.layout,
                    a = i.align,
                    s = i.verticalAlign,
                    u = i.margin,
                    l = i.chartWidth,
                    c = i.chartHeight,
                    f, d;
                if (!r || (r.left === void 0 || r.left === null) && (r.right === void 0 || r.right === null))
                    if (a === "center" && o === "vertical") {
                        var h = this.getBBoxSnapshot();
                        f = {
                            left: ((l || 0) - h.width) / 2
                        }
                    } else f = a === "right" ? {
                        right: u && u.right || 0
                    } : {
                        left: u && u.left || 0
                    };
                if (!r || (r.top === void 0 || r.top === null) && (r.bottom === void 0 || r.bottom === null))
                    if (s === "middle") {
                        var m = this.getBBoxSnapshot();
                        d = {
                            top: ((c || 0) - m.height) / 2
                        }
                    } else d = s === "bottom" ? {
                        bottom: u && u.bottom || 0
                    } : {
                        top: u && u.top || 0
                    };
                return Pi(Pi({}, f), d)
            }
        }, {
            key: "render",
            value: function() {
                var r = this,
                    i = this.props,
                    o = i.content,
                    a = i.width,
                    s = i.height,
                    u = i.wrapperStyle,
                    l = i.payloadUniqBy,
                    c = i.payload,
                    f = Pi(Pi({
                        position: "absolute",
                        width: a || "auto",
                        height: s || "auto"
                    }, this.getDefaultPosition(u)), u);
                return R.createElement("div", {
                    className: "recharts-legend-wrapper",
                    style: f,
                    ref: function(h) {
                        r.wrapperNode = h
                    }
                }, fge(o, Pi(Pi({}, this.props), {}, {
                    payload: B5(c, l, cge)
                })))
            }
        }], [{
            key: "getWithHeight",
            value: function(r, i) {
                var o = Pi(Pi({}, this.defaultProps), r.props),
                    a = o.layout;
                return a === "vertical" && Y(r.props.height) ? {
                    height: r.props.height
                } : a === "horizontal" ? {
                    width: r.props.width || i
                } : null
            }
        }])
    }(S.PureComponent);
Qv(ls, "displayName", "Legend");
Qv(ls, "defaultProps", {
    iconSize: 14,
    layout: "horizontal",
    align: "center",
    verticalAlign: "bottom"
});
var hC = Ah,
    dge = V_,
    hge = Rn,
    pC = hC ? hC.isConcatSpreadable : void 0;

function pge(e) {
    return hge(e) || dge(e) || !!(pC && e && e[pC])
}
var mge = pge,
    gge = _5,
    yge = mge;

function L5(e, t, n, r, i) {
    var o = -1,
        a = e.length;
    for (n || (n = yge), i || (i = []); ++o < a;) {
        var s = e[o];
        t > 0 && n(s) ? t > 1 ? L5(s, t - 1, n, r, i) : gge(i, s) : r || (i[i.length] = s)
    }
    return i
}
var F5 = L5;

function vge(e) {
    return function(t, n, r) {
        for (var i = -1, o = Object(t), a = r(t), s = a.length; s--;) {
            var u = a[e ? s : ++i];
            if (n(o[u], u, o) === !1) break
        }
        return t
    }
}
var bge = vge,
    wge = bge,
    xge = wge(),
    Age = xge,
    Ege = Age,
    Sge = G_;

function _ge(e, t) {
    return e && Ege(e, t, Sge)
}
var U5 = _ge,
    Tge = Kv;

function Pge(e, t) {
    return function(n, r) {
        if (n == null) return n;
        if (!Tge(n)) return e(n, r);
        for (var i = n.length, o = t ? i : -1, a = Object(n);
            (t ? o-- : ++o < i) && r(a[o], o, a) !== !1;);
        return n
    }
}
var Oge = Pge,
    kge = U5,
    Cge = Oge,
    Ige = Cge(kge),
    K_ = Ige,
    Mge = K_,
    Nge = Kv;

function Rge(e, t) {
    var n = -1,
        r = Nge(e) ? Array(e.length) : [];
    return Mge(e, function(i, o, a) {
        r[++n] = t(i, o, a)
    }), r
}
var H5 = Rge;

function jge(e, t) {
    var n = e.length;
    for (e.sort(t); n--;) e[n] = e[n].value;
    return e
}
var Bge = jge,
    mC = Ql;

function Dge(e, t) {
    if (e !== t) {
        var n = e !== void 0,
            r = e === null,
            i = e === e,
            o = mC(e),
            a = t !== void 0,
            s = t === null,
            u = t === t,
            l = mC(t);
        if (!s && !l && !o && e > t || o && a && u && !s && !l || r && a && u || !n && u || !i) return 1;
        if (!r && !o && !l && e < t || l && n && i && !r && !o || s && n && i || !a && i || !u) return -1
    }
    return 0
}
var $ge = Dge,
    Lge = $ge;

function Fge(e, t, n) {
    for (var r = -1, i = e.criteria, o = t.criteria, a = i.length, s = n.length; ++r < a;) {
        var u = Lge(i[r], o[r]);
        if (u) {
            if (r >= s) return u;
            var l = n[r];
            return u * (l == "desc" ? -1 : 1)
        }
    }
    return e.index - t.index
}
var Uge = Fge,
    Db = I_,
    Hge = M_,
    Vge = ic,
    zge = H5,
    Wge = Bge,
    Gge = O5,
    qge = Uge,
    Kge = rc,
    Qge = Rn;

function Yge(e, t, n) {
    t.length ? t = Db(t, function(o) {
        return Qge(o) ? function(a) {
            return Hge(a, o.length === 1 ? o[0] : o)
        } : o
    }) : t = [Kge];
    var r = -1;
    t = Db(t, Gge(Vge));
    var i = zge(e, function(o, a, s) {
        var u = Db(t, function(l) {
            return l(o)
        });
        return {
            criteria: u,
            index: ++r,
            value: o
        }
    });
    return Wge(i, function(o, a) {
        return qge(o, a, n)
    })
}
var Xge = Yge;

function Zge(e, t, n) {
    switch (n.length) {
        case 0:
            return e.call(t);
        case 1:
            return e.call(t, n[0]);
        case 2:
            return e.call(t, n[0], n[1]);
        case 3:
            return e.call(t, n[0], n[1], n[2])
    }
    return e.apply(t, n)
}
var Jge = Zge,
    eye = Jge,
    gC = Math.max;

function tye(e, t, n) {
    return t = gC(t === void 0 ? e.length - 1 : t, 0),
        function() {
            for (var r = arguments, i = -1, o = gC(r.length - t, 0), a = Array(o); ++i < o;) a[i] = r[t + i];
            i = -1;
            for (var s = Array(t + 1); ++i < t;) s[i] = r[i];
            return s[t] = n(a), eye(e, this, s)
        }
}
var nye = tye;

function rye(e) {
    return function() {
        return e
    }
}
var iye = rye,
    oye = $s,
    aye = function() {
        try {
            var e = oye(Object, "defineProperty");
            return e({}, "", {}), e
        } catch {}
    }(),
    V5 = aye,
    sye = iye,
    yC = V5,
    uye = rc,
    lye = yC ? function(e, t) {
        return yC(e, "toString", {
            configurable: !0,
            enumerable: !1,
            value: sye(t),
            writable: !0
        })
    } : uye,
    cye = lye,
    fye = 800,
    dye = 16,
    hye = Date.now;

function pye(e) {
    var t = 0,
        n = 0;
    return function() {
        var r = hye(),
            i = dye - (r - n);
        if (n = r, i > 0) {
            if (++t >= fye) return arguments[0]
        } else t = 0;
        return e.apply(void 0, arguments)
    }
}
var mye = pye,
    gye = cye,
    yye = mye,
    vye = yye(gye),
    bye = vye,
    wye = rc,
    xye = nye,
    Aye = bye;

function Eye(e, t) {
    return Aye(xye(e, t, wye), e + "")
}
var Sye = Eye,
    _ye = P_,
    Tye = Kv,
    Pye = z_,
    Oye = ya;

function kye(e, t, n) {
    if (!Oye(n)) return !1;
    var r = typeof t;
    return (r == "number" ? Tye(n) && Pye(t, n.length) : r == "string" && t in n) ? _ye(n[t], e) : !1
}
var Yv = kye,
    Cye = F5,
    Iye = Xge,
    Mye = Sye,
    vC = Yv,
    Nye = Mye(function(e, t) {
        if (e == null) return [];
        var n = t.length;
        return n > 1 && vC(e, t[0], t[1]) ? t = [] : n > 2 && vC(t[0], t[1], t[2]) && (t = [t[0]]), Iye(e, Cye(t, 1), [])
    }),
    Rye = Nye;
const Q_ = Fe(Rye);

function wd(e) {
    "@babel/helpers - typeof";
    return wd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, wd(e)
}

function k1() {
    return k1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, k1.apply(this, arguments)
}

function jye(e, t) {
    return Lye(e) || $ye(e, t) || Dye(e, t) || Bye()
}

function Bye() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function Dye(e, t) {
    if (e) {
        if (typeof e == "string") return bC(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return bC(e, t)
    }
}

function bC(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}

function $ye(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
        var r, i, o, a, s = [],
            u = !0,
            l = !1;
        try {
            if (o = (n = n.call(e)).next, t !== 0)
                for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0);
        } catch (c) {
            l = !0, i = c
        } finally {
            try {
                if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return
            } finally {
                if (l) throw i
            }
        }
        return s
    }
}

function Lye(e) {
    if (Array.isArray(e)) return e
}

function wC(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function $b(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? wC(Object(n), !0).forEach(function(r) {
            Fye(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wC(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function Fye(e, t, n) {
    return t = Uye(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function Uye(e) {
    var t = Hye(e, "string");
    return wd(t) == "symbol" ? t : t + ""
}

function Hye(e, t) {
    if (wd(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (wd(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}

function Vye(e) {
    return Array.isArray(e) && Rt(e[0]) && Rt(e[1]) ? e.join(" ~ ") : e
}
var zye = function(t) {
    var n = t.separator,
        r = n === void 0 ? " : " : n,
        i = t.contentStyle,
        o = i === void 0 ? {} : i,
        a = t.itemStyle,
        s = a === void 0 ? {} : a,
        u = t.labelStyle,
        l = u === void 0 ? {} : u,
        c = t.payload,
        f = t.formatter,
        d = t.itemSorter,
        h = t.wrapperClassName,
        m = t.labelClassName,
        p = t.label,
        y = t.labelFormatter,
        g = t.accessibilityLayer,
        b = g === void 0 ? !1 : g,
        v = function() {
            if (c && c.length) {
                var M = {
                        padding: 0,
                        margin: 0
                    },
                    B = (d ? Q_(c, d) : c).map(function(L, P) {
                        if (L.type === "none") return null;
                        var C = $b({
                                display: "block",
                                paddingTop: 4,
                                paddingBottom: 4,
                                color: L.color || "#000"
                            }, s),
                            j = L.formatter || f || Vye,
                            N = L.value,
                            D = L.name,
                            $ = N,
                            V = D;
                        if (j && $ != null && V != null) {
                            var H = j(N, D, L, P, c);
                            if (Array.isArray(H)) {
                                var Q = jye(H, 2);
                                $ = Q[0], V = Q[1]
                            } else $ = H
                        }
                        return R.createElement("li", {
                            className: "recharts-tooltip-item",
                            key: "tooltip-item-".concat(P),
                            style: C
                        }, Rt(V) ? R.createElement("span", {
                            className: "recharts-tooltip-item-name"
                        }, V) : null, Rt(V) ? R.createElement("span", {
                            className: "recharts-tooltip-item-separator"
                        }, r) : null, R.createElement("span", {
                            className: "recharts-tooltip-item-value"
                        }, $), R.createElement("span", {
                            className: "recharts-tooltip-item-unit"
                        }, L.unit || ""))
                    });
                return R.createElement("ul", {
                    className: "recharts-tooltip-item-list",
                    style: M
                }, B)
            }
            return null
        },
        A = $b({
            margin: 0,
            padding: 10,
            backgroundColor: "#fff",
            border: "1px solid #ccc",
            whiteSpace: "nowrap"
        }, o),
        w = $b({
            margin: 0
        }, l),
        x = !Pe(p),
        T = x ? p : "",
        _ = Me("recharts-default-tooltip", h),
        O = Me("recharts-tooltip-label", m);
    x && y && c !== void 0 && c !== null && (T = y(p, c));
    var k = b ? {
        role: "status",
        "aria-live": "assertive"
    } : {};
    return R.createElement("div", k1({
        className: _,
        style: A
    }, k), R.createElement("p", {
        className: O,
        style: w
    }, R.isValidElement(T) ? T : "".concat(T)), v())
};

function xd(e) {
    "@babel/helpers - typeof";
    return xd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, xd(e)
}

function up(e, t, n) {
    return t = Wye(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function Wye(e) {
    var t = Gye(e, "string");
    return xd(t) == "symbol" ? t : t + ""
}

function Gye(e, t) {
    if (xd(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (xd(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}
var Tc = "recharts-tooltip-wrapper",
    qye = {
        visibility: "hidden"
    };

function Kye(e) {
    var t = e.coordinate,
        n = e.translateX,
        r = e.translateY;
    return Me(Tc, up(up(up(up({}, "".concat(Tc, "-right"), Y(n) && t && Y(t.x) && n >= t.x), "".concat(Tc, "-left"), Y(n) && t && Y(t.x) && n < t.x), "".concat(Tc, "-bottom"), Y(r) && t && Y(t.y) && r >= t.y), "".concat(Tc, "-top"), Y(r) && t && Y(t.y) && r < t.y))
}

function xC(e) {
    var t = e.allowEscapeViewBox,
        n = e.coordinate,
        r = e.key,
        i = e.offsetTopLeft,
        o = e.position,
        a = e.reverseDirection,
        s = e.tooltipDimension,
        u = e.viewBox,
        l = e.viewBoxDimension;
    if (o && Y(o[r])) return o[r];
    var c = n[r] - s - i,
        f = n[r] + i;
    if (t[r]) return a[r] ? c : f;
    if (a[r]) {
        var d = c,
            h = u[r];
        return d < h ? Math.max(f, u[r]) : Math.max(c, u[r])
    }
    var m = f + s,
        p = u[r] + l;
    return m > p ? Math.max(c, u[r]) : Math.max(f, u[r])
}

function Qye(e) {
    var t = e.translateX,
        n = e.translateY,
        r = e.useTranslate3d;
    return {
        transform: r ? "translate3d(".concat(t, "px, ").concat(n, "px, 0)") : "translate(".concat(t, "px, ").concat(n, "px)")
    }
}

function Yye(e) {
    var t = e.allowEscapeViewBox,
        n = e.coordinate,
        r = e.offsetTopLeft,
        i = e.position,
        o = e.reverseDirection,
        a = e.tooltipBox,
        s = e.useTranslate3d,
        u = e.viewBox,
        l, c, f;
    return a.height > 0 && a.width > 0 && n ? (c = xC({
        allowEscapeViewBox: t,
        coordinate: n,
        key: "x",
        offsetTopLeft: r,
        position: i,
        reverseDirection: o,
        tooltipDimension: a.width,
        viewBox: u,
        viewBoxDimension: u.width
    }), f = xC({
        allowEscapeViewBox: t,
        coordinate: n,
        key: "y",
        offsetTopLeft: r,
        position: i,
        reverseDirection: o,
        tooltipDimension: a.height,
        viewBox: u,
        viewBoxDimension: u.height
    }), l = Qye({
        translateX: c,
        translateY: f,
        useTranslate3d: s
    })) : l = qye, {
        cssProperties: l,
        cssClasses: Kye({
            translateX: c,
            translateY: f,
            coordinate: n
        })
    }
}

function yl(e) {
    "@babel/helpers - typeof";
    return yl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, yl(e)
}

function AC(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function EC(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? AC(Object(n), !0).forEach(function(r) {
            I1(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : AC(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function Xye(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function Zye(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, W5(r.key), r)
    }
}

function Jye(e, t, n) {
    return t && Zye(e.prototype, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function eve(e, t, n) {
    return t = zg(t), tve(e, z5() ? Reflect.construct(t, n || [], zg(e).constructor) : t.apply(e, n))
}

function tve(e, t) {
    if (t && (yl(t) === "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return nve(e)
}

function nve(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function z5() {
    try {
        var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (z5 = function() {
        return !!e
    })()
}

function zg(e) {
    return zg = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }, zg(e)
}

function rve(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(e, "prototype", {
        writable: !1
    }), t && C1(e, t)
}

function C1(e, t) {
    return C1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i, r
    }, C1(e, t)
}

function I1(e, t, n) {
    return t = W5(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function W5(e) {
    var t = ive(e, "string");
    return yl(t) == "symbol" ? t : t + ""
}

function ive(e, t) {
    if (yl(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (yl(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(e)
}
var SC = 1,
    ove = function(e) {
        function t() {
            var n;
            Xye(this, t);
            for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++) i[o] = arguments[o];
            return n = eve(this, t, [].concat(i)), I1(n, "state", {
                dismissed: !1,
                dismissedAtCoordinate: {
                    x: 0,
                    y: 0
                },
                lastBoundingBox: {
                    width: -1,
                    height: -1
                }
            }), I1(n, "handleKeyDown", function(a) {
                if (a.key === "Escape") {
                    var s, u, l, c;
                    n.setState({
                        dismissed: !0,
                        dismissedAtCoordinate: {
                            x: (s = (u = n.props.coordinate) === null || u === void 0 ? void 0 : u.x) !== null && s !== void 0 ? s : 0,
                            y: (l = (c = n.props.coordinate) === null || c === void 0 ? void 0 : c.y) !== null && l !== void 0 ? l : 0
                        }
                    })
                }
            }), n
        }
        return rve(t, e), Jye(t, [{
            key: "updateBBox",
            value: function() {
                if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
                    var r = this.wrapperNode.getBoundingClientRect();
                    (Math.abs(r.width - this.state.lastBoundingBox.width) > SC || Math.abs(r.height - this.state.lastBoundingBox.height) > SC) && this.setState({
                        lastBoundingBox: {
                            width: r.width,
                            height: r.height
                        }
                    })
                } else(this.state.lastBoundingBox.width !== -1 || this.state.lastBoundingBox.height !== -1) && this.setState({
                    lastBoundingBox: {
                        width: -1,
                        height: -1
                    }
                })
            }
        }, {
            key: "componentDidMount",
            value: function() {
                document.addEventListener("keydown", this.handleKeyDown), this.updateBBox()
            }
        }, {
            key: "componentWillUnmount",
            value: function() {
                document.removeEventListener("keydown", this.handleKeyDown)
            }
        }, {
            key: "componentDidUpdate",
            value: function() {
                var r, i;
                this.props.active && this.updateBBox(), this.state.dismissed && (((r = this.props.coordinate) === null || r === void 0 ? void 0 : r.x) !== this.state.dismissedAtCoordinate.x || ((i = this.props.coordinate) === null || i === void 0 ? void 0 : i.y) !== this.state.dismissedAtCoordinate.y) && (this.state.dismissed = !1)
            }
        }, {
            key: "render",
            value: function() {
                var r = this,
                    i = this.props,
                    o = i.active,
                    a = i.allowEscapeViewBox,
                    s = i.animationDuration,
                    u = i.animationEasing,
                    l = i.children,
                    c = i.coordinate,
                    f = i.hasPayload,
                    d = i.isAnimationActive,
                    h = i.offset,
                    m = i.position,
                    p = i.reverseDirection,
                    y = i.useTranslate3d,
                    g = i.viewBox,
                    b = i.wrapperStyle,
                    v = Yye({
                        allowEscapeViewBox: a,
                        coordinate: c,
                        offsetTopLeft: h,
                        position: m,
                        reverseDirection: p,
                        tooltipBox: this.state.lastBoundingBox,
                        useTranslate3d: y,
                        viewBox: g
                    }),
                    A = v.cssClasses,
                    w = v.cssProperties,
                    x = EC(EC({
                        transition: d && o ? "transform ".concat(s, "ms ").concat(u) : void 0
                    }, w), {}, {
                        pointerEvents: "none",
                        visibility: !this.state.dismissed && o && f ? "visible" : "hidden",
                        position: "absolute",
                        top: 0,
                        left: 0
                    }, b);
                return R.createElement("div", {
                    tabIndex: -1,
                    className: A,
                    style: x,
                    ref: function(_) {
                        r.wrapperNode = _
                    }
                }, l)
            }
        }])
    }(S.PureComponent),
    ave = function() {
        return !(typeof window < "u" && window.document && window.document.createElement && window.setTimeout)
    },
    oc = {
        isSsr: ave()
    };

function vl(e) {
    "@babel/helpers - typeof";
    return vl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, vl(e)
}

function _C(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function TC(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? _C(Object(n), !0).forEach(function(r) {
            Y_(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _C(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function sve(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function uve(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, q5(r.key), r)
    }
}

function lve(e, t, n) {
    return t && uve(e.prototype, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function cve(e, t, n) {
    return t = Wg(t), fve(e, G5() ? Reflect.construct(t, n || [], Wg(e).constructor) : t.apply(e, n))
}

function fve(e, t) {
    if (t && (vl(t) === "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return dve(e)
}

function dve(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function G5() {
    try {
        var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (G5 = function() {
        return !!e
    })()
}

function Wg(e) {
    return Wg = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }, Wg(e)
}

function hve(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(e, "prototype", {
        writable: !1
    }), t && M1(e, t)
}

function M1(e, t) {
    return M1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i, r
    }, M1(e, t)
}

function Y_(e, t, n) {
    return t = q5(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function q5(e) {
    var t = pve(e, "string");
    return vl(t) == "symbol" ? t : t + ""
}

function pve(e, t) {
    if (vl(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (vl(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(e)
}

function mve(e) {
    return e.dataKey
}

function gve(e, t) {
    return R.isValidElement(e) ? R.cloneElement(e, t) : typeof e == "function" ? R.createElement(e, t) : R.createElement(zye, t)
}
var Yr = function(e) {
    function t() {
        return sve(this, t), cve(this, t, arguments)
    }
    return hve(t, e), lve(t, [{
        key: "render",
        value: function() {
            var r = this,
                i = this.props,
                o = i.active,
                a = i.allowEscapeViewBox,
                s = i.animationDuration,
                u = i.animationEasing,
                l = i.content,
                c = i.coordinate,
                f = i.filterNull,
                d = i.isAnimationActive,
                h = i.offset,
                m = i.payload,
                p = i.payloadUniqBy,
                y = i.position,
                g = i.reverseDirection,
                b = i.useTranslate3d,
                v = i.viewBox,
                A = i.wrapperStyle,
                w = m ? ? [];
            f && w.length && (w = B5(m.filter(function(T) {
                return T.value != null && (T.hide !== !0 || r.props.includeHidden)
            }), p, mve));
            var x = w.length > 0;
            return R.createElement(ove, {
                allowEscapeViewBox: a,
                animationDuration: s,
                animationEasing: u,
                isAnimationActive: d,
                active: o,
                coordinate: c,
                hasPayload: x,
                offset: h,
                position: y,
                reverseDirection: g,
                useTranslate3d: b,
                viewBox: v,
                wrapperStyle: A
            }, gve(l, TC(TC({}, this.props), {}, {
                payload: w
            })))
        }
    }])
}(S.PureComponent);
Y_(Yr, "displayName", "Tooltip");
Y_(Yr, "defaultProps", {
    accessibilityLayer: !1,
    allowEscapeViewBox: {
        x: !1,
        y: !1
    },
    animationDuration: 400,
    animationEasing: "ease",
    contentStyle: {},
    coordinate: {
        x: 0,
        y: 0
    },
    cursor: !0,
    cursorStyle: {},
    filterNull: !0,
    isAnimationActive: !oc.isSsr,
    itemStyle: {},
    labelStyle: {},
    offset: 10,
    reverseDirection: {
        x: !1,
        y: !1
    },
    separator: " : ",
    trigger: "hover",
    useTranslate3d: !1,
    viewBox: {
        x: 0,
        y: 0,
        height: 0,
        width: 0
    },
    wrapperStyle: {}
});
var yve = bi,
    vve = function() {
        return yve.Date.now()
    },
    bve = vve,
    wve = /\s/;

function xve(e) {
    for (var t = e.length; t-- && wve.test(e.charAt(t)););
    return t
}
var Ave = xve,
    Eve = Ave,
    Sve = /^\s+/;

function _ve(e) {
    return e && e.slice(0, Eve(e) + 1).replace(Sve, "")
}
var Tve = _ve,
    Pve = Tve,
    PC = ya,
    Ove = Ql,
    OC = NaN,
    kve = /^[-+]0x[0-9a-f]+$/i,
    Cve = /^0b[01]+$/i,
    Ive = /^0o[0-7]+$/i,
    Mve = parseInt;

function Nve(e) {
    if (typeof e == "number") return e;
    if (Ove(e)) return OC;
    if (PC(e)) {
        var t = typeof e.valueOf == "function" ? e.valueOf() : e;
        e = PC(t) ? t + "" : t
    }
    if (typeof e != "string") return e === 0 ? e : +e;
    e = Pve(e);
    var n = Cve.test(e);
    return n || Ive.test(e) ? Mve(e.slice(2), n ? 2 : 8) : kve.test(e) ? OC : +e
}
var K5 = Nve,
    Rve = ya,
    Lb = bve,
    kC = K5,
    jve = "Expected a function",
    Bve = Math.max,
    Dve = Math.min;

function $ve(e, t, n) {
    var r, i, o, a, s, u, l = 0,
        c = !1,
        f = !1,
        d = !0;
    if (typeof e != "function") throw new TypeError(jve);
    t = kC(t) || 0, Rve(n) && (c = !!n.leading, f = "maxWait" in n, o = f ? Bve(kC(n.maxWait) || 0, t) : o, d = "trailing" in n ? !!n.trailing : d);

    function h(x) {
        var T = r,
            _ = i;
        return r = i = void 0, l = x, a = e.apply(_, T), a
    }

    function m(x) {
        return l = x, s = setTimeout(g, t), c ? h(x) : a
    }

    function p(x) {
        var T = x - u,
            _ = x - l,
            O = t - T;
        return f ? Dve(O, o - _) : O
    }

    function y(x) {
        var T = x - u,
            _ = x - l;
        return u === void 0 || T >= t || T < 0 || f && _ >= o
    }

    function g() {
        var x = Lb();
        if (y(x)) return b(x);
        s = setTimeout(g, p(x))
    }

    function b(x) {
        return s = void 0, d && r ? h(x) : (r = i = void 0, a)
    }

    function v() {
        s !== void 0 && clearTimeout(s), l = 0, r = u = i = s = void 0
    }

    function A() {
        return s === void 0 ? a : b(Lb())
    }

    function w() {
        var x = Lb(),
            T = y(x);
        if (r = arguments, i = this, u = x, T) {
            if (s === void 0) return m(u);
            if (f) return clearTimeout(s), s = setTimeout(g, t), h(u)
        }
        return s === void 0 && (s = setTimeout(g, t)), a
    }
    return w.cancel = v, w.flush = A, w
}
var Lve = $ve,
    Fve = Lve,
    Uve = ya,
    Hve = "Expected a function";

function Vve(e, t, n) {
    var r = !0,
        i = !0;
    if (typeof e != "function") throw new TypeError(Hve);
    return Uve(n) && (r = "leading" in n ? !!n.leading : r, i = "trailing" in n ? !!n.trailing : i), Fve(e, t, {
        leading: r,
        maxWait: t,
        trailing: i
    })
}
var zve = Vve;
const Q5 = Fe(zve);

function Ad(e) {
    "@babel/helpers - typeof";
    return Ad = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Ad(e)
}

function CC(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function lp(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? CC(Object(n), !0).forEach(function(r) {
            Wve(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CC(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function Wve(e, t, n) {
    return t = Gve(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function Gve(e) {
    var t = qve(e, "string");
    return Ad(t) == "symbol" ? t : t + ""
}

function qve(e, t) {
    if (Ad(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Ad(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}

function Kve(e, t) {
    return Zve(e) || Xve(e, t) || Yve(e, t) || Qve()
}

function Qve() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function Yve(e, t) {
    if (e) {
        if (typeof e == "string") return IC(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return IC(e, t)
    }
}

function IC(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}

function Xve(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
        var r, i, o, a, s = [],
            u = !0,
            l = !1;
        try {
            if (o = (n = n.call(e)).next, t !== 0)
                for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0);
        } catch (c) {
            l = !0, i = c
        } finally {
            try {
                if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return
            } finally {
                if (l) throw i
            }
        }
        return s
    }
}

function Zve(e) {
    if (Array.isArray(e)) return e
}
var Jve = S.forwardRef(function(e, t) {
        var n = e.aspect,
            r = e.initialDimension,
            i = r === void 0 ? {
                width: -1,
                height: -1
            } : r,
            o = e.width,
            a = o === void 0 ? "100%" : o,
            s = e.height,
            u = s === void 0 ? "100%" : s,
            l = e.minWidth,
            c = l === void 0 ? 0 : l,
            f = e.minHeight,
            d = e.maxHeight,
            h = e.children,
            m = e.debounce,
            p = m === void 0 ? 0 : m,
            y = e.id,
            g = e.className,
            b = e.onResize,
            v = e.style,
            A = v === void 0 ? {} : v,
            w = S.useRef(null),
            x = S.useRef();
        x.current = b, S.useImperativeHandle(t, function() {
            return Object.defineProperty(w.current, "current", {
                get: function() {
                    return console.warn("The usage of ref.current.current is deprecated and will no longer be supported."), w.current
                },
                configurable: !0
            })
        });
        var T = S.useState({
                containerWidth: i.width,
                containerHeight: i.height
            }),
            _ = Kve(T, 2),
            O = _[0],
            k = _[1],
            I = S.useCallback(function(B, L) {
                k(function(P) {
                    var C = Math.round(B),
                        j = Math.round(L);
                    return P.containerWidth === C && P.containerHeight === j ? P : {
                        containerWidth: C,
                        containerHeight: j
                    }
                })
            }, []);
        S.useEffect(function() {
            var B = function(D) {
                var $, V = D[0].contentRect,
                    H = V.width,
                    Q = V.height;
                I(H, Q), ($ = x.current) === null || $ === void 0 || $.call(x, H, Q)
            };
            p > 0 && (B = Q5(B, p, {
                trailing: !0,
                leading: !1
            }));
            var L = new ResizeObserver(B),
                P = w.current.getBoundingClientRect(),
                C = P.width,
                j = P.height;
            return I(C, j), L.observe(w.current),
                function() {
                    L.disconnect()
                }
        }, [I, p]);
        var M = S.useMemo(function() {
            var B = O.containerWidth,
                L = O.containerHeight;
            if (B < 0 || L < 0) return null;
            us(qa(a) || qa(u), `The width(%s) and height(%s) are both fixed numbers,
       maybe you don't need to use a ResponsiveContainer.`, a, u), us(!n || n > 0, "The aspect(%s) must be greater than zero.", n);
            var P = qa(a) ? B : a,
                C = qa(u) ? L : u;
            n && n > 0 && (P ? C = P / n : C && (P = C * n), d && C > d && (C = d)), us(P > 0 || C > 0, `The width(%s) and height(%s) of chart should be greater than 0,
       please check the style of container, or the props width(%s) and height(%s),
       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the
       height and width.`, P, C, a, u, c, f, n);
            var j = !Array.isArray(h) && Gi(h.type).endsWith("Chart");
            return R.Children.map(h, function(N) {
                return R.isValidElement(N) ? S.cloneElement(N, lp({
                    width: P,
                    height: C
                }, j ? {
                    style: lp({
                        height: "100%",
                        width: "100%",
                        maxHeight: C,
                        maxWidth: P
                    }, N.props.style)
                } : {})) : N
            })
        }, [n, h, u, d, f, c, O, a]);
        return R.createElement("div", {
            id: y ? "".concat(y) : void 0,
            className: Me("recharts-responsive-container", g),
            style: lp(lp({}, A), {}, {
                width: a,
                height: u,
                minWidth: c,
                minHeight: f,
                maxHeight: d
            }),
            ref: w
        }, M)
    }),
    Y5 = function(t) {
        return null
    };
Y5.displayName = "Cell";

function Ed(e) {
    "@babel/helpers - typeof";
    return Ed = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Ed(e)
}

function MC(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function N1(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? MC(Object(n), !0).forEach(function(r) {
            e0e(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : MC(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function e0e(e, t, n) {
    return t = t0e(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function t0e(e) {
    var t = n0e(e, "string");
    return Ed(t) == "symbol" ? t : t + ""
}

function n0e(e, t) {
    if (Ed(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Ed(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}
var Qs = {
        widthCache: {},
        cacheCount: 0
    },
    r0e = 2e3,
    i0e = {
        position: "absolute",
        top: "-20000px",
        left: 0,
        padding: 0,
        margin: 0,
        border: "none",
        whiteSpace: "pre"
    },
    NC = "recharts_measurement_span";

function o0e(e) {
    var t = N1({}, e);
    return Object.keys(t).forEach(function(n) {
        t[n] || delete t[n]
    }), t
}
var mf = function(t) {
        var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (t == null || oc.isSsr) return {
            width: 0,
            height: 0
        };
        var r = o0e(n),
            i = JSON.stringify({
                text: t,
                copyStyle: r
            });
        if (Qs.widthCache[i]) return Qs.widthCache[i];
        try {
            var o = document.getElementById(NC);
            o || (o = document.createElement("span"), o.setAttribute("id", NC), o.setAttribute("aria-hidden", "true"), document.body.appendChild(o));
            var a = N1(N1({}, i0e), r);
            Object.assign(o.style, a), o.textContent = "".concat(t);
            var s = o.getBoundingClientRect(),
                u = {
                    width: s.width,
                    height: s.height
                };
            return Qs.widthCache[i] = u, ++Qs.cacheCount > r0e && (Qs.cacheCount = 0, Qs.widthCache = {}), u
        } catch {
            return {
                width: 0,
                height: 0
            }
        }
    },
    a0e = function(t) {
        return {
            top: t.top + window.scrollY - document.documentElement.clientTop,
            left: t.left + window.scrollX - document.documentElement.clientLeft
        }
    };

function Sd(e) {
    "@babel/helpers - typeof";
    return Sd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Sd(e)
}

function Gg(e, t) {
    return c0e(e) || l0e(e, t) || u0e(e, t) || s0e()
}

function s0e() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function u0e(e, t) {
    if (e) {
        if (typeof e == "string") return RC(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return RC(e, t)
    }
}

function RC(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}

function l0e(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
        var r, i, o, a, s = [],
            u = !0,
            l = !1;
        try {
            if (o = (n = n.call(e)).next, t === 0) {
                if (Object(n) !== n) return;
                u = !1
            } else
                for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0);
        } catch (c) {
            l = !0, i = c
        } finally {
            try {
                if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return
            } finally {
                if (l) throw i
            }
        }
        return s
    }
}

function c0e(e) {
    if (Array.isArray(e)) return e
}

function f0e(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function jC(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, h0e(r.key), r)
    }
}

function d0e(e, t, n) {
    return t && jC(e.prototype, t), n && jC(e, n), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function h0e(e) {
    var t = p0e(e, "string");
    return Sd(t) == "symbol" ? t : t + ""
}

function p0e(e, t) {
    if (Sd(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Sd(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(e)
}
var BC = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/,
    DC = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/,
    m0e = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/,
    g0e = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/,
    X5 = {
        cm: 96 / 2.54,
        mm: 96 / 25.4,
        pt: 96 / 72,
        pc: 96 / 6,
        in: 96,
        Q: 96 / (2.54 * 40),
        px: 1
    },
    y0e = Object.keys(X5),
    Su = "NaN";

function v0e(e, t) {
    return e * X5[t]
}
var cp = function() {
    function e(t, n) {
        f0e(this, e), this.num = t, this.unit = n, this.num = t, this.unit = n, Number.isNaN(t) && (this.unit = ""), n !== "" && !m0e.test(n) && (this.num = NaN, this.unit = ""), y0e.includes(n) && (this.num = v0e(t, n), this.unit = "px")
    }
    return d0e(e, [{
        key: "add",
        value: function(n) {
            return this.unit !== n.unit ? new e(NaN, "") : new e(this.num + n.num, this.unit)
        }
    }, {
        key: "subtract",
        value: function(n) {
            return this.unit !== n.unit ? new e(NaN, "") : new e(this.num - n.num, this.unit)
        }
    }, {
        key: "multiply",
        value: function(n) {
            return this.unit !== "" && n.unit !== "" && this.unit !== n.unit ? new e(NaN, "") : new e(this.num * n.num, this.unit || n.unit)
        }
    }, {
        key: "divide",
        value: function(n) {
            return this.unit !== "" && n.unit !== "" && this.unit !== n.unit ? new e(NaN, "") : new e(this.num / n.num, this.unit || n.unit)
        }
    }, {
        key: "toString",
        value: function() {
            return "".concat(this.num).concat(this.unit)
        }
    }, {
        key: "isNaN",
        value: function() {
            return Number.isNaN(this.num)
        }
    }], [{
        key: "parse",
        value: function(n) {
            var r, i = (r = g0e.exec(n)) !== null && r !== void 0 ? r : [],
                o = Gg(i, 3),
                a = o[1],
                s = o[2];
            return new e(parseFloat(a), s ? ? "")
        }
    }])
}();

function Z5(e) {
    if (e.includes(Su)) return Su;
    for (var t = e; t.includes("*") || t.includes("/");) {
        var n, r = (n = BC.exec(t)) !== null && n !== void 0 ? n : [],
            i = Gg(r, 4),
            o = i[1],
            a = i[2],
            s = i[3],
            u = cp.parse(o ? ? ""),
            l = cp.parse(s ? ? ""),
            c = a === "*" ? u.multiply(l) : u.divide(l);
        if (c.isNaN()) return Su;
        t = t.replace(BC, c.toString())
    }
    for (; t.includes("+") || /.-\d+(?:\.\d+)?/.test(t);) {
        var f, d = (f = DC.exec(t)) !== null && f !== void 0 ? f : [],
            h = Gg(d, 4),
            m = h[1],
            p = h[2],
            y = h[3],
            g = cp.parse(m ? ? ""),
            b = cp.parse(y ? ? ""),
            v = p === "+" ? g.add(b) : g.subtract(b);
        if (v.isNaN()) return Su;
        t = t.replace(DC, v.toString())
    }
    return t
}
var $C = /\(([^()]*)\)/;

function b0e(e) {
    for (var t = e; t.includes("(");) {
        var n = $C.exec(t),
            r = Gg(n, 2),
            i = r[1];
        t = t.replace($C, Z5(i))
    }
    return t
}

function w0e(e) {
    var t = e.replace(/\s+/g, "");
    return t = b0e(t), t = Z5(t), t
}

function x0e(e) {
    try {
        return w0e(e)
    } catch {
        return Su
    }
}

function Fb(e) {
    var t = x0e(e.slice(5, -1));
    return t === Su ? "" : t
}
var A0e = ["x", "y", "lineHeight", "capHeight", "scaleToFit", "textAnchor", "verticalAnchor", "fill"],
    E0e = ["dx", "dy", "angle", "className", "breakAll"];

function R1() {
    return R1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, R1.apply(this, arguments)
}

function LC(e, t) {
    if (e == null) return {};
    var n = S0e(e, t),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        for (i = 0; i < o.length; i++) r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
    }
    return n
}

function S0e(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
            if (t.indexOf(r) >= 0) continue;
            n[r] = e[r]
        }
    return n
}

function FC(e, t) {
    return O0e(e) || P0e(e, t) || T0e(e, t) || _0e()
}

function _0e() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function T0e(e, t) {
    if (e) {
        if (typeof e == "string") return UC(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return UC(e, t)
    }
}

function UC(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}

function P0e(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
        var r, i, o, a, s = [],
            u = !0,
            l = !1;
        try {
            if (o = (n = n.call(e)).next, t === 0) {
                if (Object(n) !== n) return;
                u = !1
            } else
                for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0);
        } catch (c) {
            l = !0, i = c
        } finally {
            try {
                if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return
            } finally {
                if (l) throw i
            }
        }
        return s
    }
}

function O0e(e) {
    if (Array.isArray(e)) return e
}
var J5 = /[ \f\n\r\t\v\u2028\u2029]+/,
    e4 = function(t) {
        var n = t.children,
            r = t.breakAll,
            i = t.style;
        try {
            var o = [];
            Pe(n) || (r ? o = n.toString().split("") : o = n.toString().split(J5));
            var a = o.map(function(u) {
                    return {
                        word: u,
                        width: mf(u, i).width
                    }
                }),
                s = r ? 0 : mf(" ", i).width;
            return {
                wordsWithComputedWidth: a,
                spaceWidth: s
            }
        } catch {
            return null
        }
    },
    k0e = function(t, n, r, i, o) {
        var a = t.maxLines,
            s = t.children,
            u = t.style,
            l = t.breakAll,
            c = Y(a),
            f = s,
            d = function() {
                var P = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                return P.reduce(function(C, j) {
                    var N = j.word,
                        D = j.width,
                        $ = C[C.length - 1];
                    if ($ && (i == null || o || $.width + D + r < Number(i))) $.words.push(N), $.width += D + r;
                    else {
                        var V = {
                            words: [N],
                            width: D
                        };
                        C.push(V)
                    }
                    return C
                }, [])
            },
            h = d(n),
            m = function(P) {
                return P.reduce(function(C, j) {
                    return C.width > j.width ? C : j
                })
            };
        if (!c) return h;
        for (var p = "…", y = function(P) {
                var C = f.slice(0, P),
                    j = e4({
                        breakAll: l,
                        style: u,
                        children: C + p
                    }).wordsWithComputedWidth,
                    N = d(j),
                    D = N.length > a || m(N).width > Number(i);
                return [D, N]
            }, g = 0, b = f.length - 1, v = 0, A; g <= b && v <= f.length - 1;) {
            var w = Math.floor((g + b) / 2),
                x = w - 1,
                T = y(x),
                _ = FC(T, 2),
                O = _[0],
                k = _[1],
                I = y(w),
                M = FC(I, 1),
                B = M[0];
            if (!O && !B && (g = w + 1), O && B && (b = w - 1), !O && B) {
                A = k;
                break
            }
            v++
        }
        return A || h
    },
    HC = function(t) {
        var n = Pe(t) ? [] : t.toString().split(J5);
        return [{
            words: n
        }]
    },
    C0e = function(t) {
        var n = t.width,
            r = t.scaleToFit,
            i = t.children,
            o = t.style,
            a = t.breakAll,
            s = t.maxLines;
        if ((n || r) && !oc.isSsr) {
            var u, l, c = e4({
                breakAll: a,
                children: i,
                style: o
            });
            if (c) {
                var f = c.wordsWithComputedWidth,
                    d = c.spaceWidth;
                u = f, l = d
            } else return HC(i);
            return k0e({
                breakAll: a,
                children: i,
                maxLines: s,
                style: o
            }, u, l, n, r)
        }
        return HC(i)
    },
    VC = "#808080",
    qg = function(t) {
        var n = t.x,
            r = n === void 0 ? 0 : n,
            i = t.y,
            o = i === void 0 ? 0 : i,
            a = t.lineHeight,
            s = a === void 0 ? "1em" : a,
            u = t.capHeight,
            l = u === void 0 ? "0.71em" : u,
            c = t.scaleToFit,
            f = c === void 0 ? !1 : c,
            d = t.textAnchor,
            h = d === void 0 ? "start" : d,
            m = t.verticalAnchor,
            p = m === void 0 ? "end" : m,
            y = t.fill,
            g = y === void 0 ? VC : y,
            b = LC(t, A0e),
            v = S.useMemo(function() {
                return C0e({
                    breakAll: b.breakAll,
                    children: b.children,
                    maxLines: b.maxLines,
                    scaleToFit: f,
                    style: b.style,
                    width: b.width
                })
            }, [b.breakAll, b.children, b.maxLines, f, b.style, b.width]),
            A = b.dx,
            w = b.dy,
            x = b.angle,
            T = b.className,
            _ = b.breakAll,
            O = LC(b, E0e);
        if (!Rt(r) || !Rt(o)) return null;
        var k = r + (Y(A) ? A : 0),
            I = o + (Y(w) ? w : 0),
            M;
        switch (p) {
            case "start":
                M = Fb("calc(".concat(l, ")"));
                break;
            case "middle":
                M = Fb("calc(".concat((v.length - 1) / 2, " * -").concat(s, " + (").concat(l, " / 2))"));
                break;
            default:
                M = Fb("calc(".concat(v.length - 1, " * -").concat(s, ")"));
                break
        }
        var B = [];
        if (f) {
            var L = v[0].width,
                P = b.width;
            B.push("scale(".concat((Y(P) ? P / L : 1) / L, ")"))
        }
        return x && B.push("rotate(".concat(x, ", ").concat(k, ", ").concat(I, ")")), B.length && (O.transform = B.join(" ")), R.createElement("text", R1({}, _e(O, !0), {
            x: k,
            y: I,
            className: Me("recharts-text", T),
            textAnchor: h,
            fill: g.includes("url") ? VC : g
        }), v.map(function(C, j) {
            var N = C.words.join(_ ? "" : " ");
            return R.createElement("tspan", {
                x: k,
                dy: j === 0 ? M : s,
                key: "".concat(N, "-").concat(j)
            }, N)
        }))
    };

function Zo(e, t) {
    return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN
}

function I0e(e, t) {
    return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN
}

function X_(e) {
    let t, n, r;
    e.length !== 2 ? (t = Zo, n = (s, u) => Zo(e(s), u), r = (s, u) => e(s) - u) : (t = e === Zo || e === I0e ? e : M0e, n = e, r = e);

    function i(s, u, l = 0, c = s.length) {
        if (l < c) {
            if (t(u, u) !== 0) return c;
            do {
                const f = l + c >>> 1;
                n(s[f], u) < 0 ? l = f + 1 : c = f
            } while (l < c)
        }
        return l
    }

    function o(s, u, l = 0, c = s.length) {
        if (l < c) {
            if (t(u, u) !== 0) return c;
            do {
                const f = l + c >>> 1;
                n(s[f], u) <= 0 ? l = f + 1 : c = f
            } while (l < c)
        }
        return l
    }

    function a(s, u, l = 0, c = s.length) {
        const f = i(s, u, l, c - 1);
        return f > l && r(s[f - 1], u) > -r(s[f], u) ? f - 1 : f
    }
    return {
        left: i,
        center: a,
        right: o
    }
}

function M0e() {
    return 0
}

function t4(e) {
    return e === null ? NaN : +e
}

function* N0e(e, t) {
    for (let n of e) n != null && (n = +n) >= n && (yield n)
}
const R0e = X_(Zo),
    _h = R0e.right;
X_(t4).center;
class zC extends Map {
    constructor(t, n = D0e) {
        if (super(), Object.defineProperties(this, {
                _intern: {
                    value: new Map
                },
                _key: {
                    value: n
                }
            }), t != null)
            for (const [r, i] of t) this.set(r, i)
    }
    get(t) {
        return super.get(WC(this, t))
    }
    has(t) {
        return super.has(WC(this, t))
    }
    set(t, n) {
        return super.set(j0e(this, t), n)
    }
    delete(t) {
        return super.delete(B0e(this, t))
    }
}

function WC({
    _intern: e,
    _key: t
}, n) {
    const r = t(n);
    return e.has(r) ? e.get(r) : n
}

function j0e({
    _intern: e,
    _key: t
}, n) {
    const r = t(n);
    return e.has(r) ? e.get(r) : (e.set(r, n), n)
}

function B0e({
    _intern: e,
    _key: t
}, n) {
    const r = t(n);
    return e.has(r) && (n = e.get(r), e.delete(r)), n
}

function D0e(e) {
    return e !== null && typeof e == "object" ? e.valueOf() : e
}

function $0e(e = Zo) {
    if (e === Zo) return n4;
    if (typeof e != "function") throw new TypeError("compare is not a function");
    return (t, n) => {
        const r = e(t, n);
        return r || r === 0 ? r : (e(n, n) === 0) - (e(t, t) === 0)
    }
}

function n4(e, t) {
    return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0)
}
const L0e = Math.sqrt(50),
    F0e = Math.sqrt(10),
    U0e = Math.sqrt(2);

function Kg(e, t, n) {
    const r = (t - e) / Math.max(0, n),
        i = Math.floor(Math.log10(r)),
        o = r / Math.pow(10, i),
        a = o >= L0e ? 10 : o >= F0e ? 5 : o >= U0e ? 2 : 1;
    let s, u, l;
    return i < 0 ? (l = Math.pow(10, -i) / a, s = Math.round(e * l), u = Math.round(t * l), s / l < e && ++s, u / l > t && --u, l = -l) : (l = Math.pow(10, i) * a, s = Math.round(e / l), u = Math.round(t / l), s * l < e && ++s, u * l > t && --u), u < s && .5 <= n && n < 2 ? Kg(e, t, n * 2) : [s, u, l]
}

function j1(e, t, n) {
    if (t = +t, e = +e, n = +n, !(n > 0)) return [];
    if (e === t) return [e];
    const r = t < e,
        [i, o, a] = r ? Kg(t, e, n) : Kg(e, t, n);
    if (!(o >= i)) return [];
    const s = o - i + 1,
        u = new Array(s);
    if (r)
        if (a < 0)
            for (let l = 0; l < s; ++l) u[l] = (o - l) / -a;
        else
            for (let l = 0; l < s; ++l) u[l] = (o - l) * a;
    else if (a < 0)
        for (let l = 0; l < s; ++l) u[l] = (i + l) / -a;
    else
        for (let l = 0; l < s; ++l) u[l] = (i + l) * a;
    return u
}

function B1(e, t, n) {
    return t = +t, e = +e, n = +n, Kg(e, t, n)[2]
}

function D1(e, t, n) {
    t = +t, e = +e, n = +n;
    const r = t < e,
        i = r ? B1(t, e, n) : B1(e, t, n);
    return (r ? -1 : 1) * (i < 0 ? 1 / -i : i)
}

function GC(e, t) {
    let n;
    for (const r of e) r != null && (n < r || n === void 0 && r >= r) && (n = r);
    return n
}

function qC(e, t) {
    let n;
    for (const r of e) r != null && (n > r || n === void 0 && r >= r) && (n = r);
    return n
}

function r4(e, t, n = 0, r = 1 / 0, i) {
    if (t = Math.floor(t), n = Math.floor(Math.max(0, n)), r = Math.floor(Math.min(e.length - 1, r)), !(n <= t && t <= r)) return e;
    for (i = i === void 0 ? n4 : $0e(i); r > n;) {
        if (r - n > 600) {
            const u = r - n + 1,
                l = t - n + 1,
                c = Math.log(u),
                f = .5 * Math.exp(2 * c / 3),
                d = .5 * Math.sqrt(c * f * (u - f) / u) * (l - u / 2 < 0 ? -1 : 1),
                h = Math.max(n, Math.floor(t - l * f / u + d)),
                m = Math.min(r, Math.floor(t + (u - l) * f / u + d));
            r4(e, t, h, m, i)
        }
        const o = e[t];
        let a = n,
            s = r;
        for (Pc(e, n, t), i(e[r], o) > 0 && Pc(e, n, r); a < s;) {
            for (Pc(e, a, s), ++a, --s; i(e[a], o) < 0;) ++a;
            for (; i(e[s], o) > 0;) --s
        }
        i(e[n], o) === 0 ? Pc(e, n, s) : (++s, Pc(e, s, r)), s <= t && (n = s + 1), t <= s && (r = s - 1)
    }
    return e
}

function Pc(e, t, n) {
    const r = e[t];
    e[t] = e[n], e[n] = r
}

function H0e(e, t, n) {
    if (e = Float64Array.from(N0e(e)), !(!(r = e.length) || isNaN(t = +t))) {
        if (t <= 0 || r < 2) return qC(e);
        if (t >= 1) return GC(e);
        var r, i = (r - 1) * t,
            o = Math.floor(i),
            a = GC(r4(e, o).subarray(0, o + 1)),
            s = qC(e.subarray(o + 1));
        return a + (s - a) * (i - o)
    }
}

function V0e(e, t, n = t4) {
    if (!(!(r = e.length) || isNaN(t = +t))) {
        if (t <= 0 || r < 2) return +n(e[0], 0, e);
        if (t >= 1) return +n(e[r - 1], r - 1, e);
        var r, i = (r - 1) * t,
            o = Math.floor(i),
            a = +n(e[o], o, e),
            s = +n(e[o + 1], o + 1, e);
        return a + (s - a) * (i - o)
    }
}

function z0e(e, t, n) {
    e = +e, t = +t, n = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +n;
    for (var r = -1, i = Math.max(0, Math.ceil((t - e) / n)) | 0, o = new Array(i); ++r < i;) o[r] = e + r * n;
    return o
}

function yr(e, t) {
    switch (arguments.length) {
        case 0:
            break;
        case 1:
            this.range(e);
            break;
        default:
            this.range(t).domain(e);
            break
    }
    return this
}

function wo(e, t) {
    switch (arguments.length) {
        case 0:
            break;
        case 1:
            {
                typeof e == "function" ? this.interpolator(e) : this.range(e);
                break
            }
        default:
            {
                this.domain(e),
                typeof t == "function" ? this.interpolator(t) : this.range(t);
                break
            }
    }
    return this
}
const $1 = Symbol("implicit");

function Z_() {
    var e = new zC,
        t = [],
        n = [],
        r = $1;

    function i(o) {
        let a = e.get(o);
        if (a === void 0) {
            if (r !== $1) return r;
            e.set(o, a = t.push(o) - 1)
        }
        return n[a % n.length]
    }
    return i.domain = function(o) {
        if (!arguments.length) return t.slice();
        t = [], e = new zC;
        for (const a of o) e.has(a) || e.set(a, t.push(a) - 1);
        return i
    }, i.range = function(o) {
        return arguments.length ? (n = Array.from(o), i) : n.slice()
    }, i.unknown = function(o) {
        return arguments.length ? (r = o, i) : r
    }, i.copy = function() {
        return Z_(t, n).unknown(r)
    }, yr.apply(i, arguments), i
}

function _d() {
    var e = Z_().unknown(void 0),
        t = e.domain,
        n = e.range,
        r = 0,
        i = 1,
        o, a, s = !1,
        u = 0,
        l = 0,
        c = .5;
    delete e.unknown;

    function f() {
        var d = t().length,
            h = i < r,
            m = h ? i : r,
            p = h ? r : i;
        o = (p - m) / Math.max(1, d - u + l * 2), s && (o = Math.floor(o)), m += (p - m - o * (d - u)) * c, a = o * (1 - u), s && (m = Math.round(m), a = Math.round(a));
        var y = z0e(d).map(function(g) {
            return m + o * g
        });
        return n(h ? y.reverse() : y)
    }
    return e.domain = function(d) {
        return arguments.length ? (t(d), f()) : t()
    }, e.range = function(d) {
        return arguments.length ? ([r, i] = d, r = +r, i = +i, f()) : [r, i]
    }, e.rangeRound = function(d) {
        return [r, i] = d, r = +r, i = +i, s = !0, f()
    }, e.bandwidth = function() {
        return a
    }, e.step = function() {
        return o
    }, e.round = function(d) {
        return arguments.length ? (s = !!d, f()) : s
    }, e.padding = function(d) {
        return arguments.length ? (u = Math.min(1, l = +d), f()) : u
    }, e.paddingInner = function(d) {
        return arguments.length ? (u = Math.min(1, d), f()) : u
    }, e.paddingOuter = function(d) {
        return arguments.length ? (l = +d, f()) : l
    }, e.align = function(d) {
        return arguments.length ? (c = Math.max(0, Math.min(1, d)), f()) : c
    }, e.copy = function() {
        return _d(t(), [r, i]).round(s).paddingInner(u).paddingOuter(l).align(c)
    }, yr.apply(f(), arguments)
}

function i4(e) {
    var t = e.copy;
    return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
        return i4(t())
    }, e
}

function gf() {
    return i4(_d.apply(null, arguments).paddingInner(1))
}

function J_(e, t, n) {
    e.prototype = t.prototype = n, n.constructor = e
}

function o4(e, t) {
    var n = Object.create(e.prototype);
    for (var r in t) n[r] = t[r];
    return n
}

function Th() {}
var Td = .7,
    Qg = 1 / Td,
    Lu = "\\s*([+-]?\\d+)\\s*",
    Pd = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    li = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    W0e = /^#([0-9a-f]{3,8})$/,
    G0e = new RegExp(`^rgb\\(${Lu},${Lu},${Lu}\\)$`),
    q0e = new RegExp(`^rgb\\(${li},${li},${li}\\)$`),
    K0e = new RegExp(`^rgba\\(${Lu},${Lu},${Lu},${Pd}\\)$`),
    Q0e = new RegExp(`^rgba\\(${li},${li},${li},${Pd}\\)$`),
    Y0e = new RegExp(`^hsl\\(${Pd},${li},${li}\\)$`),
    X0e = new RegExp(`^hsla\\(${Pd},${li},${li},${Pd}\\)$`),
    KC = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
J_(Th, Od, {
    copy(e) {
        return Object.assign(new this.constructor, this, e)
    },
    displayable() {
        return this.rgb().displayable()
    },
    hex: QC,
    formatHex: QC,
    formatHex8: Z0e,
    formatHsl: J0e,
    formatRgb: YC,
    toString: YC
});

function QC() {
    return this.rgb().formatHex()
}

function Z0e() {
    return this.rgb().formatHex8()
}

function J0e() {
    return a4(this).formatHsl()
}

function YC() {
    return this.rgb().formatRgb()
}

function Od(e) {
    var t, n;
    return e = (e + "").trim().toLowerCase(), (t = W0e.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? XC(t) : n === 3 ? new kn(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? fp(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? fp(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = G0e.exec(e)) ? new kn(t[1], t[2], t[3], 1) : (t = q0e.exec(e)) ? new kn(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = K0e.exec(e)) ? fp(t[1], t[2], t[3], t[4]) : (t = Q0e.exec(e)) ? fp(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = Y0e.exec(e)) ? eI(t[1], t[2] / 100, t[3] / 100, 1) : (t = X0e.exec(e)) ? eI(t[1], t[2] / 100, t[3] / 100, t[4]) : KC.hasOwnProperty(e) ? XC(KC[e]) : e === "transparent" ? new kn(NaN, NaN, NaN, 0) : null
}

function XC(e) {
    return new kn(e >> 16 & 255, e >> 8 & 255, e & 255, 1)
}

function fp(e, t, n, r) {
    return r <= 0 && (e = t = n = NaN), new kn(e, t, n, r)
}

function ebe(e) {
    return e instanceof Th || (e = Od(e)), e ? (e = e.rgb(), new kn(e.r, e.g, e.b, e.opacity)) : new kn
}

function L1(e, t, n, r) {
    return arguments.length === 1 ? ebe(e) : new kn(e, t, n, r ? ? 1)
}

function kn(e, t, n, r) {
    this.r = +e, this.g = +t, this.b = +n, this.opacity = +r
}
J_(kn, L1, o4(Th, {
    brighter(e) {
        return e = e == null ? Qg : Math.pow(Qg, e), new kn(this.r * e, this.g * e, this.b * e, this.opacity)
    },
    darker(e) {
        return e = e == null ? Td : Math.pow(Td, e), new kn(this.r * e, this.g * e, this.b * e, this.opacity)
    },
    rgb() {
        return this
    },
    clamp() {
        return new kn(cs(this.r), cs(this.g), cs(this.b), Yg(this.opacity))
    },
    displayable() {
        return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1
    },
    hex: ZC,
    formatHex: ZC,
    formatHex8: tbe,
    formatRgb: JC,
    toString: JC
}));

function ZC() {
    return `#${Ka(this.r)}${Ka(this.g)}${Ka(this.b)}`
}

function tbe() {
    return `#${Ka(this.r)}${Ka(this.g)}${Ka(this.b)}${Ka((isNaN(this.opacity)?1:this.opacity)*255)}`
}

function JC() {
    const e = Yg(this.opacity);
    return `${e===1?"rgb(":"rgba("}${cs(this.r)}, ${cs(this.g)}, ${cs(this.b)}${e===1?")":`, ${e})`}`
}

function Yg(e) {
    return isNaN(e) ? 1 : Math.max(0, Math.min(1, e))
}

function cs(e) {
    return Math.max(0, Math.min(255, Math.round(e) || 0))
}

function Ka(e) {
    return e = cs(e), (e < 16 ? "0" : "") + e.toString(16)
}

function eI(e, t, n, r) {
    return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Cr(e, t, n, r)
}

function a4(e) {
    if (e instanceof Cr) return new Cr(e.h, e.s, e.l, e.opacity);
    if (e instanceof Th || (e = Od(e)), !e) return new Cr;
    if (e instanceof Cr) return e;
    e = e.rgb();
    var t = e.r / 255,
        n = e.g / 255,
        r = e.b / 255,
        i = Math.min(t, n, r),
        o = Math.max(t, n, r),
        a = NaN,
        s = o - i,
        u = (o + i) / 2;
    return s ? (t === o ? a = (n - r) / s + (n < r) * 6 : n === o ? a = (r - t) / s + 2 : a = (t - n) / s + 4, s /= u < .5 ? o + i : 2 - o - i, a *= 60) : s = u > 0 && u < 1 ? 0 : a, new Cr(a, s, u, e.opacity)
}

function nbe(e, t, n, r) {
    return arguments.length === 1 ? a4(e) : new Cr(e, t, n, r ? ? 1)
}

function Cr(e, t, n, r) {
    this.h = +e, this.s = +t, this.l = +n, this.opacity = +r
}
J_(Cr, nbe, o4(Th, {
    brighter(e) {
        return e = e == null ? Qg : Math.pow(Qg, e), new Cr(this.h, this.s, this.l * e, this.opacity)
    },
    darker(e) {
        return e = e == null ? Td : Math.pow(Td, e), new Cr(this.h, this.s, this.l * e, this.opacity)
    },
    rgb() {
        var e = this.h % 360 + (this.h < 0) * 360,
            t = isNaN(e) || isNaN(this.s) ? 0 : this.s,
            n = this.l,
            r = n + (n < .5 ? n : 1 - n) * t,
            i = 2 * n - r;
        return new kn(Ub(e >= 240 ? e - 240 : e + 120, i, r), Ub(e, i, r), Ub(e < 120 ? e + 240 : e - 120, i, r), this.opacity)
    },
    clamp() {
        return new Cr(tI(this.h), dp(this.s), dp(this.l), Yg(this.opacity))
    },
    displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1
    },
    formatHsl() {
        const e = Yg(this.opacity);
        return `${e===1?"hsl(":"hsla("}${tI(this.h)}, ${dp(this.s)*100}%, ${dp(this.l)*100}%${e===1?")":`, ${e})`}`
    }
}));

function tI(e) {
    return e = (e || 0) % 360, e < 0 ? e + 360 : e
}

function dp(e) {
    return Math.max(0, Math.min(1, e || 0))
}

function Ub(e, t, n) {
    return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255
}
const eT = e => () => e;

function rbe(e, t) {
    return function(n) {
        return e + n * t
    }
}

function ibe(e, t, n) {
    return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n,
        function(r) {
            return Math.pow(e + r * t, n)
        }
}

function obe(e) {
    return (e = +e) == 1 ? s4 : function(t, n) {
        return n - t ? ibe(t, n, e) : eT(isNaN(t) ? n : t)
    }
}

function s4(e, t) {
    var n = t - e;
    return n ? rbe(e, n) : eT(isNaN(e) ? t : e)
}
const nI = function e(t) {
    var n = obe(t);

    function r(i, o) {
        var a = n((i = L1(i)).r, (o = L1(o)).r),
            s = n(i.g, o.g),
            u = n(i.b, o.b),
            l = s4(i.opacity, o.opacity);
        return function(c) {
            return i.r = a(c), i.g = s(c), i.b = u(c), i.opacity = l(c), i + ""
        }
    }
    return r.gamma = e, r
}(1);

function abe(e, t) {
    t || (t = []);
    var n = e ? Math.min(t.length, e.length) : 0,
        r = t.slice(),
        i;
    return function(o) {
        for (i = 0; i < n; ++i) r[i] = e[i] * (1 - o) + t[i] * o;
        return r
    }
}

function sbe(e) {
    return ArrayBuffer.isView(e) && !(e instanceof DataView)
}

function ube(e, t) {
    var n = t ? t.length : 0,
        r = e ? Math.min(n, e.length) : 0,
        i = new Array(r),
        o = new Array(n),
        a;
    for (a = 0; a < r; ++a) i[a] = ac(e[a], t[a]);
    for (; a < n; ++a) o[a] = t[a];
    return function(s) {
        for (a = 0; a < r; ++a) o[a] = i[a](s);
        return o
    }
}

function lbe(e, t) {
    var n = new Date;
    return e = +e, t = +t,
        function(r) {
            return n.setTime(e * (1 - r) + t * r), n
        }
}

function Xg(e, t) {
    return e = +e, t = +t,
        function(n) {
            return e * (1 - n) + t * n
        }
}

function cbe(e, t) {
    var n = {},
        r = {},
        i;
    (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
    for (i in t) i in e ? n[i] = ac(e[i], t[i]) : r[i] = t[i];
    return function(o) {
        for (i in n) r[i] = n[i](o);
        return r
    }
}
var F1 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    Hb = new RegExp(F1.source, "g");

function fbe(e) {
    return function() {
        return e
    }
}

function dbe(e) {
    return function(t) {
        return e(t) + ""
    }
}

function hbe(e, t) {
    var n = F1.lastIndex = Hb.lastIndex = 0,
        r, i, o, a = -1,
        s = [],
        u = [];
    for (e = e + "", t = t + "";
        (r = F1.exec(e)) && (i = Hb.exec(t));)(o = i.index) > n && (o = t.slice(n, o), s[a] ? s[a] += o : s[++a] = o), (r = r[0]) === (i = i[0]) ? s[a] ? s[a] += i : s[++a] = i : (s[++a] = null, u.push({
        i: a,
        x: Xg(r, i)
    })), n = Hb.lastIndex;
    return n < t.length && (o = t.slice(n), s[a] ? s[a] += o : s[++a] = o), s.length < 2 ? u[0] ? dbe(u[0].x) : fbe(t) : (t = u.length, function(l) {
        for (var c = 0, f; c < t; ++c) s[(f = u[c]).i] = f.x(l);
        return s.join("")
    })
}

function ac(e, t) {
    var n = typeof t,
        r;
    return t == null || n === "boolean" ? eT(t) : (n === "number" ? Xg : n === "string" ? (r = Od(t)) ? (t = r, nI) : hbe : t instanceof Od ? nI : t instanceof Date ? lbe : sbe(t) ? abe : Array.isArray(t) ? ube : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? cbe : Xg)(e, t)
}

function tT(e, t) {
    return e = +e, t = +t,
        function(n) {
            return Math.round(e * (1 - n) + t * n)
        }
}

function pbe(e, t) {
    t === void 0 && (t = e, e = ac);
    for (var n = 0, r = t.length - 1, i = t[0], o = new Array(r < 0 ? 0 : r); n < r;) o[n] = e(i, i = t[++n]);
    return function(a) {
        var s = Math.max(0, Math.min(r - 1, Math.floor(a *= r)));
        return o[s](a - s)
    }
}

function mbe(e) {
    return function() {
        return e
    }
}

function Zg(e) {
    return +e
}
var rI = [0, 1];

function hn(e) {
    return e
}

function U1(e, t) {
    return (t -= e = +e) ? function(n) {
        return (n - e) / t
    } : mbe(isNaN(t) ? NaN : .5)
}

function gbe(e, t) {
    var n;
    return e > t && (n = e, e = t, t = n),
        function(r) {
            return Math.max(e, Math.min(t, r))
        }
}

function ybe(e, t, n) {
    var r = e[0],
        i = e[1],
        o = t[0],
        a = t[1];
    return i < r ? (r = U1(i, r), o = n(a, o)) : (r = U1(r, i), o = n(o, a)),
        function(s) {
            return o(r(s))
        }
}

function vbe(e, t, n) {
    var r = Math.min(e.length, t.length) - 1,
        i = new Array(r),
        o = new Array(r),
        a = -1;
    for (e[r] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++a < r;) i[a] = U1(e[a], e[a + 1]), o[a] = n(t[a], t[a + 1]);
    return function(s) {
        var u = _h(e, s, 1, r) - 1;
        return o[u](i[u](s))
    }
}

function Ph(e, t) {
    return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())
}

function Xv() {
    var e = rI,
        t = rI,
        n = ac,
        r, i, o, a = hn,
        s, u, l;

    function c() {
        var d = Math.min(e.length, t.length);
        return a !== hn && (a = gbe(e[0], e[d - 1])), s = d > 2 ? vbe : ybe, u = l = null, f
    }

    function f(d) {
        return d == null || isNaN(d = +d) ? o : (u || (u = s(e.map(r), t, n)))(r(a(d)))
    }
    return f.invert = function(d) {
            return a(i((l || (l = s(t, e.map(r), Xg)))(d)))
        }, f.domain = function(d) {
            return arguments.length ? (e = Array.from(d, Zg), c()) : e.slice()
        }, f.range = function(d) {
            return arguments.length ? (t = Array.from(d), c()) : t.slice()
        }, f.rangeRound = function(d) {
            return t = Array.from(d), n = tT, c()
        }, f.clamp = function(d) {
            return arguments.length ? (a = d ? !0 : hn, c()) : a !== hn
        }, f.interpolate = function(d) {
            return arguments.length ? (n = d, c()) : n
        }, f.unknown = function(d) {
            return arguments.length ? (o = d, f) : o
        },
        function(d, h) {
            return r = d, i = h, c()
        }
}

function nT() {
    return Xv()(hn, hn)
}

function bbe(e) {
    return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10)
}

function Jg(e, t) {
    if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0) return null;
    var n, r = e.slice(0, n);
    return [r.length > 1 ? r[0] + r.slice(2) : r, +e.slice(n + 1)]
}

function bl(e) {
    return e = Jg(Math.abs(e)), e ? e[1] : NaN
}

function wbe(e, t) {
    return function(n, r) {
        for (var i = n.length, o = [], a = 0, s = e[0], u = 0; i > 0 && s > 0 && (u + s + 1 > r && (s = Math.max(1, r - u)), o.push(n.substring(i -= s, i + s)), !((u += s + 1) > r));) s = e[a = (a + 1) % e.length];
        return o.reverse().join(t)
    }
}

function xbe(e) {
    return function(t) {
        return t.replace(/[0-9]/g, function(n) {
            return e[+n]
        })
    }
}
var Abe = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function kd(e) {
    if (!(t = Abe.exec(e))) throw new Error("invalid format: " + e);
    var t;
    return new rT({
        fill: t[1],
        align: t[2],
        sign: t[3],
        symbol: t[4],
        zero: t[5],
        width: t[6],
        comma: t[7],
        precision: t[8] && t[8].slice(1),
        trim: t[9],
        type: t[10]
    })
}
kd.prototype = rT.prototype;

function rT(e) {
    this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + ""
}
rT.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type
};

function Ebe(e) {
    e: for (var t = e.length, n = 1, r = -1, i; n < t; ++n) switch (e[n]) {
        case ".":
            r = i = n;
            break;
        case "0":
            r === 0 && (r = n), i = n;
            break;
        default:
            if (!+e[n]) break e;
            r > 0 && (r = 0);
            break
    }
    return r > 0 ? e.slice(0, r) + e.slice(i + 1) : e
}
var u4;

function Sbe(e, t) {
    var n = Jg(e, t);
    if (!n) return e + "";
    var r = n[0],
        i = n[1],
        o = i - (u4 = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1,
        a = r.length;
    return o === a ? r : o > a ? r + new Array(o - a + 1).join("0") : o > 0 ? r.slice(0, o) + "." + r.slice(o) : "0." + new Array(1 - o).join("0") + Jg(e, Math.max(0, t + o - 1))[0]
}

function iI(e, t) {
    var n = Jg(e, t);
    if (!n) return e + "";
    var r = n[0],
        i = n[1];
    return i < 0 ? "0." + new Array(-i).join("0") + r : r.length > i + 1 ? r.slice(0, i + 1) + "." + r.slice(i + 1) : r + new Array(i - r.length + 2).join("0")
}
const oI = {
    "%": (e, t) => (e * 100).toFixed(t),
    b: e => Math.round(e).toString(2),
    c: e => e + "",
    d: bbe,
    e: (e, t) => e.toExponential(t),
    f: (e, t) => e.toFixed(t),
    g: (e, t) => e.toPrecision(t),
    o: e => Math.round(e).toString(8),
    p: (e, t) => iI(e * 100, t),
    r: iI,
    s: Sbe,
    X: e => Math.round(e).toString(16).toUpperCase(),
    x: e => Math.round(e).toString(16)
};

function aI(e) {
    return e
}
var sI = Array.prototype.map,
    uI = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];

function _be(e) {
    var t = e.grouping === void 0 || e.thousands === void 0 ? aI : wbe(sI.call(e.grouping, Number), e.thousands + ""),
        n = e.currency === void 0 ? "" : e.currency[0] + "",
        r = e.currency === void 0 ? "" : e.currency[1] + "",
        i = e.decimal === void 0 ? "." : e.decimal + "",
        o = e.numerals === void 0 ? aI : xbe(sI.call(e.numerals, String)),
        a = e.percent === void 0 ? "%" : e.percent + "",
        s = e.minus === void 0 ? "−" : e.minus + "",
        u = e.nan === void 0 ? "NaN" : e.nan + "";

    function l(f) {
        f = kd(f);
        var d = f.fill,
            h = f.align,
            m = f.sign,
            p = f.symbol,
            y = f.zero,
            g = f.width,
            b = f.comma,
            v = f.precision,
            A = f.trim,
            w = f.type;
        w === "n" ? (b = !0, w = "g") : oI[w] || (v === void 0 && (v = 12), A = !0, w = "g"), (y || d === "0" && h === "=") && (y = !0, d = "0", h = "=");
        var x = p === "$" ? n : p === "#" && /[boxX]/.test(w) ? "0" + w.toLowerCase() : "",
            T = p === "$" ? r : /[%p]/.test(w) ? a : "",
            _ = oI[w],
            O = /[defgprs%]/.test(w);
        v = v === void 0 ? 6 : /[gprs]/.test(w) ? Math.max(1, Math.min(21, v)) : Math.max(0, Math.min(20, v));

        function k(I) {
            var M = x,
                B = T,
                L, P, C;
            if (w === "c") B = _(I) + B, I = "";
            else {
                I = +I;
                var j = I < 0 || 1 / I < 0;
                if (I = isNaN(I) ? u : _(Math.abs(I), v), A && (I = Ebe(I)), j && +I == 0 && m !== "+" && (j = !1), M = (j ? m === "(" ? m : s : m === "-" || m === "(" ? "" : m) + M, B = (w === "s" ? uI[8 + u4 / 3] : "") + B + (j && m === "(" ? ")" : ""), O) {
                    for (L = -1, P = I.length; ++L < P;)
                        if (C = I.charCodeAt(L), 48 > C || C > 57) {
                            B = (C === 46 ? i + I.slice(L + 1) : I.slice(L)) + B, I = I.slice(0, L);
                            break
                        }
                }
            }
            b && !y && (I = t(I, 1 / 0));
            var N = M.length + I.length + B.length,
                D = N < g ? new Array(g - N + 1).join(d) : "";
            switch (b && y && (I = t(D + I, D.length ? g - B.length : 1 / 0), D = ""), h) {
                case "<":
                    I = M + I + B + D;
                    break;
                case "=":
                    I = M + D + I + B;
                    break;
                case "^":
                    I = D.slice(0, N = D.length >> 1) + M + I + B + D.slice(N);
                    break;
                default:
                    I = D + M + I + B;
                    break
            }
            return o(I)
        }
        return k.toString = function() {
            return f + ""
        }, k
    }

    function c(f, d) {
        var h = l((f = kd(f), f.type = "f", f)),
            m = Math.max(-8, Math.min(8, Math.floor(bl(d) / 3))) * 3,
            p = Math.pow(10, -m),
            y = uI[8 + m / 3];
        return function(g) {
            return h(p * g) + y
        }
    }
    return {
        format: l,
        formatPrefix: c
    }
}
var hp, iT, l4;
Tbe({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
});

function Tbe(e) {
    return hp = _be(e), iT = hp.format, l4 = hp.formatPrefix, hp
}

function Pbe(e) {
    return Math.max(0, -bl(Math.abs(e)))
}

function Obe(e, t) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(bl(t) / 3))) * 3 - bl(Math.abs(e)))
}

function kbe(e, t) {
    return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, bl(t) - bl(e)) + 1
}

function c4(e, t, n, r) {
    var i = D1(e, t, n),
        o;
    switch (r = kd(r ? ? ",f"), r.type) {
        case "s":
            {
                var a = Math.max(Math.abs(e), Math.abs(t));
                return r.precision == null && !isNaN(o = Obe(i, a)) && (r.precision = o),
                l4(r, a)
            }
        case "":
        case "e":
        case "g":
        case "p":
        case "r":
            {
                r.precision == null && !isNaN(o = kbe(i, Math.max(Math.abs(e), Math.abs(t)))) && (r.precision = o - (r.type === "e"));
                break
            }
        case "f":
        case "%":
            {
                r.precision == null && !isNaN(o = Pbe(i)) && (r.precision = o - (r.type === "%") * 2);
                break
            }
    }
    return iT(r)
}

function va(e) {
    var t = e.domain;
    return e.ticks = function(n) {
        var r = t();
        return j1(r[0], r[r.length - 1], n ? ? 10)
    }, e.tickFormat = function(n, r) {
        var i = t();
        return c4(i[0], i[i.length - 1], n ? ? 10, r)
    }, e.nice = function(n) {
        n == null && (n = 10);
        var r = t(),
            i = 0,
            o = r.length - 1,
            a = r[i],
            s = r[o],
            u, l, c = 10;
        for (s < a && (l = a, a = s, s = l, l = i, i = o, o = l); c-- > 0;) {
            if (l = B1(a, s, n), l === u) return r[i] = a, r[o] = s, t(r);
            if (l > 0) a = Math.floor(a / l) * l, s = Math.ceil(s / l) * l;
            else if (l < 0) a = Math.ceil(a * l) / l, s = Math.floor(s * l) / l;
            else break;
            u = l
        }
        return e
    }, e
}

function ey() {
    var e = nT();
    return e.copy = function() {
        return Ph(e, ey())
    }, yr.apply(e, arguments), va(e)
}

function f4(e) {
    var t;

    function n(r) {
        return r == null || isNaN(r = +r) ? t : r
    }
    return n.invert = n, n.domain = n.range = function(r) {
        return arguments.length ? (e = Array.from(r, Zg), n) : e.slice()
    }, n.unknown = function(r) {
        return arguments.length ? (t = r, n) : t
    }, n.copy = function() {
        return f4(e).unknown(t)
    }, e = arguments.length ? Array.from(e, Zg) : [0, 1], va(n)
}

function d4(e, t) {
    e = e.slice();
    var n = 0,
        r = e.length - 1,
        i = e[n],
        o = e[r],
        a;
    return o < i && (a = n, n = r, r = a, a = i, i = o, o = a), e[n] = t.floor(i), e[r] = t.ceil(o), e
}

function lI(e) {
    return Math.log(e)
}

function cI(e) {
    return Math.exp(e)
}

function Cbe(e) {
    return -Math.log(-e)
}

function Ibe(e) {
    return -Math.exp(-e)
}

function Mbe(e) {
    return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e
}

function Nbe(e) {
    return e === 10 ? Mbe : e === Math.E ? Math.exp : t => Math.pow(e, t)
}

function Rbe(e) {
    return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), t => Math.log(t) / e)
}

function fI(e) {
    return (t, n) => -e(-t, n)
}

function oT(e) {
    const t = e(lI, cI),
        n = t.domain;
    let r = 10,
        i, o;

    function a() {
        return i = Rbe(r), o = Nbe(r), n()[0] < 0 ? (i = fI(i), o = fI(o), e(Cbe, Ibe)) : e(lI, cI), t
    }
    return t.base = function(s) {
        return arguments.length ? (r = +s, a()) : r
    }, t.domain = function(s) {
        return arguments.length ? (n(s), a()) : n()
    }, t.ticks = s => {
        const u = n();
        let l = u[0],
            c = u[u.length - 1];
        const f = c < l;
        f && ([l, c] = [c, l]);
        let d = i(l),
            h = i(c),
            m, p;
        const y = s == null ? 10 : +s;
        let g = [];
        if (!(r % 1) && h - d < y) {
            if (d = Math.floor(d), h = Math.ceil(h), l > 0) {
                for (; d <= h; ++d)
                    for (m = 1; m < r; ++m)
                        if (p = d < 0 ? m / o(-d) : m * o(d), !(p < l)) {
                            if (p > c) break;
                            g.push(p)
                        }
            } else
                for (; d <= h; ++d)
                    for (m = r - 1; m >= 1; --m)
                        if (p = d > 0 ? m / o(-d) : m * o(d), !(p < l)) {
                            if (p > c) break;
                            g.push(p)
                        }
            g.length * 2 < y && (g = j1(l, c, y))
        } else g = j1(d, h, Math.min(h - d, y)).map(o);
        return f ? g.reverse() : g
    }, t.tickFormat = (s, u) => {
        if (s == null && (s = 10), u == null && (u = r === 10 ? "s" : ","), typeof u != "function" && (!(r % 1) && (u = kd(u)).precision == null && (u.trim = !0), u = iT(u)), s === 1 / 0) return u;
        const l = Math.max(1, r * s / t.ticks().length);
        return c => {
            let f = c / o(Math.round(i(c)));
            return f * r < r - .5 && (f *= r), f <= l ? u(c) : ""
        }
    }, t.nice = () => n(d4(n(), {
        floor: s => o(Math.floor(i(s))),
        ceil: s => o(Math.ceil(i(s)))
    })), t
}

function h4() {
    const e = oT(Xv()).domain([1, 10]);
    return e.copy = () => Ph(e, h4()).base(e.base()), yr.apply(e, arguments), e
}

function dI(e) {
    return function(t) {
        return Math.sign(t) * Math.log1p(Math.abs(t / e))
    }
}

function hI(e) {
    return function(t) {
        return Math.sign(t) * Math.expm1(Math.abs(t)) * e
    }
}

function aT(e) {
    var t = 1,
        n = e(dI(t), hI(t));
    return n.constant = function(r) {
        return arguments.length ? e(dI(t = +r), hI(t)) : t
    }, va(n)
}

function p4() {
    var e = aT(Xv());
    return e.copy = function() {
        return Ph(e, p4()).constant(e.constant())
    }, yr.apply(e, arguments)
}

function pI(e) {
    return function(t) {
        return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e)
    }
}

function jbe(e) {
    return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e)
}

function Bbe(e) {
    return e < 0 ? -e * e : e * e
}

function sT(e) {
    var t = e(hn, hn),
        n = 1;

    function r() {
        return n === 1 ? e(hn, hn) : n === .5 ? e(jbe, Bbe) : e(pI(n), pI(1 / n))
    }
    return t.exponent = function(i) {
        return arguments.length ? (n = +i, r()) : n
    }, va(t)
}

function uT() {
    var e = sT(Xv());
    return e.copy = function() {
        return Ph(e, uT()).exponent(e.exponent())
    }, yr.apply(e, arguments), e
}

function Dbe() {
    return uT.apply(null, arguments).exponent(.5)
}

function mI(e) {
    return Math.sign(e) * e * e
}

function $be(e) {
    return Math.sign(e) * Math.sqrt(Math.abs(e))
}

function m4() {
    var e = nT(),
        t = [0, 1],
        n = !1,
        r;

    function i(o) {
        var a = $be(e(o));
        return isNaN(a) ? r : n ? Math.round(a) : a
    }
    return i.invert = function(o) {
        return e.invert(mI(o))
    }, i.domain = function(o) {
        return arguments.length ? (e.domain(o), i) : e.domain()
    }, i.range = function(o) {
        return arguments.length ? (e.range((t = Array.from(o, Zg)).map(mI)), i) : t.slice()
    }, i.rangeRound = function(o) {
        return i.range(o).round(!0)
    }, i.round = function(o) {
        return arguments.length ? (n = !!o, i) : n
    }, i.clamp = function(o) {
        return arguments.length ? (e.clamp(o), i) : e.clamp()
    }, i.unknown = function(o) {
        return arguments.length ? (r = o, i) : r
    }, i.copy = function() {
        return m4(e.domain(), t).round(n).clamp(e.clamp()).unknown(r)
    }, yr.apply(i, arguments), va(i)
}

function g4() {
    var e = [],
        t = [],
        n = [],
        r;

    function i() {
        var a = 0,
            s = Math.max(1, t.length);
        for (n = new Array(s - 1); ++a < s;) n[a - 1] = V0e(e, a / s);
        return o
    }

    function o(a) {
        return a == null || isNaN(a = +a) ? r : t[_h(n, a)]
    }
    return o.invertExtent = function(a) {
        var s = t.indexOf(a);
        return s < 0 ? [NaN, NaN] : [s > 0 ? n[s - 1] : e[0], s < n.length ? n[s] : e[e.length - 1]]
    }, o.domain = function(a) {
        if (!arguments.length) return e.slice();
        e = [];
        for (let s of a) s != null && !isNaN(s = +s) && e.push(s);
        return e.sort(Zo), i()
    }, o.range = function(a) {
        return arguments.length ? (t = Array.from(a), i()) : t.slice()
    }, o.unknown = function(a) {
        return arguments.length ? (r = a, o) : r
    }, o.quantiles = function() {
        return n.slice()
    }, o.copy = function() {
        return g4().domain(e).range(t).unknown(r)
    }, yr.apply(o, arguments)
}

function y4() {
    var e = 0,
        t = 1,
        n = 1,
        r = [.5],
        i = [0, 1],
        o;

    function a(u) {
        return u != null && u <= u ? i[_h(r, u, 0, n)] : o
    }

    function s() {
        var u = -1;
        for (r = new Array(n); ++u < n;) r[u] = ((u + 1) * t - (u - n) * e) / (n + 1);
        return a
    }
    return a.domain = function(u) {
        return arguments.length ? ([e, t] = u, e = +e, t = +t, s()) : [e, t]
    }, a.range = function(u) {
        return arguments.length ? (n = (i = Array.from(u)).length - 1, s()) : i.slice()
    }, a.invertExtent = function(u) {
        var l = i.indexOf(u);
        return l < 0 ? [NaN, NaN] : l < 1 ? [e, r[0]] : l >= n ? [r[n - 1], t] : [r[l - 1], r[l]]
    }, a.unknown = function(u) {
        return arguments.length && (o = u), a
    }, a.thresholds = function() {
        return r.slice()
    }, a.copy = function() {
        return y4().domain([e, t]).range(i).unknown(o)
    }, yr.apply(va(a), arguments)
}

function v4() {
    var e = [.5],
        t = [0, 1],
        n, r = 1;

    function i(o) {
        return o != null && o <= o ? t[_h(e, o, 0, r)] : n
    }
    return i.domain = function(o) {
        return arguments.length ? (e = Array.from(o), r = Math.min(e.length, t.length - 1), i) : e.slice()
    }, i.range = function(o) {
        return arguments.length ? (t = Array.from(o), r = Math.min(e.length, t.length - 1), i) : t.slice()
    }, i.invertExtent = function(o) {
        var a = t.indexOf(o);
        return [e[a - 1], e[a]]
    }, i.unknown = function(o) {
        return arguments.length ? (n = o, i) : n
    }, i.copy = function() {
        return v4().domain(e).range(t).unknown(n)
    }, yr.apply(i, arguments)
}
const Vb = new Date,
    zb = new Date;

function jt(e, t, n, r) {
    function i(o) {
        return e(o = arguments.length === 0 ? new Date : new Date(+o)), o
    }
    return i.floor = o => (e(o = new Date(+o)), o), i.ceil = o => (e(o = new Date(o - 1)), t(o, 1), e(o), o), i.round = o => {
        const a = i(o),
            s = i.ceil(o);
        return o - a < s - o ? a : s
    }, i.offset = (o, a) => (t(o = new Date(+o), a == null ? 1 : Math.floor(a)), o), i.range = (o, a, s) => {
        const u = [];
        if (o = i.ceil(o), s = s == null ? 1 : Math.floor(s), !(o < a) || !(s > 0)) return u;
        let l;
        do u.push(l = new Date(+o)), t(o, s), e(o); while (l < o && o < a);
        return u
    }, i.filter = o => jt(a => {
        if (a >= a)
            for (; e(a), !o(a);) a.setTime(a - 1)
    }, (a, s) => {
        if (a >= a)
            if (s < 0)
                for (; ++s <= 0;)
                    for (; t(a, -1), !o(a););
            else
                for (; --s >= 0;)
                    for (; t(a, 1), !o(a););
    }), n && (i.count = (o, a) => (Vb.setTime(+o), zb.setTime(+a), e(Vb), e(zb), Math.floor(n(Vb, zb))), i.every = o => (o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? i.filter(r ? a => r(a) % o === 0 : a => i.count(0, a) % o === 0) : i)), i
}
const ty = jt(() => {}, (e, t) => {
    e.setTime(+e + t)
}, (e, t) => t - e);
ty.every = e => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? jt(t => {
    t.setTime(Math.floor(t / e) * e)
}, (t, n) => {
    t.setTime(+t + n * e)
}, (t, n) => (n - t) / e) : ty);
ty.range;
const $i = 1e3,
    cr = $i * 60,
    Li = cr * 60,
    io = Li * 24,
    lT = io * 7,
    gI = io * 30,
    Wb = io * 365,
    Qa = jt(e => {
        e.setTime(e - e.getMilliseconds())
    }, (e, t) => {
        e.setTime(+e + t * $i)
    }, (e, t) => (t - e) / $i, e => e.getUTCSeconds());
Qa.range;
const cT = jt(e => {
    e.setTime(e - e.getMilliseconds() - e.getSeconds() * $i)
}, (e, t) => {
    e.setTime(+e + t * cr)
}, (e, t) => (t - e) / cr, e => e.getMinutes());
cT.range;
const fT = jt(e => {
    e.setUTCSeconds(0, 0)
}, (e, t) => {
    e.setTime(+e + t * cr)
}, (e, t) => (t - e) / cr, e => e.getUTCMinutes());
fT.range;
const dT = jt(e => {
    e.setTime(e - e.getMilliseconds() - e.getSeconds() * $i - e.getMinutes() * cr)
}, (e, t) => {
    e.setTime(+e + t * Li)
}, (e, t) => (t - e) / Li, e => e.getHours());
dT.range;
const hT = jt(e => {
    e.setUTCMinutes(0, 0, 0)
}, (e, t) => {
    e.setTime(+e + t * Li)
}, (e, t) => (t - e) / Li, e => e.getUTCHours());
hT.range;
const Oh = jt(e => e.setHours(0, 0, 0, 0), (e, t) => e.setDate(e.getDate() + t), (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * cr) / io, e => e.getDate() - 1);
Oh.range;
const Zv = jt(e => {
    e.setUTCHours(0, 0, 0, 0)
}, (e, t) => {
    e.setUTCDate(e.getUTCDate() + t)
}, (e, t) => (t - e) / io, e => e.getUTCDate() - 1);
Zv.range;
const b4 = jt(e => {
    e.setUTCHours(0, 0, 0, 0)
}, (e, t) => {
    e.setUTCDate(e.getUTCDate() + t)
}, (e, t) => (t - e) / io, e => Math.floor(e / io));
b4.range;

function Ls(e) {
    return jt(t => {
        t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0)
    }, (t, n) => {
        t.setDate(t.getDate() + n * 7)
    }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * cr) / lT)
}
const Jv = Ls(0),
    ny = Ls(1),
    Lbe = Ls(2),
    Fbe = Ls(3),
    wl = Ls(4),
    Ube = Ls(5),
    Hbe = Ls(6);
Jv.range;
ny.range;
Lbe.range;
Fbe.range;
wl.range;
Ube.range;
Hbe.range;

function Fs(e) {
    return jt(t => {
        t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0)
    }, (t, n) => {
        t.setUTCDate(t.getUTCDate() + n * 7)
    }, (t, n) => (n - t) / lT)
}
const e0 = Fs(0),
    ry = Fs(1),
    Vbe = Fs(2),
    zbe = Fs(3),
    xl = Fs(4),
    Wbe = Fs(5),
    Gbe = Fs(6);
e0.range;
ry.range;
Vbe.range;
zbe.range;
xl.range;
Wbe.range;
Gbe.range;
const pT = jt(e => {
    e.setDate(1), e.setHours(0, 0, 0, 0)
}, (e, t) => {
    e.setMonth(e.getMonth() + t)
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, e => e.getMonth());
pT.range;
const mT = jt(e => {
    e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0)
}, (e, t) => {
    e.setUTCMonth(e.getUTCMonth() + t)
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, e => e.getUTCMonth());
mT.range;
const oo = jt(e => {
    e.setMonth(0, 1), e.setHours(0, 0, 0, 0)
}, (e, t) => {
    e.setFullYear(e.getFullYear() + t)
}, (e, t) => t.getFullYear() - e.getFullYear(), e => e.getFullYear());
oo.every = e => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : jt(t => {
    t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0)
}, (t, n) => {
    t.setFullYear(t.getFullYear() + n * e)
});
oo.range;
const ao = jt(e => {
    e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0)
}, (e, t) => {
    e.setUTCFullYear(e.getUTCFullYear() + t)
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), e => e.getUTCFullYear());
ao.every = e => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : jt(t => {
    t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0)
}, (t, n) => {
    t.setUTCFullYear(t.getUTCFullYear() + n * e)
});
ao.range;

function w4(e, t, n, r, i, o) {
    const a = [
        [Qa, 1, $i],
        [Qa, 5, 5 * $i],
        [Qa, 15, 15 * $i],
        [Qa, 30, 30 * $i],
        [o, 1, cr],
        [o, 5, 5 * cr],
        [o, 15, 15 * cr],
        [o, 30, 30 * cr],
        [i, 1, Li],
        [i, 3, 3 * Li],
        [i, 6, 6 * Li],
        [i, 12, 12 * Li],
        [r, 1, io],
        [r, 2, 2 * io],
        [n, 1, lT],
        [t, 1, gI],
        [t, 3, 3 * gI],
        [e, 1, Wb]
    ];

    function s(l, c, f) {
        const d = c < l;
        d && ([l, c] = [c, l]);
        const h = f && typeof f.range == "function" ? f : u(l, c, f),
            m = h ? h.range(l, +c + 1) : [];
        return d ? m.reverse() : m
    }

    function u(l, c, f) {
        const d = Math.abs(c - l) / f,
            h = X_(([, , y]) => y).right(a, d);
        if (h === a.length) return e.every(D1(l / Wb, c / Wb, f));
        if (h === 0) return ty.every(Math.max(D1(l, c, f), 1));
        const [m, p] = a[d / a[h - 1][2] < a[h][2] / d ? h - 1 : h];
        return m.every(p)
    }
    return [s, u]
}
const [qbe, Kbe] = w4(ao, mT, e0, b4, hT, fT), [Qbe, Ybe] = w4(oo, pT, Jv, Oh, dT, cT);

function Gb(e) {
    if (0 <= e.y && e.y < 100) {
        var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
        return t.setFullYear(e.y), t
    }
    return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L)
}

function qb(e) {
    if (0 <= e.y && e.y < 100) {
        var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
        return t.setUTCFullYear(e.y), t
    }
    return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L))
}

function Oc(e, t, n) {
    return {
        y: e,
        m: t,
        d: n,
        H: 0,
        M: 0,
        S: 0,
        L: 0
    }
}

function Xbe(e) {
    var t = e.dateTime,
        n = e.date,
        r = e.time,
        i = e.periods,
        o = e.days,
        a = e.shortDays,
        s = e.months,
        u = e.shortMonths,
        l = kc(i),
        c = Cc(i),
        f = kc(o),
        d = Cc(o),
        h = kc(a),
        m = Cc(a),
        p = kc(s),
        y = Cc(s),
        g = kc(u),
        b = Cc(u),
        v = {
            a: j,
            A: N,
            b: D,
            B: $,
            c: null,
            d: AI,
            e: AI,
            f: wwe,
            g: Cwe,
            G: Mwe,
            H: ywe,
            I: vwe,
            j: bwe,
            L: x4,
            m: xwe,
            M: Awe,
            p: V,
            q: H,
            Q: _I,
            s: TI,
            S: Ewe,
            u: Swe,
            U: _we,
            V: Twe,
            w: Pwe,
            W: Owe,
            x: null,
            X: null,
            y: kwe,
            Y: Iwe,
            Z: Nwe,
            "%": SI
        },
        A = {
            a: Q,
            A: X,
            b: ve,
            B: De,
            c: null,
            d: EI,
            e: EI,
            f: Dwe,
            g: qwe,
            G: Qwe,
            H: Rwe,
            I: jwe,
            j: Bwe,
            L: E4,
            m: $we,
            M: Lwe,
            p: ot,
            q: St,
            Q: _I,
            s: TI,
            S: Fwe,
            u: Uwe,
            U: Hwe,
            V: Vwe,
            w: zwe,
            W: Wwe,
            x: null,
            X: null,
            y: Gwe,
            Y: Kwe,
            Z: Ywe,
            "%": SI
        },
        w = {
            a: k,
            A: I,
            b: M,
            B,
            c: L,
            d: wI,
            e: wI,
            f: hwe,
            g: bI,
            G: vI,
            H: xI,
            I: xI,
            j: lwe,
            L: dwe,
            m: uwe,
            M: cwe,
            p: O,
            q: swe,
            Q: mwe,
            s: gwe,
            S: fwe,
            u: nwe,
            U: rwe,
            V: iwe,
            w: twe,
            W: owe,
            x: P,
            X: C,
            y: bI,
            Y: vI,
            Z: awe,
            "%": pwe
        };
    v.x = x(n, v), v.X = x(r, v), v.c = x(t, v), A.x = x(n, A), A.X = x(r, A), A.c = x(t, A);

    function x(K, ae) {
        return function(re) {
            var z = [],
                he = -1,
                me = 0,
                ht = K.length,
                pt, An, Ao;
            for (re instanceof Date || (re = new Date(+re)); ++he < ht;) K.charCodeAt(he) === 37 && (z.push(K.slice(me, he)), (An = yI[pt = K.charAt(++he)]) != null ? pt = K.charAt(++he) : An = pt === "e" ? " " : "0", (Ao = ae[pt]) && (pt = Ao(re, An)), z.push(pt), me = he + 1);
            return z.push(K.slice(me, he)), z.join("")
        }
    }

    function T(K, ae) {
        return function(re) {
            var z = Oc(1900, void 0, 1),
                he = _(z, K, re += "", 0),
                me, ht;
            if (he != re.length) return null;
            if ("Q" in z) return new Date(z.Q);
            if ("s" in z) return new Date(z.s * 1e3 + ("L" in z ? z.L : 0));
            if (ae && !("Z" in z) && (z.Z = 0), "p" in z && (z.H = z.H % 12 + z.p * 12), z.m === void 0 && (z.m = "q" in z ? z.q : 0), "V" in z) {
                if (z.V < 1 || z.V > 53) return null;
                "w" in z || (z.w = 1), "Z" in z ? (me = qb(Oc(z.y, 0, 1)), ht = me.getUTCDay(), me = ht > 4 || ht === 0 ? ry.ceil(me) : ry(me), me = Zv.offset(me, (z.V - 1) * 7), z.y = me.getUTCFullYear(), z.m = me.getUTCMonth(), z.d = me.getUTCDate() + (z.w + 6) % 7) : (me = Gb(Oc(z.y, 0, 1)), ht = me.getDay(), me = ht > 4 || ht === 0 ? ny.ceil(me) : ny(me), me = Oh.offset(me, (z.V - 1) * 7), z.y = me.getFullYear(), z.m = me.getMonth(), z.d = me.getDate() + (z.w + 6) % 7)
            } else("W" in z || "U" in z) && ("w" in z || (z.w = "u" in z ? z.u % 7 : "W" in z ? 1 : 0), ht = "Z" in z ? qb(Oc(z.y, 0, 1)).getUTCDay() : Gb(Oc(z.y, 0, 1)).getDay(), z.m = 0, z.d = "W" in z ? (z.w + 6) % 7 + z.W * 7 - (ht + 5) % 7 : z.w + z.U * 7 - (ht + 6) % 7);
            return "Z" in z ? (z.H += z.Z / 100 | 0, z.M += z.Z % 100, qb(z)) : Gb(z)
        }
    }

    function _(K, ae, re, z) {
        for (var he = 0, me = ae.length, ht = re.length, pt, An; he < me;) {
            if (z >= ht) return -1;
            if (pt = ae.charCodeAt(he++), pt === 37) {
                if (pt = ae.charAt(he++), An = w[pt in yI ? ae.charAt(he++) : pt], !An || (z = An(K, re, z)) < 0) return -1
            } else if (pt != re.charCodeAt(z++)) return -1
        }
        return z
    }

    function O(K, ae, re) {
        var z = l.exec(ae.slice(re));
        return z ? (K.p = c.get(z[0].toLowerCase()), re + z[0].length) : -1
    }

    function k(K, ae, re) {
        var z = h.exec(ae.slice(re));
        return z ? (K.w = m.get(z[0].toLowerCase()), re + z[0].length) : -1
    }

    function I(K, ae, re) {
        var z = f.exec(ae.slice(re));
        return z ? (K.w = d.get(z[0].toLowerCase()), re + z[0].length) : -1
    }

    function M(K, ae, re) {
        var z = g.exec(ae.slice(re));
        return z ? (K.m = b.get(z[0].toLowerCase()), re + z[0].length) : -1
    }

    function B(K, ae, re) {
        var z = p.exec(ae.slice(re));
        return z ? (K.m = y.get(z[0].toLowerCase()), re + z[0].length) : -1
    }

    function L(K, ae, re) {
        return _(K, t, ae, re)
    }

    function P(K, ae, re) {
        return _(K, n, ae, re)
    }

    function C(K, ae, re) {
        return _(K, r, ae, re)
    }

    function j(K) {
        return a[K.getDay()]
    }

    function N(K) {
        return o[K.getDay()]
    }

    function D(K) {
        return u[K.getMonth()]
    }

    function $(K) {
        return s[K.getMonth()]
    }

    function V(K) {
        return i[+(K.getHours() >= 12)]
    }

    function H(K) {
        return 1 + ~~(K.getMonth() / 3)
    }

    function Q(K) {
        return a[K.getUTCDay()]
    }

    function X(K) {
        return o[K.getUTCDay()]
    }

    function ve(K) {
        return u[K.getUTCMonth()]
    }

    function De(K) {
        return s[K.getUTCMonth()]
    }

    function ot(K) {
        return i[+(K.getUTCHours() >= 12)]
    }

    function St(K) {
        return 1 + ~~(K.getUTCMonth() / 3)
    }
    return {
        format: function(K) {
            var ae = x(K += "", v);
            return ae.toString = function() {
                return K
            }, ae
        },
        parse: function(K) {
            var ae = T(K += "", !1);
            return ae.toString = function() {
                return K
            }, ae
        },
        utcFormat: function(K) {
            var ae = x(K += "", A);
            return ae.toString = function() {
                return K
            }, ae
        },
        utcParse: function(K) {
            var ae = T(K += "", !0);
            return ae.toString = function() {
                return K
            }, ae
        }
    }
}
var yI = {
        "-": "",
        _: " ",
        0: "0"
    },
    Ht = /^\s*\d+/,
    Zbe = /^%/,
    Jbe = /[\\^$*+?|[\]().{}]/g;

function Ne(e, t, n) {
    var r = e < 0 ? "-" : "",
        i = (r ? -e : e) + "",
        o = i.length;
    return r + (o < n ? new Array(n - o + 1).join(t) + i : i)
}

function ewe(e) {
    return e.replace(Jbe, "\\$&")
}

function kc(e) {
    return new RegExp("^(?:" + e.map(ewe).join("|") + ")", "i")
}

function Cc(e) {
    return new Map(e.map((t, n) => [t.toLowerCase(), n]))
}

function twe(e, t, n) {
    var r = Ht.exec(t.slice(n, n + 1));
    return r ? (e.w = +r[0], n + r[0].length) : -1
}

function nwe(e, t, n) {
    var r = Ht.exec(t.slice(n, n + 1));
    return r ? (e.u = +r[0], n + r[0].length) : -1
}

function rwe(e, t, n) {
    var r = Ht.exec(t.slice(n, n + 2));
    return r ? (e.U = +r[0], n + r[0].length) : -1
}

function iwe(e, t, n) {
    var r = Ht.exec(t.slice(n, n + 2));
    return r ? (e.V = +r[0], n + r[0].length) : -1
}

function owe(e, t, n) {
    var r = Ht.exec(t.slice(n, n + 2));
    return r ? (e.W = +r[0], n + r[0].length) : -1
}

function vI(e, t, n) {
    var r = Ht.exec(t.slice(n, n + 4));
    return r ? (e.y = +r[0], n + r[0].length) : -1
}

function bI(e, t, n) {
    var r = Ht.exec(t.slice(n, n + 2));
    return r ? (e.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), n + r[0].length) : -1
}

function awe(e, t, n) {
    var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
    return r ? (e.Z = r[1] ? 0 : -(r[2] + (r[3] || "00")), n + r[0].length) : -1
}

function swe(e, t, n) {
    var r = Ht.exec(t.slice(n, n + 1));
    return r ? (e.q = r[0] * 3 - 3, n + r[0].length) : -1
}

function uwe(e, t, n) {
    var r = Ht.exec(t.slice(n, n + 2));
    return r ? (e.m = r[0] - 1, n + r[0].length) : -1
}

function wI(e, t, n) {
    var r = Ht.exec(t.slice(n, n + 2));
    return r ? (e.d = +r[0], n + r[0].length) : -1
}

function lwe(e, t, n) {
    var r = Ht.exec(t.slice(n, n + 3));
    return r ? (e.m = 0, e.d = +r[0], n + r[0].length) : -1
}

function xI(e, t, n) {
    var r = Ht.exec(t.slice(n, n + 2));
    return r ? (e.H = +r[0], n + r[0].length) : -1
}

function cwe(e, t, n) {
    var r = Ht.exec(t.slice(n, n + 2));
    return r ? (e.M = +r[0], n + r[0].length) : -1
}

function fwe(e, t, n) {
    var r = Ht.exec(t.slice(n, n + 2));
    return r ? (e.S = +r[0], n + r[0].length) : -1
}

function dwe(e, t, n) {
    var r = Ht.exec(t.slice(n, n + 3));
    return r ? (e.L = +r[0], n + r[0].length) : -1
}

function hwe(e, t, n) {
    var r = Ht.exec(t.slice(n, n + 6));
    return r ? (e.L = Math.floor(r[0] / 1e3), n + r[0].length) : -1
}

function pwe(e, t, n) {
    var r = Zbe.exec(t.slice(n, n + 1));
    return r ? n + r[0].length : -1
}

function mwe(e, t, n) {
    var r = Ht.exec(t.slice(n));
    return r ? (e.Q = +r[0], n + r[0].length) : -1
}

function gwe(e, t, n) {
    var r = Ht.exec(t.slice(n));
    return r ? (e.s = +r[0], n + r[0].length) : -1
}

function AI(e, t) {
    return Ne(e.getDate(), t, 2)
}

function ywe(e, t) {
    return Ne(e.getHours(), t, 2)
}

function vwe(e, t) {
    return Ne(e.getHours() % 12 || 12, t, 2)
}

function bwe(e, t) {
    return Ne(1 + Oh.count(oo(e), e), t, 3)
}

function x4(e, t) {
    return Ne(e.getMilliseconds(), t, 3)
}

function wwe(e, t) {
    return x4(e, t) + "000"
}

function xwe(e, t) {
    return Ne(e.getMonth() + 1, t, 2)
}

function Awe(e, t) {
    return Ne(e.getMinutes(), t, 2)
}

function Ewe(e, t) {
    return Ne(e.getSeconds(), t, 2)
}

function Swe(e) {
    var t = e.getDay();
    return t === 0 ? 7 : t
}

function _we(e, t) {
    return Ne(Jv.count(oo(e) - 1, e), t, 2)
}

function A4(e) {
    var t = e.getDay();
    return t >= 4 || t === 0 ? wl(e) : wl.ceil(e)
}

function Twe(e, t) {
    return e = A4(e), Ne(wl.count(oo(e), e) + (oo(e).getDay() === 4), t, 2)
}

function Pwe(e) {
    return e.getDay()
}

function Owe(e, t) {
    return Ne(ny.count(oo(e) - 1, e), t, 2)
}

function kwe(e, t) {
    return Ne(e.getFullYear() % 100, t, 2)
}

function Cwe(e, t) {
    return e = A4(e), Ne(e.getFullYear() % 100, t, 2)
}

function Iwe(e, t) {
    return Ne(e.getFullYear() % 1e4, t, 4)
}

function Mwe(e, t) {
    var n = e.getDay();
    return e = n >= 4 || n === 0 ? wl(e) : wl.ceil(e), Ne(e.getFullYear() % 1e4, t, 4)
}

function Nwe(e) {
    var t = e.getTimezoneOffset();
    return (t > 0 ? "-" : (t *= -1, "+")) + Ne(t / 60 | 0, "0", 2) + Ne(t % 60, "0", 2)
}

function EI(e, t) {
    return Ne(e.getUTCDate(), t, 2)
}

function Rwe(e, t) {
    return Ne(e.getUTCHours(), t, 2)
}

function jwe(e, t) {
    return Ne(e.getUTCHours() % 12 || 12, t, 2)
}

function Bwe(e, t) {
    return Ne(1 + Zv.count(ao(e), e), t, 3)
}

function E4(e, t) {
    return Ne(e.getUTCMilliseconds(), t, 3)
}

function Dwe(e, t) {
    return E4(e, t) + "000"
}

function $we(e, t) {
    return Ne(e.getUTCMonth() + 1, t, 2)
}

function Lwe(e, t) {
    return Ne(e.getUTCMinutes(), t, 2)
}

function Fwe(e, t) {
    return Ne(e.getUTCSeconds(), t, 2)
}

function Uwe(e) {
    var t = e.getUTCDay();
    return t === 0 ? 7 : t
}

function Hwe(e, t) {
    return Ne(e0.count(ao(e) - 1, e), t, 2)
}

function S4(e) {
    var t = e.getUTCDay();
    return t >= 4 || t === 0 ? xl(e) : xl.ceil(e)
}

function Vwe(e, t) {
    return e = S4(e), Ne(xl.count(ao(e), e) + (ao(e).getUTCDay() === 4), t, 2)
}

function zwe(e) {
    return e.getUTCDay()
}

function Wwe(e, t) {
    return Ne(ry.count(ao(e) - 1, e), t, 2)
}

function Gwe(e, t) {
    return Ne(e.getUTCFullYear() % 100, t, 2)
}

function qwe(e, t) {
    return e = S4(e), Ne(e.getUTCFullYear() % 100, t, 2)
}

function Kwe(e, t) {
    return Ne(e.getUTCFullYear() % 1e4, t, 4)
}

function Qwe(e, t) {
    var n = e.getUTCDay();
    return e = n >= 4 || n === 0 ? xl(e) : xl.ceil(e), Ne(e.getUTCFullYear() % 1e4, t, 4)
}

function Ywe() {
    return "+0000"
}

function SI() {
    return "%"
}

function _I(e) {
    return +e
}

function TI(e) {
    return Math.floor(+e / 1e3)
}
var Ys, _4, T4;
Xwe({
    dateTime: "%x, %X",
    date: "%-m/%-d/%Y",
    time: "%-I:%M:%S %p",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function Xwe(e) {
    return Ys = Xbe(e), _4 = Ys.format, Ys.parse, T4 = Ys.utcFormat, Ys.utcParse, Ys
}

function Zwe(e) {
    return new Date(e)
}

function Jwe(e) {
    return e instanceof Date ? +e : +new Date(+e)
}

function gT(e, t, n, r, i, o, a, s, u, l) {
    var c = nT(),
        f = c.invert,
        d = c.domain,
        h = l(".%L"),
        m = l(":%S"),
        p = l("%I:%M"),
        y = l("%I %p"),
        g = l("%a %d"),
        b = l("%b %d"),
        v = l("%B"),
        A = l("%Y");

    function w(x) {
        return (u(x) < x ? h : s(x) < x ? m : a(x) < x ? p : o(x) < x ? y : r(x) < x ? i(x) < x ? g : b : n(x) < x ? v : A)(x)
    }
    return c.invert = function(x) {
        return new Date(f(x))
    }, c.domain = function(x) {
        return arguments.length ? d(Array.from(x, Jwe)) : d().map(Zwe)
    }, c.ticks = function(x) {
        var T = d();
        return e(T[0], T[T.length - 1], x ? ? 10)
    }, c.tickFormat = function(x, T) {
        return T == null ? w : l(T)
    }, c.nice = function(x) {
        var T = d();
        return (!x || typeof x.range != "function") && (x = t(T[0], T[T.length - 1], x ? ? 10)), x ? d(d4(T, x)) : c
    }, c.copy = function() {
        return Ph(c, gT(e, t, n, r, i, o, a, s, u, l))
    }, c
}

function exe() {
    return yr.apply(gT(Qbe, Ybe, oo, pT, Jv, Oh, dT, cT, Qa, _4).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments)
}

function txe() {
    return yr.apply(gT(qbe, Kbe, ao, mT, e0, Zv, hT, fT, Qa, T4).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments)
}

function t0() {
    var e = 0,
        t = 1,
        n, r, i, o, a = hn,
        s = !1,
        u;

    function l(f) {
        return f == null || isNaN(f = +f) ? u : a(i === 0 ? .5 : (f = (o(f) - n) * i, s ? Math.max(0, Math.min(1, f)) : f))
    }
    l.domain = function(f) {
        return arguments.length ? ([e, t] = f, n = o(e = +e), r = o(t = +t), i = n === r ? 0 : 1 / (r - n), l) : [e, t]
    }, l.clamp = function(f) {
        return arguments.length ? (s = !!f, l) : s
    }, l.interpolator = function(f) {
        return arguments.length ? (a = f, l) : a
    };

    function c(f) {
        return function(d) {
            var h, m;
            return arguments.length ? ([h, m] = d, a = f(h, m), l) : [a(0), a(1)]
        }
    }
    return l.range = c(ac), l.rangeRound = c(tT), l.unknown = function(f) {
            return arguments.length ? (u = f, l) : u
        },
        function(f) {
            return o = f, n = f(e), r = f(t), i = n === r ? 0 : 1 / (r - n), l
        }
}

function ba(e, t) {
    return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown())
}

function P4() {
    var e = va(t0()(hn));
    return e.copy = function() {
        return ba(e, P4())
    }, wo.apply(e, arguments)
}

function O4() {
    var e = oT(t0()).domain([1, 10]);
    return e.copy = function() {
        return ba(e, O4()).base(e.base())
    }, wo.apply(e, arguments)
}

function k4() {
    var e = aT(t0());
    return e.copy = function() {
        return ba(e, k4()).constant(e.constant())
    }, wo.apply(e, arguments)
}

function yT() {
    var e = sT(t0());
    return e.copy = function() {
        return ba(e, yT()).exponent(e.exponent())
    }, wo.apply(e, arguments)
}

function nxe() {
    return yT.apply(null, arguments).exponent(.5)
}

function C4() {
    var e = [],
        t = hn;

    function n(r) {
        if (r != null && !isNaN(r = +r)) return t((_h(e, r, 1) - 1) / (e.length - 1))
    }
    return n.domain = function(r) {
        if (!arguments.length) return e.slice();
        e = [];
        for (let i of r) i != null && !isNaN(i = +i) && e.push(i);
        return e.sort(Zo), n
    }, n.interpolator = function(r) {
        return arguments.length ? (t = r, n) : t
    }, n.range = function() {
        return e.map((r, i) => t(i / (e.length - 1)))
    }, n.quantiles = function(r) {
        return Array.from({
            length: r + 1
        }, (i, o) => H0e(e, o / r))
    }, n.copy = function() {
        return C4(t).domain(e)
    }, wo.apply(n, arguments)
}

function n0() {
    var e = 0,
        t = .5,
        n = 1,
        r = 1,
        i, o, a, s, u, l = hn,
        c, f = !1,
        d;

    function h(p) {
        return isNaN(p = +p) ? d : (p = .5 + ((p = +c(p)) - o) * (r * p < r * o ? s : u), l(f ? Math.max(0, Math.min(1, p)) : p))
    }
    h.domain = function(p) {
        return arguments.length ? ([e, t, n] = p, i = c(e = +e), o = c(t = +t), a = c(n = +n), s = i === o ? 0 : .5 / (o - i), u = o === a ? 0 : .5 / (a - o), r = o < i ? -1 : 1, h) : [e, t, n]
    }, h.clamp = function(p) {
        return arguments.length ? (f = !!p, h) : f
    }, h.interpolator = function(p) {
        return arguments.length ? (l = p, h) : l
    };

    function m(p) {
        return function(y) {
            var g, b, v;
            return arguments.length ? ([g, b, v] = y, l = pbe(p, [g, b, v]), h) : [l(0), l(.5), l(1)]
        }
    }
    return h.range = m(ac), h.rangeRound = m(tT), h.unknown = function(p) {
            return arguments.length ? (d = p, h) : d
        },
        function(p) {
            return c = p, i = p(e), o = p(t), a = p(n), s = i === o ? 0 : .5 / (o - i), u = o === a ? 0 : .5 / (a - o), r = o < i ? -1 : 1, h
        }
}

function I4() {
    var e = va(n0()(hn));
    return e.copy = function() {
        return ba(e, I4())
    }, wo.apply(e, arguments)
}

function M4() {
    var e = oT(n0()).domain([.1, 1, 10]);
    return e.copy = function() {
        return ba(e, M4()).base(e.base())
    }, wo.apply(e, arguments)
}

function N4() {
    var e = aT(n0());
    return e.copy = function() {
        return ba(e, N4()).constant(e.constant())
    }, wo.apply(e, arguments)
}

function vT() {
    var e = sT(n0());
    return e.copy = function() {
        return ba(e, vT()).exponent(e.exponent())
    }, wo.apply(e, arguments)
}

function rxe() {
    return vT.apply(null, arguments).exponent(.5)
}
const PI = Object.freeze(Object.defineProperty({
    __proto__: null,
    scaleBand: _d,
    scaleDiverging: I4,
    scaleDivergingLog: M4,
    scaleDivergingPow: vT,
    scaleDivergingSqrt: rxe,
    scaleDivergingSymlog: N4,
    scaleIdentity: f4,
    scaleImplicit: $1,
    scaleLinear: ey,
    scaleLog: h4,
    scaleOrdinal: Z_,
    scalePoint: gf,
    scalePow: uT,
    scaleQuantile: g4,
    scaleQuantize: y4,
    scaleRadial: m4,
    scaleSequential: P4,
    scaleSequentialLog: O4,
    scaleSequentialPow: yT,
    scaleSequentialQuantile: C4,
    scaleSequentialSqrt: nxe,
    scaleSequentialSymlog: k4,
    scaleSqrt: Dbe,
    scaleSymlog: p4,
    scaleThreshold: v4,
    scaleTime: exe,
    scaleUtc: txe,
    tickFormat: c4
}, Symbol.toStringTag, {
    value: "Module"
}));
var ixe = Ql;

function oxe(e, t, n) {
    for (var r = -1, i = e.length; ++r < i;) {
        var o = e[r],
            a = t(o);
        if (a != null && (s === void 0 ? a === a && !ixe(a) : n(a, s))) var s = a,
            u = o
    }
    return u
}
var R4 = oxe;

function axe(e, t) {
    return e > t
}
var sxe = axe,
    uxe = R4,
    lxe = sxe,
    cxe = rc;

function fxe(e) {
    return e && e.length ? uxe(e, cxe, lxe) : void 0
}
var dxe = fxe;
const Fo = Fe(dxe);

function hxe(e, t) {
    return e < t
}
var pxe = hxe,
    mxe = R4,
    gxe = pxe,
    yxe = rc;

function vxe(e) {
    return e && e.length ? mxe(e, yxe, gxe) : void 0
}
var bxe = vxe;
const r0 = Fe(bxe);
var wxe = I_,
    xxe = ic,
    Axe = H5,
    Exe = Rn;

function Sxe(e, t) {
    var n = Exe(e) ? wxe : Axe;
    return n(e, xxe(t))
}
var _xe = Sxe,
    Txe = F5,
    Pxe = _xe;

function Oxe(e, t) {
    return Txe(Pxe(e, t), 1)
}
var kxe = Oxe;
const Cxe = Fe(kxe);
var Ixe = q_;

function Mxe(e, t) {
    return Ixe(e, t)
}
var Nxe = Mxe;
const Cd = Fe(Nxe);
var sc = 1e9,
    Rxe = {
        precision: 20,
        rounding: 4,
        toExpNeg: -7,
        toExpPos: 21,
        LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
    },
    wT, it = !0,
    mr = "[DecimalError] ",
    fs = mr + "Invalid argument: ",
    bT = mr + "Exponent out of range: ",
    uc = Math.floor,
    Na = Math.pow,
    jxe = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
    Ln, Dt = 1e7,
    Je = 7,
    j4 = 9007199254740991,
    iy = uc(j4 / Je),
    ne = {};
ne.absoluteValue = ne.abs = function() {
    var e = new this.constructor(this);
    return e.s && (e.s = 1), e
};
ne.comparedTo = ne.cmp = function(e) {
    var t, n, r, i, o = this;
    if (e = new o.constructor(e), o.s !== e.s) return o.s || -e.s;
    if (o.e !== e.e) return o.e > e.e ^ o.s < 0 ? 1 : -1;
    for (r = o.d.length, i = e.d.length, t = 0, n = r < i ? r : i; t < n; ++t)
        if (o.d[t] !== e.d[t]) return o.d[t] > e.d[t] ^ o.s < 0 ? 1 : -1;
    return r === i ? 0 : r > i ^ o.s < 0 ? 1 : -1
};
ne.decimalPlaces = ne.dp = function() {
    var e = this,
        t = e.d.length - 1,
        n = (t - e.e) * Je;
    if (t = e.d[t], t)
        for (; t % 10 == 0; t /= 10) n--;
    return n < 0 ? 0 : n
};
ne.dividedBy = ne.div = function(e) {
    return qi(this, new this.constructor(e))
};
ne.dividedToIntegerBy = ne.idiv = function(e) {
    var t = this,
        n = t.constructor;
    return We(qi(t, new n(e), 0, 1), n.precision)
};
ne.equals = ne.eq = function(e) {
    return !this.cmp(e)
};
ne.exponent = function() {
    return Ot(this)
};
ne.greaterThan = ne.gt = function(e) {
    return this.cmp(e) > 0
};
ne.greaterThanOrEqualTo = ne.gte = function(e) {
    return this.cmp(e) >= 0
};
ne.isInteger = ne.isint = function() {
    return this.e > this.d.length - 2
};
ne.isNegative = ne.isneg = function() {
    return this.s < 0
};
ne.isPositive = ne.ispos = function() {
    return this.s > 0
};
ne.isZero = function() {
    return this.s === 0
};
ne.lessThan = ne.lt = function(e) {
    return this.cmp(e) < 0
};
ne.lessThanOrEqualTo = ne.lte = function(e) {
    return this.cmp(e) < 1
};
ne.logarithm = ne.log = function(e) {
    var t, n = this,
        r = n.constructor,
        i = r.precision,
        o = i + 5;
    if (e === void 0) e = new r(10);
    else if (e = new r(e), e.s < 1 || e.eq(Ln)) throw Error(mr + "NaN");
    if (n.s < 1) throw Error(mr + (n.s ? "NaN" : "-Infinity"));
    return n.eq(Ln) ? new r(0) : (it = !1, t = qi(Id(n, o), Id(e, o), o), it = !0, We(t, i))
};
ne.minus = ne.sub = function(e) {
    var t = this;
    return e = new t.constructor(e), t.s == e.s ? $4(t, e) : B4(t, (e.s = -e.s, e))
};
ne.modulo = ne.mod = function(e) {
    var t, n = this,
        r = n.constructor,
        i = r.precision;
    if (e = new r(e), !e.s) throw Error(mr + "NaN");
    return n.s ? (it = !1, t = qi(n, e, 0, 1).times(e), it = !0, n.minus(t)) : We(new r(n), i)
};
ne.naturalExponential = ne.exp = function() {
    return D4(this)
};
ne.naturalLogarithm = ne.ln = function() {
    return Id(this)
};
ne.negated = ne.neg = function() {
    var e = new this.constructor(this);
    return e.s = -e.s || 0, e
};
ne.plus = ne.add = function(e) {
    var t = this;
    return e = new t.constructor(e), t.s == e.s ? B4(t, e) : $4(t, (e.s = -e.s, e))
};
ne.precision = ne.sd = function(e) {
    var t, n, r, i = this;
    if (e !== void 0 && e !== !!e && e !== 1 && e !== 0) throw Error(fs + e);
    if (t = Ot(i) + 1, r = i.d.length - 1, n = r * Je + 1, r = i.d[r], r) {
        for (; r % 10 == 0; r /= 10) n--;
        for (r = i.d[0]; r >= 10; r /= 10) n++
    }
    return e && t > n ? t : n
};
ne.squareRoot = ne.sqrt = function() {
    var e, t, n, r, i, o, a, s = this,
        u = s.constructor;
    if (s.s < 1) {
        if (!s.s) return new u(0);
        throw Error(mr + "NaN")
    }
    for (e = Ot(s), it = !1, i = Math.sqrt(+s), i == 0 || i == 1 / 0 ? (t = ri(s.d), (t.length + e) % 2 == 0 && (t += "0"), i = Math.sqrt(t), e = uc((e + 1) / 2) - (e < 0 || e % 2), i == 1 / 0 ? t = "5e" + e : (t = i.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + e), r = new u(t)) : r = new u(i.toString()), n = u.precision, i = a = n + 3;;)
        if (o = r, r = o.plus(qi(s, o, a + 2)).times(.5), ri(o.d).slice(0, a) === (t = ri(r.d)).slice(0, a)) {
            if (t = t.slice(a - 3, a + 1), i == a && t == "4999") {
                if (We(o, n + 1, 0), o.times(o).eq(s)) {
                    r = o;
                    break
                }
            } else if (t != "9999") break;
            a += 4
        }
    return it = !0, We(r, n)
};
ne.times = ne.mul = function(e) {
    var t, n, r, i, o, a, s, u, l, c = this,
        f = c.constructor,
        d = c.d,
        h = (e = new f(e)).d;
    if (!c.s || !e.s) return new f(0);
    for (e.s *= c.s, n = c.e + e.e, u = d.length, l = h.length, u < l && (o = d, d = h, h = o, a = u, u = l, l = a), o = [], a = u + l, r = a; r--;) o.push(0);
    for (r = l; --r >= 0;) {
        for (t = 0, i = u + r; i > r;) s = o[i] + h[r] * d[i - r - 1] + t, o[i--] = s % Dt | 0, t = s / Dt | 0;
        o[i] = (o[i] + t) % Dt | 0
    }
    for (; !o[--a];) o.pop();
    return t ? ++n : o.shift(), e.d = o, e.e = n, it ? We(e, f.precision) : e
};
ne.toDecimalPlaces = ne.todp = function(e, t) {
    var n = this,
        r = n.constructor;
    return n = new r(n), e === void 0 ? n : (gi(e, 0, sc), t === void 0 ? t = r.rounding : gi(t, 0, 8), We(n, e + Ot(n) + 1, t))
};
ne.toExponential = function(e, t) {
    var n, r = this,
        i = r.constructor;
    return e === void 0 ? n = Cs(r, !0) : (gi(e, 0, sc), t === void 0 ? t = i.rounding : gi(t, 0, 8), r = We(new i(r), e + 1, t), n = Cs(r, !0, e + 1)), n
};
ne.toFixed = function(e, t) {
    var n, r, i = this,
        o = i.constructor;
    return e === void 0 ? Cs(i) : (gi(e, 0, sc), t === void 0 ? t = o.rounding : gi(t, 0, 8), r = We(new o(i), e + Ot(i) + 1, t), n = Cs(r.abs(), !1, e + Ot(r) + 1), i.isneg() && !i.isZero() ? "-" + n : n)
};
ne.toInteger = ne.toint = function() {
    var e = this,
        t = e.constructor;
    return We(new t(e), Ot(e) + 1, t.rounding)
};
ne.toNumber = function() {
    return +this
};
ne.toPower = ne.pow = function(e) {
    var t, n, r, i, o, a, s = this,
        u = s.constructor,
        l = 12,
        c = +(e = new u(e));
    if (!e.s) return new u(Ln);
    if (s = new u(s), !s.s) {
        if (e.s < 1) throw Error(mr + "Infinity");
        return s
    }
    if (s.eq(Ln)) return s;
    if (r = u.precision, e.eq(Ln)) return We(s, r);
    if (t = e.e, n = e.d.length - 1, a = t >= n, o = s.s, a) {
        if ((n = c < 0 ? -c : c) <= j4) {
            for (i = new u(Ln), t = Math.ceil(r / Je + 4), it = !1; n % 2 && (i = i.times(s), kI(i.d, t)), n = uc(n / 2), n !== 0;) s = s.times(s), kI(s.d, t);
            return it = !0, e.s < 0 ? new u(Ln).div(i) : We(i, r)
        }
    } else if (o < 0) throw Error(mr + "NaN");
    return o = o < 0 && e.d[Math.max(t, n)] & 1 ? -1 : 1, s.s = 1, it = !1, i = e.times(Id(s, r + l)), it = !0, i = D4(i), i.s = o, i
};
ne.toPrecision = function(e, t) {
    var n, r, i = this,
        o = i.constructor;
    return e === void 0 ? (n = Ot(i), r = Cs(i, n <= o.toExpNeg || n >= o.toExpPos)) : (gi(e, 1, sc), t === void 0 ? t = o.rounding : gi(t, 0, 8), i = We(new o(i), e, t), n = Ot(i), r = Cs(i, e <= n || n <= o.toExpNeg, e)), r
};
ne.toSignificantDigits = ne.tosd = function(e, t) {
    var n = this,
        r = n.constructor;
    return e === void 0 ? (e = r.precision, t = r.rounding) : (gi(e, 1, sc), t === void 0 ? t = r.rounding : gi(t, 0, 8)), We(new r(n), e, t)
};
ne.toString = ne.valueOf = ne.val = ne.toJSON = ne[Symbol.for("nodejs.util.inspect.custom")] = function() {
    var e = this,
        t = Ot(e),
        n = e.constructor;
    return Cs(e, t <= n.toExpNeg || t >= n.toExpPos)
};

function B4(e, t) {
    var n, r, i, o, a, s, u, l, c = e.constructor,
        f = c.precision;
    if (!e.s || !t.s) return t.s || (t = new c(e)), it ? We(t, f) : t;
    if (u = e.d, l = t.d, a = e.e, i = t.e, u = u.slice(), o = a - i, o) {
        for (o < 0 ? (r = u, o = -o, s = l.length) : (r = l, i = a, s = u.length), a = Math.ceil(f / Je), s = a > s ? a + 1 : s + 1, o > s && (o = s, r.length = 1), r.reverse(); o--;) r.push(0);
        r.reverse()
    }
    for (s = u.length, o = l.length, s - o < 0 && (o = s, r = l, l = u, u = r), n = 0; o;) n = (u[--o] = u[o] + l[o] + n) / Dt | 0, u[o] %= Dt;
    for (n && (u.unshift(n), ++i), s = u.length; u[--s] == 0;) u.pop();
    return t.d = u, t.e = i, it ? We(t, f) : t
}

function gi(e, t, n) {
    if (e !== ~~e || e < t || e > n) throw Error(fs + e)
}

function ri(e) {
    var t, n, r, i = e.length - 1,
        o = "",
        a = e[0];
    if (i > 0) {
        for (o += a, t = 1; t < i; t++) r = e[t] + "", n = Je - r.length, n && (o += Io(n)), o += r;
        a = e[t], r = a + "", n = Je - r.length, n && (o += Io(n))
    } else if (a === 0) return "0";
    for (; a % 10 === 0;) a /= 10;
    return o + a
}
var qi = function() {
    function e(r, i) {
        var o, a = 0,
            s = r.length;
        for (r = r.slice(); s--;) o = r[s] * i + a, r[s] = o % Dt | 0, a = o / Dt | 0;
        return a && r.unshift(a), r
    }

    function t(r, i, o, a) {
        var s, u;
        if (o != a) u = o > a ? 1 : -1;
        else
            for (s = u = 0; s < o; s++)
                if (r[s] != i[s]) {
                    u = r[s] > i[s] ? 1 : -1;
                    break
                } return u
    }

    function n(r, i, o) {
        for (var a = 0; o--;) r[o] -= a, a = r[o] < i[o] ? 1 : 0, r[o] = a * Dt + r[o] - i[o];
        for (; !r[0] && r.length > 1;) r.shift()
    }
    return function(r, i, o, a) {
        var s, u, l, c, f, d, h, m, p, y, g, b, v, A, w, x, T, _, O = r.constructor,
            k = r.s == i.s ? 1 : -1,
            I = r.d,
            M = i.d;
        if (!r.s) return new O(r);
        if (!i.s) throw Error(mr + "Division by zero");
        for (u = r.e - i.e, T = M.length, w = I.length, h = new O(k), m = h.d = [], l = 0; M[l] == (I[l] || 0);) ++l;
        if (M[l] > (I[l] || 0) && --u, o == null ? b = o = O.precision : a ? b = o + (Ot(r) - Ot(i)) + 1 : b = o, b < 0) return new O(0);
        if (b = b / Je + 2 | 0, l = 0, T == 1)
            for (c = 0, M = M[0], b++;
                (l < w || c) && b--; l++) v = c * Dt + (I[l] || 0), m[l] = v / M | 0, c = v % M | 0;
        else {
            for (c = Dt / (M[0] + 1) | 0, c > 1 && (M = e(M, c), I = e(I, c), T = M.length, w = I.length), A = T, p = I.slice(0, T), y = p.length; y < T;) p[y++] = 0;
            _ = M.slice(), _.unshift(0), x = M[0], M[1] >= Dt / 2 && ++x;
            do c = 0, s = t(M, p, T, y), s < 0 ? (g = p[0], T != y && (g = g * Dt + (p[1] || 0)), c = g / x | 0, c > 1 ? (c >= Dt && (c = Dt - 1), f = e(M, c), d = f.length, y = p.length, s = t(f, p, d, y), s == 1 && (c--, n(f, T < d ? _ : M, d))) : (c == 0 && (s = c = 1), f = M.slice()), d = f.length, d < y && f.unshift(0), n(p, f, y), s == -1 && (y = p.length, s = t(M, p, T, y), s < 1 && (c++, n(p, T < y ? _ : M, y))), y = p.length) : s === 0 && (c++, p = [0]), m[l++] = c, s && p[0] ? p[y++] = I[A] || 0 : (p = [I[A]], y = 1); while ((A++ < w || p[0] !== void 0) && b--)
        }
        return m[0] || m.shift(), h.e = u, We(h, a ? o + Ot(h) + 1 : o)
    }
}();

function D4(e, t) {
    var n, r, i, o, a, s, u = 0,
        l = 0,
        c = e.constructor,
        f = c.precision;
    if (Ot(e) > 16) throw Error(bT + Ot(e));
    if (!e.s) return new c(Ln);
    for (it = !1, s = f, a = new c(.03125); e.abs().gte(.1);) e = e.times(a), l += 5;
    for (r = Math.log(Na(2, l)) / Math.LN10 * 2 + 5 | 0, s += r, n = i = o = new c(Ln), c.precision = s;;) {
        if (i = We(i.times(e), s), n = n.times(++u), a = o.plus(qi(i, n, s)), ri(a.d).slice(0, s) === ri(o.d).slice(0, s)) {
            for (; l--;) o = We(o.times(o), s);
            return c.precision = f, t == null ? (it = !0, We(o, f)) : o
        }
        o = a
    }
}

function Ot(e) {
    for (var t = e.e * Je, n = e.d[0]; n >= 10; n /= 10) t++;
    return t
}

function Kb(e, t, n) {
    if (t > e.LN10.sd()) throw it = !0, n && (e.precision = n), Error(mr + "LN10 precision limit exceeded");
    return We(new e(e.LN10), t)
}

function Io(e) {
    for (var t = ""; e--;) t += "0";
    return t
}

function Id(e, t) {
    var n, r, i, o, a, s, u, l, c, f = 1,
        d = 10,
        h = e,
        m = h.d,
        p = h.constructor,
        y = p.precision;
    if (h.s < 1) throw Error(mr + (h.s ? "NaN" : "-Infinity"));
    if (h.eq(Ln)) return new p(0);
    if (t == null ? (it = !1, l = y) : l = t, h.eq(10)) return t == null && (it = !0), Kb(p, l);
    if (l += d, p.precision = l, n = ri(m), r = n.charAt(0), o = Ot(h), Math.abs(o) < 15e14) {
        for (; r < 7 && r != 1 || r == 1 && n.charAt(1) > 3;) h = h.times(e), n = ri(h.d), r = n.charAt(0), f++;
        o = Ot(h), r > 1 ? (h = new p("0." + n), o++) : h = new p(r + "." + n.slice(1))
    } else return u = Kb(p, l + 2, y).times(o + ""), h = Id(new p(r + "." + n.slice(1)), l - d).plus(u), p.precision = y, t == null ? (it = !0, We(h, y)) : h;
    for (s = a = h = qi(h.minus(Ln), h.plus(Ln), l), c = We(h.times(h), l), i = 3;;) {
        if (a = We(a.times(c), l), u = s.plus(qi(a, new p(i), l)), ri(u.d).slice(0, l) === ri(s.d).slice(0, l)) return s = s.times(2), o !== 0 && (s = s.plus(Kb(p, l + 2, y).times(o + ""))), s = qi(s, new p(f), l), p.precision = y, t == null ? (it = !0, We(s, y)) : s;
        s = u, i += 2
    }
}

function OI(e, t) {
    var n, r, i;
    for ((n = t.indexOf(".")) > -1 && (t = t.replace(".", "")), (r = t.search(/e/i)) > 0 ? (n < 0 && (n = r), n += +t.slice(r + 1), t = t.substring(0, r)) : n < 0 && (n = t.length), r = 0; t.charCodeAt(r) === 48;) ++r;
    for (i = t.length; t.charCodeAt(i - 1) === 48;) --i;
    if (t = t.slice(r, i), t) {
        if (i -= r, n = n - r - 1, e.e = uc(n / Je), e.d = [], r = (n + 1) % Je, n < 0 && (r += Je), r < i) {
            for (r && e.d.push(+t.slice(0, r)), i -= Je; r < i;) e.d.push(+t.slice(r, r += Je));
            t = t.slice(r), r = Je - t.length
        } else r -= i;
        for (; r--;) t += "0";
        if (e.d.push(+t), it && (e.e > iy || e.e < -iy)) throw Error(bT + n)
    } else e.s = 0, e.e = 0, e.d = [0];
    return e
}

function We(e, t, n) {
    var r, i, o, a, s, u, l, c, f = e.d;
    for (a = 1, o = f[0]; o >= 10; o /= 10) a++;
    if (r = t - a, r < 0) r += Je, i = t, l = f[c = 0];
    else {
        if (c = Math.ceil((r + 1) / Je), o = f.length, c >= o) return e;
        for (l = o = f[c], a = 1; o >= 10; o /= 10) a++;
        r %= Je, i = r - Je + a
    }
    if (n !== void 0 && (o = Na(10, a - i - 1), s = l / o % 10 | 0, u = t < 0 || f[c + 1] !== void 0 || l % o, u = n < 4 ? (s || u) && (n == 0 || n == (e.s < 0 ? 3 : 2)) : s > 5 || s == 5 && (n == 4 || u || n == 6 && (r > 0 ? i > 0 ? l / Na(10, a - i) : 0 : f[c - 1]) % 10 & 1 || n == (e.s < 0 ? 8 : 7))), t < 1 || !f[0]) return u ? (o = Ot(e), f.length = 1, t = t - o - 1, f[0] = Na(10, (Je - t % Je) % Je), e.e = uc(-t / Je) || 0) : (f.length = 1, f[0] = e.e = e.s = 0), e;
    if (r == 0 ? (f.length = c, o = 1, c--) : (f.length = c + 1, o = Na(10, Je - r), f[c] = i > 0 ? (l / Na(10, a - i) % Na(10, i) | 0) * o : 0), u)
        for (;;)
            if (c == 0) {
                (f[0] += o) == Dt && (f[0] = 1, ++e.e);
                break
            } else {
                if (f[c] += o, f[c] != Dt) break;
                f[c--] = 0, o = 1
            }
    for (r = f.length; f[--r] === 0;) f.pop();
    if (it && (e.e > iy || e.e < -iy)) throw Error(bT + Ot(e));
    return e
}

function $4(e, t) {
    var n, r, i, o, a, s, u, l, c, f, d = e.constructor,
        h = d.precision;
    if (!e.s || !t.s) return t.s ? t.s = -t.s : t = new d(e), it ? We(t, h) : t;
    if (u = e.d, f = t.d, r = t.e, l = e.e, u = u.slice(), a = l - r, a) {
        for (c = a < 0, c ? (n = u, a = -a, s = f.length) : (n = f, r = l, s = u.length), i = Math.max(Math.ceil(h / Je), s) + 2, a > i && (a = i, n.length = 1), n.reverse(), i = a; i--;) n.push(0);
        n.reverse()
    } else {
        for (i = u.length, s = f.length, c = i < s, c && (s = i), i = 0; i < s; i++)
            if (u[i] != f[i]) {
                c = u[i] < f[i];
                break
            }
        a = 0
    }
    for (c && (n = u, u = f, f = n, t.s = -t.s), s = u.length, i = f.length - s; i > 0; --i) u[s++] = 0;
    for (i = f.length; i > a;) {
        if (u[--i] < f[i]) {
            for (o = i; o && u[--o] === 0;) u[o] = Dt - 1;
            --u[o], u[i] += Dt
        }
        u[i] -= f[i]
    }
    for (; u[--s] === 0;) u.pop();
    for (; u[0] === 0; u.shift()) --r;
    return u[0] ? (t.d = u, t.e = r, it ? We(t, h) : t) : new d(0)
}

function Cs(e, t, n) {
    var r, i = Ot(e),
        o = ri(e.d),
        a = o.length;
    return t ? (n && (r = n - a) > 0 ? o = o.charAt(0) + "." + o.slice(1) + Io(r) : a > 1 && (o = o.charAt(0) + "." + o.slice(1)), o = o + (i < 0 ? "e" : "e+") + i) : i < 0 ? (o = "0." + Io(-i - 1) + o, n && (r = n - a) > 0 && (o += Io(r))) : i >= a ? (o += Io(i + 1 - a), n && (r = n - i - 1) > 0 && (o = o + "." + Io(r))) : ((r = i + 1) < a && (o = o.slice(0, r) + "." + o.slice(r)), n && (r = n - a) > 0 && (i + 1 === a && (o += "."), o += Io(r))), e.s < 0 ? "-" + o : o
}

function kI(e, t) {
    if (e.length > t) return e.length = t, !0
}

function L4(e) {
    var t, n, r;

    function i(o) {
        var a = this;
        if (!(a instanceof i)) return new i(o);
        if (a.constructor = i, o instanceof i) {
            a.s = o.s, a.e = o.e, a.d = (o = o.d) ? o.slice() : o;
            return
        }
        if (typeof o == "number") {
            if (o * 0 !== 0) throw Error(fs + o);
            if (o > 0) a.s = 1;
            else if (o < 0) o = -o, a.s = -1;
            else {
                a.s = 0, a.e = 0, a.d = [0];
                return
            }
            if (o === ~~o && o < 1e7) {
                a.e = 0, a.d = [o];
                return
            }
            return OI(a, o.toString())
        } else if (typeof o != "string") throw Error(fs + o);
        if (o.charCodeAt(0) === 45 ? (o = o.slice(1), a.s = -1) : a.s = 1, jxe.test(o)) OI(a, o);
        else throw Error(fs + o)
    }
    if (i.prototype = ne, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.clone = L4, i.config = i.set = Bxe, e === void 0 && (e = {}), e)
        for (r = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"], t = 0; t < r.length;) e.hasOwnProperty(n = r[t++]) || (e[n] = this[n]);
    return i.config(e), i
}

function Bxe(e) {
    if (!e || typeof e != "object") throw Error(mr + "Object expected");
    var t, n, r, i = ["precision", 1, sc, "rounding", 0, 8, "toExpNeg", -1 / 0, 0, "toExpPos", 0, 1 / 0];
    for (t = 0; t < i.length; t += 3)
        if ((r = e[n = i[t]]) !== void 0)
            if (uc(r) === r && r >= i[t + 1] && r <= i[t + 2]) this[n] = r;
            else throw Error(fs + n + ": " + r);
    if ((r = e[n = "LN10"]) !== void 0)
        if (r == Math.LN10) this[n] = new this(r);
        else throw Error(fs + n + ": " + r);
    return this
}
var wT = L4(Rxe);
Ln = new wT(1);
const He = wT;

function Dxe(e) {
    return Uxe(e) || Fxe(e) || Lxe(e) || $xe()
}

function $xe() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function Lxe(e, t) {
    if (e) {
        if (typeof e == "string") return H1(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return H1(e, t)
    }
}

function Fxe(e) {
    if (typeof Symbol < "u" && Symbol.iterator in Object(e)) return Array.from(e)
}

function Uxe(e) {
    if (Array.isArray(e)) return H1(e)
}

function H1(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}
var Hxe = function(t) {
        return t
    },
    F4 = {},
    U4 = function(t) {
        return t === F4
    },
    CI = function(t) {
        return function n() {
            return arguments.length === 0 || arguments.length === 1 && U4(arguments.length <= 0 ? void 0 : arguments[0]) ? n : t.apply(void 0, arguments)
        }
    },
    Vxe = function e(t, n) {
        return t === 1 ? n : CI(function() {
            for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++) i[o] = arguments[o];
            var a = i.filter(function(s) {
                return s !== F4
            }).length;
            return a >= t ? n.apply(void 0, i) : e(t - a, CI(function() {
                for (var s = arguments.length, u = new Array(s), l = 0; l < s; l++) u[l] = arguments[l];
                var c = i.map(function(f) {
                    return U4(f) ? u.shift() : f
                });
                return n.apply(void 0, Dxe(c).concat(u))
            }))
        })
    },
    i0 = function(t) {
        return Vxe(t.length, t)
    },
    V1 = function(t, n) {
        for (var r = [], i = t; i < n; ++i) r[i - t] = i;
        return r
    },
    zxe = i0(function(e, t) {
        return Array.isArray(t) ? t.map(e) : Object.keys(t).map(function(n) {
            return t[n]
        }).map(e)
    }),
    Wxe = function() {
        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];
        if (!n.length) return Hxe;
        var i = n.reverse(),
            o = i[0],
            a = i.slice(1);
        return function() {
            return a.reduce(function(s, u) {
                return u(s)
            }, o.apply(void 0, arguments))
        }
    },
    z1 = function(t) {
        return Array.isArray(t) ? t.reverse() : t.split("").reverse.join("")
    },
    H4 = function(t) {
        var n = null,
            r = null;
        return function() {
            for (var i = arguments.length, o = new Array(i), a = 0; a < i; a++) o[a] = arguments[a];
            return n && o.every(function(s, u) {
                return s === n[u]
            }) || (n = o, r = t.apply(void 0, o)), r
        }
    };

function Gxe(e) {
    var t;
    return e === 0 ? t = 1 : t = Math.floor(new He(e).abs().log(10).toNumber()) + 1, t
}

function qxe(e, t, n) {
    for (var r = new He(e), i = 0, o = []; r.lt(t) && i < 1e5;) o.push(r.toNumber()), r = r.add(n), i++;
    return o
}
var Kxe = i0(function(e, t, n) {
        var r = +e,
            i = +t;
        return r + n * (i - r)
    }),
    Qxe = i0(function(e, t, n) {
        var r = t - +e;
        return r = r || 1 / 0, (n - e) / r
    }),
    Yxe = i0(function(e, t, n) {
        var r = t - +e;
        return r = r || 1 / 0, Math.max(0, Math.min(1, (n - e) / r))
    });
const o0 = {
    rangeStep: qxe,
    getDigitCount: Gxe,
    interpolateNumber: Kxe,
    uninterpolateNumber: Qxe,
    uninterpolateTruncation: Yxe
};

function W1(e) {
    return Jxe(e) || Zxe(e) || V4(e) || Xxe()
}

function Xxe() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function Zxe(e) {
    if (typeof Symbol < "u" && Symbol.iterator in Object(e)) return Array.from(e)
}

function Jxe(e) {
    if (Array.isArray(e)) return G1(e)
}

function Md(e, t) {
    return n1e(e) || t1e(e, t) || V4(e, t) || e1e()
}

function e1e() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function V4(e, t) {
    if (e) {
        if (typeof e == "string") return G1(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return G1(e, t)
    }
}

function G1(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}

function t1e(e, t) {
    if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(e)))) {
        var n = [],
            r = !0,
            i = !1,
            o = void 0;
        try {
            for (var a = e[Symbol.iterator](), s; !(r = (s = a.next()).done) && (n.push(s.value), !(t && n.length === t)); r = !0);
        } catch (u) {
            i = !0, o = u
        } finally {
            try {
                !r && a.return != null && a.return()
            } finally {
                if (i) throw o
            }
        }
        return n
    }
}

function n1e(e) {
    if (Array.isArray(e)) return e
}

function z4(e) {
    var t = Md(e, 2),
        n = t[0],
        r = t[1],
        i = n,
        o = r;
    return n > r && (i = r, o = n), [i, o]
}

function W4(e, t, n) {
    if (e.lte(0)) return new He(0);
    var r = o0.getDigitCount(e.toNumber()),
        i = new He(10).pow(r),
        o = e.div(i),
        a = r !== 1 ? .05 : .1,
        s = new He(Math.ceil(o.div(a).toNumber())).add(n).mul(a),
        u = s.mul(i);
    return t ? u : new He(Math.ceil(u))
}

function r1e(e, t, n) {
    var r = 1,
        i = new He(e);
    if (!i.isint() && n) {
        var o = Math.abs(e);
        o < 1 ? (r = new He(10).pow(o0.getDigitCount(e) - 1), i = new He(Math.floor(i.div(r).toNumber())).mul(r)) : o > 1 && (i = new He(Math.floor(e)))
    } else e === 0 ? i = new He(Math.floor((t - 1) / 2)) : n || (i = new He(Math.floor(e)));
    var a = Math.floor((t - 1) / 2),
        s = Wxe(zxe(function(u) {
            return i.add(new He(u - a).mul(r)).toNumber()
        }), V1);
    return s(0, t)
}

function G4(e, t, n, r) {
    var i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    if (!Number.isFinite((t - e) / (n - 1))) return {
        step: new He(0),
        tickMin: new He(0),
        tickMax: new He(0)
    };
    var o = W4(new He(t).sub(e).div(n - 1), r, i),
        a;
    e <= 0 && t >= 0 ? a = new He(0) : (a = new He(e).add(t).div(2), a = a.sub(new He(a).mod(o)));
    var s = Math.ceil(a.sub(e).div(o).toNumber()),
        u = Math.ceil(new He(t).sub(a).div(o).toNumber()),
        l = s + u + 1;
    return l > n ? G4(e, t, n, r, i + 1) : (l < n && (u = t > 0 ? u + (n - l) : u, s = t > 0 ? s : s + (n - l)), {
        step: o,
        tickMin: a.sub(new He(s).mul(o)),
        tickMax: a.add(new He(u).mul(o))
    })
}

function i1e(e) {
    var t = Md(e, 2),
        n = t[0],
        r = t[1],
        i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6,
        o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0,
        a = Math.max(i, 2),
        s = z4([n, r]),
        u = Md(s, 2),
        l = u[0],
        c = u[1];
    if (l === -1 / 0 || c === 1 / 0) {
        var f = c === 1 / 0 ? [l].concat(W1(V1(0, i - 1).map(function() {
            return 1 / 0
        }))) : [].concat(W1(V1(0, i - 1).map(function() {
            return -1 / 0
        })), [c]);
        return n > r ? z1(f) : f
    }
    if (l === c) return r1e(l, i, o);
    var d = G4(l, c, a, o),
        h = d.step,
        m = d.tickMin,
        p = d.tickMax,
        y = o0.rangeStep(m, p.add(new He(.1).mul(h)), h);
    return n > r ? z1(y) : y
}

function o1e(e, t) {
    var n = Md(e, 2),
        r = n[0],
        i = n[1],
        o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0,
        a = z4([r, i]),
        s = Md(a, 2),
        u = s[0],
        l = s[1];
    if (u === -1 / 0 || l === 1 / 0) return [r, i];
    if (u === l) return [u];
    var c = Math.max(t, 2),
        f = W4(new He(l).sub(u).div(c - 1), o, 0),
        d = [].concat(W1(o0.rangeStep(new He(u), new He(l).sub(new He(.99).mul(f)), f)), [l]);
    return r > i ? z1(d) : d
}
var a1e = H4(i1e),
    s1e = H4(o1e),
    u1e = "Invariant failed";

function Is(e, t) {
    throw new Error(u1e)
}
var l1e = ["offset", "layout", "width", "dataKey", "data", "dataPointFormatter", "xAxis", "yAxis"];

function Al(e) {
    "@babel/helpers - typeof";
    return Al = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Al(e)
}

function oy() {
    return oy = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, oy.apply(this, arguments)
}

function c1e(e, t) {
    return p1e(e) || h1e(e, t) || d1e(e, t) || f1e()
}

function f1e() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function d1e(e, t) {
    if (e) {
        if (typeof e == "string") return II(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return II(e, t)
    }
}

function II(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}

function h1e(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
        var r, i, o, a, s = [],
            u = !0,
            l = !1;
        try {
            if (o = (n = n.call(e)).next, t !== 0)
                for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0);
        } catch (c) {
            l = !0, i = c
        } finally {
            try {
                if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return
            } finally {
                if (l) throw i
            }
        }
        return s
    }
}

function p1e(e) {
    if (Array.isArray(e)) return e
}

function m1e(e, t) {
    if (e == null) return {};
    var n = g1e(e, t),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        for (i = 0; i < o.length; i++) r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
    }
    return n
}

function g1e(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
            if (t.indexOf(r) >= 0) continue;
            n[r] = e[r]
        }
    return n
}

function y1e(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function v1e(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, Q4(r.key), r)
    }
}

function b1e(e, t, n) {
    return t && v1e(e.prototype, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function w1e(e, t, n) {
    return t = ay(t), x1e(e, q4() ? Reflect.construct(t, n || [], ay(e).constructor) : t.apply(e, n))
}

function x1e(e, t) {
    if (t && (Al(t) === "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return A1e(e)
}

function A1e(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function q4() {
    try {
        var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (q4 = function() {
        return !!e
    })()
}

function ay(e) {
    return ay = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }, ay(e)
}

function E1e(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(e, "prototype", {
        writable: !1
    }), t && q1(e, t)
}

function q1(e, t) {
    return q1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i, r
    }, q1(e, t)
}

function K4(e, t, n) {
    return t = Q4(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function Q4(e) {
    var t = S1e(e, "string");
    return Al(t) == "symbol" ? t : t + ""
}

function S1e(e, t) {
    if (Al(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Al(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(e)
}
var a0 = function(e) {
    function t() {
        return y1e(this, t), w1e(this, t, arguments)
    }
    return E1e(t, e), b1e(t, [{
        key: "render",
        value: function() {
            var r = this.props,
                i = r.offset,
                o = r.layout,
                a = r.width,
                s = r.dataKey,
                u = r.data,
                l = r.dataPointFormatter,
                c = r.xAxis,
                f = r.yAxis,
                d = m1e(r, l1e),
                h = _e(d, !1);
            this.props.direction === "x" && c.type !== "number" && Is();
            var m = u.map(function(p) {
                var y = l(p, s),
                    g = y.x,
                    b = y.y,
                    v = y.value,
                    A = y.errorVal;
                if (!A) return null;
                var w = [],
                    x, T;
                if (Array.isArray(A)) {
                    var _ = c1e(A, 2);
                    x = _[0], T = _[1]
                } else x = T = A;
                if (o === "vertical") {
                    var O = c.scale,
                        k = b + i,
                        I = k + a,
                        M = k - a,
                        B = O(v - x),
                        L = O(v + T);
                    w.push({
                        x1: L,
                        y1: I,
                        x2: L,
                        y2: M
                    }), w.push({
                        x1: B,
                        y1: k,
                        x2: L,
                        y2: k
                    }), w.push({
                        x1: B,
                        y1: I,
                        x2: B,
                        y2: M
                    })
                } else if (o === "horizontal") {
                    var P = f.scale,
                        C = g + i,
                        j = C - a,
                        N = C + a,
                        D = P(v - x),
                        $ = P(v + T);
                    w.push({
                        x1: j,
                        y1: $,
                        x2: N,
                        y2: $
                    }), w.push({
                        x1: C,
                        y1: D,
                        x2: C,
                        y2: $
                    }), w.push({
                        x1: j,
                        y1: D,
                        x2: N,
                        y2: D
                    })
                }
                return R.createElement(lt, oy({
                    className: "recharts-errorBar",
                    key: "bar-".concat(w.map(function(V) {
                        return "".concat(V.x1, "-").concat(V.x2, "-").concat(V.y1, "-").concat(V.y2)
                    }))
                }, h), w.map(function(V) {
                    return R.createElement("line", oy({}, V, {
                        key: "line-".concat(V.x1, "-").concat(V.x2, "-").concat(V.y1, "-").concat(V.y2)
                    }))
                }))
            });
            return R.createElement(lt, {
                className: "recharts-errorBars"
            }, m)
        }
    }])
}(R.Component);
K4(a0, "defaultProps", {
    stroke: "black",
    strokeWidth: 1.5,
    width: 5,
    offset: 0,
    layout: "horizontal"
});
K4(a0, "displayName", "ErrorBar");

function Nd(e) {
    "@babel/helpers - typeof";
    return Nd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Nd(e)
}

function MI(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function Ta(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? MI(Object(n), !0).forEach(function(r) {
            _1e(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : MI(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function _1e(e, t, n) {
    return t = T1e(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function T1e(e) {
    var t = P1e(e, "string");
    return Nd(t) == "symbol" ? t : t + ""
}

function P1e(e, t) {
    if (Nd(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Nd(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}
var Y4 = function(t) {
    var n = t.children,
        r = t.formattedGraphicalItems,
        i = t.legendWidth,
        o = t.legendContent,
        a = Dn(n, ls);
    if (!a) return null;
    var s = ls.defaultProps,
        u = s !== void 0 ? Ta(Ta({}, s), a.props) : {},
        l;
    return a.props && a.props.payload ? l = a.props && a.props.payload : o === "children" ? l = (r || []).reduce(function(c, f) {
        var d = f.item,
            h = f.props,
            m = h.sectors || h.data || [];
        return c.concat(m.map(function(p) {
            return {
                type: a.props.iconType || d.props.legendType,
                value: p.name,
                color: p.fill,
                payload: p
            }
        }))
    }, []) : l = (r || []).map(function(c) {
        var f = c.item,
            d = f.type.defaultProps,
            h = d !== void 0 ? Ta(Ta({}, d), f.props) : {},
            m = h.dataKey,
            p = h.name,
            y = h.legendType,
            g = h.hide;
        return {
            inactive: g,
            dataKey: m,
            type: u.iconType || y || "square",
            color: xT(f),
            value: p || m,
            payload: h
        }
    }), Ta(Ta(Ta({}, u), ls.getWithHeight(a, i)), {}, {
        payload: l,
        item: a
    })
};

function Rd(e) {
    "@babel/helpers - typeof";
    return Rd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Rd(e)
}

function NI(e) {
    return I1e(e) || C1e(e) || k1e(e) || O1e()
}

function O1e() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function k1e(e, t) {
    if (e) {
        if (typeof e == "string") return K1(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return K1(e, t)
    }
}

function C1e(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e)
}

function I1e(e) {
    if (Array.isArray(e)) return K1(e)
}

function K1(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}

function RI(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function vt(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? RI(Object(n), !0).forEach(function(r) {
            Fu(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RI(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function Fu(e, t, n) {
    return t = M1e(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function M1e(e) {
    var t = N1e(e, "string");
    return Rd(t) == "symbol" ? t : t + ""
}

function N1e(e, t) {
    if (Rd(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Rd(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}

function Gn(e, t, n) {
    return Pe(e) || Pe(t) ? n : Rt(t) ? dr(e, t, n) : Ae(t) ? t(e) : n
}

function yf(e, t, n, r) {
    var i = Cxe(e, function(s) {
        return Gn(s, t)
    });
    if (n === "number") {
        var o = i.filter(function(s) {
            return Y(s) || parseFloat(s)
        });
        return o.length ? [r0(o), Fo(o)] : [1 / 0, -1 / 0]
    }
    var a = r ? i.filter(function(s) {
        return !Pe(s)
    }) : i;
    return a.map(function(s) {
        return Rt(s) || s instanceof Date ? s : ""
    })
}
var R1e = function(t) {
        var n, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
            i = arguments.length > 2 ? arguments[2] : void 0,
            o = arguments.length > 3 ? arguments[3] : void 0,
            a = -1,
            s = (n = r == null ? void 0 : r.length) !== null && n !== void 0 ? n : 0;
        if (s <= 1) return 0;
        if (o && o.axisType === "angleAxis" && Math.abs(Math.abs(o.range[1] - o.range[0]) - 360) <= 1e-6)
            for (var u = o.range, l = 0; l < s; l++) {
                var c = l > 0 ? i[l - 1].coordinate : i[s - 1].coordinate,
                    f = i[l].coordinate,
                    d = l >= s - 1 ? i[0].coordinate : i[l + 1].coordinate,
                    h = void 0;
                if (Mr(f - c) !== Mr(d - f)) {
                    var m = [];
                    if (Mr(d - f) === Mr(u[1] - u[0])) {
                        h = d;
                        var p = f + u[1] - u[0];
                        m[0] = Math.min(p, (p + c) / 2), m[1] = Math.max(p, (p + c) / 2)
                    } else {
                        h = c;
                        var y = d + u[1] - u[0];
                        m[0] = Math.min(f, (y + f) / 2), m[1] = Math.max(f, (y + f) / 2)
                    }
                    var g = [Math.min(f, (h + f) / 2), Math.max(f, (h + f) / 2)];
                    if (t > g[0] && t <= g[1] || t >= m[0] && t <= m[1]) {
                        a = i[l].index;
                        break
                    }
                } else {
                    var b = Math.min(c, d),
                        v = Math.max(c, d);
                    if (t > (b + f) / 2 && t <= (v + f) / 2) {
                        a = i[l].index;
                        break
                    }
                }
            } else
                for (var A = 0; A < s; A++)
                    if (A === 0 && t <= (r[A].coordinate + r[A + 1].coordinate) / 2 || A > 0 && A < s - 1 && t > (r[A].coordinate + r[A - 1].coordinate) / 2 && t <= (r[A].coordinate + r[A + 1].coordinate) / 2 || A === s - 1 && t > (r[A].coordinate + r[A - 1].coordinate) / 2) {
                        a = r[A].index;
                        break
                    }
        return a
    },
    xT = function(t) {
        var n, r = t,
            i = r.type.displayName,
            o = (n = t.type) !== null && n !== void 0 && n.defaultProps ? vt(vt({}, t.type.defaultProps), t.props) : t.props,
            a = o.stroke,
            s = o.fill,
            u;
        switch (i) {
            case "Line":
                u = a;
                break;
            case "Area":
            case "Radar":
                u = a && a !== "none" ? a : s;
                break;
            default:
                u = s;
                break
        }
        return u
    },
    j1e = function(t) {
        var n = t.barSize,
            r = t.totalSize,
            i = t.stackGroups,
            o = i === void 0 ? {} : i;
        if (!o) return {};
        for (var a = {}, s = Object.keys(o), u = 0, l = s.length; u < l; u++)
            for (var c = o[s[u]].stackGroups, f = Object.keys(c), d = 0, h = f.length; d < h; d++) {
                var m = c[f[d]],
                    p = m.items,
                    y = m.cateAxisId,
                    g = p.filter(function(T) {
                        return Gi(T.type).indexOf("Bar") >= 0
                    });
                if (g && g.length) {
                    var b = g[0].type.defaultProps,
                        v = b !== void 0 ? vt(vt({}, b), g[0].props) : g[0].props,
                        A = v.barSize,
                        w = v[y];
                    a[w] || (a[w] = []);
                    var x = Pe(A) ? n : A;
                    a[w].push({
                        item: g[0],
                        stackList: g.slice(1),
                        barSize: Pe(x) ? void 0 : ks(x, r, 0)
                    })
                }
            }
        return a
    },
    B1e = function(t) {
        var n = t.barGap,
            r = t.barCategoryGap,
            i = t.bandSize,
            o = t.sizeList,
            a = o === void 0 ? [] : o,
            s = t.maxBarSize,
            u = a.length;
        if (u < 1) return null;
        var l = ks(n, i, 0, !0),
            c, f = [];
        if (a[0].barSize === +a[0].barSize) {
            var d = !1,
                h = i / u,
                m = a.reduce(function(A, w) {
                    return A + w.barSize || 0
                }, 0);
            m += (u - 1) * l, m >= i && (m -= (u - 1) * l, l = 0), m >= i && h > 0 && (d = !0, h *= .9, m = u * h);
            var p = (i - m) / 2 >> 0,
                y = {
                    offset: p - l,
                    size: 0
                };
            c = a.reduce(function(A, w) {
                var x = {
                        item: w.item,
                        position: {
                            offset: y.offset + y.size + l,
                            size: d ? h : w.barSize
                        }
                    },
                    T = [].concat(NI(A), [x]);
                return y = T[T.length - 1].position, w.stackList && w.stackList.length && w.stackList.forEach(function(_) {
                    T.push({
                        item: _,
                        position: y
                    })
                }), T
            }, f)
        } else {
            var g = ks(r, i, 0, !0);
            i - 2 * g - (u - 1) * l <= 0 && (l = 0);
            var b = (i - 2 * g - (u - 1) * l) / u;
            b > 1 && (b >>= 0);
            var v = s === +s ? Math.min(b, s) : b;
            c = a.reduce(function(A, w, x) {
                var T = [].concat(NI(A), [{
                    item: w.item,
                    position: {
                        offset: g + (b + l) * x + (b - v) / 2,
                        size: v
                    }
                }]);
                return w.stackList && w.stackList.length && w.stackList.forEach(function(_) {
                    T.push({
                        item: _,
                        position: T[T.length - 1].position
                    })
                }), T
            }, f)
        }
        return c
    },
    D1e = function(t, n, r, i) {
        var o = r.children,
            a = r.width,
            s = r.margin,
            u = a - (s.left || 0) - (s.right || 0),
            l = Y4({
                children: o,
                legendWidth: u
            });
        if (l) {
            var c = i || {},
                f = c.width,
                d = c.height,
                h = l.align,
                m = l.verticalAlign,
                p = l.layout;
            if ((p === "vertical" || p === "horizontal" && m === "middle") && h !== "center" && Y(t[h])) return vt(vt({}, t), {}, Fu({}, h, t[h] + (f || 0)));
            if ((p === "horizontal" || p === "vertical" && h === "center") && m !== "middle" && Y(t[m])) return vt(vt({}, t), {}, Fu({}, m, t[m] + (d || 0)))
        }
        return t
    },
    $1e = function(t, n, r) {
        return Pe(n) ? !0 : t === "horizontal" ? n === "yAxis" : t === "vertical" || r === "x" ? n === "xAxis" : r === "y" ? n === "yAxis" : !0
    },
    X4 = function(t, n, r, i, o) {
        var a = n.props.children,
            s = Dr(a, a0).filter(function(l) {
                return $1e(i, o, l.props.direction)
            });
        if (s && s.length) {
            var u = s.map(function(l) {
                return l.props.dataKey
            });
            return t.reduce(function(l, c) {
                var f = Gn(c, r);
                if (Pe(f)) return l;
                var d = Array.isArray(f) ? [r0(f), Fo(f)] : [f, f],
                    h = u.reduce(function(m, p) {
                        var y = Gn(c, p, 0),
                            g = d[0] - Math.abs(Array.isArray(y) ? y[0] : y),
                            b = d[1] + Math.abs(Array.isArray(y) ? y[1] : y);
                        return [Math.min(g, m[0]), Math.max(b, m[1])]
                    }, [1 / 0, -1 / 0]);
                return [Math.min(h[0], l[0]), Math.max(h[1], l[1])]
            }, [1 / 0, -1 / 0])
        }
        return null
    },
    L1e = function(t, n, r, i, o) {
        var a = n.map(function(s) {
            return X4(t, s, r, o, i)
        }).filter(function(s) {
            return !Pe(s)
        });
        return a && a.length ? a.reduce(function(s, u) {
            return [Math.min(s[0], u[0]), Math.max(s[1], u[1])]
        }, [1 / 0, -1 / 0]) : null
    },
    Z4 = function(t, n, r, i, o) {
        var a = n.map(function(u) {
            var l = u.props.dataKey;
            return r === "number" && l && X4(t, u, l, i) || yf(t, l, r, o)
        });
        if (r === "number") return a.reduce(function(u, l) {
            return [Math.min(u[0], l[0]), Math.max(u[1], l[1])]
        }, [1 / 0, -1 / 0]);
        var s = {};
        return a.reduce(function(u, l) {
            for (var c = 0, f = l.length; c < f; c++) s[l[c]] || (s[l[c]] = !0, u.push(l[c]));
            return u
        }, [])
    },
    J4 = function(t, n) {
        return t === "horizontal" && n === "xAxis" || t === "vertical" && n === "yAxis" || t === "centric" && n === "angleAxis" || t === "radial" && n === "radiusAxis"
    },
    Ya = function(t, n, r) {
        if (!t) return null;
        var i = t.scale,
            o = t.duplicateDomain,
            a = t.type,
            s = t.range,
            u = t.realScaleType === "scaleBand" ? i.bandwidth() / 2 : 2,
            l = (n || r) && a === "category" && i.bandwidth ? i.bandwidth() / u : 0;
        if (l = t.axisType === "angleAxis" && (s == null ? void 0 : s.length) >= 2 ? Mr(s[0] - s[1]) * 2 * l : l, n && (t.ticks || t.niceTicks)) {
            var c = (t.ticks || t.niceTicks).map(function(f) {
                var d = o ? o.indexOf(f) : f;
                return {
                    coordinate: i(d) + l,
                    value: f,
                    offset: l
                }
            });
            return c.filter(function(f) {
                return !ec(f.coordinate)
            })
        }
        return t.isCategorical && t.categoricalDomain ? t.categoricalDomain.map(function(f, d) {
            return {
                coordinate: i(f) + l,
                value: f,
                index: d,
                offset: l
            }
        }) : i.ticks && !r ? i.ticks(t.tickCount).map(function(f) {
            return {
                coordinate: i(f) + l,
                value: f,
                offset: l
            }
        }) : i.domain().map(function(f, d) {
            return {
                coordinate: i(f) + l,
                value: o ? o[f] : f,
                index: d,
                offset: l
            }
        })
    },
    Qb = new WeakMap,
    pp = function(t, n) {
        if (typeof n != "function") return t;
        Qb.has(t) || Qb.set(t, new WeakMap);
        var r = Qb.get(t);
        if (r.has(n)) return r.get(n);
        var i = function() {
            t.apply(void 0, arguments), n.apply(void 0, arguments)
        };
        return r.set(n, i), i
    },
    F1e = function(t, n, r) {
        var i = t.scale,
            o = t.type,
            a = t.layout,
            s = t.axisType;
        if (i === "auto") return a === "radial" && s === "radiusAxis" ? {
            scale: _d(),
            realScaleType: "band"
        } : a === "radial" && s === "angleAxis" ? {
            scale: ey(),
            realScaleType: "linear"
        } : o === "category" && n && (n.indexOf("LineChart") >= 0 || n.indexOf("AreaChart") >= 0 || n.indexOf("ComposedChart") >= 0 && !r) ? {
            scale: gf(),
            realScaleType: "point"
        } : o === "category" ? {
            scale: _d(),
            realScaleType: "band"
        } : {
            scale: ey(),
            realScaleType: "linear"
        };
        if (Eh(i)) {
            var u = "scale".concat(zv(i));
            return {
                scale: (PI[u] || gf)(),
                realScaleType: PI[u] ? u : "point"
            }
        }
        return Ae(i) ? {
            scale: i
        } : {
            scale: gf(),
            realScaleType: "point"
        }
    },
    jI = 1e-4,
    U1e = function(t) {
        var n = t.domain();
        if (!(!n || n.length <= 2)) {
            var r = n.length,
                i = t.range(),
                o = Math.min(i[0], i[1]) - jI,
                a = Math.max(i[0], i[1]) + jI,
                s = t(n[0]),
                u = t(n[r - 1]);
            (s < o || s > a || u < o || u > a) && t.domain([n[0], n[r - 1]])
        }
    },
    H1e = function(t, n) {
        if (!t) return null;
        for (var r = 0, i = t.length; r < i; r++)
            if (t[r].item === n) return t[r].position;
        return null
    },
    V1e = function(t, n) {
        if (!n || n.length !== 2 || !Y(n[0]) || !Y(n[1])) return t;
        var r = Math.min(n[0], n[1]),
            i = Math.max(n[0], n[1]),
            o = [t[0], t[1]];
        return (!Y(t[0]) || t[0] < r) && (o[0] = r), (!Y(t[1]) || t[1] > i) && (o[1] = i), o[0] > i && (o[0] = i), o[1] < r && (o[1] = r), o
    },
    z1e = function(t) {
        var n = t.length;
        if (!(n <= 0))
            for (var r = 0, i = t[0].length; r < i; ++r)
                for (var o = 0, a = 0, s = 0; s < n; ++s) {
                    var u = ec(t[s][r][1]) ? t[s][r][0] : t[s][r][1];
                    u >= 0 ? (t[s][r][0] = o, t[s][r][1] = o + u, o = t[s][r][1]) : (t[s][r][0] = a, t[s][r][1] = a + u, a = t[s][r][1])
                }
    },
    W1e = function(t) {
        var n = t.length;
        if (!(n <= 0))
            for (var r = 0, i = t[0].length; r < i; ++r)
                for (var o = 0, a = 0; a < n; ++a) {
                    var s = ec(t[a][r][1]) ? t[a][r][0] : t[a][r][1];
                    s >= 0 ? (t[a][r][0] = o, t[a][r][1] = o + s, o = t[a][r][1]) : (t[a][r][0] = 0, t[a][r][1] = 0)
                }
    },
    G1e = {
        sign: z1e,
        expand: oce,
        none: pl,
        silhouette: ace,
        wiggle: sce,
        positive: W1e
    },
    q1e = function(t, n, r) {
        var i = n.map(function(s) {
                return s.props.dataKey
            }),
            o = G1e[r],
            a = ice().keys(i).value(function(s, u) {
                return +Gn(s, u, 0)
            }).order(b1).offset(o);
        return a(t)
    },
    K1e = function(t, n, r, i, o, a) {
        if (!t) return null;
        var s = a ? n.reverse() : n,
            u = {},
            l = s.reduce(function(f, d) {
                var h, m = (h = d.type) !== null && h !== void 0 && h.defaultProps ? vt(vt({}, d.type.defaultProps), d.props) : d.props,
                    p = m.stackId,
                    y = m.hide;
                if (y) return f;
                var g = m[r],
                    b = f[g] || {
                        hasStack: !1,
                        stackGroups: {}
                    };
                if (Rt(p)) {
                    var v = b.stackGroups[p] || {
                        numericAxisId: r,
                        cateAxisId: i,
                        items: []
                    };
                    v.items.push(d), b.hasStack = !0, b.stackGroups[p] = v
                } else b.stackGroups[Sh("_stackId_")] = {
                    numericAxisId: r,
                    cateAxisId: i,
                    items: [d]
                };
                return vt(vt({}, f), {}, Fu({}, g, b))
            }, u),
            c = {};
        return Object.keys(l).reduce(function(f, d) {
            var h = l[d];
            if (h.hasStack) {
                var m = {};
                h.stackGroups = Object.keys(h.stackGroups).reduce(function(p, y) {
                    var g = h.stackGroups[y];
                    return vt(vt({}, p), {}, Fu({}, y, {
                        numericAxisId: r,
                        cateAxisId: i,
                        items: g.items,
                        stackedData: q1e(t, g.items, o)
                    }))
                }, m)
            }
            return vt(vt({}, f), {}, Fu({}, d, h))
        }, c)
    },
    Q1e = function(t, n) {
        var r = n.realScaleType,
            i = n.type,
            o = n.tickCount,
            a = n.originalDomain,
            s = n.allowDecimals,
            u = r || n.scale;
        if (u !== "auto" && u !== "linear") return null;
        if (o && i === "number" && a && (a[0] === "auto" || a[1] === "auto")) {
            var l = t.domain();
            if (!l.length) return null;
            var c = a1e(l, o, s);
            return t.domain([r0(c), Fo(c)]), {
                niceTicks: c
            }
        }
        if (o && i === "number") {
            var f = t.domain(),
                d = s1e(f, o, s);
            return {
                niceTicks: d
            }
        }
        return null
    };

function BI(e) {
    var t = e.axis,
        n = e.ticks,
        r = e.bandSize,
        i = e.entry,
        o = e.index,
        a = e.dataKey;
    if (t.type === "category") {
        if (!t.allowDuplicatedCategory && t.dataKey && !Pe(i[t.dataKey])) {
            var s = Ig(n, "value", i[t.dataKey]);
            if (s) return s.coordinate + r / 2
        }
        return n[o] ? n[o].coordinate + r / 2 : null
    }
    var u = Gn(i, Pe(a) ? t.dataKey : a);
    return Pe(u) ? null : t.scale(u)
}
var DI = function(t) {
        var n = t.axis,
            r = t.ticks,
            i = t.offset,
            o = t.bandSize,
            a = t.entry,
            s = t.index;
        if (n.type === "category") return r[s] ? r[s].coordinate + i : null;
        var u = Gn(a, n.dataKey, n.domain[s]);
        return Pe(u) ? null : n.scale(u) - o / 2 + i
    },
    Y1e = function(t) {
        var n = t.numericAxis,
            r = n.scale.domain();
        if (n.type === "number") {
            var i = Math.min(r[0], r[1]),
                o = Math.max(r[0], r[1]);
            return i <= 0 && o >= 0 ? 0 : o < 0 ? o : i
        }
        return r[0]
    },
    X1e = function(t, n) {
        var r, i = (r = t.type) !== null && r !== void 0 && r.defaultProps ? vt(vt({}, t.type.defaultProps), t.props) : t.props,
            o = i.stackId;
        if (Rt(o)) {
            var a = n[o];
            if (a) {
                var s = a.items.indexOf(t);
                return s >= 0 ? a.stackedData[s] : null
            }
        }
        return null
    },
    Z1e = function(t) {
        return t.reduce(function(n, r) {
            return [r0(r.concat([n[0]]).filter(Y)), Fo(r.concat([n[1]]).filter(Y))]
        }, [1 / 0, -1 / 0])
    },
    e6 = function(t, n, r) {
        return Object.keys(t).reduce(function(i, o) {
            var a = t[o],
                s = a.stackedData,
                u = s.reduce(function(l, c) {
                    var f = Z1e(c.slice(n, r + 1));
                    return [Math.min(l[0], f[0]), Math.max(l[1], f[1])]
                }, [1 / 0, -1 / 0]);
            return [Math.min(u[0], i[0]), Math.max(u[1], i[1])]
        }, [1 / 0, -1 / 0]).map(function(i) {
            return i === 1 / 0 || i === -1 / 0 ? 0 : i
        })
    },
    $I = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/,
    LI = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/,
    Q1 = function(t, n, r) {
        if (Ae(t)) return t(n, r);
        if (!Array.isArray(t)) return n;
        var i = [];
        if (Y(t[0])) i[0] = r ? t[0] : Math.min(t[0], n[0]);
        else if ($I.test(t[0])) {
            var o = +$I.exec(t[0])[1];
            i[0] = n[0] - o
        } else Ae(t[0]) ? i[0] = t[0](n[0]) : i[0] = n[0];
        if (Y(t[1])) i[1] = r ? t[1] : Math.max(t[1], n[1]);
        else if (LI.test(t[1])) {
            var a = +LI.exec(t[1])[1];
            i[1] = n[1] + a
        } else Ae(t[1]) ? i[1] = t[1](n[1]) : i[1] = n[1];
        return i
    },
    sy = function(t, n, r) {
        if (t && t.scale && t.scale.bandwidth) {
            var i = t.scale.bandwidth();
            if (!r || i > 0) return i
        }
        if (t && n && n.length >= 2) {
            for (var o = Q_(n, function(f) {
                    return f.coordinate
                }), a = 1 / 0, s = 1, u = o.length; s < u; s++) {
                var l = o[s],
                    c = o[s - 1];
                a = Math.min((l.coordinate || 0) - (c.coordinate || 0), a)
            }
            return a === 1 / 0 ? 0 : a
        }
        return r ? void 0 : 0
    },
    FI = function(t, n, r) {
        return !t || !t.length || Cd(t, dr(r, "type.defaultProps.domain")) ? n : t
    },
    t6 = function(t, n) {
        var r = t.type.defaultProps ? vt(vt({}, t.type.defaultProps), t.props) : t.props,
            i = r.dataKey,
            o = r.name,
            a = r.unit,
            s = r.formatter,
            u = r.tooltipType,
            l = r.chartType,
            c = r.hide;
        return vt(vt({}, _e(t, !1)), {}, {
            dataKey: i,
            unit: a,
            formatter: s,
            name: o || i,
            color: xT(t),
            value: Gn(n, i),
            type: u,
            payload: n,
            chartType: l,
            hide: c
        })
    };

function jd(e) {
    "@babel/helpers - typeof";
    return jd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, jd(e)
}

function UI(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function HI(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? UI(Object(n), !0).forEach(function(r) {
            J1e(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UI(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function J1e(e, t, n) {
    return t = eAe(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function eAe(e) {
    var t = tAe(e, "string");
    return jd(t) == "symbol" ? t : t + ""
}

function tAe(e, t) {
    if (jd(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (jd(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}
var uy = Math.PI / 180,
    nAe = function(t) {
        return t * 180 / Math.PI
    },
    Gt = function(t, n, r, i) {
        return {
            x: t + Math.cos(-uy * i) * r,
            y: n + Math.sin(-uy * i) * r
        }
    },
    rAe = function(t, n) {
        var r = t.x,
            i = t.y,
            o = n.x,
            a = n.y;
        return Math.sqrt(Math.pow(r - o, 2) + Math.pow(i - a, 2))
    },
    iAe = function(t, n) {
        var r = t.x,
            i = t.y,
            o = n.cx,
            a = n.cy,
            s = rAe({
                x: r,
                y: i
            }, {
                x: o,
                y: a
            });
        if (s <= 0) return {
            radius: s
        };
        var u = (r - o) / s,
            l = Math.acos(u);
        return i > a && (l = 2 * Math.PI - l), {
            radius: s,
            angle: nAe(l),
            angleInRadian: l
        }
    },
    oAe = function(t) {
        var n = t.startAngle,
            r = t.endAngle,
            i = Math.floor(n / 360),
            o = Math.floor(r / 360),
            a = Math.min(i, o);
        return {
            startAngle: n - a * 360,
            endAngle: r - a * 360
        }
    },
    aAe = function(t, n) {
        var r = n.startAngle,
            i = n.endAngle,
            o = Math.floor(r / 360),
            a = Math.floor(i / 360),
            s = Math.min(o, a);
        return t + s * 360
    },
    VI = function(t, n) {
        var r = t.x,
            i = t.y,
            o = iAe({
                x: r,
                y: i
            }, n),
            a = o.radius,
            s = o.angle,
            u = n.innerRadius,
            l = n.outerRadius;
        if (a < u || a > l) return !1;
        if (a === 0) return !0;
        var c = oAe(n),
            f = c.startAngle,
            d = c.endAngle,
            h = s,
            m;
        if (f <= d) {
            for (; h > d;) h -= 360;
            for (; h < f;) h += 360;
            m = h >= f && h <= d
        } else {
            for (; h > f;) h -= 360;
            for (; h < d;) h += 360;
            m = h >= d && h <= f
        }
        return m ? HI(HI({}, n), {}, {
            radius: a,
            angle: aAe(h, n)
        }) : null
    };

function Bd(e) {
    "@babel/helpers - typeof";
    return Bd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Bd(e)
}
var sAe = ["offset"];

function uAe(e) {
    return dAe(e) || fAe(e) || cAe(e) || lAe()
}

function lAe() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function cAe(e, t) {
    if (e) {
        if (typeof e == "string") return Y1(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Y1(e, t)
    }
}

function fAe(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e)
}

function dAe(e) {
    if (Array.isArray(e)) return Y1(e)
}

function Y1(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}

function hAe(e, t) {
    if (e == null) return {};
    var n = pAe(e, t),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        for (i = 0; i < o.length; i++) r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
    }
    return n
}

function pAe(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
            if (t.indexOf(r) >= 0) continue;
            n[r] = e[r]
        }
    return n
}

function zI(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function kt(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? zI(Object(n), !0).forEach(function(r) {
            mAe(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zI(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function mAe(e, t, n) {
    return t = gAe(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function gAe(e) {
    var t = yAe(e, "string");
    return Bd(t) == "symbol" ? t : t + ""
}

function yAe(e, t) {
    if (Bd(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Bd(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}

function Dd() {
    return Dd = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, Dd.apply(this, arguments)
}
var vAe = function(t) {
        var n = t.value,
            r = t.formatter,
            i = Pe(t.children) ? n : t.children;
        return Ae(r) ? r(i) : i
    },
    bAe = function(t, n) {
        var r = Mr(n - t),
            i = Math.min(Math.abs(n - t), 360);
        return r * i
    },
    wAe = function(t, n, r) {
        var i = t.position,
            o = t.viewBox,
            a = t.offset,
            s = t.className,
            u = o,
            l = u.cx,
            c = u.cy,
            f = u.innerRadius,
            d = u.outerRadius,
            h = u.startAngle,
            m = u.endAngle,
            p = u.clockWise,
            y = (f + d) / 2,
            g = bAe(h, m),
            b = g >= 0 ? 1 : -1,
            v, A;
        i === "insideStart" ? (v = h + b * a, A = p) : i === "insideEnd" ? (v = m - b * a, A = !p) : i === "end" && (v = m + b * a, A = p), A = g <= 0 ? A : !A;
        var w = Gt(l, c, y, v),
            x = Gt(l, c, y, v + (A ? 1 : -1) * 359),
            T = "M".concat(w.x, ",").concat(w.y, `
    A`).concat(y, ",").concat(y, ",0,1,").concat(A ? 0 : 1, `,
    `).concat(x.x, ",").concat(x.y),
            _ = Pe(t.id) ? Sh("recharts-radial-line-") : t.id;
        return R.createElement("text", Dd({}, r, {
            dominantBaseline: "central",
            className: Me("recharts-radial-bar-label", s)
        }), R.createElement("defs", null, R.createElement("path", {
            id: _,
            d: T
        })), R.createElement("textPath", {
            xlinkHref: "#".concat(_)
        }, n))
    },
    xAe = function(t) {
        var n = t.viewBox,
            r = t.offset,
            i = t.position,
            o = n,
            a = o.cx,
            s = o.cy,
            u = o.innerRadius,
            l = o.outerRadius,
            c = o.startAngle,
            f = o.endAngle,
            d = (c + f) / 2;
        if (i === "outside") {
            var h = Gt(a, s, l + r, d),
                m = h.x,
                p = h.y;
            return {
                x: m,
                y: p,
                textAnchor: m >= a ? "start" : "end",
                verticalAnchor: "middle"
            }
        }
        if (i === "center") return {
            x: a,
            y: s,
            textAnchor: "middle",
            verticalAnchor: "middle"
        };
        if (i === "centerTop") return {
            x: a,
            y: s,
            textAnchor: "middle",
            verticalAnchor: "start"
        };
        if (i === "centerBottom") return {
            x: a,
            y: s,
            textAnchor: "middle",
            verticalAnchor: "end"
        };
        var y = (u + l) / 2,
            g = Gt(a, s, y, d),
            b = g.x,
            v = g.y;
        return {
            x: b,
            y: v,
            textAnchor: "middle",
            verticalAnchor: "middle"
        }
    },
    AAe = function(t) {
        var n = t.viewBox,
            r = t.parentViewBox,
            i = t.offset,
            o = t.position,
            a = n,
            s = a.x,
            u = a.y,
            l = a.width,
            c = a.height,
            f = c >= 0 ? 1 : -1,
            d = f * i,
            h = f > 0 ? "end" : "start",
            m = f > 0 ? "start" : "end",
            p = l >= 0 ? 1 : -1,
            y = p * i,
            g = p > 0 ? "end" : "start",
            b = p > 0 ? "start" : "end";
        if (o === "top") {
            var v = {
                x: s + l / 2,
                y: u - f * i,
                textAnchor: "middle",
                verticalAnchor: h
            };
            return kt(kt({}, v), r ? {
                height: Math.max(u - r.y, 0),
                width: l
            } : {})
        }
        if (o === "bottom") {
            var A = {
                x: s + l / 2,
                y: u + c + d,
                textAnchor: "middle",
                verticalAnchor: m
            };
            return kt(kt({}, A), r ? {
                height: Math.max(r.y + r.height - (u + c), 0),
                width: l
            } : {})
        }
        if (o === "left") {
            var w = {
                x: s - y,
                y: u + c / 2,
                textAnchor: g,
                verticalAnchor: "middle"
            };
            return kt(kt({}, w), r ? {
                width: Math.max(w.x - r.x, 0),
                height: c
            } : {})
        }
        if (o === "right") {
            var x = {
                x: s + l + y,
                y: u + c / 2,
                textAnchor: b,
                verticalAnchor: "middle"
            };
            return kt(kt({}, x), r ? {
                width: Math.max(r.x + r.width - x.x, 0),
                height: c
            } : {})
        }
        var T = r ? {
            width: l,
            height: c
        } : {};
        return o === "insideLeft" ? kt({
            x: s + y,
            y: u + c / 2,
            textAnchor: b,
            verticalAnchor: "middle"
        }, T) : o === "insideRight" ? kt({
            x: s + l - y,
            y: u + c / 2,
            textAnchor: g,
            verticalAnchor: "middle"
        }, T) : o === "insideTop" ? kt({
            x: s + l / 2,
            y: u + d,
            textAnchor: "middle",
            verticalAnchor: m
        }, T) : o === "insideBottom" ? kt({
            x: s + l / 2,
            y: u + c - d,
            textAnchor: "middle",
            verticalAnchor: h
        }, T) : o === "insideTopLeft" ? kt({
            x: s + y,
            y: u + d,
            textAnchor: b,
            verticalAnchor: m
        }, T) : o === "insideTopRight" ? kt({
            x: s + l - y,
            y: u + d,
            textAnchor: g,
            verticalAnchor: m
        }, T) : o === "insideBottomLeft" ? kt({
            x: s + y,
            y: u + c - d,
            textAnchor: b,
            verticalAnchor: h
        }, T) : o === "insideBottomRight" ? kt({
            x: s + l - y,
            y: u + c - d,
            textAnchor: g,
            verticalAnchor: h
        }, T) : Yl(o) && (Y(o.x) || qa(o.x)) && (Y(o.y) || qa(o.y)) ? kt({
            x: s + ks(o.x, l),
            y: u + ks(o.y, c),
            textAnchor: "end",
            verticalAnchor: "end"
        }, T) : kt({
            x: s + l / 2,
            y: u + c / 2,
            textAnchor: "middle",
            verticalAnchor: "middle"
        }, T)
    },
    EAe = function(t) {
        return "cx" in t && Y(t.cx)
    };

function nn(e) {
    var t = e.offset,
        n = t === void 0 ? 5 : t,
        r = hAe(e, sAe),
        i = kt({
            offset: n
        }, r),
        o = i.viewBox,
        a = i.position,
        s = i.value,
        u = i.children,
        l = i.content,
        c = i.className,
        f = c === void 0 ? "" : c,
        d = i.textBreakAll;
    if (!o || Pe(s) && Pe(u) && !S.isValidElement(l) && !Ae(l)) return null;
    if (S.isValidElement(l)) return S.cloneElement(l, i);
    var h;
    if (Ae(l)) {
        if (h = S.createElement(l, i), S.isValidElement(h)) return h
    } else h = vAe(i);
    var m = EAe(o),
        p = _e(i, !0);
    if (m && (a === "insideStart" || a === "insideEnd" || a === "end")) return wAe(i, h, p);
    var y = m ? xAe(i) : AAe(i);
    return R.createElement(qg, Dd({
        className: Me("recharts-label", f)
    }, p, y, {
        breakAll: d
    }), h)
}
nn.displayName = "Label";
var n6 = function(t) {
        var n = t.cx,
            r = t.cy,
            i = t.angle,
            o = t.startAngle,
            a = t.endAngle,
            s = t.r,
            u = t.radius,
            l = t.innerRadius,
            c = t.outerRadius,
            f = t.x,
            d = t.y,
            h = t.top,
            m = t.left,
            p = t.width,
            y = t.height,
            g = t.clockWise,
            b = t.labelViewBox;
        if (b) return b;
        if (Y(p) && Y(y)) {
            if (Y(f) && Y(d)) return {
                x: f,
                y: d,
                width: p,
                height: y
            };
            if (Y(h) && Y(m)) return {
                x: h,
                y: m,
                width: p,
                height: y
            }
        }
        return Y(f) && Y(d) ? {
            x: f,
            y: d,
            width: 0,
            height: 0
        } : Y(n) && Y(r) ? {
            cx: n,
            cy: r,
            startAngle: o || i || 0,
            endAngle: a || i || 0,
            innerRadius: l || 0,
            outerRadius: c || u || s || 0,
            clockWise: g
        } : t.viewBox ? t.viewBox : {}
    },
    SAe = function(t, n) {
        return t ? t === !0 ? R.createElement(nn, {
            key: "label-implicit",
            viewBox: n
        }) : Rt(t) ? R.createElement(nn, {
            key: "label-implicit",
            viewBox: n,
            value: t
        }) : S.isValidElement(t) ? t.type === nn ? S.cloneElement(t, {
            key: "label-implicit",
            viewBox: n
        }) : R.createElement(nn, {
            key: "label-implicit",
            content: t,
            viewBox: n
        }) : Ae(t) ? R.createElement(nn, {
            key: "label-implicit",
            content: t,
            viewBox: n
        }) : Yl(t) ? R.createElement(nn, Dd({
            viewBox: n
        }, t, {
            key: "label-implicit"
        })) : null : null
    },
    _Ae = function(t, n) {
        var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
        if (!t || !t.children && r && !t.label) return null;
        var i = t.children,
            o = n6(t),
            a = Dr(i, nn).map(function(u, l) {
                return S.cloneElement(u, {
                    viewBox: n || o,
                    key: "label-".concat(l)
                })
            });
        if (!r) return a;
        var s = SAe(t.label, n || o);
        return [s].concat(uAe(a))
    };
nn.parseViewBox = n6;
nn.renderCallByParent = _Ae;

function TAe(e) {
    var t = e == null ? 0 : e.length;
    return t ? e[t - 1] : void 0
}
var PAe = TAe;
const OAe = Fe(PAe);

function $d(e) {
    "@babel/helpers - typeof";
    return $d = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, $d(e)
}
var kAe = ["valueAccessor"],
    CAe = ["data", "dataKey", "clockWise", "id", "textBreakAll"];

function IAe(e) {
    return jAe(e) || RAe(e) || NAe(e) || MAe()
}

function MAe() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function NAe(e, t) {
    if (e) {
        if (typeof e == "string") return X1(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return X1(e, t)
    }
}

function RAe(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e)
}

function jAe(e) {
    if (Array.isArray(e)) return X1(e)
}

function X1(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}

function ly() {
    return ly = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, ly.apply(this, arguments)
}

function WI(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function GI(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? WI(Object(n), !0).forEach(function(r) {
            BAe(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : WI(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function BAe(e, t, n) {
    return t = DAe(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function DAe(e) {
    var t = $Ae(e, "string");
    return $d(t) == "symbol" ? t : t + ""
}

function $Ae(e, t) {
    if ($d(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if ($d(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}

function qI(e, t) {
    if (e == null) return {};
    var n = LAe(e, t),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        for (i = 0; i < o.length; i++) r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
    }
    return n
}

function LAe(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
            if (t.indexOf(r) >= 0) continue;
            n[r] = e[r]
        }
    return n
}
var FAe = function(t) {
    return Array.isArray(t.value) ? OAe(t.value) : t.value
};

function Jo(e) {
    var t = e.valueAccessor,
        n = t === void 0 ? FAe : t,
        r = qI(e, kAe),
        i = r.data,
        o = r.dataKey,
        a = r.clockWise,
        s = r.id,
        u = r.textBreakAll,
        l = qI(r, CAe);
    return !i || !i.length ? null : R.createElement(lt, {
        className: "recharts-label-list"
    }, i.map(function(c, f) {
        var d = Pe(o) ? n(c, f) : Gn(c && c.payload, o),
            h = Pe(s) ? {} : {
                id: "".concat(s, "-").concat(f)
            };
        return R.createElement(nn, ly({}, _e(c, !0), l, h, {
            parentViewBox: c.parentViewBox,
            value: d,
            textBreakAll: u,
            viewBox: nn.parseViewBox(Pe(a) ? c : GI(GI({}, c), {}, {
                clockWise: a
            })),
            key: "label-".concat(f),
            index: f
        }))
    }))
}
Jo.displayName = "LabelList";

function UAe(e, t) {
    return e ? e === !0 ? R.createElement(Jo, {
        key: "labelList-implicit",
        data: t
    }) : R.isValidElement(e) || Ae(e) ? R.createElement(Jo, {
        key: "labelList-implicit",
        data: t,
        content: e
    }) : Yl(e) ? R.createElement(Jo, ly({
        data: t
    }, e, {
        key: "labelList-implicit"
    })) : null : null
}

function HAe(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
    if (!e || !e.children && n && !e.label) return null;
    var r = e.children,
        i = Dr(r, Jo).map(function(a, s) {
            return S.cloneElement(a, {
                data: t,
                key: "labelList-".concat(s)
            })
        });
    if (!n) return i;
    var o = UAe(e.label, t);
    return [o].concat(IAe(i))
}
Jo.renderCallByParent = HAe;

function Ld(e) {
    "@babel/helpers - typeof";
    return Ld = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Ld(e)
}

function Z1() {
    return Z1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, Z1.apply(this, arguments)
}

function KI(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function QI(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? KI(Object(n), !0).forEach(function(r) {
            VAe(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KI(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function VAe(e, t, n) {
    return t = zAe(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function zAe(e) {
    var t = WAe(e, "string");
    return Ld(t) == "symbol" ? t : t + ""
}

function WAe(e, t) {
    if (Ld(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Ld(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}
var GAe = function(t, n) {
        var r = Mr(n - t),
            i = Math.min(Math.abs(n - t), 359.999);
        return r * i
    },
    mp = function(t) {
        var n = t.cx,
            r = t.cy,
            i = t.radius,
            o = t.angle,
            a = t.sign,
            s = t.isExternal,
            u = t.cornerRadius,
            l = t.cornerIsExternal,
            c = u * (s ? 1 : -1) + i,
            f = Math.asin(u / c) / uy,
            d = l ? o : o + a * f,
            h = Gt(n, r, c, d),
            m = Gt(n, r, i, d),
            p = l ? o - a * f : o,
            y = Gt(n, r, c * Math.cos(f * uy), p);
        return {
            center: h,
            circleTangency: m,
            lineTangency: y,
            theta: f
        }
    },
    r6 = function(t) {
        var n = t.cx,
            r = t.cy,
            i = t.innerRadius,
            o = t.outerRadius,
            a = t.startAngle,
            s = t.endAngle,
            u = GAe(a, s),
            l = a + u,
            c = Gt(n, r, o, a),
            f = Gt(n, r, o, l),
            d = "M ".concat(c.x, ",").concat(c.y, `
    A `).concat(o, ",").concat(o, `,0,
    `).concat(+(Math.abs(u) > 180), ",").concat(+(a > l), `,
    `).concat(f.x, ",").concat(f.y, `
  `);
        if (i > 0) {
            var h = Gt(n, r, i, a),
                m = Gt(n, r, i, l);
            d += "L ".concat(m.x, ",").concat(m.y, `
            A `).concat(i, ",").concat(i, `,0,
            `).concat(+(Math.abs(u) > 180), ",").concat(+(a <= l), `,
            `).concat(h.x, ",").concat(h.y, " Z")
        } else d += "L ".concat(n, ",").concat(r, " Z");
        return d
    },
    qAe = function(t) {
        var n = t.cx,
            r = t.cy,
            i = t.innerRadius,
            o = t.outerRadius,
            a = t.cornerRadius,
            s = t.forceCornerRadius,
            u = t.cornerIsExternal,
            l = t.startAngle,
            c = t.endAngle,
            f = Mr(c - l),
            d = mp({
                cx: n,
                cy: r,
                radius: o,
                angle: l,
                sign: f,
                cornerRadius: a,
                cornerIsExternal: u
            }),
            h = d.circleTangency,
            m = d.lineTangency,
            p = d.theta,
            y = mp({
                cx: n,
                cy: r,
                radius: o,
                angle: c,
                sign: -f,
                cornerRadius: a,
                cornerIsExternal: u
            }),
            g = y.circleTangency,
            b = y.lineTangency,
            v = y.theta,
            A = u ? Math.abs(l - c) : Math.abs(l - c) - p - v;
        if (A < 0) return s ? "M ".concat(m.x, ",").concat(m.y, `
        a`).concat(a, ",").concat(a, ",0,0,1,").concat(a * 2, `,0
        a`).concat(a, ",").concat(a, ",0,0,1,").concat(-a * 2, `,0
      `) : r6({
            cx: n,
            cy: r,
            innerRadius: i,
            outerRadius: o,
            startAngle: l,
            endAngle: c
        });
        var w = "M ".concat(m.x, ",").concat(m.y, `
    A`).concat(a, ",").concat(a, ",0,0,").concat(+(f < 0), ",").concat(h.x, ",").concat(h.y, `
    A`).concat(o, ",").concat(o, ",0,").concat(+(A > 180), ",").concat(+(f < 0), ",").concat(g.x, ",").concat(g.y, `
    A`).concat(a, ",").concat(a, ",0,0,").concat(+(f < 0), ",").concat(b.x, ",").concat(b.y, `
  `);
        if (i > 0) {
            var x = mp({
                    cx: n,
                    cy: r,
                    radius: i,
                    angle: l,
                    sign: f,
                    isExternal: !0,
                    cornerRadius: a,
                    cornerIsExternal: u
                }),
                T = x.circleTangency,
                _ = x.lineTangency,
                O = x.theta,
                k = mp({
                    cx: n,
                    cy: r,
                    radius: i,
                    angle: c,
                    sign: -f,
                    isExternal: !0,
                    cornerRadius: a,
                    cornerIsExternal: u
                }),
                I = k.circleTangency,
                M = k.lineTangency,
                B = k.theta,
                L = u ? Math.abs(l - c) : Math.abs(l - c) - O - B;
            if (L < 0 && a === 0) return "".concat(w, "L").concat(n, ",").concat(r, "Z");
            w += "L".concat(M.x, ",").concat(M.y, `
      A`).concat(a, ",").concat(a, ",0,0,").concat(+(f < 0), ",").concat(I.x, ",").concat(I.y, `
      A`).concat(i, ",").concat(i, ",0,").concat(+(L > 180), ",").concat(+(f > 0), ",").concat(T.x, ",").concat(T.y, `
      A`).concat(a, ",").concat(a, ",0,0,").concat(+(f < 0), ",").concat(_.x, ",").concat(_.y, "Z")
        } else w += "L".concat(n, ",").concat(r, "Z");
        return w
    },
    KAe = {
        cx: 0,
        cy: 0,
        innerRadius: 0,
        outerRadius: 0,
        startAngle: 0,
        endAngle: 0,
        cornerRadius: 0,
        forceCornerRadius: !1,
        cornerIsExternal: !1
    },
    i6 = function(t) {
        var n = QI(QI({}, KAe), t),
            r = n.cx,
            i = n.cy,
            o = n.innerRadius,
            a = n.outerRadius,
            s = n.cornerRadius,
            u = n.forceCornerRadius,
            l = n.cornerIsExternal,
            c = n.startAngle,
            f = n.endAngle,
            d = n.className;
        if (a < o || c === f) return null;
        var h = Me("recharts-sector", d),
            m = a - o,
            p = ks(s, m, 0, !0),
            y;
        return p > 0 && Math.abs(c - f) < 360 ? y = qAe({
            cx: r,
            cy: i,
            innerRadius: o,
            outerRadius: a,
            cornerRadius: Math.min(p, m / 2),
            forceCornerRadius: u,
            cornerIsExternal: l,
            startAngle: c,
            endAngle: f
        }) : y = r6({
            cx: r,
            cy: i,
            innerRadius: o,
            outerRadius: a,
            startAngle: c,
            endAngle: f
        }), R.createElement("path", Z1({}, _e(n, !0), {
            className: h,
            d: y,
            role: "img"
        }))
    };

function Fd(e) {
    "@babel/helpers - typeof";
    return Fd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Fd(e)
}

function J1() {
    return J1 = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, J1.apply(this, arguments)
}

function YI(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function XI(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? YI(Object(n), !0).forEach(function(r) {
            QAe(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YI(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function QAe(e, t, n) {
    return t = YAe(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function YAe(e) {
    var t = XAe(e, "string");
    return Fd(t) == "symbol" ? t : t + ""
}

function XAe(e, t) {
    if (Fd(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Fd(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}
var ZI = {
        curveBasisClosed: qle,
        curveBasisOpen: Kle,
        curveBasis: Gle,
        curveBumpX: Mle,
        curveBumpY: Nle,
        curveLinearClosed: Qle,
        curveLinear: Gv,
        curveMonotoneX: Yle,
        curveMonotoneY: Xle,
        curveNatural: Zle,
        curveStep: Jle,
        curveStepAfter: tce,
        curveStepBefore: ece
    },
    gp = function(t) {
        return t.x === +t.x && t.y === +t.y
    },
    Ic = function(t) {
        return t.x
    },
    Mc = function(t) {
        return t.y
    },
    ZAe = function(t, n) {
        if (Ae(t)) return t;
        var r = "curve".concat(zv(t));
        return (r === "curveMonotone" || r === "curveBump") && n ? ZI["".concat(r).concat(n === "vertical" ? "Y" : "X")] : ZI[r] || Gv
    },
    JAe = function(t) {
        var n = t.type,
            r = n === void 0 ? "linear" : n,
            i = t.points,
            o = i === void 0 ? [] : i,
            a = t.baseLine,
            s = t.layout,
            u = t.connectNulls,
            l = u === void 0 ? !1 : u,
            c = ZAe(r, s),
            f = l ? o.filter(function(p) {
                return gp(p)
            }) : o,
            d;
        if (Array.isArray(a)) {
            var h = l ? a.filter(function(p) {
                    return gp(p)
                }) : a,
                m = f.map(function(p, y) {
                    return XI(XI({}, p), {}, {
                        base: h[y]
                    })
                });
            return s === "vertical" ? d = ap().y(Mc).x1(Ic).x0(function(p) {
                return p.base.x
            }) : d = ap().x(Ic).y1(Mc).y0(function(p) {
                return p.base.y
            }), d.defined(gp).curve(c), d(m)
        }
        return s === "vertical" && Y(a) ? d = ap().y(Mc).x1(Ic).x0(a) : Y(a) ? d = ap().x(Ic).y1(Mc).y0(a) : d = a5().x(Ic).y(Mc), d.defined(gp).curve(c), d(f)
    },
    vf = function(t) {
        var n = t.className,
            r = t.points,
            i = t.path,
            o = t.pathRef;
        if ((!r || !r.length) && !i) return null;
        var a = r && r.length ? JAe(t) : i;
        return R.createElement("path", J1({}, _e(t, !1), Mg(t), {
            className: Me("recharts-curve", n),
            d: a,
            ref: o
        }))
    },
    o6 = {
        exports: {}
    },
    eEe = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
    tEe = eEe,
    nEe = tEe;

function a6() {}

function s6() {}
s6.resetWarningCache = a6;
var rEe = function() {
    function e(r, i, o, a, s, u) {
        if (u !== nEe) {
            var l = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw l.name = "Invariant Violation", l
        }
    }
    e.isRequired = e;

    function t() {
        return e
    }
    var n = {
        array: e,
        bigint: e,
        bool: e,
        func: e,
        number: e,
        object: e,
        string: e,
        symbol: e,
        any: e,
        arrayOf: t,
        element: e,
        elementType: e,
        instanceOf: t,
        node: e,
        objectOf: t,
        oneOf: t,
        oneOfType: t,
        shape: t,
        exact: t,
        checkPropTypes: s6,
        resetWarningCache: a6
    };
    return n.PropTypes = n, n
};
o6.exports = rEe();
var iEe = o6.exports;
const je = Fe(iEe);
var oEe = Object.getOwnPropertyNames,
    aEe = Object.getOwnPropertySymbols,
    sEe = Object.prototype.hasOwnProperty;

function JI(e, t) {
    return function(r, i, o) {
        return e(r, i, o) && t(r, i, o)
    }
}

function yp(e) {
    return function(n, r, i) {
        if (!n || !r || typeof n != "object" || typeof r != "object") return e(n, r, i);
        var o = i.cache,
            a = o.get(n),
            s = o.get(r);
        if (a && s) return a === r && s === n;
        o.set(n, r), o.set(r, n);
        var u = e(n, r, i);
        return o.delete(n), o.delete(r), u
    }
}

function eM(e) {
    return oEe(e).concat(aEe(e))
}
var uEe = Object.hasOwn || function(e, t) {
    return sEe.call(e, t)
};

function Us(e, t) {
    return e === t || !e && !t && e !== e && t !== t
}
var lEe = "__v",
    cEe = "__o",
    fEe = "_owner",
    tM = Object.getOwnPropertyDescriptor,
    nM = Object.keys;

function dEe(e, t, n) {
    var r = e.length;
    if (t.length !== r) return !1;
    for (; r-- > 0;)
        if (!n.equals(e[r], t[r], r, r, e, t, n)) return !1;
    return !0
}

function hEe(e, t) {
    return Us(e.getTime(), t.getTime())
}

function pEe(e, t) {
    return e.name === t.name && e.message === t.message && e.cause === t.cause && e.stack === t.stack
}

function mEe(e, t) {
    return e === t
}

function rM(e, t, n) {
    var r = e.size;
    if (r !== t.size) return !1;
    if (!r) return !0;
    for (var i = new Array(r), o = e.entries(), a, s, u = 0;
        (a = o.next()) && !a.done;) {
        for (var l = t.entries(), c = !1, f = 0;
            (s = l.next()) && !s.done;) {
            if (i[f]) {
                f++;
                continue
            }
            var d = a.value,
                h = s.value;
            if (n.equals(d[0], h[0], u, f, e, t, n) && n.equals(d[1], h[1], d[0], h[0], e, t, n)) {
                c = i[f] = !0;
                break
            }
            f++
        }
        if (!c) return !1;
        u++
    }
    return !0
}
var gEe = Us;

function yEe(e, t, n) {
    var r = nM(e),
        i = r.length;
    if (nM(t).length !== i) return !1;
    for (; i-- > 0;)
        if (!u6(e, t, n, r[i])) return !1;
    return !0
}

function Nc(e, t, n) {
    var r = eM(e),
        i = r.length;
    if (eM(t).length !== i) return !1;
    for (var o, a, s; i-- > 0;)
        if (o = r[i], !u6(e, t, n, o) || (a = tM(e, o), s = tM(t, o), (a || s) && (!a || !s || a.configurable !== s.configurable || a.enumerable !== s.enumerable || a.writable !== s.writable))) return !1;
    return !0
}

function vEe(e, t) {
    return Us(e.valueOf(), t.valueOf())
}

function bEe(e, t) {
    return e.source === t.source && e.flags === t.flags
}

function iM(e, t, n) {
    var r = e.size;
    if (r !== t.size) return !1;
    if (!r) return !0;
    for (var i = new Array(r), o = e.values(), a, s;
        (a = o.next()) && !a.done;) {
        for (var u = t.values(), l = !1, c = 0;
            (s = u.next()) && !s.done;) {
            if (!i[c] && n.equals(a.value, s.value, a.value, s.value, e, t, n)) {
                l = i[c] = !0;
                break
            }
            c++
        }
        if (!l) return !1
    }
    return !0
}

function wEe(e, t) {
    var n = e.length;
    if (t.length !== n) return !1;
    for (; n-- > 0;)
        if (e[n] !== t[n]) return !1;
    return !0
}

function xEe(e, t) {
    return e.hostname === t.hostname && e.pathname === t.pathname && e.protocol === t.protocol && e.port === t.port && e.hash === t.hash && e.username === t.username && e.password === t.password
}

function u6(e, t, n, r) {
    return (r === fEe || r === cEe || r === lEe) && (e.$$typeof || t.$$typeof) ? !0 : uEe(t, r) && n.equals(e[r], t[r], r, r, e, t, n)
}
var AEe = "[object Arguments]",
    EEe = "[object Boolean]",
    SEe = "[object Date]",
    _Ee = "[object Error]",
    TEe = "[object Map]",
    PEe = "[object Number]",
    OEe = "[object Object]",
    kEe = "[object RegExp]",
    CEe = "[object Set]",
    IEe = "[object String]",
    MEe = "[object URL]",
    NEe = Array.isArray,
    oM = typeof ArrayBuffer == "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null,
    aM = Object.assign,
    REe = Object.prototype.toString.call.bind(Object.prototype.toString);

function jEe(e) {
    var t = e.areArraysEqual,
        n = e.areDatesEqual,
        r = e.areErrorsEqual,
        i = e.areFunctionsEqual,
        o = e.areMapsEqual,
        a = e.areNumbersEqual,
        s = e.areObjectsEqual,
        u = e.arePrimitiveWrappersEqual,
        l = e.areRegExpsEqual,
        c = e.areSetsEqual,
        f = e.areTypedArraysEqual,
        d = e.areUrlsEqual;
    return function(m, p, y) {
        if (m === p) return !0;
        if (m == null || p == null) return !1;
        var g = typeof m;
        if (g !== typeof p) return !1;
        if (g !== "object") return g === "number" ? a(m, p, y) : g === "function" ? i(m, p, y) : !1;
        var b = m.constructor;
        if (b !== p.constructor) return !1;
        if (b === Object) return s(m, p, y);
        if (NEe(m)) return t(m, p, y);
        if (oM != null && oM(m)) return f(m, p, y);
        if (b === Date) return n(m, p, y);
        if (b === RegExp) return l(m, p, y);
        if (b === Map) return o(m, p, y);
        if (b === Set) return c(m, p, y);
        var v = REe(m);
        return v === SEe ? n(m, p, y) : v === kEe ? l(m, p, y) : v === TEe ? o(m, p, y) : v === CEe ? c(m, p, y) : v === OEe ? typeof m.then != "function" && typeof p.then != "function" && s(m, p, y) : v === MEe ? d(m, p, y) : v === _Ee ? r(m, p, y) : v === AEe ? s(m, p, y) : v === EEe || v === PEe || v === IEe ? u(m, p, y) : !1
    }
}

function BEe(e) {
    var t = e.circular,
        n = e.createCustomConfig,
        r = e.strict,
        i = {
            areArraysEqual: r ? Nc : dEe,
            areDatesEqual: hEe,
            areErrorsEqual: pEe,
            areFunctionsEqual: mEe,
            areMapsEqual: r ? JI(rM, Nc) : rM,
            areNumbersEqual: gEe,
            areObjectsEqual: r ? Nc : yEe,
            arePrimitiveWrappersEqual: vEe,
            areRegExpsEqual: bEe,
            areSetsEqual: r ? JI(iM, Nc) : iM,
            areTypedArraysEqual: r ? Nc : wEe,
            areUrlsEqual: xEe
        };
    if (n && (i = aM({}, i, n(i))), t) {
        var o = yp(i.areArraysEqual),
            a = yp(i.areMapsEqual),
            s = yp(i.areObjectsEqual),
            u = yp(i.areSetsEqual);
        i = aM({}, i, {
            areArraysEqual: o,
            areMapsEqual: a,
            areObjectsEqual: s,
            areSetsEqual: u
        })
    }
    return i
}

function DEe(e) {
    return function(t, n, r, i, o, a, s) {
        return e(t, n, s)
    }
}

function $Ee(e) {
    var t = e.circular,
        n = e.comparator,
        r = e.createState,
        i = e.equals,
        o = e.strict;
    if (r) return function(u, l) {
        var c = r(),
            f = c.cache,
            d = f === void 0 ? t ? new WeakMap : void 0 : f,
            h = c.meta;
        return n(u, l, {
            cache: d,
            equals: i,
            meta: h,
            strict: o
        })
    };
    if (t) return function(u, l) {
        return n(u, l, {
            cache: new WeakMap,
            equals: i,
            meta: void 0,
            strict: o
        })
    };
    var a = {
        cache: void 0,
        equals: i,
        meta: void 0,
        strict: o
    };
    return function(u, l) {
        return n(u, l, a)
    }
}
var LEe = wa();
wa({
    strict: !0
});
wa({
    circular: !0
});
wa({
    circular: !0,
    strict: !0
});
wa({
    createInternalComparator: function() {
        return Us
    }
});
wa({
    strict: !0,
    createInternalComparator: function() {
        return Us
    }
});
wa({
    circular: !0,
    createInternalComparator: function() {
        return Us
    }
});
wa({
    circular: !0,
    createInternalComparator: function() {
        return Us
    },
    strict: !0
});

function wa(e) {
    e === void 0 && (e = {});
    var t = e.circular,
        n = t === void 0 ? !1 : t,
        r = e.createInternalComparator,
        i = e.createState,
        o = e.strict,
        a = o === void 0 ? !1 : o,
        s = BEe(e),
        u = jEe(s),
        l = r ? r(u) : DEe(u);
    return $Ee({
        circular: n,
        comparator: u,
        createState: i,
        equals: l,
        strict: a
    })
}

function FEe(e) {
    typeof requestAnimationFrame < "u" && requestAnimationFrame(e)
}

function sM(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
        n = -1,
        r = function i(o) {
            n < 0 && (n = o), o - n > t ? (e(o), n = -1) : FEe(i)
        };
    requestAnimationFrame(r)
}

function eA(e) {
    "@babel/helpers - typeof";
    return eA = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, eA(e)
}

function UEe(e) {
    return WEe(e) || zEe(e) || VEe(e) || HEe()
}

function HEe() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function VEe(e, t) {
    if (e) {
        if (typeof e == "string") return uM(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return uM(e, t)
    }
}

function uM(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}

function zEe(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e)
}

function WEe(e) {
    if (Array.isArray(e)) return e
}

function GEe() {
    var e = {},
        t = function() {
            return null
        },
        n = !1,
        r = function i(o) {
            if (!n) {
                if (Array.isArray(o)) {
                    if (!o.length) return;
                    var a = o,
                        s = UEe(a),
                        u = s[0],
                        l = s.slice(1);
                    if (typeof u == "number") {
                        sM(i.bind(null, l), u);
                        return
                    }
                    i(u), sM(i.bind(null, l));
                    return
                }
                eA(o) === "object" && (e = o, t(e)), typeof o == "function" && o()
            }
        };
    return {
        stop: function() {
            n = !0
        },
        start: function(o) {
            n = !1, r(o)
        },
        subscribe: function(o) {
            return t = o,
                function() {
                    t = function() {
                        return null
                    }
                }
        }
    }
}

function Ud(e) {
    "@babel/helpers - typeof";
    return Ud = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Ud(e)
}

function lM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function cM(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? lM(Object(n), !0).forEach(function(r) {
            l6(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lM(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function l6(e, t, n) {
    return t = qEe(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function qEe(e) {
    var t = KEe(e, "string");
    return Ud(t) === "symbol" ? t : String(t)
}

function KEe(e, t) {
    if (Ud(e) !== "object" || e === null) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Ud(r) !== "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}
var QEe = function(t, n) {
        return [Object.keys(t), Object.keys(n)].reduce(function(r, i) {
            return r.filter(function(o) {
                return i.includes(o)
            })
        })
    },
    YEe = function(t) {
        return t
    },
    XEe = function(t) {
        return t.replace(/([A-Z])/g, function(n) {
            return "-".concat(n.toLowerCase())
        })
    },
    bf = function(t, n) {
        return Object.keys(n).reduce(function(r, i) {
            return cM(cM({}, r), {}, l6({}, i, t(i, n[i])))
        }, {})
    },
    fM = function(t, n, r) {
        return t.map(function(i) {
            return "".concat(XEe(i), " ").concat(n, "ms ").concat(r)
        }).join(",")
    };

function ZEe(e, t) {
    return tSe(e) || eSe(e, t) || c6(e, t) || JEe()
}

function JEe() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function eSe(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
        var r, i, o, a, s = [],
            u = !0,
            l = !1;
        try {
            if (o = (n = n.call(e)).next, t !== 0)
                for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0);
        } catch (c) {
            l = !0, i = c
        } finally {
            try {
                if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return
            } finally {
                if (l) throw i
            }
        }
        return s
    }
}

function tSe(e) {
    if (Array.isArray(e)) return e
}

function nSe(e) {
    return oSe(e) || iSe(e) || c6(e) || rSe()
}

function rSe() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function c6(e, t) {
    if (e) {
        if (typeof e == "string") return tA(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return tA(e, t)
    }
}

function iSe(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e)
}

function oSe(e) {
    if (Array.isArray(e)) return tA(e)
}

function tA(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}
var cy = 1e-4,
    f6 = function(t, n) {
        return [0, 3 * t, 3 * n - 6 * t, 3 * t - 3 * n + 1]
    },
    d6 = function(t, n) {
        return t.map(function(r, i) {
            return r * Math.pow(n, i)
        }).reduce(function(r, i) {
            return r + i
        })
    },
    dM = function(t, n) {
        return function(r) {
            var i = f6(t, n);
            return d6(i, r)
        }
    },
    aSe = function(t, n) {
        return function(r) {
            var i = f6(t, n),
                o = [].concat(nSe(i.map(function(a, s) {
                    return a * s
                }).slice(1)), [0]);
            return d6(o, r)
        }
    },
    hM = function() {
        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];
        var i = n[0],
            o = n[1],
            a = n[2],
            s = n[3];
        if (n.length === 1) switch (n[0]) {
            case "linear":
                i = 0, o = 0, a = 1, s = 1;
                break;
            case "ease":
                i = .25, o = .1, a = .25, s = 1;
                break;
            case "ease-in":
                i = .42, o = 0, a = 1, s = 1;
                break;
            case "ease-out":
                i = .42, o = 0, a = .58, s = 1;
                break;
            case "ease-in-out":
                i = 0, o = 0, a = .58, s = 1;
                break;
            default:
                {
                    var u = n[0].split("(");
                    if (u[0] === "cubic-bezier" && u[1].split(")")[0].split(",").length === 4) {
                        var l = u[1].split(")")[0].split(",").map(function(y) {
                                return parseFloat(y)
                            }),
                            c = ZEe(l, 4);
                        i = c[0], o = c[1], a = c[2], s = c[3]
                    }
                }
        }
        var f = dM(i, a),
            d = dM(o, s),
            h = aSe(i, a),
            m = function(g) {
                return g > 1 ? 1 : g < 0 ? 0 : g
            },
            p = function(g) {
                for (var b = g > 1 ? 1 : g, v = b, A = 0; A < 8; ++A) {
                    var w = f(v) - b,
                        x = h(v);
                    if (Math.abs(w - b) < cy || x < cy) return d(v);
                    v = m(v - w / x)
                }
                return d(v)
            };
        return p.isStepper = !1, p
    },
    sSe = function() {
        var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            n = t.stiff,
            r = n === void 0 ? 100 : n,
            i = t.damping,
            o = i === void 0 ? 8 : i,
            a = t.dt,
            s = a === void 0 ? 17 : a,
            u = function(c, f, d) {
                var h = -(c - f) * r,
                    m = d * o,
                    p = d + (h - m) * s / 1e3,
                    y = d * s / 1e3 + c;
                return Math.abs(y - f) < cy && Math.abs(p) < cy ? [f, 0] : [y, p]
            };
        return u.isStepper = !0, u.dt = s, u
    },
    uSe = function() {
        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];
        var i = n[0];
        if (typeof i == "string") switch (i) {
            case "ease":
            case "ease-in-out":
            case "ease-out":
            case "ease-in":
            case "linear":
                return hM(i);
            case "spring":
                return sSe();
            default:
                if (i.split("(")[0] === "cubic-bezier") return hM(i)
        }
        return typeof i == "function" ? i : null
    };

function Hd(e) {
    "@babel/helpers - typeof";
    return Hd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Hd(e)
}

function pM(e) {
    return fSe(e) || cSe(e) || h6(e) || lSe()
}

function lSe() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function cSe(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e)
}

function fSe(e) {
    if (Array.isArray(e)) return rA(e)
}

function mM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function Vt(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? mM(Object(n), !0).forEach(function(r) {
            nA(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mM(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function nA(e, t, n) {
    return t = dSe(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function dSe(e) {
    var t = hSe(e, "string");
    return Hd(t) === "symbol" ? t : String(t)
}

function hSe(e, t) {
    if (Hd(e) !== "object" || e === null) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Hd(r) !== "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}

function pSe(e, t) {
    return ySe(e) || gSe(e, t) || h6(e, t) || mSe()
}

function mSe() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function h6(e, t) {
    if (e) {
        if (typeof e == "string") return rA(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return rA(e, t)
    }
}

function rA(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}

function gSe(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
        var r, i, o, a, s = [],
            u = !0,
            l = !1;
        try {
            if (o = (n = n.call(e)).next, t !== 0)
                for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0);
        } catch (c) {
            l = !0, i = c
        } finally {
            try {
                if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return
            } finally {
                if (l) throw i
            }
        }
        return s
    }
}

function ySe(e) {
    if (Array.isArray(e)) return e
}
var fy = function(t, n, r) {
        return t + (n - t) * r
    },
    iA = function(t) {
        var n = t.from,
            r = t.to;
        return n !== r
    },
    vSe = function e(t, n, r) {
        var i = bf(function(o, a) {
            if (iA(a)) {
                var s = t(a.from, a.to, a.velocity),
                    u = pSe(s, 2),
                    l = u[0],
                    c = u[1];
                return Vt(Vt({}, a), {}, {
                    from: l,
                    velocity: c
                })
            }
            return a
        }, n);
        return r < 1 ? bf(function(o, a) {
            return iA(a) ? Vt(Vt({}, a), {}, {
                velocity: fy(a.velocity, i[o].velocity, r),
                from: fy(a.from, i[o].from, r)
            }) : a
        }, n) : e(t, i, r - 1)
    };
const bSe = function(e, t, n, r, i) {
    var o = QEe(e, t),
        a = o.reduce(function(y, g) {
            return Vt(Vt({}, y), {}, nA({}, g, [e[g], t[g]]))
        }, {}),
        s = o.reduce(function(y, g) {
            return Vt(Vt({}, y), {}, nA({}, g, {
                from: e[g],
                velocity: 0,
                to: t[g]
            }))
        }, {}),
        u = -1,
        l, c, f = function() {
            return null
        },
        d = function() {
            return bf(function(g, b) {
                return b.from
            }, s)
        },
        h = function() {
            return !Object.values(s).filter(iA).length
        },
        m = function(g) {
            l || (l = g);
            var b = g - l,
                v = b / n.dt;
            s = vSe(n, s, v), i(Vt(Vt(Vt({}, e), t), d())), l = g, h() || (u = requestAnimationFrame(f))
        },
        p = function(g) {
            c || (c = g);
            var b = (g - c) / r,
                v = bf(function(w, x) {
                    return fy.apply(void 0, pM(x).concat([n(b)]))
                }, a);
            if (i(Vt(Vt(Vt({}, e), t), v)), b < 1) u = requestAnimationFrame(f);
            else {
                var A = bf(function(w, x) {
                    return fy.apply(void 0, pM(x).concat([n(1)]))
                }, a);
                i(Vt(Vt(Vt({}, e), t), A))
            }
        };
    return f = n.isStepper ? m : p,
        function() {
            return requestAnimationFrame(f),
                function() {
                    cancelAnimationFrame(u)
                }
        }
};

function El(e) {
    "@babel/helpers - typeof";
    return El = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, El(e)
}
var wSe = ["children", "begin", "duration", "attributeName", "easing", "isActive", "steps", "from", "to", "canBegin", "onAnimationEnd", "shouldReAnimate", "onAnimationReStart"];

function xSe(e, t) {
    if (e == null) return {};
    var n = ASe(e, t),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        for (i = 0; i < o.length; i++) r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
    }
    return n
}

function ASe(e, t) {
    if (e == null) return {};
    var n = {},
        r = Object.keys(e),
        i, o;
    for (o = 0; o < r.length; o++) i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
    return n
}

function Yb(e) {
    return TSe(e) || _Se(e) || SSe(e) || ESe()
}

function ESe() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function SSe(e, t) {
    if (e) {
        if (typeof e == "string") return oA(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return oA(e, t)
    }
}

function _Se(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e)
}

function TSe(e) {
    if (Array.isArray(e)) return oA(e)
}

function oA(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}

function gM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function xr(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? gM(Object(n), !0).forEach(function(r) {
            qc(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gM(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function qc(e, t, n) {
    return t = p6(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function PSe(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function OSe(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, p6(r.key), r)
    }
}

function kSe(e, t, n) {
    return t && OSe(e.prototype, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function p6(e) {
    var t = CSe(e, "string");
    return El(t) === "symbol" ? t : String(t)
}

function CSe(e, t) {
    if (El(e) !== "object" || e === null) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (El(r) !== "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}

function ISe(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(e, "prototype", {
        writable: !1
    }), t && aA(e, t)
}

function aA(e, t) {
    return aA = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i, r
    }, aA(e, t)
}

function MSe(e) {
    var t = NSe();
    return function() {
        var r = dy(e),
            i;
        if (t) {
            var o = dy(this).constructor;
            i = Reflect.construct(r, arguments, o)
        } else i = r.apply(this, arguments);
        return sA(this, i)
    }
}

function sA(e, t) {
    if (t && (El(t) === "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return uA(e)
}

function uA(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function NSe() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
    } catch {
        return !1
    }
}

function dy(e) {
    return dy = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }, dy(e)
}
var so = function(e) {
    ISe(n, e);
    var t = MSe(n);

    function n(r, i) {
        var o;
        PSe(this, n), o = t.call(this, r, i);
        var a = o.props,
            s = a.isActive,
            u = a.attributeName,
            l = a.from,
            c = a.to,
            f = a.steps,
            d = a.children,
            h = a.duration;
        if (o.handleStyleChange = o.handleStyleChange.bind(uA(o)), o.changeStyle = o.changeStyle.bind(uA(o)), !s || h <= 0) return o.state = {
            style: {}
        }, typeof d == "function" && (o.state = {
            style: c
        }), sA(o);
        if (f && f.length) o.state = {
            style: f[0].style
        };
        else if (l) {
            if (typeof d == "function") return o.state = {
                style: l
            }, sA(o);
            o.state = {
                style: u ? qc({}, u, l) : l
            }
        } else o.state = {
            style: {}
        };
        return o
    }
    return kSe(n, [{
        key: "componentDidMount",
        value: function() {
            var i = this.props,
                o = i.isActive,
                a = i.canBegin;
            this.mounted = !0, !(!o || !a) && this.runAnimation(this.props)
        }
    }, {
        key: "componentDidUpdate",
        value: function(i) {
            var o = this.props,
                a = o.isActive,
                s = o.canBegin,
                u = o.attributeName,
                l = o.shouldReAnimate,
                c = o.to,
                f = o.from,
                d = this.state.style;
            if (s) {
                if (!a) {
                    var h = {
                        style: u ? qc({}, u, c) : c
                    };
                    this.state && d && (u && d[u] !== c || !u && d !== c) && this.setState(h);
                    return
                }
                if (!(LEe(i.to, c) && i.canBegin && i.isActive)) {
                    var m = !i.canBegin || !i.isActive;
                    this.manager && this.manager.stop(), this.stopJSAnimation && this.stopJSAnimation();
                    var p = m || l ? f : i.to;
                    if (this.state && d) {
                        var y = {
                            style: u ? qc({}, u, p) : p
                        };
                        (u && d[u] !== p || !u && d !== p) && this.setState(y)
                    }
                    this.runAnimation(xr(xr({}, this.props), {}, {
                        from: p,
                        begin: 0
                    }))
                }
            }
        }
    }, {
        key: "componentWillUnmount",
        value: function() {
            this.mounted = !1;
            var i = this.props.onAnimationEnd;
            this.unSubscribe && this.unSubscribe(), this.manager && (this.manager.stop(), this.manager = null), this.stopJSAnimation && this.stopJSAnimation(), i && i()
        }
    }, {
        key: "handleStyleChange",
        value: function(i) {
            this.changeStyle(i)
        }
    }, {
        key: "changeStyle",
        value: function(i) {
            this.mounted && this.setState({
                style: i
            })
        }
    }, {
        key: "runJSAnimation",
        value: function(i) {
            var o = this,
                a = i.from,
                s = i.to,
                u = i.duration,
                l = i.easing,
                c = i.begin,
                f = i.onAnimationEnd,
                d = i.onAnimationStart,
                h = bSe(a, s, uSe(l), u, this.changeStyle),
                m = function() {
                    o.stopJSAnimation = h()
                };
            this.manager.start([d, c, m, u, f])
        }
    }, {
        key: "runStepAnimation",
        value: function(i) {
            var o = this,
                a = i.steps,
                s = i.begin,
                u = i.onAnimationStart,
                l = a[0],
                c = l.style,
                f = l.duration,
                d = f === void 0 ? 0 : f,
                h = function(p, y, g) {
                    if (g === 0) return p;
                    var b = y.duration,
                        v = y.easing,
                        A = v === void 0 ? "ease" : v,
                        w = y.style,
                        x = y.properties,
                        T = y.onAnimationEnd,
                        _ = g > 0 ? a[g - 1] : y,
                        O = x || Object.keys(w);
                    if (typeof A == "function" || A === "spring") return [].concat(Yb(p), [o.runJSAnimation.bind(o, {
                        from: _.style,
                        to: w,
                        duration: b,
                        easing: A
                    }), b]);
                    var k = fM(O, b, A),
                        I = xr(xr(xr({}, _.style), w), {}, {
                            transition: k
                        });
                    return [].concat(Yb(p), [I, b, T]).filter(YEe)
                };
            return this.manager.start([u].concat(Yb(a.reduce(h, [c, Math.max(d, s)])), [i.onAnimationEnd]))
        }
    }, {
        key: "runAnimation",
        value: function(i) {
            this.manager || (this.manager = GEe());
            var o = i.begin,
                a = i.duration,
                s = i.attributeName,
                u = i.to,
                l = i.easing,
                c = i.onAnimationStart,
                f = i.onAnimationEnd,
                d = i.steps,
                h = i.children,
                m = this.manager;
            if (this.unSubscribe = m.subscribe(this.handleStyleChange), typeof l == "function" || typeof h == "function" || l === "spring") {
                this.runJSAnimation(i);
                return
            }
            if (d.length > 1) {
                this.runStepAnimation(i);
                return
            }
            var p = s ? qc({}, s, u) : u,
                y = fM(Object.keys(p), a, l);
            m.start([c, o, xr(xr({}, p), {}, {
                transition: y
            }), a, f])
        }
    }, {
        key: "render",
        value: function() {
            var i = this.props,
                o = i.children;
            i.begin;
            var a = i.duration;
            i.attributeName, i.easing;
            var s = i.isActive;
            i.steps, i.from, i.to, i.canBegin, i.onAnimationEnd, i.shouldReAnimate, i.onAnimationReStart;
            var u = xSe(i, wSe),
                l = S.Children.count(o),
                c = this.state.style;
            if (typeof o == "function") return o(c);
            if (!s || l === 0 || a <= 0) return o;
            var f = function(h) {
                var m = h.props,
                    p = m.style,
                    y = p === void 0 ? {} : p,
                    g = m.className,
                    b = S.cloneElement(h, xr(xr({}, u), {}, {
                        style: xr(xr({}, y), c),
                        className: g
                    }));
                return b
            };
            return l === 1 ? f(S.Children.only(o)) : R.createElement("div", null, S.Children.map(o, function(d) {
                return f(d)
            }))
        }
    }]), n
}(S.PureComponent);
so.displayName = "Animate";
so.defaultProps = {
    begin: 0,
    duration: 1e3,
    from: "",
    to: "",
    attributeName: "",
    easing: "ease",
    isActive: !0,
    canBegin: !0,
    steps: [],
    onAnimationEnd: function() {},
    onAnimationStart: function() {}
};
so.propTypes = {
    from: je.oneOfType([je.object, je.string]),
    to: je.oneOfType([je.object, je.string]),
    attributeName: je.string,
    duration: je.number,
    begin: je.number,
    easing: je.oneOfType([je.string, je.func]),
    steps: je.arrayOf(je.shape({
        duration: je.number.isRequired,
        style: je.object.isRequired,
        easing: je.oneOfType([je.oneOf(["ease", "ease-in", "ease-out", "ease-in-out", "linear"]), je.func]),
        properties: je.arrayOf("string"),
        onAnimationEnd: je.func
    })),
    children: je.oneOfType([je.node, je.func]),
    isActive: je.bool,
    canBegin: je.bool,
    onAnimationEnd: je.func,
    shouldReAnimate: je.bool,
    onAnimationStart: je.func,
    onAnimationReStart: je.func
};

function Vd(e) {
    "@babel/helpers - typeof";
    return Vd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Vd(e)
}

function hy() {
    return hy = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, hy.apply(this, arguments)
}

function RSe(e, t) {
    return $Se(e) || DSe(e, t) || BSe(e, t) || jSe()
}

function jSe() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function BSe(e, t) {
    if (e) {
        if (typeof e == "string") return yM(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return yM(e, t)
    }
}

function yM(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}

function DSe(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
        var r, i, o, a, s = [],
            u = !0,
            l = !1;
        try {
            if (o = (n = n.call(e)).next, t !== 0)
                for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0);
        } catch (c) {
            l = !0, i = c
        } finally {
            try {
                if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return
            } finally {
                if (l) throw i
            }
        }
        return s
    }
}

function $Se(e) {
    if (Array.isArray(e)) return e
}

function vM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function bM(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? vM(Object(n), !0).forEach(function(r) {
            LSe(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vM(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function LSe(e, t, n) {
    return t = FSe(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function FSe(e) {
    var t = USe(e, "string");
    return Vd(t) == "symbol" ? t : t + ""
}

function USe(e, t) {
    if (Vd(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Vd(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}
var wM = function(t, n, r, i, o) {
        var a = Math.min(Math.abs(r) / 2, Math.abs(i) / 2),
            s = i >= 0 ? 1 : -1,
            u = r >= 0 ? 1 : -1,
            l = i >= 0 && r >= 0 || i < 0 && r < 0 ? 1 : 0,
            c;
        if (a > 0 && o instanceof Array) {
            for (var f = [0, 0, 0, 0], d = 0, h = 4; d < h; d++) f[d] = o[d] > a ? a : o[d];
            c = "M".concat(t, ",").concat(n + s * f[0]), f[0] > 0 && (c += "A ".concat(f[0], ",").concat(f[0], ",0,0,").concat(l, ",").concat(t + u * f[0], ",").concat(n)), c += "L ".concat(t + r - u * f[1], ",").concat(n), f[1] > 0 && (c += "A ".concat(f[1], ",").concat(f[1], ",0,0,").concat(l, `,
        `).concat(t + r, ",").concat(n + s * f[1])), c += "L ".concat(t + r, ",").concat(n + i - s * f[2]), f[2] > 0 && (c += "A ".concat(f[2], ",").concat(f[2], ",0,0,").concat(l, `,
        `).concat(t + r - u * f[2], ",").concat(n + i)), c += "L ".concat(t + u * f[3], ",").concat(n + i), f[3] > 0 && (c += "A ".concat(f[3], ",").concat(f[3], ",0,0,").concat(l, `,
        `).concat(t, ",").concat(n + i - s * f[3])), c += "Z"
        } else if (a > 0 && o === +o && o > 0) {
            var m = Math.min(a, o);
            c = "M ".concat(t, ",").concat(n + s * m, `
            A `).concat(m, ",").concat(m, ",0,0,").concat(l, ",").concat(t + u * m, ",").concat(n, `
            L `).concat(t + r - u * m, ",").concat(n, `
            A `).concat(m, ",").concat(m, ",0,0,").concat(l, ",").concat(t + r, ",").concat(n + s * m, `
            L `).concat(t + r, ",").concat(n + i - s * m, `
            A `).concat(m, ",").concat(m, ",0,0,").concat(l, ",").concat(t + r - u * m, ",").concat(n + i, `
            L `).concat(t + u * m, ",").concat(n + i, `
            A `).concat(m, ",").concat(m, ",0,0,").concat(l, ",").concat(t, ",").concat(n + i - s * m, " Z")
        } else c = "M ".concat(t, ",").concat(n, " h ").concat(r, " v ").concat(i, " h ").concat(-r, " Z");
        return c
    },
    HSe = function(t, n) {
        if (!t || !n) return !1;
        var r = t.x,
            i = t.y,
            o = n.x,
            a = n.y,
            s = n.width,
            u = n.height;
        if (Math.abs(s) > 0 && Math.abs(u) > 0) {
            var l = Math.min(o, o + s),
                c = Math.max(o, o + s),
                f = Math.min(a, a + u),
                d = Math.max(a, a + u);
            return r >= l && r <= c && i >= f && i <= d
        }
        return !1
    },
    VSe = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        radius: 0,
        isAnimationActive: !1,
        isUpdateAnimationActive: !1,
        animationBegin: 0,
        animationDuration: 1500,
        animationEasing: "ease"
    },
    AT = function(t) {
        var n = bM(bM({}, VSe), t),
            r = S.useRef(),
            i = S.useState(-1),
            o = RSe(i, 2),
            a = o[0],
            s = o[1];
        S.useEffect(function() {
            if (r.current && r.current.getTotalLength) try {
                var A = r.current.getTotalLength();
                A && s(A)
            } catch {}
        }, []);
        var u = n.x,
            l = n.y,
            c = n.width,
            f = n.height,
            d = n.radius,
            h = n.className,
            m = n.animationEasing,
            p = n.animationDuration,
            y = n.animationBegin,
            g = n.isAnimationActive,
            b = n.isUpdateAnimationActive;
        if (u !== +u || l !== +l || c !== +c || f !== +f || c === 0 || f === 0) return null;
        var v = Me("recharts-rectangle", h);
        return b ? R.createElement(so, {
            canBegin: a > 0,
            from: {
                width: c,
                height: f,
                x: u,
                y: l
            },
            to: {
                width: c,
                height: f,
                x: u,
                y: l
            },
            duration: p,
            animationEasing: m,
            isActive: b
        }, function(A) {
            var w = A.width,
                x = A.height,
                T = A.x,
                _ = A.y;
            return R.createElement(so, {
                canBegin: a > 0,
                from: "0px ".concat(a === -1 ? 1 : a, "px"),
                to: "".concat(a, "px 0px"),
                attributeName: "strokeDasharray",
                begin: y,
                duration: p,
                isActive: g,
                easing: m
            }, R.createElement("path", hy({}, _e(n, !0), {
                className: v,
                d: wM(T, _, w, x, d),
                ref: r
            })))
        }) : R.createElement("path", hy({}, _e(n, !0), {
            className: v,
            d: wM(u, l, c, f, d)
        }))
    };

function lA() {
    return lA = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, lA.apply(this, arguments)
}
var ET = function(t) {
    var n = t.cx,
        r = t.cy,
        i = t.r,
        o = t.className,
        a = Me("recharts-dot", o);
    return n === +n && r === +r && i === +i ? R.createElement("circle", lA({}, _e(t, !1), Mg(t), {
        className: a,
        cx: n,
        cy: r,
        r: i
    })) : null
};

function zd(e) {
    "@babel/helpers - typeof";
    return zd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, zd(e)
}
var zSe = ["x", "y", "top", "left", "width", "height", "className"];

function cA() {
    return cA = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, cA.apply(this, arguments)
}

function xM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function WSe(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? xM(Object(n), !0).forEach(function(r) {
            GSe(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xM(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function GSe(e, t, n) {
    return t = qSe(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function qSe(e) {
    var t = KSe(e, "string");
    return zd(t) == "symbol" ? t : t + ""
}

function KSe(e, t) {
    if (zd(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (zd(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}

function QSe(e, t) {
    if (e == null) return {};
    var n = YSe(e, t),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        for (i = 0; i < o.length; i++) r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
    }
    return n
}

function YSe(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
            if (t.indexOf(r) >= 0) continue;
            n[r] = e[r]
        }
    return n
}
var XSe = function(t, n, r, i, o, a) {
        return "M".concat(t, ",").concat(o, "v").concat(i, "M").concat(a, ",").concat(n, "h").concat(r)
    },
    ZSe = function(t) {
        var n = t.x,
            r = n === void 0 ? 0 : n,
            i = t.y,
            o = i === void 0 ? 0 : i,
            a = t.top,
            s = a === void 0 ? 0 : a,
            u = t.left,
            l = u === void 0 ? 0 : u,
            c = t.width,
            f = c === void 0 ? 0 : c,
            d = t.height,
            h = d === void 0 ? 0 : d,
            m = t.className,
            p = QSe(t, zSe),
            y = WSe({
                x: r,
                y: o,
                top: s,
                left: l,
                width: f,
                height: h
            }, p);
        return !Y(r) || !Y(o) || !Y(f) || !Y(h) || !Y(s) || !Y(l) ? null : R.createElement("path", cA({}, _e(y, !0), {
            className: Me("recharts-cross", m),
            d: XSe(r, o, f, h, s, l)
        }))
    },
    JSe = C5,
    e_e = JSe(Object.getPrototypeOf, Object),
    t_e = e_e,
    n_e = vo,
    r_e = t_e,
    i_e = bo,
    o_e = "[object Object]",
    a_e = Function.prototype,
    s_e = Object.prototype,
    m6 = a_e.toString,
    u_e = s_e.hasOwnProperty,
    l_e = m6.call(Object);

function c_e(e) {
    if (!i_e(e) || n_e(e) != o_e) return !1;
    var t = r_e(e);
    if (t === null) return !0;
    var n = u_e.call(t, "constructor") && t.constructor;
    return typeof n == "function" && n instanceof n && m6.call(n) == l_e
}
var f_e = c_e;
const d_e = Fe(f_e);
var h_e = vo,
    p_e = bo,
    m_e = "[object Boolean]";

function g_e(e) {
    return e === !0 || e === !1 || p_e(e) && h_e(e) == m_e
}
var y_e = g_e;
const v_e = Fe(y_e);

function Wd(e) {
    "@babel/helpers - typeof";
    return Wd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Wd(e)
}

function py() {
    return py = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, py.apply(this, arguments)
}

function b_e(e, t) {
    return E_e(e) || A_e(e, t) || x_e(e, t) || w_e()
}

function w_e() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function x_e(e, t) {
    if (e) {
        if (typeof e == "string") return AM(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AM(e, t)
    }
}

function AM(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}

function A_e(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
        var r, i, o, a, s = [],
            u = !0,
            l = !1;
        try {
            if (o = (n = n.call(e)).next, t !== 0)
                for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0);
        } catch (c) {
            l = !0, i = c
        } finally {
            try {
                if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return
            } finally {
                if (l) throw i
            }
        }
        return s
    }
}

function E_e(e) {
    if (Array.isArray(e)) return e
}

function EM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function SM(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? EM(Object(n), !0).forEach(function(r) {
            S_e(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : EM(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function S_e(e, t, n) {
    return t = __e(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function __e(e) {
    var t = T_e(e, "string");
    return Wd(t) == "symbol" ? t : t + ""
}

function T_e(e, t) {
    if (Wd(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Wd(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}
var _M = function(t, n, r, i, o) {
        var a = r - i,
            s;
        return s = "M ".concat(t, ",").concat(n), s += "L ".concat(t + r, ",").concat(n), s += "L ".concat(t + r - a / 2, ",").concat(n + o), s += "L ".concat(t + r - a / 2 - i, ",").concat(n + o), s += "L ".concat(t, ",").concat(n, " Z"), s
    },
    P_e = {
        x: 0,
        y: 0,
        upperWidth: 0,
        lowerWidth: 0,
        height: 0,
        isUpdateAnimationActive: !1,
        animationBegin: 0,
        animationDuration: 1500,
        animationEasing: "ease"
    },
    O_e = function(t) {
        var n = SM(SM({}, P_e), t),
            r = S.useRef(),
            i = S.useState(-1),
            o = b_e(i, 2),
            a = o[0],
            s = o[1];
        S.useEffect(function() {
            if (r.current && r.current.getTotalLength) try {
                var v = r.current.getTotalLength();
                v && s(v)
            } catch {}
        }, []);
        var u = n.x,
            l = n.y,
            c = n.upperWidth,
            f = n.lowerWidth,
            d = n.height,
            h = n.className,
            m = n.animationEasing,
            p = n.animationDuration,
            y = n.animationBegin,
            g = n.isUpdateAnimationActive;
        if (u !== +u || l !== +l || c !== +c || f !== +f || d !== +d || c === 0 && f === 0 || d === 0) return null;
        var b = Me("recharts-trapezoid", h);
        return g ? R.createElement(so, {
            canBegin: a > 0,
            from: {
                upperWidth: 0,
                lowerWidth: 0,
                height: d,
                x: u,
                y: l
            },
            to: {
                upperWidth: c,
                lowerWidth: f,
                height: d,
                x: u,
                y: l
            },
            duration: p,
            animationEasing: m,
            isActive: g
        }, function(v) {
            var A = v.upperWidth,
                w = v.lowerWidth,
                x = v.height,
                T = v.x,
                _ = v.y;
            return R.createElement(so, {
                canBegin: a > 0,
                from: "0px ".concat(a === -1 ? 1 : a, "px"),
                to: "".concat(a, "px 0px"),
                attributeName: "strokeDasharray",
                begin: y,
                duration: p,
                easing: m
            }, R.createElement("path", py({}, _e(n, !0), {
                className: b,
                d: _M(T, _, A, w, x),
                ref: r
            })))
        }) : R.createElement("g", null, R.createElement("path", py({}, _e(n, !0), {
            className: b,
            d: _M(u, l, c, f, d)
        })))
    },
    k_e = ["option", "shapeType", "propTransformer", "activeClassName", "isActive"];

function Gd(e) {
    "@babel/helpers - typeof";
    return Gd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Gd(e)
}

function C_e(e, t) {
    if (e == null) return {};
    var n = I_e(e, t),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        for (i = 0; i < o.length; i++) r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
    }
    return n
}

function I_e(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
            if (t.indexOf(r) >= 0) continue;
            n[r] = e[r]
        }
    return n
}

function TM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function my(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? TM(Object(n), !0).forEach(function(r) {
            M_e(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TM(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function M_e(e, t, n) {
    return t = N_e(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function N_e(e) {
    var t = R_e(e, "string");
    return Gd(t) == "symbol" ? t : t + ""
}

function R_e(e, t) {
    if (Gd(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Gd(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}

function j_e(e, t) {
    return my(my({}, t), e)
}

function B_e(e, t) {
    return e === "symbols"
}

function PM(e) {
    var t = e.shapeType,
        n = e.elementProps;
    switch (t) {
        case "rectangle":
            return R.createElement(AT, n);
        case "trapezoid":
            return R.createElement(O_e, n);
        case "sector":
            return R.createElement(i6, n);
        case "symbols":
            if (B_e(t)) return R.createElement(F_, n);
            break;
        default:
            return null
    }
}

function D_e(e) {
    return S.isValidElement(e) ? e.props : e
}

function $_e(e) {
    var t = e.option,
        n = e.shapeType,
        r = e.propTransformer,
        i = r === void 0 ? j_e : r,
        o = e.activeClassName,
        a = o === void 0 ? "recharts-active-shape" : o,
        s = e.isActive,
        u = C_e(e, k_e),
        l;
    if (S.isValidElement(t)) l = S.cloneElement(t, my(my({}, u), D_e(t)));
    else if (Ae(t)) l = t(u);
    else if (d_e(t) && !v_e(t)) {
        var c = i(t, u);
        l = R.createElement(PM, {
            shapeType: n,
            elementProps: c
        })
    } else {
        var f = u;
        l = R.createElement(PM, {
            shapeType: n,
            elementProps: f
        })
    }
    return s ? R.createElement(lt, {
        className: a
    }, l) : l
}

function s0(e, t) {
    return t != null && "trapezoids" in e.props
}

function u0(e, t) {
    return t != null && "sectors" in e.props
}

function qd(e, t) {
    return t != null && "points" in e.props
}

function L_e(e, t) {
    var n, r, i = e.x === (t == null || (n = t.labelViewBox) === null || n === void 0 ? void 0 : n.x) || e.x === t.x,
        o = e.y === (t == null || (r = t.labelViewBox) === null || r === void 0 ? void 0 : r.y) || e.y === t.y;
    return i && o
}

function F_e(e, t) {
    var n = e.endAngle === t.endAngle,
        r = e.startAngle === t.startAngle;
    return n && r
}

function U_e(e, t) {
    var n = e.x === t.x,
        r = e.y === t.y,
        i = e.z === t.z;
    return n && r && i
}

function H_e(e, t) {
    var n;
    return s0(e, t) ? n = L_e : u0(e, t) ? n = F_e : qd(e, t) && (n = U_e), n
}

function V_e(e, t) {
    var n;
    return s0(e, t) ? n = "trapezoids" : u0(e, t) ? n = "sectors" : qd(e, t) && (n = "points"), n
}

function z_e(e, t) {
    if (s0(e, t)) {
        var n;
        return (n = t.tooltipPayload) === null || n === void 0 || (n = n[0]) === null || n === void 0 || (n = n.payload) === null || n === void 0 ? void 0 : n.payload
    }
    if (u0(e, t)) {
        var r;
        return (r = t.tooltipPayload) === null || r === void 0 || (r = r[0]) === null || r === void 0 || (r = r.payload) === null || r === void 0 ? void 0 : r.payload
    }
    return qd(e, t) ? t.payload : {}
}

function W_e(e) {
    var t = e.activeTooltipItem,
        n = e.graphicalItem,
        r = e.itemData,
        i = V_e(n, t),
        o = z_e(n, t),
        a = r.filter(function(u, l) {
            var c = Cd(o, u),
                f = n.props[i].filter(function(m) {
                    var p = H_e(n, t);
                    return p(m, t)
                }),
                d = n.props[i].indexOf(f[f.length - 1]),
                h = l === d;
            return c && h
        }),
        s = r.indexOf(a[a.length - 1]);
    return s
}
var G_e = Math.ceil,
    q_e = Math.max;

function K_e(e, t, n, r) {
    for (var i = -1, o = q_e(G_e((t - e) / (n || 1)), 0), a = Array(o); o--;) a[r ? o : ++i] = e, e += n;
    return a
}
var Q_e = K_e,
    Y_e = K5,
    X_e = 1 / 0,
    Z_e = 17976931348623157e292;

function J_e(e) {
    if (!e) return e === 0 ? e : 0;
    if (e = Y_e(e), e === X_e || e === -1 / 0) {
        var t = e < 0 ? -1 : 1;
        return t * Z_e
    }
    return e === e ? e : 0
}
var eTe = J_e,
    tTe = Q_e,
    nTe = Yv,
    Xb = eTe;

function rTe(e) {
    return function(t, n, r) {
        return r && typeof r != "number" && nTe(t, n, r) && (n = r = void 0), t = Xb(t), n === void 0 ? (n = t, t = 0) : n = Xb(n), r = r === void 0 ? t < n ? 1 : -1 : Xb(r), tTe(t, n, r, e)
    }
}
var iTe = rTe,
    oTe = iTe,
    aTe = oTe(),
    sTe = aTe;
const gy = Fe(sTe);

function Kd(e) {
    "@babel/helpers - typeof";
    return Kd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Kd(e)
}

function OM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function kM(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? OM(Object(n), !0).forEach(function(r) {
            g6(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OM(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function g6(e, t, n) {
    return t = uTe(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function uTe(e) {
    var t = lTe(e, "string");
    return Kd(t) == "symbol" ? t : t + ""
}

function lTe(e, t) {
    if (Kd(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Kd(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}
var cTe = ["Webkit", "Moz", "O", "ms"],
    fTe = function(t, n) {
        var r = t.replace(/(\w)/, function(o) {
                return o.toUpperCase()
            }),
            i = cTe.reduce(function(o, a) {
                return kM(kM({}, o), {}, g6({}, a + r, n))
            }, {});
        return i[t] = n, i
    };

function Sl(e) {
    "@babel/helpers - typeof";
    return Sl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Sl(e)
}

function yy() {
    return yy = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, yy.apply(this, arguments)
}

function CM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function Zb(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? CM(Object(n), !0).forEach(function(r) {
            jn(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CM(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function dTe(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function IM(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, v6(r.key), r)
    }
}

function hTe(e, t, n) {
    return t && IM(e.prototype, t), n && IM(e, n), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function pTe(e, t, n) {
    return t = vy(t), mTe(e, y6() ? Reflect.construct(t, n || [], vy(e).constructor) : t.apply(e, n))
}

function mTe(e, t) {
    if (t && (Sl(t) === "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return gTe(e)
}

function gTe(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function y6() {
    try {
        var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (y6 = function() {
        return !!e
    })()
}

function vy(e) {
    return vy = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }, vy(e)
}

function yTe(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(e, "prototype", {
        writable: !1
    }), t && fA(e, t)
}

function fA(e, t) {
    return fA = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i, r
    }, fA(e, t)
}

function jn(e, t, n) {
    return t = v6(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function v6(e) {
    var t = vTe(e, "string");
    return Sl(t) == "symbol" ? t : t + ""
}

function vTe(e, t) {
    if (Sl(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Sl(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(e)
}
var bTe = function(t) {
        var n = t.data,
            r = t.startIndex,
            i = t.endIndex,
            o = t.x,
            a = t.width,
            s = t.travellerWidth;
        if (!n || !n.length) return {};
        var u = n.length,
            l = gf().domain(gy(0, u)).range([o, o + a - s]),
            c = l.domain().map(function(f) {
                return l(f)
            });
        return {
            isTextActive: !1,
            isSlideMoving: !1,
            isTravellerMoving: !1,
            isTravellerFocused: !1,
            startX: l(r),
            endX: l(i),
            scale: l,
            scaleValues: c
        }
    },
    MM = function(t) {
        return t.changedTouches && !!t.changedTouches.length
    },
    _l = function(e) {
        function t(n) {
            var r;
            return dTe(this, t), r = pTe(this, t, [n]), jn(r, "handleDrag", function(i) {
                r.leaveTimer && (clearTimeout(r.leaveTimer), r.leaveTimer = null), r.state.isTravellerMoving ? r.handleTravellerMove(i) : r.state.isSlideMoving && r.handleSlideDrag(i)
            }), jn(r, "handleTouchMove", function(i) {
                i.changedTouches != null && i.changedTouches.length > 0 && r.handleDrag(i.changedTouches[0])
            }), jn(r, "handleDragEnd", function() {
                r.setState({
                    isTravellerMoving: !1,
                    isSlideMoving: !1
                }, function() {
                    var i = r.props,
                        o = i.endIndex,
                        a = i.onDragEnd,
                        s = i.startIndex;
                    a == null || a({
                        endIndex: o,
                        startIndex: s
                    })
                }), r.detachDragEndListener()
            }), jn(r, "handleLeaveWrapper", function() {
                (r.state.isTravellerMoving || r.state.isSlideMoving) && (r.leaveTimer = window.setTimeout(r.handleDragEnd, r.props.leaveTimeOut))
            }), jn(r, "handleEnterSlideOrTraveller", function() {
                r.setState({
                    isTextActive: !0
                })
            }), jn(r, "handleLeaveSlideOrTraveller", function() {
                r.setState({
                    isTextActive: !1
                })
            }), jn(r, "handleSlideDragStart", function(i) {
                var o = MM(i) ? i.changedTouches[0] : i;
                r.setState({
                    isTravellerMoving: !1,
                    isSlideMoving: !0,
                    slideMoveStartX: o.pageX
                }), r.attachDragEndListener()
            }), r.travellerDragStartHandlers = {
                startX: r.handleTravellerDragStart.bind(r, "startX"),
                endX: r.handleTravellerDragStart.bind(r, "endX")
            }, r.state = {}, r
        }
        return yTe(t, e), hTe(t, [{
            key: "componentWillUnmount",
            value: function() {
                this.leaveTimer && (clearTimeout(this.leaveTimer), this.leaveTimer = null), this.detachDragEndListener()
            }
        }, {
            key: "getIndex",
            value: function(r) {
                var i = r.startX,
                    o = r.endX,
                    a = this.state.scaleValues,
                    s = this.props,
                    u = s.gap,
                    l = s.data,
                    c = l.length - 1,
                    f = Math.min(i, o),
                    d = Math.max(i, o),
                    h = t.getIndexInRange(a, f),
                    m = t.getIndexInRange(a, d);
                return {
                    startIndex: h - h % u,
                    endIndex: m === c ? c : m - m % u
                }
            }
        }, {
            key: "getTextOfTick",
            value: function(r) {
                var i = this.props,
                    o = i.data,
                    a = i.tickFormatter,
                    s = i.dataKey,
                    u = Gn(o[r], s, r);
                return Ae(a) ? a(u, r) : u
            }
        }, {
            key: "attachDragEndListener",
            value: function() {
                window.addEventListener("mouseup", this.handleDragEnd, !0), window.addEventListener("touchend", this.handleDragEnd, !0), window.addEventListener("mousemove", this.handleDrag, !0)
            }
        }, {
            key: "detachDragEndListener",
            value: function() {
                window.removeEventListener("mouseup", this.handleDragEnd, !0), window.removeEventListener("touchend", this.handleDragEnd, !0), window.removeEventListener("mousemove", this.handleDrag, !0)
            }
        }, {
            key: "handleSlideDrag",
            value: function(r) {
                var i = this.state,
                    o = i.slideMoveStartX,
                    a = i.startX,
                    s = i.endX,
                    u = this.props,
                    l = u.x,
                    c = u.width,
                    f = u.travellerWidth,
                    d = u.startIndex,
                    h = u.endIndex,
                    m = u.onChange,
                    p = r.pageX - o;
                p > 0 ? p = Math.min(p, l + c - f - s, l + c - f - a) : p < 0 && (p = Math.max(p, l - a, l - s));
                var y = this.getIndex({
                    startX: a + p,
                    endX: s + p
                });
                (y.startIndex !== d || y.endIndex !== h) && m && m(y), this.setState({
                    startX: a + p,
                    endX: s + p,
                    slideMoveStartX: r.pageX
                })
            }
        }, {
            key: "handleTravellerDragStart",
            value: function(r, i) {
                var o = MM(i) ? i.changedTouches[0] : i;
                this.setState({
                    isSlideMoving: !1,
                    isTravellerMoving: !0,
                    movingTravellerId: r,
                    brushMoveStartX: o.pageX
                }), this.attachDragEndListener()
            }
        }, {
            key: "handleTravellerMove",
            value: function(r) {
                var i = this.state,
                    o = i.brushMoveStartX,
                    a = i.movingTravellerId,
                    s = i.endX,
                    u = i.startX,
                    l = this.state[a],
                    c = this.props,
                    f = c.x,
                    d = c.width,
                    h = c.travellerWidth,
                    m = c.onChange,
                    p = c.gap,
                    y = c.data,
                    g = {
                        startX: this.state.startX,
                        endX: this.state.endX
                    },
                    b = r.pageX - o;
                b > 0 ? b = Math.min(b, f + d - h - l) : b < 0 && (b = Math.max(b, f - l)), g[a] = l + b;
                var v = this.getIndex(g),
                    A = v.startIndex,
                    w = v.endIndex,
                    x = function() {
                        var _ = y.length - 1;
                        return a === "startX" && (s > u ? A % p === 0 : w % p === 0) || s < u && w === _ || a === "endX" && (s > u ? w % p === 0 : A % p === 0) || s > u && w === _
                    };
                this.setState(jn(jn({}, a, l + b), "brushMoveStartX", r.pageX), function() {
                    m && x() && m(v)
                })
            }
        }, {
            key: "handleTravellerMoveKeyboard",
            value: function(r, i) {
                var o = this,
                    a = this.state,
                    s = a.scaleValues,
                    u = a.startX,
                    l = a.endX,
                    c = this.state[i],
                    f = s.indexOf(c);
                if (f !== -1) {
                    var d = f + r;
                    if (!(d === -1 || d >= s.length)) {
                        var h = s[d];
                        i === "startX" && h >= l || i === "endX" && h <= u || this.setState(jn({}, i, h), function() {
                            o.props.onChange(o.getIndex({
                                startX: o.state.startX,
                                endX: o.state.endX
                            }))
                        })
                    }
                }
            }
        }, {
            key: "renderBackground",
            value: function() {
                var r = this.props,
                    i = r.x,
                    o = r.y,
                    a = r.width,
                    s = r.height,
                    u = r.fill,
                    l = r.stroke;
                return R.createElement("rect", {
                    stroke: l,
                    fill: u,
                    x: i,
                    y: o,
                    width: a,
                    height: s
                })
            }
        }, {
            key: "renderPanorama",
            value: function() {
                var r = this.props,
                    i = r.x,
                    o = r.y,
                    a = r.width,
                    s = r.height,
                    u = r.data,
                    l = r.children,
                    c = r.padding,
                    f = S.Children.only(l);
                return f ? R.cloneElement(f, {
                    x: i,
                    y: o,
                    width: a,
                    height: s,
                    margin: c,
                    compact: !0,
                    data: u
                }) : null
            }
        }, {
            key: "renderTravellerLayer",
            value: function(r, i) {
                var o, a, s = this,
                    u = this.props,
                    l = u.y,
                    c = u.travellerWidth,
                    f = u.height,
                    d = u.traveller,
                    h = u.ariaLabel,
                    m = u.data,
                    p = u.startIndex,
                    y = u.endIndex,
                    g = Math.max(r, this.props.x),
                    b = Zb(Zb({}, _e(this.props, !1)), {}, {
                        x: g,
                        y: l,
                        width: c,
                        height: f
                    }),
                    v = h || "Min value: ".concat((o = m[p]) === null || o === void 0 ? void 0 : o.name, ", Max value: ").concat((a = m[y]) === null || a === void 0 ? void 0 : a.name);
                return R.createElement(lt, {
                    tabIndex: 0,
                    role: "slider",
                    "aria-label": v,
                    "aria-valuenow": r,
                    className: "recharts-brush-traveller",
                    onMouseEnter: this.handleEnterSlideOrTraveller,
                    onMouseLeave: this.handleLeaveSlideOrTraveller,
                    onMouseDown: this.travellerDragStartHandlers[i],
                    onTouchStart: this.travellerDragStartHandlers[i],
                    onKeyDown: function(w) {
                        ["ArrowLeft", "ArrowRight"].includes(w.key) && (w.preventDefault(), w.stopPropagation(), s.handleTravellerMoveKeyboard(w.key === "ArrowRight" ? 1 : -1, i))
                    },
                    onFocus: function() {
                        s.setState({
                            isTravellerFocused: !0
                        })
                    },
                    onBlur: function() {
                        s.setState({
                            isTravellerFocused: !1
                        })
                    },
                    style: {
                        cursor: "col-resize"
                    }
                }, t.renderTraveller(d, b))
            }
        }, {
            key: "renderSlide",
            value: function(r, i) {
                var o = this.props,
                    a = o.y,
                    s = o.height,
                    u = o.stroke,
                    l = o.travellerWidth,
                    c = Math.min(r, i) + l,
                    f = Math.max(Math.abs(i - r) - l, 0);
                return R.createElement("rect", {
                    className: "recharts-brush-slide",
                    onMouseEnter: this.handleEnterSlideOrTraveller,
                    onMouseLeave: this.handleLeaveSlideOrTraveller,
                    onMouseDown: this.handleSlideDragStart,
                    onTouchStart: this.handleSlideDragStart,
                    style: {
                        cursor: "move"
                    },
                    stroke: "none",
                    fill: u,
                    fillOpacity: .2,
                    x: c,
                    y: a,
                    width: f,
                    height: s
                })
            }
        }, {
            key: "renderText",
            value: function() {
                var r = this.props,
                    i = r.startIndex,
                    o = r.endIndex,
                    a = r.y,
                    s = r.height,
                    u = r.travellerWidth,
                    l = r.stroke,
                    c = this.state,
                    f = c.startX,
                    d = c.endX,
                    h = 5,
                    m = {
                        pointerEvents: "none",
                        fill: l
                    };
                return R.createElement(lt, {
                    className: "recharts-brush-texts"
                }, R.createElement(qg, yy({
                    textAnchor: "end",
                    verticalAnchor: "middle",
                    x: Math.min(f, d) - h,
                    y: a + s / 2
                }, m), this.getTextOfTick(i)), R.createElement(qg, yy({
                    textAnchor: "start",
                    verticalAnchor: "middle",
                    x: Math.max(f, d) + u + h,
                    y: a + s / 2
                }, m), this.getTextOfTick(o)))
            }
        }, {
            key: "render",
            value: function() {
                var r = this.props,
                    i = r.data,
                    o = r.className,
                    a = r.children,
                    s = r.x,
                    u = r.y,
                    l = r.width,
                    c = r.height,
                    f = r.alwaysShowText,
                    d = this.state,
                    h = d.startX,
                    m = d.endX,
                    p = d.isTextActive,
                    y = d.isSlideMoving,
                    g = d.isTravellerMoving,
                    b = d.isTravellerFocused;
                if (!i || !i.length || !Y(s) || !Y(u) || !Y(l) || !Y(c) || l <= 0 || c <= 0) return null;
                var v = Me("recharts-brush", o),
                    A = R.Children.count(a) === 1,
                    w = fTe("userSelect", "none");
                return R.createElement(lt, {
                    className: v,
                    onMouseLeave: this.handleLeaveWrapper,
                    onTouchMove: this.handleTouchMove,
                    style: w
                }, this.renderBackground(), A && this.renderPanorama(), this.renderSlide(h, m), this.renderTravellerLayer(h, "startX"), this.renderTravellerLayer(m, "endX"), (p || y || g || b || f) && this.renderText())
            }
        }], [{
            key: "renderDefaultTraveller",
            value: function(r) {
                var i = r.x,
                    o = r.y,
                    a = r.width,
                    s = r.height,
                    u = r.stroke,
                    l = Math.floor(o + s / 2) - 1;
                return R.createElement(R.Fragment, null, R.createElement("rect", {
                    x: i,
                    y: o,
                    width: a,
                    height: s,
                    fill: u,
                    stroke: "none"
                }), R.createElement("line", {
                    x1: i + 1,
                    y1: l,
                    x2: i + a - 1,
                    y2: l,
                    fill: "none",
                    stroke: "#fff"
                }), R.createElement("line", {
                    x1: i + 1,
                    y1: l + 2,
                    x2: i + a - 1,
                    y2: l + 2,
                    fill: "none",
                    stroke: "#fff"
                }))
            }
        }, {
            key: "renderTraveller",
            value: function(r, i) {
                var o;
                return R.isValidElement(r) ? o = R.cloneElement(r, i) : Ae(r) ? o = r(i) : o = t.renderDefaultTraveller(i), o
            }
        }, {
            key: "getDerivedStateFromProps",
            value: function(r, i) {
                var o = r.data,
                    a = r.width,
                    s = r.x,
                    u = r.travellerWidth,
                    l = r.updateId,
                    c = r.startIndex,
                    f = r.endIndex;
                if (o !== i.prevData || l !== i.prevUpdateId) return Zb({
                    prevData: o,
                    prevTravellerWidth: u,
                    prevUpdateId: l,
                    prevX: s,
                    prevWidth: a
                }, o && o.length ? bTe({
                    data: o,
                    width: a,
                    x: s,
                    travellerWidth: u,
                    startIndex: c,
                    endIndex: f
                }) : {
                    scale: null,
                    scaleValues: null
                });
                if (i.scale && (a !== i.prevWidth || s !== i.prevX || u !== i.prevTravellerWidth)) {
                    i.scale.range([s, s + a - u]);
                    var d = i.scale.domain().map(function(h) {
                        return i.scale(h)
                    });
                    return {
                        prevData: o,
                        prevTravellerWidth: u,
                        prevUpdateId: l,
                        prevX: s,
                        prevWidth: a,
                        startX: i.scale(r.startIndex),
                        endX: i.scale(r.endIndex),
                        scaleValues: d
                    }
                }
                return null
            }
        }, {
            key: "getIndexInRange",
            value: function(r, i) {
                for (var o = r.length, a = 0, s = o - 1; s - a > 1;) {
                    var u = Math.floor((a + s) / 2);
                    r[u] > i ? s = u : a = u
                }
                return i >= r[s] ? s : a
            }
        }])
    }(S.PureComponent);
jn(_l, "displayName", "Brush");
jn(_l, "defaultProps", {
    height: 40,
    travellerWidth: 5,
    gap: 1,
    fill: "#fff",
    stroke: "#666",
    padding: {
        top: 1,
        right: 1,
        bottom: 1,
        left: 1
    },
    leaveTimeOut: 1e3,
    alwaysShowText: !1
});
var wTe = K_;

function xTe(e, t) {
    var n;
    return wTe(e, function(r, i, o) {
        return n = t(r, i, o), !n
    }), !!n
}
var ATe = xTe,
    ETe = A5,
    STe = ic,
    _Te = ATe,
    TTe = Rn,
    PTe = Yv;

function OTe(e, t, n) {
    var r = TTe(e) ? ETe : _Te;
    return n && PTe(e, t, n) && (t = void 0), r(e, STe(t))
}
var kTe = OTe;
const CTe = Fe(kTe);
var ci = function(t, n) {
        var r = t.alwaysShow,
            i = t.ifOverflow;
        return r && (i = "extendDomain"), i === n
    },
    NM = V5;

function ITe(e, t, n) {
    t == "__proto__" && NM ? NM(e, t, {
        configurable: !0,
        enumerable: !0,
        value: n,
        writable: !0
    }) : e[t] = n
}
var MTe = ITe,
    NTe = MTe,
    RTe = U5,
    jTe = ic;

function BTe(e, t) {
    var n = {};
    return t = jTe(t), RTe(e, function(r, i, o) {
        NTe(n, i, t(r, i, o))
    }), n
}
var DTe = BTe;
const $Te = Fe(DTe);

function LTe(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length; ++n < r;)
        if (!t(e[n], n, e)) return !1;
    return !0
}
var FTe = LTe,
    UTe = K_;

function HTe(e, t) {
    var n = !0;
    return UTe(e, function(r, i, o) {
        return n = !!t(r, i, o), n
    }), n
}
var VTe = HTe,
    zTe = FTe,
    WTe = VTe,
    GTe = ic,
    qTe = Rn,
    KTe = Yv;

function QTe(e, t, n) {
    var r = qTe(e) ? zTe : WTe;
    return n && KTe(e, t, n) && (t = void 0), r(e, GTe(t))
}
var YTe = QTe;
const XTe = Fe(YTe);
var ZTe = ["x", "y"];

function Qd(e) {
    "@babel/helpers - typeof";
    return Qd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Qd(e)
}

function dA() {
    return dA = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, dA.apply(this, arguments)
}

function RM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function Rc(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? RM(Object(n), !0).forEach(function(r) {
            JTe(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RM(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function JTe(e, t, n) {
    return t = ePe(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function ePe(e) {
    var t = tPe(e, "string");
    return Qd(t) == "symbol" ? t : t + ""
}

function tPe(e, t) {
    if (Qd(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Qd(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}

function nPe(e, t) {
    if (e == null) return {};
    var n = rPe(e, t),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        for (i = 0; i < o.length; i++) r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
    }
    return n
}

function rPe(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
            if (t.indexOf(r) >= 0) continue;
            n[r] = e[r]
        }
    return n
}

function iPe(e, t) {
    var n = e.x,
        r = e.y,
        i = nPe(e, ZTe),
        o = "".concat(n),
        a = parseInt(o, 10),
        s = "".concat(r),
        u = parseInt(s, 10),
        l = "".concat(t.height || i.height),
        c = parseInt(l, 10),
        f = "".concat(t.width || i.width),
        d = parseInt(f, 10);
    return Rc(Rc(Rc(Rc(Rc({}, t), i), a ? {
        x: a
    } : {}), u ? {
        y: u
    } : {}), {}, {
        height: c,
        width: d,
        name: t.name,
        radius: t.radius
    })
}

function jM(e) {
    return R.createElement($_e, dA({
        shapeType: "rectangle",
        propTransformer: iPe,
        activeClassName: "recharts-active-bar"
    }, e))
}
var oPe = function(t) {
        var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return function(r, i) {
            if (typeof t == "number") return t;
            var o = typeof r == "number";
            return o ? t(r, i) : (o || Is(), n)
        }
    },
    aPe = ["value", "background"],
    b6;

function Tl(e) {
    "@babel/helpers - typeof";
    return Tl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Tl(e)
}

function sPe(e, t) {
    if (e == null) return {};
    var n = uPe(e, t),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        for (i = 0; i < o.length; i++) r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
    }
    return n
}

function uPe(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
            if (t.indexOf(r) >= 0) continue;
            n[r] = e[r]
        }
    return n
}

function by() {
    return by = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, by.apply(this, arguments)
}

function BM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function _t(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? BM(Object(n), !0).forEach(function(r) {
            Uo(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BM(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function lPe(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function DM(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, x6(r.key), r)
    }
}

function cPe(e, t, n) {
    return t && DM(e.prototype, t), n && DM(e, n), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function fPe(e, t, n) {
    return t = wy(t), dPe(e, w6() ? Reflect.construct(t, n || [], wy(e).constructor) : t.apply(e, n))
}

function dPe(e, t) {
    if (t && (Tl(t) === "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return hPe(e)
}

function hPe(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function w6() {
    try {
        var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (w6 = function() {
        return !!e
    })()
}

function wy(e) {
    return wy = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }, wy(e)
}

function pPe(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(e, "prototype", {
        writable: !1
    }), t && hA(e, t)
}

function hA(e, t) {
    return hA = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i, r
    }, hA(e, t)
}

function Uo(e, t, n) {
    return t = x6(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function x6(e) {
    var t = mPe(e, "string");
    return Tl(t) == "symbol" ? t : t + ""
}

function mPe(e, t) {
    if (Tl(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Tl(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(e)
}
var kh = function(e) {
    function t() {
        var n;
        lPe(this, t);
        for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++) i[o] = arguments[o];
        return n = fPe(this, t, [].concat(i)), Uo(n, "state", {
            isAnimationFinished: !1
        }), Uo(n, "id", Sh("recharts-bar-")), Uo(n, "handleAnimationEnd", function() {
            var a = n.props.onAnimationEnd;
            n.setState({
                isAnimationFinished: !0
            }), a && a()
        }), Uo(n, "handleAnimationStart", function() {
            var a = n.props.onAnimationStart;
            n.setState({
                isAnimationFinished: !1
            }), a && a()
        }), n
    }
    return pPe(t, e), cPe(t, [{
        key: "renderRectanglesStatically",
        value: function(r) {
            var i = this,
                o = this.props,
                a = o.shape,
                s = o.dataKey,
                u = o.activeIndex,
                l = o.activeBar,
                c = _e(this.props, !1);
            return r && r.map(function(f, d) {
                var h = d === u,
                    m = h ? l : a,
                    p = _t(_t(_t({}, c), f), {}, {
                        isActive: h,
                        option: m,
                        index: d,
                        dataKey: s,
                        onAnimationStart: i.handleAnimationStart,
                        onAnimationEnd: i.handleAnimationEnd
                    });
                return R.createElement(lt, by({
                    className: "recharts-bar-rectangle"
                }, Ng(i.props, f, d), {
                    key: "rectangle-".concat(f == null ? void 0 : f.x, "-").concat(f == null ? void 0 : f.y, "-").concat(f == null ? void 0 : f.value)
                }), R.createElement(jM, p))
            })
        }
    }, {
        key: "renderRectanglesWithAnimation",
        value: function() {
            var r = this,
                i = this.props,
                o = i.data,
                a = i.layout,
                s = i.isAnimationActive,
                u = i.animationBegin,
                l = i.animationDuration,
                c = i.animationEasing,
                f = i.animationId,
                d = this.state.prevData;
            return R.createElement(so, {
                begin: u,
                duration: l,
                isActive: s,
                easing: c,
                from: {
                    t: 0
                },
                to: {
                    t: 1
                },
                key: "bar-".concat(f),
                onAnimationEnd: this.handleAnimationEnd,
                onAnimationStart: this.handleAnimationStart
            }, function(h) {
                var m = h.t,
                    p = o.map(function(y, g) {
                        var b = d && d[g];
                        if (b) {
                            var v = ar(b.x, y.x),
                                A = ar(b.y, y.y),
                                w = ar(b.width, y.width),
                                x = ar(b.height, y.height);
                            return _t(_t({}, y), {}, {
                                x: v(m),
                                y: A(m),
                                width: w(m),
                                height: x(m)
                            })
                        }
                        if (a === "horizontal") {
                            var T = ar(0, y.height),
                                _ = T(m);
                            return _t(_t({}, y), {}, {
                                y: y.y + y.height - _,
                                height: _
                            })
                        }
                        var O = ar(0, y.width),
                            k = O(m);
                        return _t(_t({}, y), {}, {
                            width: k
                        })
                    });
                return R.createElement(lt, null, r.renderRectanglesStatically(p))
            })
        }
    }, {
        key: "renderRectangles",
        value: function() {
            var r = this.props,
                i = r.data,
                o = r.isAnimationActive,
                a = this.state.prevData;
            return o && i && i.length && (!a || !Cd(a, i)) ? this.renderRectanglesWithAnimation() : this.renderRectanglesStatically(i)
        }
    }, {
        key: "renderBackground",
        value: function() {
            var r = this,
                i = this.props,
                o = i.data,
                a = i.dataKey,
                s = i.activeIndex,
                u = _e(this.props.background, !1);
            return o.map(function(l, c) {
                l.value;
                var f = l.background,
                    d = sPe(l, aPe);
                if (!f) return null;
                var h = _t(_t(_t(_t(_t({}, d), {}, {
                    fill: "#eee"
                }, f), u), Ng(r.props, l, c)), {}, {
                    onAnimationStart: r.handleAnimationStart,
                    onAnimationEnd: r.handleAnimationEnd,
                    dataKey: a,
                    index: c,
                    className: "recharts-bar-background-rectangle"
                });
                return R.createElement(jM, by({
                    key: "background-bar-".concat(c),
                    option: r.props.background,
                    isActive: c === s
                }, h))
            })
        }
    }, {
        key: "renderErrorBar",
        value: function(r, i) {
            if (this.props.isAnimationActive && !this.state.isAnimationFinished) return null;
            var o = this.props,
                a = o.data,
                s = o.xAxis,
                u = o.yAxis,
                l = o.layout,
                c = o.children,
                f = Dr(c, a0);
            if (!f) return null;
            var d = l === "vertical" ? a[0].height / 2 : a[0].width / 2,
                h = function(y, g) {
                    var b = Array.isArray(y.value) ? y.value[1] : y.value;
                    return {
                        x: y.x,
                        y: y.y,
                        value: b,
                        errorVal: Gn(y, g)
                    }
                },
                m = {
                    clipPath: r ? "url(#clipPath-".concat(i, ")") : null
                };
            return R.createElement(lt, m, f.map(function(p) {
                return R.cloneElement(p, {
                    key: "error-bar-".concat(i, "-").concat(p.props.dataKey),
                    data: a,
                    xAxis: s,
                    yAxis: u,
                    layout: l,
                    offset: d,
                    dataPointFormatter: h
                })
            }))
        }
    }, {
        key: "render",
        value: function() {
            var r = this.props,
                i = r.hide,
                o = r.data,
                a = r.className,
                s = r.xAxis,
                u = r.yAxis,
                l = r.left,
                c = r.top,
                f = r.width,
                d = r.height,
                h = r.isAnimationActive,
                m = r.background,
                p = r.id;
            if (i || !o || !o.length) return null;
            var y = this.state.isAnimationFinished,
                g = Me("recharts-bar", a),
                b = s && s.allowDataOverflow,
                v = u && u.allowDataOverflow,
                A = b || v,
                w = Pe(p) ? this.id : p;
            return R.createElement(lt, {
                className: g
            }, b || v ? R.createElement("defs", null, R.createElement("clipPath", {
                id: "clipPath-".concat(w)
            }, R.createElement("rect", {
                x: b ? l : l - f / 2,
                y: v ? c : c - d / 2,
                width: b ? f : f * 2,
                height: v ? d : d * 2
            }))) : null, R.createElement(lt, {
                className: "recharts-bar-rectangles",
                clipPath: A ? "url(#clipPath-".concat(w, ")") : null
            }, m ? this.renderBackground() : null, this.renderRectangles()), this.renderErrorBar(A, w), (!h || y) && Jo.renderCallByParent(this.props, o))
        }
    }], [{
        key: "getDerivedStateFromProps",
        value: function(r, i) {
            return r.animationId !== i.prevAnimationId ? {
                prevAnimationId: r.animationId,
                curData: r.data,
                prevData: i.curData
            } : r.data !== i.curData ? {
                curData: r.data
            } : null
        }
    }])
}(S.PureComponent);
b6 = kh;
Uo(kh, "displayName", "Bar");
Uo(kh, "defaultProps", {
    xAxisId: 0,
    yAxisId: 0,
    legendType: "rect",
    minPointSize: 0,
    hide: !1,
    data: [],
    layout: "vertical",
    activeBar: !1,
    isAnimationActive: !oc.isSsr,
    animationBegin: 0,
    animationDuration: 400,
    animationEasing: "ease"
});
Uo(kh, "getComposedData", function(e) {
    var t = e.props,
        n = e.item,
        r = e.barPosition,
        i = e.bandSize,
        o = e.xAxis,
        a = e.yAxis,
        s = e.xAxisTicks,
        u = e.yAxisTicks,
        l = e.stackedData,
        c = e.dataStartIndex,
        f = e.displayedData,
        d = e.offset,
        h = H1e(r, n);
    if (!h) return null;
    var m = t.layout,
        p = n.type.defaultProps,
        y = p !== void 0 ? _t(_t({}, p), n.props) : n.props,
        g = y.dataKey,
        b = y.children,
        v = y.minPointSize,
        A = m === "horizontal" ? a : o,
        w = l ? A.scale.domain() : null,
        x = Y1e({
            numericAxis: A
        }),
        T = Dr(b, Y5),
        _ = f.map(function(O, k) {
            var I, M, B, L, P, C;
            l ? I = V1e(l[c + k], w) : (I = Gn(O, g), Array.isArray(I) || (I = [x, I]));
            var j = oPe(v, b6.defaultProps.minPointSize)(I[1], k);
            if (m === "horizontal") {
                var N, D = [a.scale(I[0]), a.scale(I[1])],
                    $ = D[0],
                    V = D[1];
                M = DI({
                    axis: o,
                    ticks: s,
                    bandSize: i,
                    offset: h.offset,
                    entry: O,
                    index: k
                }), B = (N = V ? ? $) !== null && N !== void 0 ? N : void 0, L = h.size;
                var H = $ - V;
                if (P = Number.isNaN(H) ? 0 : H, C = {
                        x: M,
                        y: a.y,
                        width: L,
                        height: a.height
                    }, Math.abs(j) > 0 && Math.abs(P) < Math.abs(j)) {
                    var Q = Mr(P || j) * (Math.abs(j) - Math.abs(P));
                    B -= Q, P += Q
                }
            } else {
                var X = [o.scale(I[0]), o.scale(I[1])],
                    ve = X[0],
                    De = X[1];
                if (M = ve, B = DI({
                        axis: a,
                        ticks: u,
                        bandSize: i,
                        offset: h.offset,
                        entry: O,
                        index: k
                    }), L = De - ve, P = h.size, C = {
                        x: o.x,
                        y: B,
                        width: o.width,
                        height: P
                    }, Math.abs(j) > 0 && Math.abs(L) < Math.abs(j)) {
                    var ot = Mr(L || j) * (Math.abs(j) - Math.abs(L));
                    L += ot
                }
            }
            return _t(_t(_t({}, O), {}, {
                x: M,
                y: B,
                width: L,
                height: P,
                value: l ? I : I[1],
                payload: O,
                background: C
            }, T && T[k] && T[k].props), {}, {
                tooltipPayload: [t6(n, O)],
                tooltipPosition: {
                    x: M + L / 2,
                    y: B + P / 2
                }
            })
        });
    return _t({
        data: _,
        layout: m
    }, d)
});

function Yd(e) {
    "@babel/helpers - typeof";
    return Yd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Yd(e)
}

function gPe(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function $M(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, A6(r.key), r)
    }
}

function yPe(e, t, n) {
    return t && $M(e.prototype, t), n && $M(e, n), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function LM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function Pr(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? LM(Object(n), !0).forEach(function(r) {
            l0(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LM(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function l0(e, t, n) {
    return t = A6(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function A6(e) {
    var t = vPe(e, "string");
    return Yd(t) == "symbol" ? t : t + ""
}

function vPe(e, t) {
    if (Yd(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Yd(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}
var bPe = function(t, n, r, i, o) {
        var a = t.width,
            s = t.height,
            u = t.layout,
            l = t.children,
            c = Object.keys(n),
            f = {
                left: r.left,
                leftMirror: r.left,
                right: a - r.right,
                rightMirror: a - r.right,
                top: r.top,
                topMirror: r.top,
                bottom: s - r.bottom,
                bottomMirror: s - r.bottom
            },
            d = !!Dn(l, kh);
        return c.reduce(function(h, m) {
            var p = n[m],
                y = p.orientation,
                g = p.domain,
                b = p.padding,
                v = b === void 0 ? {} : b,
                A = p.mirror,
                w = p.reversed,
                x = "".concat(y).concat(A ? "Mirror" : ""),
                T, _, O, k, I;
            if (p.type === "number" && (p.padding === "gap" || p.padding === "no-gap")) {
                var M = g[1] - g[0],
                    B = 1 / 0,
                    L = p.categoricalDomain.sort();
                if (L.forEach(function(X, ve) {
                        ve > 0 && (B = Math.min((X || 0) - (L[ve - 1] || 0), B))
                    }), Number.isFinite(B)) {
                    var P = B / M,
                        C = p.layout === "vertical" ? r.height : r.width;
                    if (p.padding === "gap" && (T = P * C / 2), p.padding === "no-gap") {
                        var j = ks(t.barCategoryGap, P * C),
                            N = P * C / 2;
                        T = N - j - (N - j) / C * j
                    }
                }
            }
            i === "xAxis" ? _ = [r.left + (v.left || 0) + (T || 0), r.left + r.width - (v.right || 0) - (T || 0)] : i === "yAxis" ? _ = u === "horizontal" ? [r.top + r.height - (v.bottom || 0), r.top + (v.top || 0)] : [r.top + (v.top || 0) + (T || 0), r.top + r.height - (v.bottom || 0) - (T || 0)] : _ = p.range, w && (_ = [_[1], _[0]]);
            var D = F1e(p, o, d),
                $ = D.scale,
                V = D.realScaleType;
            $.domain(g).range(_), U1e($);
            var H = Q1e($, Pr(Pr({}, p), {}, {
                realScaleType: V
            }));
            i === "xAxis" ? (I = y === "top" && !A || y === "bottom" && A, O = r.left, k = f[x] - I * p.height) : i === "yAxis" && (I = y === "left" && !A || y === "right" && A, O = f[x] - I * p.width, k = r.top);
            var Q = Pr(Pr(Pr({}, p), H), {}, {
                realScaleType: V,
                x: O,
                y: k,
                scale: $,
                width: i === "xAxis" ? r.width : p.width,
                height: i === "yAxis" ? r.height : p.height
            });
            return Q.bandSize = sy(Q, H), !p.hide && i === "xAxis" ? f[x] += (I ? -1 : 1) * Q.height : p.hide || (f[x] += (I ? -1 : 1) * Q.width), Pr(Pr({}, h), {}, l0({}, m, Q))
        }, {})
    },
    E6 = function(t, n) {
        var r = t.x,
            i = t.y,
            o = n.x,
            a = n.y;
        return {
            x: Math.min(r, o),
            y: Math.min(i, a),
            width: Math.abs(o - r),
            height: Math.abs(a - i)
        }
    },
    wPe = function(t) {
        var n = t.x1,
            r = t.y1,
            i = t.x2,
            o = t.y2;
        return E6({
            x: n,
            y: r
        }, {
            x: i,
            y: o
        })
    },
    S6 = function() {
        function e(t) {
            gPe(this, e), this.scale = t
        }
        return yPe(e, [{
            key: "domain",
            get: function() {
                return this.scale.domain
            }
        }, {
            key: "range",
            get: function() {
                return this.scale.range
            }
        }, {
            key: "rangeMin",
            get: function() {
                return this.range()[0]
            }
        }, {
            key: "rangeMax",
            get: function() {
                return this.range()[1]
            }
        }, {
            key: "bandwidth",
            get: function() {
                return this.scale.bandwidth
            }
        }, {
            key: "apply",
            value: function(n) {
                var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                    i = r.bandAware,
                    o = r.position;
                if (n !== void 0) {
                    if (o) switch (o) {
                        case "start":
                            return this.scale(n);
                        case "middle":
                            {
                                var a = this.bandwidth ? this.bandwidth() / 2 : 0;
                                return this.scale(n) + a
                            }
                        case "end":
                            {
                                var s = this.bandwidth ? this.bandwidth() : 0;
                                return this.scale(n) + s
                            }
                        default:
                            return this.scale(n)
                    }
                    if (i) {
                        var u = this.bandwidth ? this.bandwidth() / 2 : 0;
                        return this.scale(n) + u
                    }
                    return this.scale(n)
                }
            }
        }, {
            key: "isInRange",
            value: function(n) {
                var r = this.range(),
                    i = r[0],
                    o = r[r.length - 1];
                return i <= o ? n >= i && n <= o : n >= o && n <= i
            }
        }], [{
            key: "create",
            value: function(n) {
                return new e(n)
            }
        }])
    }();
l0(S6, "EPS", 1e-4);
var ST = function(t) {
    var n = Object.keys(t).reduce(function(r, i) {
        return Pr(Pr({}, r), {}, l0({}, i, S6.create(t[i])))
    }, {});
    return Pr(Pr({}, n), {}, {
        apply: function(i) {
            var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                a = o.bandAware,
                s = o.position;
            return $Te(i, function(u, l) {
                return n[l].apply(u, {
                    bandAware: a,
                    position: s
                })
            })
        },
        isInRange: function(i) {
            return XTe(i, function(o, a) {
                return n[a].isInRange(o)
            })
        }
    })
};

function xPe(e) {
    return (e % 180 + 180) % 180
}
var APe = function(t) {
        var n = t.width,
            r = t.height,
            i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
            o = xPe(i),
            a = o * Math.PI / 180,
            s = Math.atan(r / n),
            u = a > s && a < Math.PI - s ? r / Math.sin(a) : n / Math.cos(a);
        return Math.abs(u)
    },
    EPe = _se(function(e) {
        return {
            x: e.left,
            y: e.top,
            width: e.width,
            height: e.height
        }
    }, function(e) {
        return ["l", e.left, "t", e.top, "w", e.width, "h", e.height].join("")
    }),
    _6 = S.createContext(void 0),
    T6 = S.createContext(void 0),
    P6 = S.createContext(void 0),
    SPe = S.createContext({}),
    O6 = S.createContext(void 0),
    k6 = S.createContext(0),
    C6 = S.createContext(0),
    FM = function(t) {
        var n = t.state,
            r = n.xAxisMap,
            i = n.yAxisMap,
            o = n.offset,
            a = t.clipPathId,
            s = t.children,
            u = t.width,
            l = t.height,
            c = EPe(o);
        return R.createElement(_6.Provider, {
            value: r
        }, R.createElement(T6.Provider, {
            value: i
        }, R.createElement(SPe.Provider, {
            value: o
        }, R.createElement(P6.Provider, {
            value: c
        }, R.createElement(O6.Provider, {
            value: a
        }, R.createElement(k6.Provider, {
            value: l
        }, R.createElement(C6.Provider, {
            value: u
        }, s)))))))
    },
    _Pe = function() {
        return S.useContext(O6)
    },
    I6 = function(t) {
        var n = S.useContext(_6);
        n == null && Is();
        var r = n[t];
        return r == null && Is(), r
    },
    M6 = function(t) {
        var n = S.useContext(T6);
        n == null && Is();
        var r = n[t];
        return r == null && Is(), r
    },
    TPe = function() {
        var t = S.useContext(P6);
        return t
    },
    N6 = function() {
        return S.useContext(C6)
    },
    R6 = function() {
        return S.useContext(k6)
    };

function Pl(e) {
    "@babel/helpers - typeof";
    return Pl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Pl(e)
}

function PPe(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function OPe(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, B6(r.key), r)
    }
}

function kPe(e, t, n) {
    return t && OPe(e.prototype, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function CPe(e, t, n) {
    return t = xy(t), IPe(e, j6() ? Reflect.construct(t, n || [], xy(e).constructor) : t.apply(e, n))
}

function IPe(e, t) {
    if (t && (Pl(t) === "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return MPe(e)
}

function MPe(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function j6() {
    try {
        var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (j6 = function() {
        return !!e
    })()
}

function xy(e) {
    return xy = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }, xy(e)
}

function NPe(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(e, "prototype", {
        writable: !1
    }), t && pA(e, t)
}

function pA(e, t) {
    return pA = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i, r
    }, pA(e, t)
}

function UM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function HM(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? UM(Object(n), !0).forEach(function(r) {
            _T(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UM(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function _T(e, t, n) {
    return t = B6(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function B6(e) {
    var t = RPe(e, "string");
    return Pl(t) == "symbol" ? t : t + ""
}

function RPe(e, t) {
    if (Pl(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Pl(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(e)
}

function jPe(e, t) {
    return LPe(e) || $Pe(e, t) || DPe(e, t) || BPe()
}

function BPe() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function DPe(e, t) {
    if (e) {
        if (typeof e == "string") return VM(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return VM(e, t)
    }
}

function VM(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}

function $Pe(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
        var r, i, o, a, s = [],
            u = !0,
            l = !1;
        try {
            if (o = (n = n.call(e)).next, t !== 0)
                for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0);
        } catch (c) {
            l = !0, i = c
        } finally {
            try {
                if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return
            } finally {
                if (l) throw i
            }
        }
        return s
    }
}

function LPe(e) {
    if (Array.isArray(e)) return e
}

function mA() {
    return mA = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, mA.apply(this, arguments)
}
var FPe = function(t, n) {
        var r;
        return R.isValidElement(t) ? r = R.cloneElement(t, n) : Ae(t) ? r = t(n) : r = R.createElement("line", mA({}, n, {
            className: "recharts-reference-line-line"
        })), r
    },
    UPe = function(t, n, r, i, o, a, s, u, l) {
        var c = o.x,
            f = o.y,
            d = o.width,
            h = o.height;
        if (r) {
            var m = l.y,
                p = t.y.apply(m, {
                    position: a
                });
            if (ci(l, "discard") && !t.y.isInRange(p)) return null;
            var y = [{
                x: c + d,
                y: p
            }, {
                x: c,
                y: p
            }];
            return u === "left" ? y.reverse() : y
        }
        if (n) {
            var g = l.x,
                b = t.x.apply(g, {
                    position: a
                });
            if (ci(l, "discard") && !t.x.isInRange(b)) return null;
            var v = [{
                x: b,
                y: f + h
            }, {
                x: b,
                y: f
            }];
            return s === "top" ? v.reverse() : v
        }
        if (i) {
            var A = l.segment,
                w = A.map(function(x) {
                    return t.apply(x, {
                        position: a
                    })
                });
            return ci(l, "discard") && CTe(w, function(x) {
                return !t.isInRange(x)
            }) ? null : w
        }
        return null
    };

function HPe(e) {
    var t = e.x,
        n = e.y,
        r = e.segment,
        i = e.xAxisId,
        o = e.yAxisId,
        a = e.shape,
        s = e.className,
        u = e.alwaysShow,
        l = _Pe(),
        c = I6(i),
        f = M6(o),
        d = TPe();
    if (!l || !d) return null;
    us(u === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
    var h = ST({
            x: c.scale,
            y: f.scale
        }),
        m = Rt(t),
        p = Rt(n),
        y = r && r.length === 2,
        g = UPe(h, m, p, y, d, e.position, c.orientation, f.orientation, e);
    if (!g) return null;
    var b = jPe(g, 2),
        v = b[0],
        A = v.x,
        w = v.y,
        x = b[1],
        T = x.x,
        _ = x.y,
        O = ci(e, "hidden") ? "url(#".concat(l, ")") : void 0,
        k = HM(HM({
            clipPath: O
        }, _e(e, !0)), {}, {
            x1: A,
            y1: w,
            x2: T,
            y2: _
        });
    return R.createElement(lt, {
        className: Me("recharts-reference-line", s)
    }, FPe(a, k), nn.renderCallByParent(e, wPe({
        x1: A,
        y1: w,
        x2: T,
        y2: _
    })))
}
var TT = function(e) {
    function t() {
        return PPe(this, t), CPe(this, t, arguments)
    }
    return NPe(t, e), kPe(t, [{
        key: "render",
        value: function() {
            return R.createElement(HPe, this.props)
        }
    }])
}(R.Component);
_T(TT, "displayName", "ReferenceLine");
_T(TT, "defaultProps", {
    isFront: !1,
    ifOverflow: "discard",
    xAxisId: 0,
    yAxisId: 0,
    fill: "none",
    stroke: "#ccc",
    fillOpacity: 1,
    strokeWidth: 1,
    position: "middle"
});

function gA() {
    return gA = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, gA.apply(this, arguments)
}

function Ol(e) {
    "@babel/helpers - typeof";
    return Ol = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Ol(e)
}

function zM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function WM(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? zM(Object(n), !0).forEach(function(r) {
            c0(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zM(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function VPe(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function zPe(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, $6(r.key), r)
    }
}

function WPe(e, t, n) {
    return t && zPe(e.prototype, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function GPe(e, t, n) {
    return t = Ay(t), qPe(e, D6() ? Reflect.construct(t, n || [], Ay(e).constructor) : t.apply(e, n))
}

function qPe(e, t) {
    if (t && (Ol(t) === "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return KPe(e)
}

function KPe(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function D6() {
    try {
        var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (D6 = function() {
        return !!e
    })()
}

function Ay(e) {
    return Ay = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }, Ay(e)
}

function QPe(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(e, "prototype", {
        writable: !1
    }), t && yA(e, t)
}

function yA(e, t) {
    return yA = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i, r
    }, yA(e, t)
}

function c0(e, t, n) {
    return t = $6(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function $6(e) {
    var t = YPe(e, "string");
    return Ol(t) == "symbol" ? t : t + ""
}

function YPe(e, t) {
    if (Ol(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Ol(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(e)
}
var XPe = function(t) {
        var n = t.x,
            r = t.y,
            i = t.xAxis,
            o = t.yAxis,
            a = ST({
                x: i.scale,
                y: o.scale
            }),
            s = a.apply({
                x: n,
                y: r
            }, {
                bandAware: !0
            });
        return ci(t, "discard") && !a.isInRange(s) ? null : s
    },
    f0 = function(e) {
        function t() {
            return VPe(this, t), GPe(this, t, arguments)
        }
        return QPe(t, e), WPe(t, [{
            key: "render",
            value: function() {
                var r = this.props,
                    i = r.x,
                    o = r.y,
                    a = r.r,
                    s = r.alwaysShow,
                    u = r.clipPathId,
                    l = Rt(i),
                    c = Rt(o);
                if (us(s === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.'), !l || !c) return null;
                var f = XPe(this.props);
                if (!f) return null;
                var d = f.x,
                    h = f.y,
                    m = this.props,
                    p = m.shape,
                    y = m.className,
                    g = ci(this.props, "hidden") ? "url(#".concat(u, ")") : void 0,
                    b = WM(WM({
                        clipPath: g
                    }, _e(this.props, !0)), {}, {
                        cx: d,
                        cy: h
                    });
                return R.createElement(lt, {
                    className: Me("recharts-reference-dot", y)
                }, t.renderDot(p, b), nn.renderCallByParent(this.props, {
                    x: d - a,
                    y: h - a,
                    width: 2 * a,
                    height: 2 * a
                }))
            }
        }])
    }(R.Component);
c0(f0, "displayName", "ReferenceDot");
c0(f0, "defaultProps", {
    isFront: !1,
    ifOverflow: "discard",
    xAxisId: 0,
    yAxisId: 0,
    r: 10,
    fill: "#fff",
    stroke: "#ccc",
    fillOpacity: 1,
    strokeWidth: 1
});
c0(f0, "renderDot", function(e, t) {
    var n;
    return R.isValidElement(e) ? n = R.cloneElement(e, t) : Ae(e) ? n = e(t) : n = R.createElement(ET, gA({}, t, {
        cx: t.cx,
        cy: t.cy,
        className: "recharts-reference-dot-dot"
    })), n
});

function vA() {
    return vA = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, vA.apply(this, arguments)
}

function kl(e) {
    "@babel/helpers - typeof";
    return kl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, kl(e)
}

function GM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function qM(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? GM(Object(n), !0).forEach(function(r) {
            d0(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GM(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function ZPe(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function JPe(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, F6(r.key), r)
    }
}

function e2e(e, t, n) {
    return t && JPe(e.prototype, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function t2e(e, t, n) {
    return t = Ey(t), n2e(e, L6() ? Reflect.construct(t, n || [], Ey(e).constructor) : t.apply(e, n))
}

function n2e(e, t) {
    if (t && (kl(t) === "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return r2e(e)
}

function r2e(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function L6() {
    try {
        var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (L6 = function() {
        return !!e
    })()
}

function Ey(e) {
    return Ey = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }, Ey(e)
}

function i2e(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(e, "prototype", {
        writable: !1
    }), t && bA(e, t)
}

function bA(e, t) {
    return bA = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i, r
    }, bA(e, t)
}

function d0(e, t, n) {
    return t = F6(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function F6(e) {
    var t = o2e(e, "string");
    return kl(t) == "symbol" ? t : t + ""
}

function o2e(e, t) {
    if (kl(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (kl(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(e)
}
var a2e = function(t, n, r, i, o) {
        var a = o.x1,
            s = o.x2,
            u = o.y1,
            l = o.y2,
            c = o.xAxis,
            f = o.yAxis;
        if (!c || !f) return null;
        var d = ST({
                x: c.scale,
                y: f.scale
            }),
            h = {
                x: t ? d.x.apply(a, {
                    position: "start"
                }) : d.x.rangeMin,
                y: r ? d.y.apply(u, {
                    position: "start"
                }) : d.y.rangeMin
            },
            m = {
                x: n ? d.x.apply(s, {
                    position: "end"
                }) : d.x.rangeMax,
                y: i ? d.y.apply(l, {
                    position: "end"
                }) : d.y.rangeMax
            };
        return ci(o, "discard") && (!d.isInRange(h) || !d.isInRange(m)) ? null : E6(h, m)
    },
    h0 = function(e) {
        function t() {
            return ZPe(this, t), t2e(this, t, arguments)
        }
        return i2e(t, e), e2e(t, [{
            key: "render",
            value: function() {
                var r = this.props,
                    i = r.x1,
                    o = r.x2,
                    a = r.y1,
                    s = r.y2,
                    u = r.className,
                    l = r.alwaysShow,
                    c = r.clipPathId;
                us(l === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
                var f = Rt(i),
                    d = Rt(o),
                    h = Rt(a),
                    m = Rt(s),
                    p = this.props.shape;
                if (!f && !d && !h && !m && !p) return null;
                var y = a2e(f, d, h, m, this.props);
                if (!y && !p) return null;
                var g = ci(this.props, "hidden") ? "url(#".concat(c, ")") : void 0;
                return R.createElement(lt, {
                    className: Me("recharts-reference-area", u)
                }, t.renderRect(p, qM(qM({
                    clipPath: g
                }, _e(this.props, !0)), y)), nn.renderCallByParent(this.props, y))
            }
        }])
    }(R.Component);
d0(h0, "displayName", "ReferenceArea");
d0(h0, "defaultProps", {
    isFront: !1,
    ifOverflow: "discard",
    xAxisId: 0,
    yAxisId: 0,
    r: 10,
    fill: "#ccc",
    fillOpacity: .5,
    stroke: "none",
    strokeWidth: 1
});
d0(h0, "renderRect", function(e, t) {
    var n;
    return R.isValidElement(e) ? n = R.cloneElement(e, t) : Ae(e) ? n = e(t) : n = R.createElement(AT, vA({}, t, {
        className: "recharts-reference-area-rect"
    })), n
});

function U6(e, t, n) {
    if (t < 1) return [];
    if (t === 1 && n === void 0) return e;
    for (var r = [], i = 0; i < e.length; i += t) r.push(e[i]);
    return r
}

function s2e(e, t, n) {
    var r = {
        width: e.width + t.width,
        height: e.height + t.height
    };
    return APe(r, n)
}

function u2e(e, t, n) {
    var r = n === "width",
        i = e.x,
        o = e.y,
        a = e.width,
        s = e.height;
    return t === 1 ? {
        start: r ? i : o,
        end: r ? i + a : o + s
    } : {
        start: r ? i + a : o + s,
        end: r ? i : o
    }
}

function Sy(e, t, n, r, i) {
    if (e * t < e * r || e * t > e * i) return !1;
    var o = n();
    return e * (t - e * o / 2 - r) >= 0 && e * (t + e * o / 2 - i) <= 0
}

function l2e(e, t) {
    return U6(e, t + 1)
}

function c2e(e, t, n, r, i) {
    for (var o = (r || []).slice(), a = t.start, s = t.end, u = 0, l = 1, c = a, f = function() {
            var m = r == null ? void 0 : r[u];
            if (m === void 0) return {
                v: U6(r, l)
            };
            var p = u,
                y, g = function() {
                    return y === void 0 && (y = n(m, p)), y
                },
                b = m.coordinate,
                v = u === 0 || Sy(e, b, g, c, s);
            v || (u = 0, c = a, l += 1), v && (c = b + e * (g() / 2 + i), u += l)
        }, d; l <= o.length;)
        if (d = f(), d) return d.v;
    return []
}

function Xd(e) {
    "@babel/helpers - typeof";
    return Xd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Xd(e)
}

function KM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function en(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? KM(Object(n), !0).forEach(function(r) {
            f2e(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KM(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function f2e(e, t, n) {
    return t = d2e(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function d2e(e) {
    var t = h2e(e, "string");
    return Xd(t) == "symbol" ? t : t + ""
}

function h2e(e, t) {
    if (Xd(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Xd(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}

function p2e(e, t, n, r, i) {
    for (var o = (r || []).slice(), a = o.length, s = t.start, u = t.end, l = function(d) {
            var h = o[d],
                m, p = function() {
                    return m === void 0 && (m = n(h, d)), m
                };
            if (d === a - 1) {
                var y = e * (h.coordinate + e * p() / 2 - u);
                o[d] = h = en(en({}, h), {}, {
                    tickCoord: y > 0 ? h.coordinate - y * e : h.coordinate
                })
            } else o[d] = h = en(en({}, h), {}, {
                tickCoord: h.coordinate
            });
            var g = Sy(e, h.tickCoord, p, s, u);
            g && (u = h.tickCoord - e * (p() / 2 + i), o[d] = en(en({}, h), {}, {
                isShow: !0
            }))
        }, c = a - 1; c >= 0; c--) l(c);
    return o
}

function m2e(e, t, n, r, i, o) {
    var a = (r || []).slice(),
        s = a.length,
        u = t.start,
        l = t.end;
    if (o) {
        var c = r[s - 1],
            f = n(c, s - 1),
            d = e * (c.coordinate + e * f / 2 - l);
        a[s - 1] = c = en(en({}, c), {}, {
            tickCoord: d > 0 ? c.coordinate - d * e : c.coordinate
        });
        var h = Sy(e, c.tickCoord, function() {
            return f
        }, u, l);
        h && (l = c.tickCoord - e * (f / 2 + i), a[s - 1] = en(en({}, c), {}, {
            isShow: !0
        }))
    }
    for (var m = o ? s - 1 : s, p = function(b) {
            var v = a[b],
                A, w = function() {
                    return A === void 0 && (A = n(v, b)), A
                };
            if (b === 0) {
                var x = e * (v.coordinate - e * w() / 2 - u);
                a[b] = v = en(en({}, v), {}, {
                    tickCoord: x < 0 ? v.coordinate - x * e : v.coordinate
                })
            } else a[b] = v = en(en({}, v), {}, {
                tickCoord: v.coordinate
            });
            var T = Sy(e, v.tickCoord, w, u, l);
            T && (u = v.tickCoord + e * (w() / 2 + i), a[b] = en(en({}, v), {}, {
                isShow: !0
            }))
        }, y = 0; y < m; y++) p(y);
    return a
}

function g2e(e, t, n) {
    var r = e.tick,
        i = e.ticks,
        o = e.viewBox,
        a = e.minTickGap,
        s = e.orientation,
        u = e.interval,
        l = e.tickFormatter,
        c = e.unit,
        f = e.angle;
    if (!i || !i.length || !r) return [];
    if (Y(u) || oc.isSsr) return l2e(i, typeof u == "number" && Y(u) ? u : 0);
    var d = [],
        h = s === "top" || s === "bottom" ? "width" : "height",
        m = c && h === "width" ? mf(c, {
            fontSize: t,
            letterSpacing: n
        }) : {
            width: 0,
            height: 0
        },
        p = function(v, A) {
            var w = Ae(l) ? l(v.value, A) : v.value;
            return h === "width" ? s2e(mf(w, {
                fontSize: t,
                letterSpacing: n
            }), m, f) : mf(w, {
                fontSize: t,
                letterSpacing: n
            })[h]
        },
        y = i.length >= 2 ? Mr(i[1].coordinate - i[0].coordinate) : 1,
        g = u2e(o, y, h);
    return u === "equidistantPreserveStart" ? c2e(y, g, p, i, a) : (u === "preserveStart" || u === "preserveStartEnd" ? d = m2e(y, g, p, i, a, u === "preserveStartEnd") : d = p2e(y, g, p, i, a), d.filter(function(b) {
        return b.isShow
    }))
}
var y2e = ["viewBox"],
    v2e = ["viewBox"],
    b2e = ["ticks"];

function Cl(e) {
    "@babel/helpers - typeof";
    return Cl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Cl(e)
}

function _u() {
    return _u = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, _u.apply(this, arguments)
}

function QM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function ln(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? QM(Object(n), !0).forEach(function(r) {
            PT(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : QM(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function Jb(e, t) {
    if (e == null) return {};
    var n = w2e(e, t),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        for (i = 0; i < o.length; i++) r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
    }
    return n
}

function w2e(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
            if (t.indexOf(r) >= 0) continue;
            n[r] = e[r]
        }
    return n
}

function x2e(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function YM(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, V6(r.key), r)
    }
}

function A2e(e, t, n) {
    return t && YM(e.prototype, t), n && YM(e, n), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function E2e(e, t, n) {
    return t = _y(t), S2e(e, H6() ? Reflect.construct(t, n || [], _y(e).constructor) : t.apply(e, n))
}

function S2e(e, t) {
    if (t && (Cl(t) === "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return _2e(e)
}

function _2e(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function H6() {
    try {
        var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (H6 = function() {
        return !!e
    })()
}

function _y(e) {
    return _y = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }, _y(e)
}

function T2e(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(e, "prototype", {
        writable: !1
    }), t && wA(e, t)
}

function wA(e, t) {
    return wA = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i, r
    }, wA(e, t)
}

function PT(e, t, n) {
    return t = V6(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function V6(e) {
    var t = P2e(e, "string");
    return Cl(t) == "symbol" ? t : t + ""
}

function P2e(e, t) {
    if (Cl(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Cl(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(e)
}
var p0 = function(e) {
    function t(n) {
        var r;
        return x2e(this, t), r = E2e(this, t, [n]), r.state = {
            fontSize: "",
            letterSpacing: ""
        }, r
    }
    return T2e(t, e), A2e(t, [{
        key: "shouldComponentUpdate",
        value: function(r, i) {
            var o = r.viewBox,
                a = Jb(r, y2e),
                s = this.props,
                u = s.viewBox,
                l = Jb(s, v2e);
            return !$u(o, u) || !$u(a, l) || !$u(i, this.state)
        }
    }, {
        key: "componentDidMount",
        value: function() {
            var r = this.layerReference;
            if (r) {
                var i = r.getElementsByClassName("recharts-cartesian-axis-tick-value")[0];
                i && this.setState({
                    fontSize: window.getComputedStyle(i).fontSize,
                    letterSpacing: window.getComputedStyle(i).letterSpacing
                })
            }
        }
    }, {
        key: "getTickLineCoord",
        value: function(r) {
            var i = this.props,
                o = i.x,
                a = i.y,
                s = i.width,
                u = i.height,
                l = i.orientation,
                c = i.tickSize,
                f = i.mirror,
                d = i.tickMargin,
                h, m, p, y, g, b, v = f ? -1 : 1,
                A = r.tickSize || c,
                w = Y(r.tickCoord) ? r.tickCoord : r.coordinate;
            switch (l) {
                case "top":
                    h = m = r.coordinate, y = a + +!f * u, p = y - v * A, b = p - v * d, g = w;
                    break;
                case "left":
                    p = y = r.coordinate, m = o + +!f * s, h = m - v * A, g = h - v * d, b = w;
                    break;
                case "right":
                    p = y = r.coordinate, m = o + +f * s, h = m + v * A, g = h + v * d, b = w;
                    break;
                default:
                    h = m = r.coordinate, y = a + +f * u, p = y + v * A, b = p + v * d, g = w;
                    break
            }
            return {
                line: {
                    x1: h,
                    y1: p,
                    x2: m,
                    y2: y
                },
                tick: {
                    x: g,
                    y: b
                }
            }
        }
    }, {
        key: "getTickTextAnchor",
        value: function() {
            var r = this.props,
                i = r.orientation,
                o = r.mirror,
                a;
            switch (i) {
                case "left":
                    a = o ? "start" : "end";
                    break;
                case "right":
                    a = o ? "end" : "start";
                    break;
                default:
                    a = "middle";
                    break
            }
            return a
        }
    }, {
        key: "getTickVerticalAnchor",
        value: function() {
            var r = this.props,
                i = r.orientation,
                o = r.mirror,
                a = "end";
            switch (i) {
                case "left":
                case "right":
                    a = "middle";
                    break;
                case "top":
                    a = o ? "start" : "end";
                    break;
                default:
                    a = o ? "end" : "start";
                    break
            }
            return a
        }
    }, {
        key: "renderAxisLine",
        value: function() {
            var r = this.props,
                i = r.x,
                o = r.y,
                a = r.width,
                s = r.height,
                u = r.orientation,
                l = r.mirror,
                c = r.axisLine,
                f = ln(ln(ln({}, _e(this.props, !1)), _e(c, !1)), {}, {
                    fill: "none"
                });
            if (u === "top" || u === "bottom") {
                var d = +(u === "top" && !l || u === "bottom" && l);
                f = ln(ln({}, f), {}, {
                    x1: i,
                    y1: o + d * s,
                    x2: i + a,
                    y2: o + d * s
                })
            } else {
                var h = +(u === "left" && !l || u === "right" && l);
                f = ln(ln({}, f), {}, {
                    x1: i + h * a,
                    y1: o,
                    x2: i + h * a,
                    y2: o + s
                })
            }
            return R.createElement("line", _u({}, f, {
                className: Me("recharts-cartesian-axis-line", dr(c, "className"))
            }))
        }
    }, {
        key: "renderTicks",
        value: function(r, i, o) {
            var a = this,
                s = this.props,
                u = s.tickLine,
                l = s.stroke,
                c = s.tick,
                f = s.tickFormatter,
                d = s.unit,
                h = g2e(ln(ln({}, this.props), {}, {
                    ticks: r
                }), i, o),
                m = this.getTickTextAnchor(),
                p = this.getTickVerticalAnchor(),
                y = _e(this.props, !1),
                g = _e(c, !1),
                b = ln(ln({}, y), {}, {
                    fill: "none"
                }, _e(u, !1)),
                v = h.map(function(A, w) {
                    var x = a.getTickLineCoord(A),
                        T = x.line,
                        _ = x.tick,
                        O = ln(ln(ln(ln({
                            textAnchor: m,
                            verticalAnchor: p
                        }, y), {}, {
                            stroke: "none",
                            fill: l
                        }, g), _), {}, {
                            index: w,
                            payload: A,
                            visibleTicksCount: h.length,
                            tickFormatter: f
                        });
                    return R.createElement(lt, _u({
                        className: "recharts-cartesian-axis-tick",
                        key: "tick-".concat(A.value, "-").concat(A.coordinate, "-").concat(A.tickCoord)
                    }, Ng(a.props, A, w)), u && R.createElement("line", _u({}, b, T, {
                        className: Me("recharts-cartesian-axis-tick-line", dr(u, "className"))
                    })), c && t.renderTickItem(c, O, "".concat(Ae(f) ? f(A.value, w) : A.value).concat(d || "")))
                });
            return R.createElement("g", {
                className: "recharts-cartesian-axis-ticks"
            }, v)
        }
    }, {
        key: "render",
        value: function() {
            var r = this,
                i = this.props,
                o = i.axisLine,
                a = i.width,
                s = i.height,
                u = i.ticksGenerator,
                l = i.className,
                c = i.hide;
            if (c) return null;
            var f = this.props,
                d = f.ticks,
                h = Jb(f, b2e),
                m = d;
            return Ae(u) && (m = d && d.length > 0 ? u(this.props) : u(h)), a <= 0 || s <= 0 || !m || !m.length ? null : R.createElement(lt, {
                className: Me("recharts-cartesian-axis", l),
                ref: function(y) {
                    r.layerReference = y
                }
            }, o && this.renderAxisLine(), this.renderTicks(m, this.state.fontSize, this.state.letterSpacing), nn.renderCallByParent(this.props))
        }
    }], [{
        key: "renderTickItem",
        value: function(r, i, o) {
            var a;
            return R.isValidElement(r) ? a = R.cloneElement(r, i) : Ae(r) ? a = r(i) : a = R.createElement(qg, _u({}, i, {
                className: "recharts-cartesian-axis-tick-value"
            }), o), a
        }
    }])
}(S.Component);
PT(p0, "displayName", "CartesianAxis");
PT(p0, "defaultProps", {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    viewBox: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    },
    orientation: "bottom",
    ticks: [],
    stroke: "#666",
    tickLine: !0,
    axisLine: !0,
    tick: !0,
    mirror: !1,
    minTickGap: 5,
    tickSize: 6,
    tickMargin: 2,
    interval: "preserveEnd"
});
var O2e = ["layout", "type", "stroke", "connectNulls", "isRange", "ref"],
    k2e = ["key"],
    z6;

function Il(e) {
    "@babel/helpers - typeof";
    return Il = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Il(e)
}

function W6(e, t) {
    if (e == null) return {};
    var n = C2e(e, t),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        for (i = 0; i < o.length; i++) r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
    }
    return n
}

function C2e(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
            if (t.indexOf(r) >= 0) continue;
            n[r] = e[r]
        }
    return n
}

function Xa() {
    return Xa = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, Xa.apply(this, arguments)
}

function XM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function Oo(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? XM(Object(n), !0).forEach(function(r) {
            ii(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XM(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function I2e(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function ZM(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, q6(r.key), r)
    }
}

function M2e(e, t, n) {
    return t && ZM(e.prototype, t), n && ZM(e, n), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function N2e(e, t, n) {
    return t = Ty(t), R2e(e, G6() ? Reflect.construct(t, n || [], Ty(e).constructor) : t.apply(e, n))
}

function R2e(e, t) {
    if (t && (Il(t) === "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return j2e(e)
}

function j2e(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function G6() {
    try {
        var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (G6 = function() {
        return !!e
    })()
}

function Ty(e) {
    return Ty = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }, Ty(e)
}

function B2e(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(e, "prototype", {
        writable: !1
    }), t && xA(e, t)
}

function xA(e, t) {
    return xA = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i, r
    }, xA(e, t)
}

function ii(e, t, n) {
    return t = q6(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function q6(e) {
    var t = D2e(e, "string");
    return Il(t) == "symbol" ? t : t + ""
}

function D2e(e, t) {
    if (Il(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Il(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(e)
}
var fi = function(e) {
    function t() {
        var n;
        I2e(this, t);
        for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++) i[o] = arguments[o];
        return n = N2e(this, t, [].concat(i)), ii(n, "state", {
            isAnimationFinished: !0
        }), ii(n, "id", Sh("recharts-area-")), ii(n, "handleAnimationEnd", function() {
            var a = n.props.onAnimationEnd;
            n.setState({
                isAnimationFinished: !0
            }), Ae(a) && a()
        }), ii(n, "handleAnimationStart", function() {
            var a = n.props.onAnimationStart;
            n.setState({
                isAnimationFinished: !1
            }), Ae(a) && a()
        }), n
    }
    return B2e(t, e), M2e(t, [{
        key: "renderDots",
        value: function(r, i, o) {
            var a = this.props.isAnimationActive,
                s = this.state.isAnimationFinished;
            if (a && !s) return null;
            var u = this.props,
                l = u.dot,
                c = u.points,
                f = u.dataKey,
                d = _e(this.props, !1),
                h = _e(l, !0),
                m = c.map(function(y, g) {
                    var b = Oo(Oo(Oo({
                        key: "dot-".concat(g),
                        r: 3
                    }, d), h), {}, {
                        index: g,
                        cx: y.x,
                        cy: y.y,
                        dataKey: f,
                        value: y.value,
                        payload: y.payload,
                        points: c
                    });
                    return t.renderDotItem(l, b)
                }),
                p = {
                    clipPath: r ? "url(#clipPath-".concat(i ? "" : "dots-").concat(o, ")") : null
                };
            return R.createElement(lt, Xa({
                className: "recharts-area-dots"
            }, p), m)
        }
    }, {
        key: "renderHorizontalRect",
        value: function(r) {
            var i = this.props,
                o = i.baseLine,
                a = i.points,
                s = i.strokeWidth,
                u = a[0].x,
                l = a[a.length - 1].x,
                c = r * Math.abs(u - l),
                f = Fo(a.map(function(d) {
                    return d.y || 0
                }));
            return Y(o) && typeof o == "number" ? f = Math.max(o, f) : o && Array.isArray(o) && o.length && (f = Math.max(Fo(o.map(function(d) {
                return d.y || 0
            })), f)), Y(f) ? R.createElement("rect", {
                x: u < l ? u : u - c,
                y: 0,
                width: c,
                height: Math.floor(f + (s ? parseInt("".concat(s), 10) : 1))
            }) : null
        }
    }, {
        key: "renderVerticalRect",
        value: function(r) {
            var i = this.props,
                o = i.baseLine,
                a = i.points,
                s = i.strokeWidth,
                u = a[0].y,
                l = a[a.length - 1].y,
                c = r * Math.abs(u - l),
                f = Fo(a.map(function(d) {
                    return d.x || 0
                }));
            return Y(o) && typeof o == "number" ? f = Math.max(o, f) : o && Array.isArray(o) && o.length && (f = Math.max(Fo(o.map(function(d) {
                return d.x || 0
            })), f)), Y(f) ? R.createElement("rect", {
                x: 0,
                y: u < l ? u : u - c,
                width: f + (s ? parseInt("".concat(s), 10) : 1),
                height: Math.floor(c)
            }) : null
        }
    }, {
        key: "renderClipRect",
        value: function(r) {
            var i = this.props.layout;
            return i === "vertical" ? this.renderVerticalRect(r) : this.renderHorizontalRect(r)
        }
    }, {
        key: "renderAreaStatically",
        value: function(r, i, o, a) {
            var s = this.props,
                u = s.layout,
                l = s.type,
                c = s.stroke,
                f = s.connectNulls,
                d = s.isRange;
            s.ref;
            var h = W6(s, O2e);
            return R.createElement(lt, {
                clipPath: o ? "url(#clipPath-".concat(a, ")") : null
            }, R.createElement(vf, Xa({}, _e(h, !0), {
                points: r,
                connectNulls: f,
                type: l,
                baseLine: i,
                layout: u,
                stroke: "none",
                className: "recharts-area-area"
            })), c !== "none" && R.createElement(vf, Xa({}, _e(this.props, !1), {
                className: "recharts-area-curve",
                layout: u,
                type: l,
                connectNulls: f,
                fill: "none",
                points: r
            })), c !== "none" && d && R.createElement(vf, Xa({}, _e(this.props, !1), {
                className: "recharts-area-curve",
                layout: u,
                type: l,
                connectNulls: f,
                fill: "none",
                points: i
            })))
        }
    }, {
        key: "renderAreaWithAnimation",
        value: function(r, i) {
            var o = this,
                a = this.props,
                s = a.points,
                u = a.baseLine,
                l = a.isAnimationActive,
                c = a.animationBegin,
                f = a.animationDuration,
                d = a.animationEasing,
                h = a.animationId,
                m = this.state,
                p = m.prevPoints,
                y = m.prevBaseLine;
            return R.createElement(so, {
                begin: c,
                duration: f,
                isActive: l,
                easing: d,
                from: {
                    t: 0
                },
                to: {
                    t: 1
                },
                key: "area-".concat(h),
                onAnimationEnd: this.handleAnimationEnd,
                onAnimationStart: this.handleAnimationStart
            }, function(g) {
                var b = g.t;
                if (p) {
                    var v = p.length / s.length,
                        A = s.map(function(_, O) {
                            var k = Math.floor(O * v);
                            if (p[k]) {
                                var I = p[k],
                                    M = ar(I.x, _.x),
                                    B = ar(I.y, _.y);
                                return Oo(Oo({}, _), {}, {
                                    x: M(b),
                                    y: B(b)
                                })
                            }
                            return _
                        }),
                        w;
                    if (Y(u) && typeof u == "number") {
                        var x = ar(y, u);
                        w = x(b)
                    } else if (Pe(u) || ec(u)) {
                        var T = ar(y, 0);
                        w = T(b)
                    } else w = u.map(function(_, O) {
                        var k = Math.floor(O * v);
                        if (y[k]) {
                            var I = y[k],
                                M = ar(I.x, _.x),
                                B = ar(I.y, _.y);
                            return Oo(Oo({}, _), {}, {
                                x: M(b),
                                y: B(b)
                            })
                        }
                        return _
                    });
                    return o.renderAreaStatically(A, w, r, i)
                }
                return R.createElement(lt, null, R.createElement("defs", null, R.createElement("clipPath", {
                    id: "animationClipPath-".concat(i)
                }, o.renderClipRect(b))), R.createElement(lt, {
                    clipPath: "url(#animationClipPath-".concat(i, ")")
                }, o.renderAreaStatically(s, u, r, i)))
            })
        }
    }, {
        key: "renderArea",
        value: function(r, i) {
            var o = this.props,
                a = o.points,
                s = o.baseLine,
                u = o.isAnimationActive,
                l = this.state,
                c = l.prevPoints,
                f = l.prevBaseLine,
                d = l.totalLength;
            return u && a && a.length && (!c && d > 0 || !Cd(c, a) || !Cd(f, s)) ? this.renderAreaWithAnimation(r, i) : this.renderAreaStatically(a, s, r, i)
        }
    }, {
        key: "render",
        value: function() {
            var r, i = this.props,
                o = i.hide,
                a = i.dot,
                s = i.points,
                u = i.className,
                l = i.top,
                c = i.left,
                f = i.xAxis,
                d = i.yAxis,
                h = i.width,
                m = i.height,
                p = i.isAnimationActive,
                y = i.id;
            if (o || !s || !s.length) return null;
            var g = this.state.isAnimationFinished,
                b = s.length === 1,
                v = Me("recharts-area", u),
                A = f && f.allowDataOverflow,
                w = d && d.allowDataOverflow,
                x = A || w,
                T = Pe(y) ? this.id : y,
                _ = (r = _e(a, !1)) !== null && r !== void 0 ? r : {
                    r: 3,
                    strokeWidth: 2
                },
                O = _.r,
                k = O === void 0 ? 3 : O,
                I = _.strokeWidth,
                M = I === void 0 ? 2 : I,
                B = kue(a) ? a : {},
                L = B.clipDot,
                P = L === void 0 ? !0 : L,
                C = k * 2 + M;
            return R.createElement(lt, {
                className: v
            }, A || w ? R.createElement("defs", null, R.createElement("clipPath", {
                id: "clipPath-".concat(T)
            }, R.createElement("rect", {
                x: A ? c : c - h / 2,
                y: w ? l : l - m / 2,
                width: A ? h : h * 2,
                height: w ? m : m * 2
            })), !P && R.createElement("clipPath", {
                id: "clipPath-dots-".concat(T)
            }, R.createElement("rect", {
                x: c - C / 2,
                y: l - C / 2,
                width: h + C,
                height: m + C
            }))) : null, b ? null : this.renderArea(x, T), (a || b) && this.renderDots(x, P, T), (!p || g) && Jo.renderCallByParent(this.props, s))
        }
    }], [{
        key: "getDerivedStateFromProps",
        value: function(r, i) {
            return r.animationId !== i.prevAnimationId ? {
                prevAnimationId: r.animationId,
                curPoints: r.points,
                curBaseLine: r.baseLine,
                prevPoints: i.curPoints,
                prevBaseLine: i.curBaseLine
            } : r.points !== i.curPoints || r.baseLine !== i.curBaseLine ? {
                curPoints: r.points,
                curBaseLine: r.baseLine
            } : null
        }
    }])
}(S.PureComponent);
z6 = fi;
ii(fi, "displayName", "Area");
ii(fi, "defaultProps", {
    stroke: "#3182bd",
    fill: "#3182bd",
    fillOpacity: .6,
    xAxisId: 0,
    yAxisId: 0,
    legendType: "line",
    connectNulls: !1,
    points: [],
    dot: !1,
    activeDot: !0,
    hide: !1,
    isAnimationActive: !oc.isSsr,
    animationBegin: 0,
    animationDuration: 1500,
    animationEasing: "ease"
});
ii(fi, "getBaseValue", function(e, t, n, r) {
    var i = e.layout,
        o = e.baseValue,
        a = t.props.baseValue,
        s = a ? ? o;
    if (Y(s) && typeof s == "number") return s;
    var u = i === "horizontal" ? r : n,
        l = u.scale.domain();
    if (u.type === "number") {
        var c = Math.max(l[0], l[1]),
            f = Math.min(l[0], l[1]);
        return s === "dataMin" ? f : s === "dataMax" || c < 0 ? c : Math.max(Math.min(l[0], l[1]), 0)
    }
    return s === "dataMin" ? l[0] : s === "dataMax" ? l[1] : l[0]
});
ii(fi, "getComposedData", function(e) {
    var t = e.props,
        n = e.item,
        r = e.xAxis,
        i = e.yAxis,
        o = e.xAxisTicks,
        a = e.yAxisTicks,
        s = e.bandSize,
        u = e.dataKey,
        l = e.stackedData,
        c = e.dataStartIndex,
        f = e.displayedData,
        d = e.offset,
        h = t.layout,
        m = l && l.length,
        p = z6.getBaseValue(t, n, r, i),
        y = h === "horizontal",
        g = !1,
        b = f.map(function(A, w) {
            var x;
            m ? x = l[c + w] : (x = Gn(A, u), Array.isArray(x) ? g = !0 : x = [p, x]);
            var T = x[1] == null || m && Gn(A, u) == null;
            return y ? {
                x: BI({
                    axis: r,
                    ticks: o,
                    bandSize: s,
                    entry: A,
                    index: w
                }),
                y: T ? null : i.scale(x[1]),
                value: x,
                payload: A
            } : {
                x: T ? null : r.scale(x[1]),
                y: BI({
                    axis: i,
                    ticks: a,
                    bandSize: s,
                    entry: A,
                    index: w
                }),
                value: x,
                payload: A
            }
        }),
        v;
    return m || g ? v = b.map(function(A) {
        var w = Array.isArray(A.value) ? A.value[0] : null;
        return y ? {
            x: A.x,
            y: w != null && A.y != null ? i.scale(w) : null
        } : {
            x: w != null ? r.scale(w) : null,
            y: A.y
        }
    }) : v = y ? i.scale(p) : r.scale(p), Oo({
        points: b,
        baseLine: v,
        layout: h,
        isRange: g
    }, d)
});
ii(fi, "renderDotItem", function(e, t) {
    var n;
    if (R.isValidElement(e)) n = R.cloneElement(e, t);
    else if (Ae(e)) n = e(t);
    else {
        var r = Me("recharts-area-dot", typeof e != "boolean" ? e.className : ""),
            i = t.key,
            o = W6(t, k2e);
        n = R.createElement(ET, Xa({}, o, {
            key: i,
            className: r
        }))
    }
    return n
});

function Ml(e) {
    "@babel/helpers - typeof";
    return Ml = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Ml(e)
}

function $2e(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function L2e(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, Y6(r.key), r)
    }
}

function F2e(e, t, n) {
    return t && L2e(e.prototype, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function U2e(e, t, n) {
    return t = Py(t), H2e(e, K6() ? Reflect.construct(t, n || [], Py(e).constructor) : t.apply(e, n))
}

function H2e(e, t) {
    if (t && (Ml(t) === "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return V2e(e)
}

function V2e(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function K6() {
    try {
        var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (K6 = function() {
        return !!e
    })()
}

function Py(e) {
    return Py = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }, Py(e)
}

function z2e(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(e, "prototype", {
        writable: !1
    }), t && AA(e, t)
}

function AA(e, t) {
    return AA = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i, r
    }, AA(e, t)
}

function Q6(e, t, n) {
    return t = Y6(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function Y6(e) {
    var t = W2e(e, "string");
    return Ml(t) == "symbol" ? t : t + ""
}

function W2e(e, t) {
    if (Ml(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Ml(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(e)
}

function EA() {
    return EA = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, EA.apply(this, arguments)
}

function G2e(e) {
    var t = e.xAxisId,
        n = N6(),
        r = R6(),
        i = I6(t);
    return i == null ? null : R.createElement(p0, EA({}, i, {
        className: Me("recharts-".concat(i.axisType, " ").concat(i.axisType), i.className),
        viewBox: {
            x: 0,
            y: 0,
            width: n,
            height: r
        },
        ticksGenerator: function(a) {
            return Ya(a, !0)
        }
    }))
}
var m0 = function(e) {
    function t() {
        return $2e(this, t), U2e(this, t, arguments)
    }
    return z2e(t, e), F2e(t, [{
        key: "render",
        value: function() {
            return R.createElement(G2e, this.props)
        }
    }])
}(R.Component);
Q6(m0, "displayName", "XAxis");
Q6(m0, "defaultProps", {
    allowDecimals: !0,
    hide: !1,
    orientation: "bottom",
    width: 0,
    height: 30,
    mirror: !1,
    xAxisId: 0,
    tickCount: 5,
    type: "category",
    padding: {
        left: 0,
        right: 0
    },
    allowDataOverflow: !1,
    scale: "auto",
    reversed: !1,
    allowDuplicatedCategory: !0
});

function Nl(e) {
    "@babel/helpers - typeof";
    return Nl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Nl(e)
}

function q2e(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function K2e(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, J6(r.key), r)
    }
}

function Q2e(e, t, n) {
    return t && K2e(e.prototype, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function Y2e(e, t, n) {
    return t = Oy(t), X2e(e, X6() ? Reflect.construct(t, n || [], Oy(e).constructor) : t.apply(e, n))
}

function X2e(e, t) {
    if (t && (Nl(t) === "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return Z2e(e)
}

function Z2e(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function X6() {
    try {
        var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (X6 = function() {
        return !!e
    })()
}

function Oy(e) {
    return Oy = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }, Oy(e)
}

function J2e(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(e, "prototype", {
        writable: !1
    }), t && SA(e, t)
}

function SA(e, t) {
    return SA = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i, r
    }, SA(e, t)
}

function Z6(e, t, n) {
    return t = J6(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function J6(e) {
    var t = eOe(e, "string");
    return Nl(t) == "symbol" ? t : t + ""
}

function eOe(e, t) {
    if (Nl(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Nl(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(e)
}

function _A() {
    return _A = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, _A.apply(this, arguments)
}
var tOe = function(t) {
        var n = t.yAxisId,
            r = N6(),
            i = R6(),
            o = M6(n);
        return o == null ? null : R.createElement(p0, _A({}, o, {
            className: Me("recharts-".concat(o.axisType, " ").concat(o.axisType), o.className),
            viewBox: {
                x: 0,
                y: 0,
                width: r,
                height: i
            },
            ticksGenerator: function(s) {
                return Ya(s, !0)
            }
        }))
    },
    g0 = function(e) {
        function t() {
            return q2e(this, t), Y2e(this, t, arguments)
        }
        return J2e(t, e), Q2e(t, [{
            key: "render",
            value: function() {
                return R.createElement(tOe, this.props)
            }
        }])
    }(R.Component);
Z6(g0, "displayName", "YAxis");
Z6(g0, "defaultProps", {
    allowDuplicatedCategory: !0,
    allowDecimals: !0,
    hide: !1,
    orientation: "left",
    width: 60,
    height: 0,
    mirror: !1,
    yAxisId: 0,
    tickCount: 5,
    type: "number",
    padding: {
        top: 0,
        bottom: 0
    },
    allowDataOverflow: !1,
    scale: "auto",
    reversed: !1
});

function JM(e) {
    return oOe(e) || iOe(e) || rOe(e) || nOe()
}

function nOe() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function rOe(e, t) {
    if (e) {
        if (typeof e == "string") return TA(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TA(e, t)
    }
}

function iOe(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e)
}

function oOe(e) {
    if (Array.isArray(e)) return TA(e)
}

function TA(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}
var PA = function(t, n, r, i, o) {
        var a = Dr(t, TT),
            s = Dr(t, f0),
            u = [].concat(JM(a), JM(s)),
            l = Dr(t, h0),
            c = "".concat(i, "Id"),
            f = i[0],
            d = n;
        if (u.length && (d = u.reduce(function(p, y) {
                if (y.props[c] === r && ci(y.props, "extendDomain") && Y(y.props[f])) {
                    var g = y.props[f];
                    return [Math.min(p[0], g), Math.max(p[1], g)]
                }
                return p
            }, d)), l.length) {
            var h = "".concat(f, "1"),
                m = "".concat(f, "2");
            d = l.reduce(function(p, y) {
                if (y.props[c] === r && ci(y.props, "extendDomain") && Y(y.props[h]) && Y(y.props[m])) {
                    var g = y.props[h],
                        b = y.props[m];
                    return [Math.min(p[0], g, b), Math.max(p[1], g, b)]
                }
                return p
            }, d)
        }
        return o && o.length && (d = o.reduce(function(p, y) {
            return Y(y) ? [Math.min(p[0], y), Math.max(p[1], y)] : p
        }, d)), d
    },
    e8 = {
        exports: {}
    };
(function(e) {
    var t = Object.prototype.hasOwnProperty,
        n = "~";

    function r() {}
    Object.create && (r.prototype = Object.create(null), new r().__proto__ || (n = !1));

    function i(u, l, c) {
        this.fn = u, this.context = l, this.once = c || !1
    }

    function o(u, l, c, f, d) {
        if (typeof c != "function") throw new TypeError("The listener must be a function");
        var h = new i(c, f || u, d),
            m = n ? n + l : l;
        return u._events[m] ? u._events[m].fn ? u._events[m] = [u._events[m], h] : u._events[m].push(h) : (u._events[m] = h, u._eventsCount++), u
    }

    function a(u, l) {
        --u._eventsCount === 0 ? u._events = new r : delete u._events[l]
    }

    function s() {
        this._events = new r, this._eventsCount = 0
    }
    s.prototype.eventNames = function() {
        var l = [],
            c, f;
        if (this._eventsCount === 0) return l;
        for (f in c = this._events) t.call(c, f) && l.push(n ? f.slice(1) : f);
        return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(c)) : l
    }, s.prototype.listeners = function(l) {
        var c = n ? n + l : l,
            f = this._events[c];
        if (!f) return [];
        if (f.fn) return [f.fn];
        for (var d = 0, h = f.length, m = new Array(h); d < h; d++) m[d] = f[d].fn;
        return m
    }, s.prototype.listenerCount = function(l) {
        var c = n ? n + l : l,
            f = this._events[c];
        return f ? f.fn ? 1 : f.length : 0
    }, s.prototype.emit = function(l, c, f, d, h, m) {
        var p = n ? n + l : l;
        if (!this._events[p]) return !1;
        var y = this._events[p],
            g = arguments.length,
            b, v;
        if (y.fn) {
            switch (y.once && this.removeListener(l, y.fn, void 0, !0), g) {
                case 1:
                    return y.fn.call(y.context), !0;
                case 2:
                    return y.fn.call(y.context, c), !0;
                case 3:
                    return y.fn.call(y.context, c, f), !0;
                case 4:
                    return y.fn.call(y.context, c, f, d), !0;
                case 5:
                    return y.fn.call(y.context, c, f, d, h), !0;
                case 6:
                    return y.fn.call(y.context, c, f, d, h, m), !0
            }
            for (v = 1, b = new Array(g - 1); v < g; v++) b[v - 1] = arguments[v];
            y.fn.apply(y.context, b)
        } else {
            var A = y.length,
                w;
            for (v = 0; v < A; v++) switch (y[v].once && this.removeListener(l, y[v].fn, void 0, !0), g) {
                case 1:
                    y[v].fn.call(y[v].context);
                    break;
                case 2:
                    y[v].fn.call(y[v].context, c);
                    break;
                case 3:
                    y[v].fn.call(y[v].context, c, f);
                    break;
                case 4:
                    y[v].fn.call(y[v].context, c, f, d);
                    break;
                default:
                    if (!b)
                        for (w = 1, b = new Array(g - 1); w < g; w++) b[w - 1] = arguments[w];
                    y[v].fn.apply(y[v].context, b)
            }
        }
        return !0
    }, s.prototype.on = function(l, c, f) {
        return o(this, l, c, f, !1)
    }, s.prototype.once = function(l, c, f) {
        return o(this, l, c, f, !0)
    }, s.prototype.removeListener = function(l, c, f, d) {
        var h = n ? n + l : l;
        if (!this._events[h]) return this;
        if (!c) return a(this, h), this;
        var m = this._events[h];
        if (m.fn) m.fn === c && (!d || m.once) && (!f || m.context === f) && a(this, h);
        else {
            for (var p = 0, y = [], g = m.length; p < g; p++)(m[p].fn !== c || d && !m[p].once || f && m[p].context !== f) && y.push(m[p]);
            y.length ? this._events[h] = y.length === 1 ? y[0] : y : a(this, h)
        }
        return this
    }, s.prototype.removeAllListeners = function(l) {
        var c;
        return l ? (c = n ? n + l : l, this._events[c] && a(this, c)) : (this._events = new r, this._eventsCount = 0), this
    }, s.prototype.off = s.prototype.removeListener, s.prototype.addListener = s.prototype.on, s.prefixed = n, s.EventEmitter = s, e.exports = s
})(e8);
var aOe = e8.exports;
const sOe = Fe(aOe);
var ew = new sOe,
    tw = "recharts.syncMouseEvents";

function Zd(e) {
    "@babel/helpers - typeof";
    return Zd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Zd(e)
}

function uOe(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function lOe(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, t8(r.key), r)
    }
}

function cOe(e, t, n) {
    return t && lOe(e.prototype, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function nw(e, t, n) {
    return t = t8(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function t8(e) {
    var t = fOe(e, "string");
    return Zd(t) == "symbol" ? t : t + ""
}

function fOe(e, t) {
    if (Zd(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Zd(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(e)
}
var dOe = function() {
    function e() {
        uOe(this, e), nw(this, "activeIndex", 0), nw(this, "coordinateList", []), nw(this, "layout", "horizontal")
    }
    return cOe(e, [{
        key: "setDetails",
        value: function(n) {
            var r, i = n.coordinateList,
                o = i === void 0 ? null : i,
                a = n.container,
                s = a === void 0 ? null : a,
                u = n.layout,
                l = u === void 0 ? null : u,
                c = n.offset,
                f = c === void 0 ? null : c,
                d = n.mouseHandlerCallback,
                h = d === void 0 ? null : d;
            this.coordinateList = (r = o ? ? this.coordinateList) !== null && r !== void 0 ? r : [], this.container = s ? ? this.container, this.layout = l ? ? this.layout, this.offset = f ? ? this.offset, this.mouseHandlerCallback = h ? ? this.mouseHandlerCallback, this.activeIndex = Math.min(Math.max(this.activeIndex, 0), this.coordinateList.length - 1)
        }
    }, {
        key: "focus",
        value: function() {
            this.spoofMouse()
        }
    }, {
        key: "keyboardEvent",
        value: function(n) {
            if (this.coordinateList.length !== 0) switch (n.key) {
                case "ArrowRight":
                    {
                        if (this.layout !== "horizontal") return;this.activeIndex = Math.min(this.activeIndex + 1, this.coordinateList.length - 1),
                        this.spoofMouse();
                        break
                    }
                case "ArrowLeft":
                    {
                        if (this.layout !== "horizontal") return;this.activeIndex = Math.max(this.activeIndex - 1, 0),
                        this.spoofMouse();
                        break
                    }
            }
        }
    }, {
        key: "setIndex",
        value: function(n) {
            this.activeIndex = n
        }
    }, {
        key: "spoofMouse",
        value: function() {
            var n, r;
            if (this.layout === "horizontal" && this.coordinateList.length !== 0) {
                var i = this.container.getBoundingClientRect(),
                    o = i.x,
                    a = i.y,
                    s = i.height,
                    u = this.coordinateList[this.activeIndex].coordinate,
                    l = ((n = window) === null || n === void 0 ? void 0 : n.scrollX) || 0,
                    c = ((r = window) === null || r === void 0 ? void 0 : r.scrollY) || 0,
                    f = o + u + l,
                    d = a + this.offset.top + s / 2 + c;
                this.mouseHandlerCallback({
                    pageX: f,
                    pageY: d
                })
            }
        }
    }])
}();

function hOe(e, t, n) {
    if (n === "number" && t === !0 && Array.isArray(e)) {
        var r = e == null ? void 0 : e[0],
            i = e == null ? void 0 : e[1];
        if (r && i && Y(r) && Y(i)) return !0
    }
    return !1
}

function pOe(e, t, n, r) {
    var i = r / 2;
    return {
        stroke: "none",
        fill: "#ccc",
        x: e === "horizontal" ? t.x - i : n.left + .5,
        y: e === "horizontal" ? n.top + .5 : t.y - i,
        width: e === "horizontal" ? r : n.width - 1,
        height: e === "horizontal" ? n.height - 1 : r
    }
}

function n8(e) {
    var t = e.cx,
        n = e.cy,
        r = e.radius,
        i = e.startAngle,
        o = e.endAngle,
        a = Gt(t, n, r, i),
        s = Gt(t, n, r, o);
    return {
        points: [a, s],
        cx: t,
        cy: n,
        radius: r,
        startAngle: i,
        endAngle: o
    }
}

function mOe(e, t, n) {
    var r, i, o, a;
    if (e === "horizontal") r = t.x, o = r, i = n.top, a = n.top + n.height;
    else if (e === "vertical") i = t.y, a = i, r = n.left, o = n.left + n.width;
    else if (t.cx != null && t.cy != null)
        if (e === "centric") {
            var s = t.cx,
                u = t.cy,
                l = t.innerRadius,
                c = t.outerRadius,
                f = t.angle,
                d = Gt(s, u, l, f),
                h = Gt(s, u, c, f);
            r = d.x, i = d.y, o = h.x, a = h.y
        } else return n8(t);
    return [{
        x: r,
        y: i
    }, {
        x: o,
        y: a
    }]
}

function Jd(e) {
    "@babel/helpers - typeof";
    return Jd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Jd(e)
}

function eN(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function vp(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? eN(Object(n), !0).forEach(function(r) {
            gOe(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eN(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function gOe(e, t, n) {
    return t = yOe(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function yOe(e) {
    var t = vOe(e, "string");
    return Jd(t) == "symbol" ? t : t + ""
}

function vOe(e, t) {
    if (Jd(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Jd(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}

function bOe(e) {
    var t, n, r = e.element,
        i = e.tooltipEventType,
        o = e.isActive,
        a = e.activeCoordinate,
        s = e.activePayload,
        u = e.offset,
        l = e.activeTooltipIndex,
        c = e.tooltipAxisBandSize,
        f = e.layout,
        d = e.chartName,
        h = (t = r.props.cursor) !== null && t !== void 0 ? t : (n = r.type.defaultProps) === null || n === void 0 ? void 0 : n.cursor;
    if (!r || !h || !o || !a || d !== "ScatterChart" && i !== "axis") return null;
    var m, p = vf;
    if (d === "ScatterChart") m = a, p = ZSe;
    else if (d === "BarChart") m = pOe(f, a, u, c), p = AT;
    else if (f === "radial") {
        var y = n8(a),
            g = y.cx,
            b = y.cy,
            v = y.radius,
            A = y.startAngle,
            w = y.endAngle;
        m = {
            cx: g,
            cy: b,
            startAngle: A,
            endAngle: w,
            innerRadius: v,
            outerRadius: v
        }, p = i6
    } else m = {
        points: mOe(f, a, u)
    }, p = vf;
    var x = vp(vp(vp(vp({
        stroke: "#ccc",
        pointerEvents: "none"
    }, u), m), _e(h, !1)), {}, {
        payload: s,
        payloadIndex: l,
        className: Me("recharts-tooltip-cursor", h.className)
    });
    return S.isValidElement(h) ? S.cloneElement(h, x) : S.createElement(p, x)
}
var wOe = ["item"],
    xOe = ["children", "className", "width", "height", "style", "compact", "title", "desc"];

function Rl(e) {
    "@babel/helpers - typeof";
    return Rl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Rl(e)
}

function Tu() {
    return Tu = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, Tu.apply(this, arguments)
}

function tN(e, t) {
    return SOe(e) || EOe(e, t) || i8(e, t) || AOe()
}

function AOe() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function EOe(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
        var r, i, o, a, s = [],
            u = !0,
            l = !1;
        try {
            if (o = (n = n.call(e)).next, t !== 0)
                for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); u = !0);
        } catch (c) {
            l = !0, i = c
        } finally {
            try {
                if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return
            } finally {
                if (l) throw i
            }
        }
        return s
    }
}

function SOe(e) {
    if (Array.isArray(e)) return e
}

function nN(e, t) {
    if (e == null) return {};
    var n = _Oe(e, t),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        for (i = 0; i < o.length; i++) r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
    }
    return n
}

function _Oe(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
            if (t.indexOf(r) >= 0) continue;
            n[r] = e[r]
        }
    return n
}

function TOe(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function POe(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, o8(r.key), r)
    }
}

function OOe(e, t, n) {
    return t && POe(e.prototype, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function kOe(e, t, n) {
    return t = ky(t), COe(e, r8() ? Reflect.construct(t, n || [], ky(e).constructor) : t.apply(e, n))
}

function COe(e, t) {
    if (t && (Rl(t) === "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return IOe(e)
}

function IOe(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function r8() {
    try {
        var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (r8 = function() {
        return !!e
    })()
}

function ky(e) {
    return ky = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }, ky(e)
}

function MOe(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(e, "prototype", {
        writable: !1
    }), t && OA(e, t)
}

function OA(e, t) {
    return OA = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i, r
    }, OA(e, t)
}

function jl(e) {
    return jOe(e) || ROe(e) || i8(e) || NOe()
}

function NOe() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function i8(e, t) {
    if (e) {
        if (typeof e == "string") return kA(e, t);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return kA(e, t)
    }
}

function ROe(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e)
}

function jOe(e) {
    if (Array.isArray(e)) return kA(e)
}

function kA(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
    return r
}

function rN(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function U(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t] != null ? arguments[t] : {};
        t % 2 ? rN(Object(n), !0).forEach(function(r) {
            se(e, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rN(Object(n)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return e
}

function se(e, t, n) {
    return t = o8(t), t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}

function o8(e) {
    var t = BOe(e, "string");
    return Rl(t) == "symbol" ? t : t + ""
}

function BOe(e, t) {
    if (Rl(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(e, t);
        if (Rl(r) != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}
var DOe = {
        xAxis: ["bottom", "top"],
        yAxis: ["left", "right"]
    },
    $Oe = {
        width: "100%",
        height: "100%"
    },
    a8 = {
        x: 0,
        y: 0
    };

function bp(e) {
    return e
}
var LOe = function(t, n) {
        return n === "horizontal" ? t.x : n === "vertical" ? t.y : n === "centric" ? t.angle : t.radius
    },
    FOe = function(t, n, r, i) {
        var o = n.find(function(c) {
            return c && c.index === r
        });
        if (o) {
            if (t === "horizontal") return {
                x: o.coordinate,
                y: i.y
            };
            if (t === "vertical") return {
                x: i.x,
                y: o.coordinate
            };
            if (t === "centric") {
                var a = o.coordinate,
                    s = i.radius;
                return U(U(U({}, i), Gt(i.cx, i.cy, s, a)), {}, {
                    angle: a,
                    radius: s
                })
            }
            var u = o.coordinate,
                l = i.angle;
            return U(U(U({}, i), Gt(i.cx, i.cy, u, l)), {}, {
                angle: l,
                radius: u
            })
        }
        return a8
    },
    y0 = function(t, n) {
        var r = n.graphicalItems,
            i = n.dataStartIndex,
            o = n.dataEndIndex,
            a = (r ? ? []).reduce(function(s, u) {
                var l = u.props.data;
                return l && l.length ? [].concat(jl(s), jl(l)) : s
            }, []);
        return a.length > 0 ? a : t && t.length && Y(i) && Y(o) ? t.slice(i, o + 1) : []
    };

function s8(e) {
    return e === "number" ? [0, "auto"] : void 0
}
var CA = function(t, n, r, i) {
        var o = t.graphicalItems,
            a = t.tooltipAxis,
            s = y0(n, t);
        return r < 0 || !o || !o.length || r >= s.length ? null : o.reduce(function(u, l) {
            var c, f = (c = l.props.data) !== null && c !== void 0 ? c : n;
            f && t.dataStartIndex + t.dataEndIndex !== 0 && t.dataEndIndex - t.dataStartIndex >= r && (f = f.slice(t.dataStartIndex, t.dataEndIndex + 1));
            var d;
            if (a.dataKey && !a.allowDuplicatedCategory) {
                var h = f === void 0 ? s : f;
                d = Ig(h, a.dataKey, i)
            } else d = f && f[r] || s[r];
            return d ? [].concat(jl(u), [t6(l, d)]) : u
        }, [])
    },
    iN = function(t, n, r, i) {
        var o = i || {
                x: t.chartX,
                y: t.chartY
            },
            a = LOe(o, r),
            s = t.orderedTooltipTicks,
            u = t.tooltipAxis,
            l = t.tooltipTicks,
            c = R1e(a, s, l, u);
        if (c >= 0 && l) {
            var f = l[c] && l[c].value,
                d = CA(t, n, c, f),
                h = FOe(r, s, c, o);
            return {
                activeTooltipIndex: c,
                activeLabel: f,
                activePayload: d,
                activeCoordinate: h
            }
        }
        return null
    },
    UOe = function(t, n) {
        var r = n.axes,
            i = n.graphicalItems,
            o = n.axisType,
            a = n.axisIdKey,
            s = n.stackGroups,
            u = n.dataStartIndex,
            l = n.dataEndIndex,
            c = t.layout,
            f = t.children,
            d = t.stackOffset,
            h = J4(c, o);
        return r.reduce(function(m, p) {
            var y, g = p.type.defaultProps !== void 0 ? U(U({}, p.type.defaultProps), p.props) : p.props,
                b = g.type,
                v = g.dataKey,
                A = g.allowDataOverflow,
                w = g.allowDuplicatedCategory,
                x = g.scale,
                T = g.ticks,
                _ = g.includeHidden,
                O = g[a];
            if (m[O]) return m;
            var k = y0(t.data, {
                    graphicalItems: i.filter(function(H) {
                        var Q, X = a in H.props ? H.props[a] : (Q = H.type.defaultProps) === null || Q === void 0 ? void 0 : Q[a];
                        return X === O
                    }),
                    dataStartIndex: u,
                    dataEndIndex: l
                }),
                I = k.length,
                M, B, L;
            hOe(g.domain, A, b) && (M = Q1(g.domain, null, A), h && (b === "number" || x !== "auto") && (L = yf(k, v, "category")));
            var P = s8(b);
            if (!M || M.length === 0) {
                var C, j = (C = g.domain) !== null && C !== void 0 ? C : P;
                if (v) {
                    if (M = yf(k, v, b), b === "category" && h) {
                        var N = wue(M);
                        w && N ? (B = M, M = gy(0, I)) : w || (M = FI(j, M, p).reduce(function(H, Q) {
                            return H.indexOf(Q) >= 0 ? H : [].concat(jl(H), [Q])
                        }, []))
                    } else if (b === "category") w ? M = M.filter(function(H) {
                        return H !== "" && !Pe(H)
                    }) : M = FI(j, M, p).reduce(function(H, Q) {
                        return H.indexOf(Q) >= 0 || Q === "" || Pe(Q) ? H : [].concat(jl(H), [Q])
                    }, []);
                    else if (b === "number") {
                        var D = L1e(k, i.filter(function(H) {
                            var Q, X, ve = a in H.props ? H.props[a] : (Q = H.type.defaultProps) === null || Q === void 0 ? void 0 : Q[a],
                                De = "hide" in H.props ? H.props.hide : (X = H.type.defaultProps) === null || X === void 0 ? void 0 : X.hide;
                            return ve === O && (_ || !De)
                        }), v, o, c);
                        D && (M = D)
                    }
                    h && (b === "number" || x !== "auto") && (L = yf(k, v, "category"))
                } else h ? M = gy(0, I) : s && s[O] && s[O].hasStack && b === "number" ? M = d === "expand" ? [0, 1] : e6(s[O].stackGroups, u, l) : M = Z4(k, i.filter(function(H) {
                    var Q = a in H.props ? H.props[a] : H.type.defaultProps[a],
                        X = "hide" in H.props ? H.props.hide : H.type.defaultProps.hide;
                    return Q === O && (_ || !X)
                }), b, c, !0);
                if (b === "number") M = PA(f, M, O, o, T), j && (M = Q1(j, M, A));
                else if (b === "category" && j) {
                    var $ = j,
                        V = M.every(function(H) {
                            return $.indexOf(H) >= 0
                        });
                    V && (M = $)
                }
            }
            return U(U({}, m), {}, se({}, O, U(U({}, g), {}, {
                axisType: o,
                domain: M,
                categoricalDomain: L,
                duplicateDomain: B,
                originalDomain: (y = g.domain) !== null && y !== void 0 ? y : P,
                isCategorical: h,
                layout: c
            })))
        }, {})
    },
    HOe = function(t, n) {
        var r = n.graphicalItems,
            i = n.Axis,
            o = n.axisType,
            a = n.axisIdKey,
            s = n.stackGroups,
            u = n.dataStartIndex,
            l = n.dataEndIndex,
            c = t.layout,
            f = t.children,
            d = y0(t.data, {
                graphicalItems: r,
                dataStartIndex: u,
                dataEndIndex: l
            }),
            h = d.length,
            m = J4(c, o),
            p = -1;
        return r.reduce(function(y, g) {
            var b = g.type.defaultProps !== void 0 ? U(U({}, g.type.defaultProps), g.props) : g.props,
                v = b[a],
                A = s8("number");
            if (!y[v]) {
                p++;
                var w;
                return m ? w = gy(0, h) : s && s[v] && s[v].hasStack ? (w = e6(s[v].stackGroups, u, l), w = PA(f, w, v, o)) : (w = Q1(A, Z4(d, r.filter(function(x) {
                    var T, _, O = a in x.props ? x.props[a] : (T = x.type.defaultProps) === null || T === void 0 ? void 0 : T[a],
                        k = "hide" in x.props ? x.props.hide : (_ = x.type.defaultProps) === null || _ === void 0 ? void 0 : _.hide;
                    return O === v && !k
                }), "number", c), i.defaultProps.allowDataOverflow), w = PA(f, w, v, o)), U(U({}, y), {}, se({}, v, U(U({
                    axisType: o
                }, i.defaultProps), {}, {
                    hide: !0,
                    orientation: dr(DOe, "".concat(o, ".").concat(p % 2), null),
                    domain: w,
                    originalDomain: A,
                    isCategorical: m,
                    layout: c
                })))
            }
            return y
        }, {})
    },
    VOe = function(t, n) {
        var r = n.axisType,
            i = r === void 0 ? "xAxis" : r,
            o = n.AxisComp,
            a = n.graphicalItems,
            s = n.stackGroups,
            u = n.dataStartIndex,
            l = n.dataEndIndex,
            c = t.children,
            f = "".concat(i, "Id"),
            d = Dr(c, o),
            h = {};
        return d && d.length ? h = UOe(t, {
            axes: d,
            graphicalItems: a,
            axisType: i,
            axisIdKey: f,
            stackGroups: s,
            dataStartIndex: u,
            dataEndIndex: l
        }) : a && a.length && (h = HOe(t, {
            Axis: o,
            graphicalItems: a,
            axisType: i,
            axisIdKey: f,
            stackGroups: s,
            dataStartIndex: u,
            dataEndIndex: l
        })), h
    },
    zOe = function(t) {
        var n = ru(t),
            r = Ya(n, !1, !0);
        return {
            tooltipTicks: r,
            orderedTooltipTicks: Q_(r, function(i) {
                return i.coordinate
            }),
            tooltipAxis: n,
            tooltipAxisBandSize: sy(n, r)
        }
    },
    oN = function(t) {
        var n = t.children,
            r = t.defaultShowTooltip,
            i = Dn(n, _l),
            o = 0,
            a = 0;
        return t.data && t.data.length !== 0 && (a = t.data.length - 1), i && i.props && (i.props.startIndex >= 0 && (o = i.props.startIndex), i.props.endIndex >= 0 && (a = i.props.endIndex)), {
            chartX: 0,
            chartY: 0,
            dataStartIndex: o,
            dataEndIndex: a,
            activeTooltipIndex: -1,
            isTooltipActive: !!r
        }
    },
    WOe = function(t) {
        return !t || !t.length ? !1 : t.some(function(n) {
            var r = Gi(n && n.type);
            return r && r.indexOf("Bar") >= 0
        })
    },
    aN = function(t) {
        return t === "horizontal" ? {
            numericAxisName: "yAxis",
            cateAxisName: "xAxis"
        } : t === "vertical" ? {
            numericAxisName: "xAxis",
            cateAxisName: "yAxis"
        } : t === "centric" ? {
            numericAxisName: "radiusAxis",
            cateAxisName: "angleAxis"
        } : {
            numericAxisName: "angleAxis",
            cateAxisName: "radiusAxis"
        }
    },
    GOe = function(t, n) {
        var r = t.props,
            i = t.graphicalItems,
            o = t.xAxisMap,
            a = o === void 0 ? {} : o,
            s = t.yAxisMap,
            u = s === void 0 ? {} : s,
            l = r.width,
            c = r.height,
            f = r.children,
            d = r.margin || {},
            h = Dn(f, _l),
            m = Dn(f, ls),
            p = Object.keys(u).reduce(function(w, x) {
                var T = u[x],
                    _ = T.orientation;
                return !T.mirror && !T.hide ? U(U({}, w), {}, se({}, _, w[_] + T.width)) : w
            }, {
                left: d.left || 0,
                right: d.right || 0
            }),
            y = Object.keys(a).reduce(function(w, x) {
                var T = a[x],
                    _ = T.orientation;
                return !T.mirror && !T.hide ? U(U({}, w), {}, se({}, _, dr(w, "".concat(_)) + T.height)) : w
            }, {
                top: d.top || 0,
                bottom: d.bottom || 0
            }),
            g = U(U({}, y), p),
            b = g.bottom;
        h && (g.bottom += h.props.height || _l.defaultProps.height), m && n && (g = D1e(g, i, r, n));
        var v = l - g.left - g.right,
            A = c - g.top - g.bottom;
        return U(U({
            brushBottom: b
        }, g), {}, {
            width: Math.max(v, 0),
            height: Math.max(A, 0)
        })
    },
    qOe = function(t, n) {
        if (n === "xAxis") return t[n].width;
        if (n === "yAxis") return t[n].height
    },
    KOe = function(t) {
        var n = t.chartName,
            r = t.GraphicalChild,
            i = t.defaultTooltipEventType,
            o = i === void 0 ? "axis" : i,
            a = t.validateTooltipEventTypes,
            s = a === void 0 ? ["axis"] : a,
            u = t.axisComponents,
            l = t.legendContent,
            c = t.formatAxisMap,
            f = t.defaultProps,
            d = function(g, b) {
                var v = b.graphicalItems,
                    A = b.stackGroups,
                    w = b.offset,
                    x = b.updateId,
                    T = b.dataStartIndex,
                    _ = b.dataEndIndex,
                    O = g.barSize,
                    k = g.layout,
                    I = g.barGap,
                    M = g.barCategoryGap,
                    B = g.maxBarSize,
                    L = aN(k),
                    P = L.numericAxisName,
                    C = L.cateAxisName,
                    j = WOe(v),
                    N = [];
                return v.forEach(function(D, $) {
                    var V = y0(g.data, {
                            graphicalItems: [D],
                            dataStartIndex: T,
                            dataEndIndex: _
                        }),
                        H = D.type.defaultProps !== void 0 ? U(U({}, D.type.defaultProps), D.props) : D.props,
                        Q = H.dataKey,
                        X = H.maxBarSize,
                        ve = H["".concat(P, "Id")],
                        De = H["".concat(C, "Id")],
                        ot = {},
                        St = u.reduce(function(xa, Aa) {
                            var E0 = b["".concat(Aa.axisType, "Map")],
                                CT = H["".concat(Aa.axisType, "Id")];
                            E0 && E0[CT] || Aa.axisType === "zAxis" || Is();
                            var IT = E0[CT];
                            return U(U({}, xa), {}, se(se({}, Aa.axisType, IT), "".concat(Aa.axisType, "Ticks"), Ya(IT)))
                        }, ot),
                        K = St[C],
                        ae = St["".concat(C, "Ticks")],
                        re = A && A[ve] && A[ve].hasStack && X1e(D, A[ve].stackGroups),
                        z = Gi(D.type).indexOf("Bar") >= 0,
                        he = sy(K, ae),
                        me = [],
                        ht = j && j1e({
                            barSize: O,
                            stackGroups: A,
                            totalSize: qOe(St, C)
                        });
                    if (z) {
                        var pt, An, Ao = Pe(X) ? B : X,
                            Hs = (pt = (An = sy(K, ae, !0)) !== null && An !== void 0 ? An : Ao) !== null && pt !== void 0 ? pt : 0;
                        me = B1e({
                            barGap: I,
                            barCategoryGap: M,
                            bandSize: Hs !== he ? Hs : he,
                            sizeList: ht[De],
                            maxBarSize: Ao
                        }), Hs !== he && (me = me.map(function(xa) {
                            return U(U({}, xa), {}, {
                                position: U(U({}, xa.position), {}, {
                                    offset: xa.position.offset - Hs / 2
                                })
                            })
                        }))
                    }
                    var Mh = D && D.type && D.type.getComposedData;
                    Mh && N.push({
                        props: U(U({}, Mh(U(U({}, St), {}, {
                            displayedData: V,
                            props: g,
                            dataKey: Q,
                            item: D,
                            bandSize: he,
                            barPosition: me,
                            offset: w,
                            stackedData: re,
                            layout: k,
                            dataStartIndex: T,
                            dataEndIndex: _
                        }))), {}, se(se(se({
                            key: D.key || "item-".concat($)
                        }, P, St[P]), C, St[C]), "animationId", x)),
                        childIndex: Mue(D, g.children),
                        item: D
                    })
                }), N
            },
            h = function(g, b) {
                var v = g.props,
                    A = g.dataStartIndex,
                    w = g.dataEndIndex,
                    x = g.updateId;
                if (!Nk({
                        props: v
                    })) return null;
                var T = v.children,
                    _ = v.layout,
                    O = v.stackOffset,
                    k = v.data,
                    I = v.reverseStackOrder,
                    M = aN(_),
                    B = M.numericAxisName,
                    L = M.cateAxisName,
                    P = Dr(T, r),
                    C = K1e(k, P, "".concat(B, "Id"), "".concat(L, "Id"), O, I),
                    j = u.reduce(function(H, Q) {
                        var X = "".concat(Q.axisType, "Map");
                        return U(U({}, H), {}, se({}, X, VOe(v, U(U({}, Q), {}, {
                            graphicalItems: P,
                            stackGroups: Q.axisType === B && C,
                            dataStartIndex: A,
                            dataEndIndex: w
                        }))))
                    }, {}),
                    N = GOe(U(U({}, j), {}, {
                        props: v,
                        graphicalItems: P
                    }), b == null ? void 0 : b.legendBBox);
                Object.keys(j).forEach(function(H) {
                    j[H] = c(v, j[H], N, H.replace("Map", ""), n)
                });
                var D = j["".concat(L, "Map")],
                    $ = zOe(D),
                    V = d(v, U(U({}, j), {}, {
                        dataStartIndex: A,
                        dataEndIndex: w,
                        updateId: x,
                        graphicalItems: P,
                        stackGroups: C,
                        offset: N
                    }));
                return U(U({
                    formattedGraphicalItems: V,
                    graphicalItems: P,
                    offset: N,
                    stackGroups: C
                }, $), j)
            },
            m = function(y) {
                function g(b) {
                    var v, A, w;
                    return TOe(this, g), w = kOe(this, g, [b]), se(w, "eventEmitterSymbol", Symbol("rechartsEventEmitter")), se(w, "accessibilityManager", new dOe), se(w, "handleLegendBBoxUpdate", function(x) {
                        if (x) {
                            var T = w.state,
                                _ = T.dataStartIndex,
                                O = T.dataEndIndex,
                                k = T.updateId;
                            w.setState(U({
                                legendBBox: x
                            }, h({
                                props: w.props,
                                dataStartIndex: _,
                                dataEndIndex: O,
                                updateId: k
                            }, U(U({}, w.state), {}, {
                                legendBBox: x
                            }))))
                        }
                    }), se(w, "handleReceiveSyncEvent", function(x, T, _) {
                        if (w.props.syncId === x) {
                            if (_ === w.eventEmitterSymbol && typeof w.props.syncMethod != "function") return;
                            w.applySyncEvent(T)
                        }
                    }), se(w, "handleBrushChange", function(x) {
                        var T = x.startIndex,
                            _ = x.endIndex;
                        if (T !== w.state.dataStartIndex || _ !== w.state.dataEndIndex) {
                            var O = w.state.updateId;
                            w.setState(function() {
                                return U({
                                    dataStartIndex: T,
                                    dataEndIndex: _
                                }, h({
                                    props: w.props,
                                    dataStartIndex: T,
                                    dataEndIndex: _,
                                    updateId: O
                                }, w.state))
                            }), w.triggerSyncEvent({
                                dataStartIndex: T,
                                dataEndIndex: _
                            })
                        }
                    }), se(w, "handleMouseEnter", function(x) {
                        var T = w.getMouseInfo(x);
                        if (T) {
                            var _ = U(U({}, T), {}, {
                                isTooltipActive: !0
                            });
                            w.setState(_), w.triggerSyncEvent(_);
                            var O = w.props.onMouseEnter;
                            Ae(O) && O(_, x)
                        }
                    }), se(w, "triggeredAfterMouseMove", function(x) {
                        var T = w.getMouseInfo(x),
                            _ = T ? U(U({}, T), {}, {
                                isTooltipActive: !0
                            }) : {
                                isTooltipActive: !1
                            };
                        w.setState(_), w.triggerSyncEvent(_);
                        var O = w.props.onMouseMove;
                        Ae(O) && O(_, x)
                    }), se(w, "handleItemMouseEnter", function(x) {
                        w.setState(function() {
                            return {
                                isTooltipActive: !0,
                                activeItem: x,
                                activePayload: x.tooltipPayload,
                                activeCoordinate: x.tooltipPosition || {
                                    x: x.cx,
                                    y: x.cy
                                }
                            }
                        })
                    }), se(w, "handleItemMouseLeave", function() {
                        w.setState(function() {
                            return {
                                isTooltipActive: !1
                            }
                        })
                    }), se(w, "handleMouseMove", function(x) {
                        x.persist(), w.throttleTriggeredAfterMouseMove(x)
                    }), se(w, "handleMouseLeave", function(x) {
                        w.throttleTriggeredAfterMouseMove.cancel();
                        var T = {
                            isTooltipActive: !1
                        };
                        w.setState(T), w.triggerSyncEvent(T);
                        var _ = w.props.onMouseLeave;
                        Ae(_) && _(T, x)
                    }), se(w, "handleOuterEvent", function(x) {
                        var T = Iue(x),
                            _ = dr(w.props, "".concat(T));
                        if (T && Ae(_)) {
                            var O, k;
                            /.*touch.*/i.test(T) ? k = w.getMouseInfo(x.changedTouches[0]) : k = w.getMouseInfo(x), _((O = k) !== null && O !== void 0 ? O : {}, x)
                        }
                    }), se(w, "handleClick", function(x) {
                        var T = w.getMouseInfo(x);
                        if (T) {
                            var _ = U(U({}, T), {}, {
                                isTooltipActive: !0
                            });
                            w.setState(_), w.triggerSyncEvent(_);
                            var O = w.props.onClick;
                            Ae(O) && O(_, x)
                        }
                    }), se(w, "handleMouseDown", function(x) {
                        var T = w.props.onMouseDown;
                        if (Ae(T)) {
                            var _ = w.getMouseInfo(x);
                            T(_, x)
                        }
                    }), se(w, "handleMouseUp", function(x) {
                        var T = w.props.onMouseUp;
                        if (Ae(T)) {
                            var _ = w.getMouseInfo(x);
                            T(_, x)
                        }
                    }), se(w, "handleTouchMove", function(x) {
                        x.changedTouches != null && x.changedTouches.length > 0 && w.throttleTriggeredAfterMouseMove(x.changedTouches[0])
                    }), se(w, "handleTouchStart", function(x) {
                        x.changedTouches != null && x.changedTouches.length > 0 && w.handleMouseDown(x.changedTouches[0])
                    }), se(w, "handleTouchEnd", function(x) {
                        x.changedTouches != null && x.changedTouches.length > 0 && w.handleMouseUp(x.changedTouches[0])
                    }), se(w, "handleDoubleClick", function(x) {
                        var T = w.props.onDoubleClick;
                        if (Ae(T)) {
                            var _ = w.getMouseInfo(x);
                            T(_, x)
                        }
                    }), se(w, "handleContextMenu", function(x) {
                        var T = w.props.onContextMenu;
                        if (Ae(T)) {
                            var _ = w.getMouseInfo(x);
                            T(_, x)
                        }
                    }), se(w, "triggerSyncEvent", function(x) {
                        w.props.syncId !== void 0 && ew.emit(tw, w.props.syncId, x, w.eventEmitterSymbol)
                    }), se(w, "applySyncEvent", function(x) {
                        var T = w.props,
                            _ = T.layout,
                            O = T.syncMethod,
                            k = w.state.updateId,
                            I = x.dataStartIndex,
                            M = x.dataEndIndex;
                        if (x.dataStartIndex !== void 0 || x.dataEndIndex !== void 0) w.setState(U({
                            dataStartIndex: I,
                            dataEndIndex: M
                        }, h({
                            props: w.props,
                            dataStartIndex: I,
                            dataEndIndex: M,
                            updateId: k
                        }, w.state)));
                        else if (x.activeTooltipIndex !== void 0) {
                            var B = x.chartX,
                                L = x.chartY,
                                P = x.activeTooltipIndex,
                                C = w.state,
                                j = C.offset,
                                N = C.tooltipTicks;
                            if (!j) return;
                            if (typeof O == "function") P = O(N, x);
                            else if (O === "value") {
                                P = -1;
                                for (var D = 0; D < N.length; D++)
                                    if (N[D].value === x.activeLabel) {
                                        P = D;
                                        break
                                    }
                            }
                            var $ = U(U({}, j), {}, {
                                    x: j.left,
                                    y: j.top
                                }),
                                V = Math.min(B, $.x + $.width),
                                H = Math.min(L, $.y + $.height),
                                Q = N[P] && N[P].value,
                                X = CA(w.state, w.props.data, P),
                                ve = N[P] ? {
                                    x: _ === "horizontal" ? N[P].coordinate : V,
                                    y: _ === "horizontal" ? H : N[P].coordinate
                                } : a8;
                            w.setState(U(U({}, x), {}, {
                                activeLabel: Q,
                                activeCoordinate: ve,
                                activePayload: X,
                                activeTooltipIndex: P
                            }))
                        } else w.setState(x)
                    }), se(w, "renderCursor", function(x) {
                        var T, _ = w.state,
                            O = _.isTooltipActive,
                            k = _.activeCoordinate,
                            I = _.activePayload,
                            M = _.offset,
                            B = _.activeTooltipIndex,
                            L = _.tooltipAxisBandSize,
                            P = w.getTooltipEventType(),
                            C = (T = x.props.active) !== null && T !== void 0 ? T : O,
                            j = w.props.layout,
                            N = x.key || "_recharts-cursor";
                        return R.createElement(bOe, {
                            key: N,
                            activeCoordinate: k,
                            activePayload: I,
                            activeTooltipIndex: B,
                            chartName: n,
                            element: x,
                            isActive: C,
                            layout: j,
                            offset: M,
                            tooltipAxisBandSize: L,
                            tooltipEventType: P
                        })
                    }), se(w, "renderPolarAxis", function(x, T, _) {
                        var O = dr(x, "type.axisType"),
                            k = dr(w.state, "".concat(O, "Map")),
                            I = x.type.defaultProps,
                            M = I !== void 0 ? U(U({}, I), x.props) : x.props,
                            B = k && k[M["".concat(O, "Id")]];
                        return S.cloneElement(x, U(U({}, B), {}, {
                            className: Me(O, B.className),
                            key: x.key || "".concat(T, "-").concat(_),
                            ticks: Ya(B, !0)
                        }))
                    }), se(w, "renderPolarGrid", function(x) {
                        var T = x.props,
                            _ = T.radialLines,
                            O = T.polarAngles,
                            k = T.polarRadius,
                            I = w.state,
                            M = I.radiusAxisMap,
                            B = I.angleAxisMap,
                            L = ru(M),
                            P = ru(B),
                            C = P.cx,
                            j = P.cy,
                            N = P.innerRadius,
                            D = P.outerRadius;
                        return S.cloneElement(x, {
                            polarAngles: Array.isArray(O) ? O : Ya(P, !0).map(function($) {
                                return $.coordinate
                            }),
                            polarRadius: Array.isArray(k) ? k : Ya(L, !0).map(function($) {
                                return $.coordinate
                            }),
                            cx: C,
                            cy: j,
                            innerRadius: N,
                            outerRadius: D,
                            key: x.key || "polar-grid",
                            radialLines: _
                        })
                    }), se(w, "renderLegend", function() {
                        var x = w.state.formattedGraphicalItems,
                            T = w.props,
                            _ = T.children,
                            O = T.width,
                            k = T.height,
                            I = w.props.margin || {},
                            M = O - (I.left || 0) - (I.right || 0),
                            B = Y4({
                                children: _,
                                formattedGraphicalItems: x,
                                legendWidth: M,
                                legendContent: l
                            });
                        if (!B) return null;
                        var L = B.item,
                            P = nN(B, wOe);
                        return S.cloneElement(L, U(U({}, P), {}, {
                            chartWidth: O,
                            chartHeight: k,
                            margin: I,
                            onBBoxUpdate: w.handleLegendBBoxUpdate
                        }))
                    }), se(w, "renderTooltip", function() {
                        var x, T = w.props,
                            _ = T.children,
                            O = T.accessibilityLayer,
                            k = Dn(_, Yr);
                        if (!k) return null;
                        var I = w.state,
                            M = I.isTooltipActive,
                            B = I.activeCoordinate,
                            L = I.activePayload,
                            P = I.activeLabel,
                            C = I.offset,
                            j = (x = k.props.active) !== null && x !== void 0 ? x : M;
                        return S.cloneElement(k, {
                            viewBox: U(U({}, C), {}, {
                                x: C.left,
                                y: C.top
                            }),
                            active: j,
                            label: P,
                            payload: j ? L : [],
                            coordinate: B,
                            accessibilityLayer: O
                        })
                    }), se(w, "renderBrush", function(x) {
                        var T = w.props,
                            _ = T.margin,
                            O = T.data,
                            k = w.state,
                            I = k.offset,
                            M = k.dataStartIndex,
                            B = k.dataEndIndex,
                            L = k.updateId;
                        return S.cloneElement(x, {
                            key: x.key || "_recharts-brush",
                            onChange: pp(w.handleBrushChange, x.props.onChange),
                            data: O,
                            x: Y(x.props.x) ? x.props.x : I.left,
                            y: Y(x.props.y) ? x.props.y : I.top + I.height + I.brushBottom - (_.bottom || 0),
                            width: Y(x.props.width) ? x.props.width : I.width,
                            startIndex: M,
                            endIndex: B,
                            updateId: "brush-".concat(L)
                        })
                    }), se(w, "renderReferenceElement", function(x, T, _) {
                        if (!x) return null;
                        var O = w,
                            k = O.clipPathId,
                            I = w.state,
                            M = I.xAxisMap,
                            B = I.yAxisMap,
                            L = I.offset,
                            P = x.type.defaultProps || {},
                            C = x.props,
                            j = C.xAxisId,
                            N = j === void 0 ? P.xAxisId : j,
                            D = C.yAxisId,
                            $ = D === void 0 ? P.yAxisId : D;
                        return S.cloneElement(x, {
                            key: x.key || "".concat(T, "-").concat(_),
                            xAxis: M[N],
                            yAxis: B[$],
                            viewBox: {
                                x: L.left,
                                y: L.top,
                                width: L.width,
                                height: L.height
                            },
                            clipPathId: k
                        })
                    }), se(w, "renderActivePoints", function(x) {
                        var T = x.item,
                            _ = x.activePoint,
                            O = x.basePoint,
                            k = x.childIndex,
                            I = x.isRange,
                            M = [],
                            B = T.props.key,
                            L = T.item.type.defaultProps !== void 0 ? U(U({}, T.item.type.defaultProps), T.item.props) : T.item.props,
                            P = L.activeDot,
                            C = L.dataKey,
                            j = U(U({
                                index: k,
                                dataKey: C,
                                cx: _.x,
                                cy: _.y,
                                r: 4,
                                fill: xT(T.item),
                                strokeWidth: 2,
                                stroke: "#fff",
                                payload: _.payload,
                                value: _.value
                            }, _e(P, !1)), Mg(P));
                        return M.push(g.renderActiveDot(P, j, "".concat(B, "-activePoint-").concat(k))), O ? M.push(g.renderActiveDot(P, U(U({}, j), {}, {
                            cx: O.x,
                            cy: O.y
                        }), "".concat(B, "-basePoint-").concat(k))) : I && M.push(null), M
                    }), se(w, "renderGraphicChild", function(x, T, _) {
                        var O = w.filterFormatItem(x, T, _);
                        if (!O) return null;
                        var k = w.getTooltipEventType(),
                            I = w.state,
                            M = I.isTooltipActive,
                            B = I.tooltipAxis,
                            L = I.activeTooltipIndex,
                            P = I.activeLabel,
                            C = w.props.children,
                            j = Dn(C, Yr),
                            N = O.props,
                            D = N.points,
                            $ = N.isRange,
                            V = N.baseLine,
                            H = O.item.type.defaultProps !== void 0 ? U(U({}, O.item.type.defaultProps), O.item.props) : O.item.props,
                            Q = H.activeDot,
                            X = H.hide,
                            ve = H.activeBar,
                            De = H.activeShape,
                            ot = !!(!X && M && j && (Q || ve || De)),
                            St = {};
                        k !== "axis" && j && j.props.trigger === "click" ? St = {
                            onClick: pp(w.handleItemMouseEnter, x.props.onClick)
                        } : k !== "axis" && (St = {
                            onMouseLeave: pp(w.handleItemMouseLeave, x.props.onMouseLeave),
                            onMouseEnter: pp(w.handleItemMouseEnter, x.props.onMouseEnter)
                        });
                        var K = S.cloneElement(x, U(U({}, O.props), St));

                        function ae(Aa) {
                            return typeof B.dataKey == "function" ? B.dataKey(Aa.payload) : null
                        }
                        if (ot)
                            if (L >= 0) {
                                var re, z;
                                if (B.dataKey && !B.allowDuplicatedCategory) {
                                    var he = typeof B.dataKey == "function" ? ae : "payload.".concat(B.dataKey.toString());
                                    re = Ig(D, he, P), z = $ && V && Ig(V, he, P)
                                } else re = D == null ? void 0 : D[L], z = $ && V && V[L];
                                if (De || ve) {
                                    var me = x.props.activeIndex !== void 0 ? x.props.activeIndex : L;
                                    return [S.cloneElement(x, U(U(U({}, O.props), St), {}, {
                                        activeIndex: me
                                    })), null, null]
                                }
                                if (!Pe(re)) return [K].concat(jl(w.renderActivePoints({
                                    item: O,
                                    activePoint: re,
                                    basePoint: z,
                                    childIndex: L,
                                    isRange: $
                                })))
                            } else {
                                var ht, pt = (ht = w.getItemByXY(w.state.activeCoordinate)) !== null && ht !== void 0 ? ht : {
                                        graphicalItem: K
                                    },
                                    An = pt.graphicalItem,
                                    Ao = An.item,
                                    Hs = Ao === void 0 ? x : Ao,
                                    Mh = An.childIndex,
                                    xa = U(U(U({}, O.props), St), {}, {
                                        activeIndex: Mh
                                    });
                                return [S.cloneElement(Hs, xa), null, null]
                            }
                        return $ ? [K, null, null] : [K, null]
                    }), se(w, "renderCustomized", function(x, T, _) {
                        return S.cloneElement(x, U(U({
                            key: "recharts-customized-".concat(_)
                        }, w.props), w.state))
                    }), se(w, "renderMap", {
                        CartesianGrid: {
                            handler: bp,
                            once: !0
                        },
                        ReferenceArea: {
                            handler: w.renderReferenceElement
                        },
                        ReferenceLine: {
                            handler: bp
                        },
                        ReferenceDot: {
                            handler: w.renderReferenceElement
                        },
                        XAxis: {
                            handler: bp
                        },
                        YAxis: {
                            handler: bp
                        },
                        Brush: {
                            handler: w.renderBrush,
                            once: !0
                        },
                        Bar: {
                            handler: w.renderGraphicChild
                        },
                        Line: {
                            handler: w.renderGraphicChild
                        },
                        Area: {
                            handler: w.renderGraphicChild
                        },
                        Radar: {
                            handler: w.renderGraphicChild
                        },
                        RadialBar: {
                            handler: w.renderGraphicChild
                        },
                        Scatter: {
                            handler: w.renderGraphicChild
                        },
                        Pie: {
                            handler: w.renderGraphicChild
                        },
                        Funnel: {
                            handler: w.renderGraphicChild
                        },
                        Tooltip: {
                            handler: w.renderCursor,
                            once: !0
                        },
                        PolarGrid: {
                            handler: w.renderPolarGrid,
                            once: !0
                        },
                        PolarAngleAxis: {
                            handler: w.renderPolarAxis
                        },
                        PolarRadiusAxis: {
                            handler: w.renderPolarAxis
                        },
                        Customized: {
                            handler: w.renderCustomized
                        }
                    }), w.clipPathId = "".concat((v = b.id) !== null && v !== void 0 ? v : Sh("recharts"), "-clip"), w.throttleTriggeredAfterMouseMove = Q5(w.triggeredAfterMouseMove, (A = b.throttleDelay) !== null && A !== void 0 ? A : 1e3 / 60), w.state = {}, w
                }
                return MOe(g, y), OOe(g, [{
                    key: "componentDidMount",
                    value: function() {
                        var v, A;
                        this.addListener(), this.accessibilityManager.setDetails({
                            container: this.container,
                            offset: {
                                left: (v = this.props.margin.left) !== null && v !== void 0 ? v : 0,
                                top: (A = this.props.margin.top) !== null && A !== void 0 ? A : 0
                            },
                            coordinateList: this.state.tooltipTicks,
                            mouseHandlerCallback: this.triggeredAfterMouseMove,
                            layout: this.props.layout
                        }), this.displayDefaultTooltip()
                    }
                }, {
                    key: "displayDefaultTooltip",
                    value: function() {
                        var v = this.props,
                            A = v.children,
                            w = v.data,
                            x = v.height,
                            T = v.layout,
                            _ = Dn(A, Yr);
                        if (_) {
                            var O = _.props.defaultIndex;
                            if (!(typeof O != "number" || O < 0 || O > this.state.tooltipTicks.length - 1)) {
                                var k = this.state.tooltipTicks[O] && this.state.tooltipTicks[O].value,
                                    I = CA(this.state, w, O, k),
                                    M = this.state.tooltipTicks[O].coordinate,
                                    B = (this.state.offset.top + x) / 2,
                                    L = T === "horizontal",
                                    P = L ? {
                                        x: M,
                                        y: B
                                    } : {
                                        y: M,
                                        x: B
                                    },
                                    C = this.state.formattedGraphicalItems.find(function(N) {
                                        var D = N.item;
                                        return D.type.name === "Scatter"
                                    });
                                C && (P = U(U({}, P), C.props.points[O].tooltipPosition), I = C.props.points[O].tooltipPayload);
                                var j = {
                                    activeTooltipIndex: O,
                                    isTooltipActive: !0,
                                    activeLabel: k,
                                    activePayload: I,
                                    activeCoordinate: P
                                };
                                this.setState(j), this.renderCursor(_), this.accessibilityManager.setIndex(O)
                            }
                        }
                    }
                }, {
                    key: "getSnapshotBeforeUpdate",
                    value: function(v, A) {
                        if (!this.props.accessibilityLayer) return null;
                        if (this.state.tooltipTicks !== A.tooltipTicks && this.accessibilityManager.setDetails({
                                coordinateList: this.state.tooltipTicks
                            }), this.props.layout !== v.layout && this.accessibilityManager.setDetails({
                                layout: this.props.layout
                            }), this.props.margin !== v.margin) {
                            var w, x;
                            this.accessibilityManager.setDetails({
                                offset: {
                                    left: (w = this.props.margin.left) !== null && w !== void 0 ? w : 0,
                                    top: (x = this.props.margin.top) !== null && x !== void 0 ? x : 0
                                }
                            })
                        }
                        return null
                    }
                }, {
                    key: "componentDidUpdate",
                    value: function(v) {
                        c1([Dn(v.children, Yr)], [Dn(this.props.children, Yr)]) || this.displayDefaultTooltip()
                    }
                }, {
                    key: "componentWillUnmount",
                    value: function() {
                        this.removeListener(), this.throttleTriggeredAfterMouseMove.cancel()
                    }
                }, {
                    key: "getTooltipEventType",
                    value: function() {
                        var v = Dn(this.props.children, Yr);
                        if (v && typeof v.props.shared == "boolean") {
                            var A = v.props.shared ? "axis" : "item";
                            return s.indexOf(A) >= 0 ? A : o
                        }
                        return o
                    }
                }, {
                    key: "getMouseInfo",
                    value: function(v) {
                        if (!this.container) return null;
                        var A = this.container,
                            w = A.getBoundingClientRect(),
                            x = a0e(w),
                            T = {
                                chartX: Math.round(v.pageX - x.left),
                                chartY: Math.round(v.pageY - x.top)
                            },
                            _ = w.width / A.offsetWidth || 1,
                            O = this.inRange(T.chartX, T.chartY, _);
                        if (!O) return null;
                        var k = this.state,
                            I = k.xAxisMap,
                            M = k.yAxisMap,
                            B = this.getTooltipEventType();
                        if (B !== "axis" && I && M) {
                            var L = ru(I).scale,
                                P = ru(M).scale,
                                C = L && L.invert ? L.invert(T.chartX) : null,
                                j = P && P.invert ? P.invert(T.chartY) : null;
                            return U(U({}, T), {}, {
                                xValue: C,
                                yValue: j
                            })
                        }
                        var N = iN(this.state, this.props.data, this.props.layout, O);
                        return N ? U(U({}, T), N) : null
                    }
                }, {
                    key: "inRange",
                    value: function(v, A) {
                        var w = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1,
                            x = this.props.layout,
                            T = v / w,
                            _ = A / w;
                        if (x === "horizontal" || x === "vertical") {
                            var O = this.state.offset,
                                k = T >= O.left && T <= O.left + O.width && _ >= O.top && _ <= O.top + O.height;
                            return k ? {
                                x: T,
                                y: _
                            } : null
                        }
                        var I = this.state,
                            M = I.angleAxisMap,
                            B = I.radiusAxisMap;
                        if (M && B) {
                            var L = ru(M);
                            return VI({
                                x: T,
                                y: _
                            }, L)
                        }
                        return null
                    }
                }, {
                    key: "parseEventsOfWrapper",
                    value: function() {
                        var v = this.props.children,
                            A = this.getTooltipEventType(),
                            w = Dn(v, Yr),
                            x = {};
                        w && A === "axis" && (w.props.trigger === "click" ? x = {
                            onClick: this.handleClick
                        } : x = {
                            onMouseEnter: this.handleMouseEnter,
                            onDoubleClick: this.handleDoubleClick,
                            onMouseMove: this.handleMouseMove,
                            onMouseLeave: this.handleMouseLeave,
                            onTouchMove: this.handleTouchMove,
                            onTouchStart: this.handleTouchStart,
                            onTouchEnd: this.handleTouchEnd,
                            onContextMenu: this.handleContextMenu
                        });
                        var T = Mg(this.props, this.handleOuterEvent);
                        return U(U({}, T), x)
                    }
                }, {
                    key: "addListener",
                    value: function() {
                        ew.on(tw, this.handleReceiveSyncEvent)
                    }
                }, {
                    key: "removeListener",
                    value: function() {
                        ew.removeListener(tw, this.handleReceiveSyncEvent)
                    }
                }, {
                    key: "filterFormatItem",
                    value: function(v, A, w) {
                        for (var x = this.state.formattedGraphicalItems, T = 0, _ = x.length; T < _; T++) {
                            var O = x[T];
                            if (O.item === v || O.props.key === v.key || A === Gi(O.item.type) && w === O.childIndex) return O
                        }
                        return null
                    }
                }, {
                    key: "renderClipPath",
                    value: function() {
                        var v = this.clipPathId,
                            A = this.state.offset,
                            w = A.left,
                            x = A.top,
                            T = A.height,
                            _ = A.width;
                        return R.createElement("defs", null, R.createElement("clipPath", {
                            id: v
                        }, R.createElement("rect", {
                            x: w,
                            y: x,
                            height: T,
                            width: _
                        })))
                    }
                }, {
                    key: "getXScales",
                    value: function() {
                        var v = this.state.xAxisMap;
                        return v ? Object.entries(v).reduce(function(A, w) {
                            var x = tN(w, 2),
                                T = x[0],
                                _ = x[1];
                            return U(U({}, A), {}, se({}, T, _.scale))
                        }, {}) : null
                    }
                }, {
                    key: "getYScales",
                    value: function() {
                        var v = this.state.yAxisMap;
                        return v ? Object.entries(v).reduce(function(A, w) {
                            var x = tN(w, 2),
                                T = x[0],
                                _ = x[1];
                            return U(U({}, A), {}, se({}, T, _.scale))
                        }, {}) : null
                    }
                }, {
                    key: "getXScaleByAxisId",
                    value: function(v) {
                        var A;
                        return (A = this.state.xAxisMap) === null || A === void 0 || (A = A[v]) === null || A === void 0 ? void 0 : A.scale
                    }
                }, {
                    key: "getYScaleByAxisId",
                    value: function(v) {
                        var A;
                        return (A = this.state.yAxisMap) === null || A === void 0 || (A = A[v]) === null || A === void 0 ? void 0 : A.scale
                    }
                }, {
                    key: "getItemByXY",
                    value: function(v) {
                        var A = this.state,
                            w = A.formattedGraphicalItems,
                            x = A.activeItem;
                        if (w && w.length)
                            for (var T = 0, _ = w.length; T < _; T++) {
                                var O = w[T],
                                    k = O.props,
                                    I = O.item,
                                    M = I.type.defaultProps !== void 0 ? U(U({}, I.type.defaultProps), I.props) : I.props,
                                    B = Gi(I.type);
                                if (B === "Bar") {
                                    var L = (k.data || []).find(function(N) {
                                        return HSe(v, N)
                                    });
                                    if (L) return {
                                        graphicalItem: O,
                                        payload: L
                                    }
                                } else if (B === "RadialBar") {
                                    var P = (k.data || []).find(function(N) {
                                        return VI(v, N)
                                    });
                                    if (P) return {
                                        graphicalItem: O,
                                        payload: P
                                    }
                                } else if (s0(O, x) || u0(O, x) || qd(O, x)) {
                                    var C = W_e({
                                            graphicalItem: O,
                                            activeTooltipItem: x,
                                            itemData: M.data
                                        }),
                                        j = M.activeIndex === void 0 ? C : M.activeIndex;
                                    return {
                                        graphicalItem: U(U({}, O), {}, {
                                            childIndex: j
                                        }),
                                        payload: qd(O, x) ? M.data[C] : O.props.data[C]
                                    }
                                }
                            }
                        return null
                    }
                }, {
                    key: "render",
                    value: function() {
                        var v = this;
                        if (!Nk(this)) return null;
                        var A = this.props,
                            w = A.children,
                            x = A.className,
                            T = A.width,
                            _ = A.height,
                            O = A.style,
                            k = A.compact,
                            I = A.title,
                            M = A.desc,
                            B = nN(A, xOe),
                            L = _e(B, !1);
                        if (k) return R.createElement(FM, {
                            state: this.state,
                            width: this.props.width,
                            height: this.props.height,
                            clipPathId: this.clipPathId
                        }, R.createElement(d1, Tu({}, L, {
                            width: T,
                            height: _,
                            title: I,
                            desc: M
                        }), this.renderClipPath(), jk(w, this.renderMap)));
                        if (this.props.accessibilityLayer) {
                            var P, C;
                            L.tabIndex = (P = this.props.tabIndex) !== null && P !== void 0 ? P : 0, L.role = (C = this.props.role) !== null && C !== void 0 ? C : "application", L.onKeyDown = function(N) {
                                v.accessibilityManager.keyboardEvent(N)
                            }, L.onFocus = function() {
                                v.accessibilityManager.focus()
                            }
                        }
                        var j = this.parseEventsOfWrapper();
                        return R.createElement(FM, {
                            state: this.state,
                            width: this.props.width,
                            height: this.props.height,
                            clipPathId: this.clipPathId
                        }, R.createElement("div", Tu({
                            className: Me("recharts-wrapper", x),
                            style: U({
                                position: "relative",
                                cursor: "default",
                                width: T,
                                height: _
                            }, O)
                        }, j, {
                            ref: function(D) {
                                v.container = D
                            }
                        }), R.createElement(d1, Tu({}, L, {
                            width: T,
                            height: _,
                            title: I,
                            desc: M,
                            style: $Oe
                        }), this.renderClipPath(), jk(w, this.renderMap)), this.renderLegend(), this.renderTooltip()))
                    }
                }])
            }(S.Component);
        se(m, "displayName", n), se(m, "defaultProps", U({
            layout: "horizontal",
            stackOffset: "none",
            barCategoryGap: "10%",
            barGap: 4,
            margin: {
                top: 5,
                right: 5,
                bottom: 5,
                left: 5
            },
            reverseStackOrder: !1,
            syncMethod: "index"
        }, f)), se(m, "getDerivedStateFromProps", function(y, g) {
            var b = y.dataKey,
                v = y.data,
                A = y.children,
                w = y.width,
                x = y.height,
                T = y.layout,
                _ = y.stackOffset,
                O = y.margin,
                k = g.dataStartIndex,
                I = g.dataEndIndex;
            if (g.updateId === void 0) {
                var M = oN(y);
                return U(U(U({}, M), {}, {
                    updateId: 0
                }, h(U(U({
                    props: y
                }, M), {}, {
                    updateId: 0
                }), g)), {}, {
                    prevDataKey: b,
                    prevData: v,
                    prevWidth: w,
                    prevHeight: x,
                    prevLayout: T,
                    prevStackOffset: _,
                    prevMargin: O,
                    prevChildren: A
                })
            }
            if (b !== g.prevDataKey || v !== g.prevData || w !== g.prevWidth || x !== g.prevHeight || T !== g.prevLayout || _ !== g.prevStackOffset || !$u(O, g.prevMargin)) {
                var B = oN(y),
                    L = {
                        chartX: g.chartX,
                        chartY: g.chartY,
                        isTooltipActive: g.isTooltipActive
                    },
                    P = U(U({}, iN(g, v, T)), {}, {
                        updateId: g.updateId + 1
                    }),
                    C = U(U(U({}, B), L), P);
                return U(U(U({}, C), h(U({
                    props: y
                }, C), g)), {}, {
                    prevDataKey: b,
                    prevData: v,
                    prevWidth: w,
                    prevHeight: x,
                    prevLayout: T,
                    prevStackOffset: _,
                    prevMargin: O,
                    prevChildren: A
                })
            }
            if (!c1(A, g.prevChildren)) {
                var j, N, D, $, V = Dn(A, _l),
                    H = V && (j = (N = V.props) === null || N === void 0 ? void 0 : N.startIndex) !== null && j !== void 0 ? j : k,
                    Q = V && (D = ($ = V.props) === null || $ === void 0 ? void 0 : $.endIndex) !== null && D !== void 0 ? D : I,
                    X = H !== k || Q !== I,
                    ve = !Pe(v),
                    De = ve && !X ? g.updateId : g.updateId + 1;
                return U(U({
                    updateId: De
                }, h(U(U({
                    props: y
                }, g), {}, {
                    updateId: De,
                    dataStartIndex: H,
                    dataEndIndex: Q
                }), g)), {}, {
                    prevChildren: A,
                    dataStartIndex: H,
                    dataEndIndex: Q
                })
            }
            return null
        }), se(m, "renderActiveDot", function(y, g, b) {
            var v;
            return S.isValidElement(y) ? v = S.cloneElement(y, g) : Ae(y) ? v = y(g) : v = R.createElement(ET, g), R.createElement(lt, {
                className: "recharts-active-dot",
                key: b
            }, v)
        });
        var p = S.forwardRef(function(g, b) {
            return R.createElement(m, Tu({}, g, {
                ref: b
            }))
        });
        return p.displayName = m.displayName, p
    },
    QOe = KOe({
        chartName: "AreaChart",
        GraphicalChild: fi,
        axisComponents: [{
            axisType: "xAxis",
            AxisComp: m0
        }, {
            axisType: "yAxis",
            AxisComp: g0
        }],
        formatAxisMap: bPe
    });
const u8 = 6048e5,
    YOe = 864e5,
    sN = Symbol.for("constructDateFrom");

function uo(e, t) {
    return typeof e == "function" ? e(t) : e && typeof e == "object" && sN in e ? e[sN](t) : e instanceof Date ? new e.constructor(t) : new Date(t)
}

function vr(e, t) {
    return uo(t || e, e)
}
let XOe = {};

function v0() {
    return XOe
}

function eh(e, t) {
    var s, u, l, c;
    const n = v0(),
        r = (t == null ? void 0 : t.weekStartsOn) ? ? ((u = (s = t == null ? void 0 : t.locale) == null ? void 0 : s.options) == null ? void 0 : u.weekStartsOn) ? ? n.weekStartsOn ? ? ((c = (l = n.locale) == null ? void 0 : l.options) == null ? void 0 : c.weekStartsOn) ? ? 0,
        i = vr(e, t == null ? void 0 : t.in),
        o = i.getDay(),
        a = (o < r ? 7 : 0) + o - r;
    return i.setDate(i.getDate() - a), i.setHours(0, 0, 0, 0), i
}

function Cy(e, t) {
    return eh(e, { ...t,
        weekStartsOn: 1
    })
}

function l8(e, t) {
    const n = vr(e, t == null ? void 0 : t.in),
        r = n.getFullYear(),
        i = uo(n, 0);
    i.setFullYear(r + 1, 0, 4), i.setHours(0, 0, 0, 0);
    const o = Cy(i),
        a = uo(n, 0);
    a.setFullYear(r, 0, 4), a.setHours(0, 0, 0, 0);
    const s = Cy(a);
    return n.getTime() >= o.getTime() ? r + 1 : n.getTime() >= s.getTime() ? r : r - 1
}

function uN(e) {
    const t = vr(e),
        n = new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds()));
    return n.setUTCFullYear(t.getFullYear()), +e - +n
}

function c8(e, ...t) {
    const n = uo.bind(null, t.find(r => typeof r == "object"));
    return t.map(n)
}

function IA(e, t) {
    const n = vr(e, t == null ? void 0 : t.in);
    return n.setHours(0, 0, 0, 0), n
}

function ZOe(e, t, n) {
    const [r, i] = c8(n == null ? void 0 : n.in, e, t), o = IA(r), a = IA(i), s = +o - uN(o), u = +a - uN(a);
    return Math.round((s - u) / YOe)
}

function JOe(e, t) {
    const n = l8(e, t),
        r = uo(e, 0);
    return r.setFullYear(n, 0, 4), r.setHours(0, 0, 0, 0), Cy(r)
}

function eke(e) {
    return e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]"
}

function tke(e) {
    return !(!eke(e) && typeof e != "number" || isNaN(+vr(e)))
}

function nke(e, t) {
    const n = vr(e, t == null ? void 0 : t.in);
    return n.setHours(23, 59, 59, 999), n
}

function rke(e, t) {
    const [n, r] = c8(e, t.start, t.end);
    return {
        start: n,
        end: r
    }
}

function ike(e, t) {
    const {
        start: n,
        end: r
    } = rke(t == null ? void 0 : t.in, e);
    let i = +n > +r;
    const o = i ? +n : +r,
        a = i ? r : n;
    a.setHours(0, 0, 0, 0);
    let s = 1;
    const u = [];
    for (; + a <= o;) u.push(uo(n, a)), a.setDate(a.getDate() + s), a.setHours(0, 0, 0, 0);
    return i ? u.reverse() : u
}

function oke(e, t) {
    const n = vr(e, t == null ? void 0 : t.in);
    return n.setFullYear(n.getFullYear(), 0, 1), n.setHours(0, 0, 0, 0), n
}
const ake = {
        lessThanXSeconds: {
            one: "less than a second",
            other: "less than {{count}} seconds"
        },
        xSeconds: {
            one: "1 second",
            other: "{{count}} seconds"
        },
        halfAMinute: "half a minute",
        lessThanXMinutes: {
            one: "less than a minute",
            other: "less than {{count}} minutes"
        },
        xMinutes: {
            one: "1 minute",
            other: "{{count}} minutes"
        },
        aboutXHours: {
            one: "about 1 hour",
            other: "about {{count}} hours"
        },
        xHours: {
            one: "1 hour",
            other: "{{count}} hours"
        },
        xDays: {
            one: "1 day",
            other: "{{count}} days"
        },
        aboutXWeeks: {
            one: "about 1 week",
            other: "about {{count}} weeks"
        },
        xWeeks: {
            one: "1 week",
            other: "{{count}} weeks"
        },
        aboutXMonths: {
            one: "about 1 month",
            other: "about {{count}} months"
        },
        xMonths: {
            one: "1 month",
            other: "{{count}} months"
        },
        aboutXYears: {
            one: "about 1 year",
            other: "about {{count}} years"
        },
        xYears: {
            one: "1 year",
            other: "{{count}} years"
        },
        overXYears: {
            one: "over 1 year",
            other: "over {{count}} years"
        },
        almostXYears: {
            one: "almost 1 year",
            other: "almost {{count}} years"
        }
    },
    ske = (e, t, n) => {
        let r;
        const i = ake[e];
        return typeof i == "string" ? r = i : t === 1 ? r = i.one : r = i.other.replace("{{count}}", t.toString()), n != null && n.addSuffix ? n.comparison && n.comparison > 0 ? "in " + r : r + " ago" : r
    };

function rw(e) {
    return (t = {}) => {
        const n = t.width ? String(t.width) : e.defaultWidth;
        return e.formats[n] || e.formats[e.defaultWidth]
    }
}
const uke = {
        full: "EEEE, MMMM do, y",
        long: "MMMM do, y",
        medium: "MMM d, y",
        short: "MM/dd/yyyy"
    },
    lke = {
        full: "h:mm:ss a zzzz",
        long: "h:mm:ss a z",
        medium: "h:mm:ss a",
        short: "h:mm a"
    },
    cke = {
        full: "{{date}} 'at' {{time}}",
        long: "{{date}} 'at' {{time}}",
        medium: "{{date}}, {{time}}",
        short: "{{date}}, {{time}}"
    },
    fke = {
        date: rw({
            formats: uke,
            defaultWidth: "full"
        }),
        time: rw({
            formats: lke,
            defaultWidth: "full"
        }),
        dateTime: rw({
            formats: cke,
            defaultWidth: "full"
        })
    },
    dke = {
        lastWeek: "'last' eeee 'at' p",
        yesterday: "'yesterday at' p",
        today: "'today at' p",
        tomorrow: "'tomorrow at' p",
        nextWeek: "eeee 'at' p",
        other: "P"
    },
    hke = (e, t, n, r) => dke[e];

function jc(e) {
    return (t, n) => {
        const r = n != null && n.context ? String(n.context) : "standalone";
        let i;
        if (r === "formatting" && e.formattingValues) {
            const a = e.defaultFormattingWidth || e.defaultWidth,
                s = n != null && n.width ? String(n.width) : a;
            i = e.formattingValues[s] || e.formattingValues[a]
        } else {
            const a = e.defaultWidth,
                s = n != null && n.width ? String(n.width) : e.defaultWidth;
            i = e.values[s] || e.values[a]
        }
        const o = e.argumentCallback ? e.argumentCallback(t) : t;
        return i[o]
    }
}
const pke = {
        narrow: ["B", "A"],
        abbreviated: ["BC", "AD"],
        wide: ["Before Christ", "Anno Domini"]
    },
    mke = {
        narrow: ["1", "2", "3", "4"],
        abbreviated: ["Q1", "Q2", "Q3", "Q4"],
        wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
    },
    gke = {
        narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
        abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    },
    yke = {
        narrow: ["S", "M", "T", "W", "T", "F", "S"],
        short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
        abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    },
    vke = {
        narrow: {
            am: "a",
            pm: "p",
            midnight: "mi",
            noon: "n",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
        },
        abbreviated: {
            am: "AM",
            pm: "PM",
            midnight: "midnight",
            noon: "noon",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
        },
        wide: {
            am: "a.m.",
            pm: "p.m.",
            midnight: "midnight",
            noon: "noon",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
        }
    },
    bke = {
        narrow: {
            am: "a",
            pm: "p",
            midnight: "mi",
            noon: "n",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
        },
        abbreviated: {
            am: "AM",
            pm: "PM",
            midnight: "midnight",
            noon: "noon",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
        },
        wide: {
            am: "a.m.",
            pm: "p.m.",
            midnight: "midnight",
            noon: "noon",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
        }
    },
    wke = (e, t) => {
        const n = Number(e),
            r = n % 100;
        if (r > 20 || r < 10) switch (r % 10) {
            case 1:
                return n + "st";
            case 2:
                return n + "nd";
            case 3:
                return n + "rd"
        }
        return n + "th"
    },
    xke = {
        ordinalNumber: wke,
        era: jc({
            values: pke,
            defaultWidth: "wide"
        }),
        quarter: jc({
            values: mke,
            defaultWidth: "wide",
            argumentCallback: e => e - 1
        }),
        month: jc({
            values: gke,
            defaultWidth: "wide"
        }),
        day: jc({
            values: yke,
            defaultWidth: "wide"
        }),
        dayPeriod: jc({
            values: vke,
            defaultWidth: "wide",
            formattingValues: bke,
            defaultFormattingWidth: "wide"
        })
    };

function Bc(e) {
    return (t, n = {}) => {
        const r = n.width,
            i = r && e.matchPatterns[r] || e.matchPatterns[e.defaultMatchWidth],
            o = t.match(i);
        if (!o) return null;
        const a = o[0],
            s = r && e.parsePatterns[r] || e.parsePatterns[e.defaultParseWidth],
            u = Array.isArray(s) ? Eke(s, f => f.test(a)) : Ake(s, f => f.test(a));
        let l;
        l = e.valueCallback ? e.valueCallback(u) : u, l = n.valueCallback ? n.valueCallback(l) : l;
        const c = t.slice(a.length);
        return {
            value: l,
            rest: c
        }
    }
}

function Ake(e, t) {
    for (const n in e)
        if (Object.prototype.hasOwnProperty.call(e, n) && t(e[n])) return n
}

function Eke(e, t) {
    for (let n = 0; n < e.length; n++)
        if (t(e[n])) return n
}

function Ske(e) {
    return (t, n = {}) => {
        const r = t.match(e.matchPattern);
        if (!r) return null;
        const i = r[0],
            o = t.match(e.parsePattern);
        if (!o) return null;
        let a = e.valueCallback ? e.valueCallback(o[0]) : o[0];
        a = n.valueCallback ? n.valueCallback(a) : a;
        const s = t.slice(i.length);
        return {
            value: a,
            rest: s
        }
    }
}
const _ke = /^(\d+)(th|st|nd|rd)?/i,
    Tke = /\d+/i,
    Pke = {
        narrow: /^(b|a)/i,
        abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
        wide: /^(before christ|before common era|anno domini|common era)/i
    },
    Oke = {
        any: [/^b/i, /^(a|c)/i]
    },
    kke = {
        narrow: /^[1234]/i,
        abbreviated: /^q[1234]/i,
        wide: /^[1234](th|st|nd|rd)? quarter/i
    },
    Cke = {
        any: [/1/i, /2/i, /3/i, /4/i]
    },
    Ike = {
        narrow: /^[jfmasond]/i,
        abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
        wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    },
    Mke = {
        narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
        any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    },
    Nke = {
        narrow: /^[smtwf]/i,
        short: /^(su|mo|tu|we|th|fr|sa)/i,
        abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
        wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    },
    Rke = {
        narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
        any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    },
    jke = {
        narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
        any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    },
    Bke = {
        any: {
            am: /^a/i,
            pm: /^p/i,
            midnight: /^mi/i,
            noon: /^no/i,
            morning: /morning/i,
            afternoon: /afternoon/i,
            evening: /evening/i,
            night: /night/i
        }
    },
    Dke = {
        ordinalNumber: Ske({
            matchPattern: _ke,
            parsePattern: Tke,
            valueCallback: e => parseInt(e, 10)
        }),
        era: Bc({
            matchPatterns: Pke,
            defaultMatchWidth: "wide",
            parsePatterns: Oke,
            defaultParseWidth: "any"
        }),
        quarter: Bc({
            matchPatterns: kke,
            defaultMatchWidth: "wide",
            parsePatterns: Cke,
            defaultParseWidth: "any",
            valueCallback: e => e + 1
        }),
        month: Bc({
            matchPatterns: Ike,
            defaultMatchWidth: "wide",
            parsePatterns: Mke,
            defaultParseWidth: "any"
        }),
        day: Bc({
            matchPatterns: Nke,
            defaultMatchWidth: "wide",
            parsePatterns: Rke,
            defaultParseWidth: "any"
        }),
        dayPeriod: Bc({
            matchPatterns: jke,
            defaultMatchWidth: "any",
            parsePatterns: Bke,
            defaultParseWidth: "any"
        })
    },
    $ke = {
        code: "en-US",
        formatDistance: ske,
        formatLong: fke,
        formatRelative: hke,
        localize: xke,
        match: Dke,
        options: {
            weekStartsOn: 0,
            firstWeekContainsDate: 1
        }
    };

function Lke(e, t) {
    const n = vr(e, t == null ? void 0 : t.in);
    return ZOe(n, oke(n)) + 1
}

function Fke(e, t) {
    const n = vr(e, t == null ? void 0 : t.in),
        r = +Cy(n) - +JOe(n);
    return Math.round(r / u8) + 1
}

function f8(e, t) {
    var c, f, d, h;
    const n = vr(e, t == null ? void 0 : t.in),
        r = n.getFullYear(),
        i = v0(),
        o = (t == null ? void 0 : t.firstWeekContainsDate) ? ? ((f = (c = t == null ? void 0 : t.locale) == null ? void 0 : c.options) == null ? void 0 : f.firstWeekContainsDate) ? ? i.firstWeekContainsDate ? ? ((h = (d = i.locale) == null ? void 0 : d.options) == null ? void 0 : h.firstWeekContainsDate) ? ? 1,
        a = uo((t == null ? void 0 : t.in) || e, 0);
    a.setFullYear(r + 1, 0, o), a.setHours(0, 0, 0, 0);
    const s = eh(a, t),
        u = uo((t == null ? void 0 : t.in) || e, 0);
    u.setFullYear(r, 0, o), u.setHours(0, 0, 0, 0);
    const l = eh(u, t);
    return +n >= +s ? r + 1 : +n >= +l ? r : r - 1
}

function Uke(e, t) {
    var s, u, l, c;
    const n = v0(),
        r = (t == null ? void 0 : t.firstWeekContainsDate) ? ? ((u = (s = t == null ? void 0 : t.locale) == null ? void 0 : s.options) == null ? void 0 : u.firstWeekContainsDate) ? ? n.firstWeekContainsDate ? ? ((c = (l = n.locale) == null ? void 0 : l.options) == null ? void 0 : c.firstWeekContainsDate) ? ? 1,
        i = f8(e, t),
        o = uo((t == null ? void 0 : t.in) || e, 0);
    return o.setFullYear(i, 0, r), o.setHours(0, 0, 0, 0), eh(o, t)
}

function Hke(e, t) {
    const n = vr(e, t == null ? void 0 : t.in),
        r = +eh(n, t) - +Uke(n, t);
    return Math.round(r / u8) + 1
}

function $e(e, t) {
    const n = e < 0 ? "-" : "",
        r = Math.abs(e).toString().padStart(t, "0");
    return n + r
}
const To = {
        y(e, t) {
            const n = e.getFullYear(),
                r = n > 0 ? n : 1 - n;
            return $e(t === "yy" ? r % 100 : r, t.length)
        },
        M(e, t) {
            const n = e.getMonth();
            return t === "M" ? String(n + 1) : $e(n + 1, 2)
        },
        d(e, t) {
            return $e(e.getDate(), t.length)
        },
        a(e, t) {
            const n = e.getHours() / 12 >= 1 ? "pm" : "am";
            switch (t) {
                case "a":
                case "aa":
                    return n.toUpperCase();
                case "aaa":
                    return n;
                case "aaaaa":
                    return n[0];
                case "aaaa":
                default:
                    return n === "am" ? "a.m." : "p.m."
            }
        },
        h(e, t) {
            return $e(e.getHours() % 12 || 12, t.length)
        },
        H(e, t) {
            return $e(e.getHours(), t.length)
        },
        m(e, t) {
            return $e(e.getMinutes(), t.length)
        },
        s(e, t) {
            return $e(e.getSeconds(), t.length)
        },
        S(e, t) {
            const n = t.length,
                r = e.getMilliseconds(),
                i = Math.trunc(r * Math.pow(10, n - 3));
            return $e(i, t.length)
        }
    },
    Xs = {
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    lN = {
        G: function(e, t, n) {
            const r = e.getFullYear() > 0 ? 1 : 0;
            switch (t) {
                case "G":
                case "GG":
                case "GGG":
                    return n.era(r, {
                        width: "abbreviated"
                    });
                case "GGGGG":
                    return n.era(r, {
                        width: "narrow"
                    });
                case "GGGG":
                default:
                    return n.era(r, {
                        width: "wide"
                    })
            }
        },
        y: function(e, t, n) {
            if (t === "yo") {
                const r = e.getFullYear(),
                    i = r > 0 ? r : 1 - r;
                return n.ordinalNumber(i, {
                    unit: "year"
                })
            }
            return To.y(e, t)
        },
        Y: function(e, t, n, r) {
            const i = f8(e, r),
                o = i > 0 ? i : 1 - i;
            if (t === "YY") {
                const a = o % 100;
                return $e(a, 2)
            }
            return t === "Yo" ? n.ordinalNumber(o, {
                unit: "year"
            }) : $e(o, t.length)
        },
        R: function(e, t) {
            const n = l8(e);
            return $e(n, t.length)
        },
        u: function(e, t) {
            const n = e.getFullYear();
            return $e(n, t.length)
        },
        Q: function(e, t, n) {
            const r = Math.ceil((e.getMonth() + 1) / 3);
            switch (t) {
                case "Q":
                    return String(r);
                case "QQ":
                    return $e(r, 2);
                case "Qo":
                    return n.ordinalNumber(r, {
                        unit: "quarter"
                    });
                case "QQQ":
                    return n.quarter(r, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "QQQQQ":
                    return n.quarter(r, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "QQQQ":
                default:
                    return n.quarter(r, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        q: function(e, t, n) {
            const r = Math.ceil((e.getMonth() + 1) / 3);
            switch (t) {
                case "q":
                    return String(r);
                case "qq":
                    return $e(r, 2);
                case "qo":
                    return n.ordinalNumber(r, {
                        unit: "quarter"
                    });
                case "qqq":
                    return n.quarter(r, {
                        width: "abbreviated",
                        context: "standalone"
                    });
                case "qqqqq":
                    return n.quarter(r, {
                        width: "narrow",
                        context: "standalone"
                    });
                case "qqqq":
                default:
                    return n.quarter(r, {
                        width: "wide",
                        context: "standalone"
                    })
            }
        },
        M: function(e, t, n) {
            const r = e.getMonth();
            switch (t) {
                case "M":
                case "MM":
                    return To.M(e, t);
                case "Mo":
                    return n.ordinalNumber(r + 1, {
                        unit: "month"
                    });
                case "MMM":
                    return n.month(r, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "MMMMM":
                    return n.month(r, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "MMMM":
                default:
                    return n.month(r, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        L: function(e, t, n) {
            const r = e.getMonth();
            switch (t) {
                case "L":
                    return String(r + 1);
                case "LL":
                    return $e(r + 1, 2);
                case "Lo":
                    return n.ordinalNumber(r + 1, {
                        unit: "month"
                    });
                case "LLL":
                    return n.month(r, {
                        width: "abbreviated",
                        context: "standalone"
                    });
                case "LLLLL":
                    return n.month(r, {
                        width: "narrow",
                        context: "standalone"
                    });
                case "LLLL":
                default:
                    return n.month(r, {
                        width: "wide",
                        context: "standalone"
                    })
            }
        },
        w: function(e, t, n, r) {
            const i = Hke(e, r);
            return t === "wo" ? n.ordinalNumber(i, {
                unit: "week"
            }) : $e(i, t.length)
        },
        I: function(e, t, n) {
            const r = Fke(e);
            return t === "Io" ? n.ordinalNumber(r, {
                unit: "week"
            }) : $e(r, t.length)
        },
        d: function(e, t, n) {
            return t === "do" ? n.ordinalNumber(e.getDate(), {
                unit: "date"
            }) : To.d(e, t)
        },
        D: function(e, t, n) {
            const r = Lke(e);
            return t === "Do" ? n.ordinalNumber(r, {
                unit: "dayOfYear"
            }) : $e(r, t.length)
        },
        E: function(e, t, n) {
            const r = e.getDay();
            switch (t) {
                case "E":
                case "EE":
                case "EEE":
                    return n.day(r, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "EEEEE":
                    return n.day(r, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "EEEEEE":
                    return n.day(r, {
                        width: "short",
                        context: "formatting"
                    });
                case "EEEE":
                default:
                    return n.day(r, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        e: function(e, t, n, r) {
            const i = e.getDay(),
                o = (i - r.weekStartsOn + 8) % 7 || 7;
            switch (t) {
                case "e":
                    return String(o);
                case "ee":
                    return $e(o, 2);
                case "eo":
                    return n.ordinalNumber(o, {
                        unit: "day"
                    });
                case "eee":
                    return n.day(i, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "eeeee":
                    return n.day(i, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "eeeeee":
                    return n.day(i, {
                        width: "short",
                        context: "formatting"
                    });
                case "eeee":
                default:
                    return n.day(i, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        c: function(e, t, n, r) {
            const i = e.getDay(),
                o = (i - r.weekStartsOn + 8) % 7 || 7;
            switch (t) {
                case "c":
                    return String(o);
                case "cc":
                    return $e(o, t.length);
                case "co":
                    return n.ordinalNumber(o, {
                        unit: "day"
                    });
                case "ccc":
                    return n.day(i, {
                        width: "abbreviated",
                        context: "standalone"
                    });
                case "ccccc":
                    return n.day(i, {
                        width: "narrow",
                        context: "standalone"
                    });
                case "cccccc":
                    return n.day(i, {
                        width: "short",
                        context: "standalone"
                    });
                case "cccc":
                default:
                    return n.day(i, {
                        width: "wide",
                        context: "standalone"
                    })
            }
        },
        i: function(e, t, n) {
            const r = e.getDay(),
                i = r === 0 ? 7 : r;
            switch (t) {
                case "i":
                    return String(i);
                case "ii":
                    return $e(i, t.length);
                case "io":
                    return n.ordinalNumber(i, {
                        unit: "day"
                    });
                case "iii":
                    return n.day(r, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "iiiii":
                    return n.day(r, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "iiiiii":
                    return n.day(r, {
                        width: "short",
                        context: "formatting"
                    });
                case "iiii":
                default:
                    return n.day(r, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        a: function(e, t, n) {
            const i = e.getHours() / 12 >= 1 ? "pm" : "am";
            switch (t) {
                case "a":
                case "aa":
                    return n.dayPeriod(i, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "aaa":
                    return n.dayPeriod(i, {
                        width: "abbreviated",
                        context: "formatting"
                    }).toLowerCase();
                case "aaaaa":
                    return n.dayPeriod(i, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "aaaa":
                default:
                    return n.dayPeriod(i, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        b: function(e, t, n) {
            const r = e.getHours();
            let i;
            switch (r === 12 ? i = Xs.noon : r === 0 ? i = Xs.midnight : i = r / 12 >= 1 ? "pm" : "am", t) {
                case "b":
                case "bb":
                    return n.dayPeriod(i, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "bbb":
                    return n.dayPeriod(i, {
                        width: "abbreviated",
                        context: "formatting"
                    }).toLowerCase();
                case "bbbbb":
                    return n.dayPeriod(i, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "bbbb":
                default:
                    return n.dayPeriod(i, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        B: function(e, t, n) {
            const r = e.getHours();
            let i;
            switch (r >= 17 ? i = Xs.evening : r >= 12 ? i = Xs.afternoon : r >= 4 ? i = Xs.morning : i = Xs.night, t) {
                case "B":
                case "BB":
                case "BBB":
                    return n.dayPeriod(i, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "BBBBB":
                    return n.dayPeriod(i, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "BBBB":
                default:
                    return n.dayPeriod(i, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        h: function(e, t, n) {
            if (t === "ho") {
                let r = e.getHours() % 12;
                return r === 0 && (r = 12), n.ordinalNumber(r, {
                    unit: "hour"
                })
            }
            return To.h(e, t)
        },
        H: function(e, t, n) {
            return t === "Ho" ? n.ordinalNumber(e.getHours(), {
                unit: "hour"
            }) : To.H(e, t)
        },
        K: function(e, t, n) {
            const r = e.getHours() % 12;
            return t === "Ko" ? n.ordinalNumber(r, {
                unit: "hour"
            }) : $e(r, t.length)
        },
        k: function(e, t, n) {
            let r = e.getHours();
            return r === 0 && (r = 24), t === "ko" ? n.ordinalNumber(r, {
                unit: "hour"
            }) : $e(r, t.length)
        },
        m: function(e, t, n) {
            return t === "mo" ? n.ordinalNumber(e.getMinutes(), {
                unit: "minute"
            }) : To.m(e, t)
        },
        s: function(e, t, n) {
            return t === "so" ? n.ordinalNumber(e.getSeconds(), {
                unit: "second"
            }) : To.s(e, t)
        },
        S: function(e, t) {
            return To.S(e, t)
        },
        X: function(e, t, n) {
            const r = e.getTimezoneOffset();
            if (r === 0) return "Z";
            switch (t) {
                case "X":
                    return fN(r);
                case "XXXX":
                case "XX":
                    return Ra(r);
                case "XXXXX":
                case "XXX":
                default:
                    return Ra(r, ":")
            }
        },
        x: function(e, t, n) {
            const r = e.getTimezoneOffset();
            switch (t) {
                case "x":
                    return fN(r);
                case "xxxx":
                case "xx":
                    return Ra(r);
                case "xxxxx":
                case "xxx":
                default:
                    return Ra(r, ":")
            }
        },
        O: function(e, t, n) {
            const r = e.getTimezoneOffset();
            switch (t) {
                case "O":
                case "OO":
                case "OOO":
                    return "GMT" + cN(r, ":");
                case "OOOO":
                default:
                    return "GMT" + Ra(r, ":")
            }
        },
        z: function(e, t, n) {
            const r = e.getTimezoneOffset();
            switch (t) {
                case "z":
                case "zz":
                case "zzz":
                    return "GMT" + cN(r, ":");
                case "zzzz":
                default:
                    return "GMT" + Ra(r, ":")
            }
        },
        t: function(e, t, n) {
            const r = Math.trunc(+e / 1e3);
            return $e(r, t.length)
        },
        T: function(e, t, n) {
            return $e(+e, t.length)
        }
    };

function cN(e, t = "") {
    const n = e > 0 ? "-" : "+",
        r = Math.abs(e),
        i = Math.trunc(r / 60),
        o = r % 60;
    return o === 0 ? n + String(i) : n + String(i) + t + $e(o, 2)
}

function fN(e, t) {
    return e % 60 === 0 ? (e > 0 ? "-" : "+") + $e(Math.abs(e) / 60, 2) : Ra(e, t)
}

function Ra(e, t = "") {
    const n = e > 0 ? "-" : "+",
        r = Math.abs(e),
        i = $e(Math.trunc(r / 60), 2),
        o = $e(r % 60, 2);
    return n + i + t + o
}
const dN = (e, t) => {
        switch (e) {
            case "P":
                return t.date({
                    width: "short"
                });
            case "PP":
                return t.date({
                    width: "medium"
                });
            case "PPP":
                return t.date({
                    width: "long"
                });
            case "PPPP":
            default:
                return t.date({
                    width: "full"
                })
        }
    },
    d8 = (e, t) => {
        switch (e) {
            case "p":
                return t.time({
                    width: "short"
                });
            case "pp":
                return t.time({
                    width: "medium"
                });
            case "ppp":
                return t.time({
                    width: "long"
                });
            case "pppp":
            default:
                return t.time({
                    width: "full"
                })
        }
    },
    Vke = (e, t) => {
        const n = e.match(/(P+)(p+)?/) || [],
            r = n[1],
            i = n[2];
        if (!i) return dN(e, t);
        let o;
        switch (r) {
            case "P":
                o = t.dateTime({
                    width: "short"
                });
                break;
            case "PP":
                o = t.dateTime({
                    width: "medium"
                });
                break;
            case "PPP":
                o = t.dateTime({
                    width: "long"
                });
                break;
            case "PPPP":
            default:
                o = t.dateTime({
                    width: "full"
                });
                break
        }
        return o.replace("{{date}}", dN(r, t)).replace("{{time}}", d8(i, t))
    },
    zke = {
        p: d8,
        P: Vke
    },
    Wke = /^D+$/,
    Gke = /^Y+$/,
    qke = ["D", "DD", "YY", "YYYY"];

function Kke(e) {
    return Wke.test(e)
}

function Qke(e) {
    return Gke.test(e)
}

function Yke(e, t, n) {
    const r = Xke(e, t, n);
    if (console.warn(r), qke.includes(e)) throw new RangeError(r)
}

function Xke(e, t, n) {
    const r = e[0] === "Y" ? "years" : "days of the month";
    return `Use \`${e.toLowerCase()}\` instead of \`${e}\` (in \`${t}\`) for formatting ${r} to the input \`${n}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`
}
const Zke = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,
    Jke = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,
    eCe = /^'([^]*?)'?$/,
    tCe = /''/g,
    nCe = /[a-zA-Z]/;

function wp(e, t, n) {
    var c, f, d, h;
    const r = v0(),
        i = r.locale ? ? $ke,
        o = r.firstWeekContainsDate ? ? ((f = (c = r.locale) == null ? void 0 : c.options) == null ? void 0 : f.firstWeekContainsDate) ? ? 1,
        a = r.weekStartsOn ? ? ((h = (d = r.locale) == null ? void 0 : d.options) == null ? void 0 : h.weekStartsOn) ? ? 0,
        s = vr(e, n == null ? void 0 : n.in);
    if (!tke(s)) throw new RangeError("Invalid time value");
    let u = t.match(Jke).map(m => {
        const p = m[0];
        if (p === "p" || p === "P") {
            const y = zke[p];
            return y(m, i.formatLong)
        }
        return m
    }).join("").match(Zke).map(m => {
        if (m === "''") return {
            isToken: !1,
            value: "'"
        };
        const p = m[0];
        if (p === "'") return {
            isToken: !1,
            value: rCe(m)
        };
        if (lN[p]) return {
            isToken: !0,
            value: m
        };
        if (p.match(nCe)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + p + "`");
        return {
            isToken: !1,
            value: m
        }
    });
    i.localize.preprocessor && (u = i.localize.preprocessor(s, u));
    const l = {
        firstWeekContainsDate: o,
        weekStartsOn: a,
        locale: i
    };
    return u.map(m => {
        if (!m.isToken) return m.value;
        const p = m.value;
        (Qke(p) || Kke(p)) && Yke(p, t, String(e));
        const y = lN[p[0]];
        return y(s, p, i.localize, l)
    }).join("")
}

function rCe(e) {
    const t = e.match(eCe);
    return t ? t[1].replace(tCe, "'") : e
}
const iCe = ({
        data: e,
        title: t,
        valuePrefix: n = "",
        isLoading: r = !1,
        bnbPrice: i
    }) => {
        if (r) return E.jsx("div", {
            className: "h-[400px] bg-background-light rounded-lg animate-pulse"
        });
        const o = (() => {
                if (e.length === 0) return [];
                const l = [...e].sort((m, p) => new Date(m.timestamp).getTime() - new Date(p.timestamp).getTime()),
                    c = IA(new Date(l[0].timestamp)),
                    f = nke(new Date(l[l.length - 1].timestamp)),
                    d = ike({
                        start: c,
                        end: f
                    }),
                    h = new Map(l.map(m => [wp(new Date(m.timestamp), "yyyy-MM-dd"), m]));
                return d.map(m => {
                    const p = wp(m, "yyyy-MM-dd"),
                        y = h.get(p);
                    if (y) return y;
                    const g = l.reduce((b, v) => new Date(v.timestamp) <= m ? v : b, l[0]);
                    return {
                        timestamp: p,
                        value: g.value,
                        deposits: 0,
                        withdraws: 0,
                        usdValue: g.value * i
                    }
                })
            })(),
            a = l => wp(new Date(l), "MMM dd"),
            s = ({
                active: l,
                payload: c,
                label: f
            }) => {
                var d, h;
                if (l && c && c.length) {
                    const m = c[0].value,
                        p = m * i,
                        y = ((d = c[1]) == null ? void 0 : d.value) || 0,
                        g = ((h = c[2]) == null ? void 0 : h.value) || 0;
                    return E.jsxs("div", {
                        className: "bg-background-light p-4 rounded-lg border border-gray-800 space-y-2",
                        children: [E.jsx("p", {
                            className: "text-sm text-gray-400 font-medium",
                            children: wp(new Date(f), "MMM dd, yyyy")
                        }), E.jsxs("div", {
                            className: "space-y-1",
                            children: [E.jsxs("p", {
                                className: "text-sm",
                                children: [E.jsx("span", {
                                    className: "text-gray-400",
                                    children: "Balance:"
                                }), " ", E.jsxs("span", {
                                    className: "font-bold",
                                    children: [n, m.toFixed(4)]
                                })]
                            }), E.jsxs("p", {
                                className: "text-sm text-gray-400",
                                children: ["≈ $", p.toFixed(2), " USD"]
                            })]
                        }), E.jsxs("div", {
                            className: "space-y-1 pt-2 border-t border-gray-800",
                            children: [E.jsxs("p", {
                                className: "text-sm",
                                children: [E.jsx("span", {
                                    className: "text-gray-400",
                                    children: "Deposits:"
                                }), " ", E.jsxs("span", {
                                    className: "font-bold text-green-500",
                                    children: ["+", n, y.toFixed(4)]
                                })]
                            }), E.jsxs("p", {
                                className: "text-sm",
                                children: [E.jsx("span", {
                                    className: "text-gray-400",
                                    children: "Withdraws:"
                                }), " ", E.jsxs("span", {
                                    className: "font-bold text-red-500",
                                    children: ["-", n, g.toFixed(4)]
                                })]
                            })]
                        })]
                    })
                }
                return null
            },
            u = ({
                payload: l
            }) => E.jsx("div", {
                className: "flex justify-center space-x-6 text-sm",
                children: l.map((c, f) => E.jsxs("div", {
                    className: "flex items-center space-x-2",
                    children: [E.jsx("div", {
                        className: "w-3 h-3 rounded-full",
                        style: {
                            backgroundColor: c.color
                        }
                    }), E.jsx("span", {
                        className: "text-gray-400",
                        children: c.value
                    })]
                }, `item-${f}`))
            });
        return E.jsx("div", {
            className: "h-[400px] bg-background-light rounded-lg p-4",
            children: E.jsx(Jve, {
                width: "100%",
                height: "100%",
                children: E.jsxs(QOe, {
                    data: o,
                    margin: {
                        top: 10,
                        right: 30,
                        left: 0,
                        bottom: 20
                    },
                    children: [E.jsxs("defs", {
                        children: [E.jsxs("linearGradient", {
                            id: "colorValue",
                            x1: "0",
                            y1: "0",
                            x2: "0",
                            y2: "1",
                            children: [E.jsx("stop", {
                                offset: "5%",
                                stopColor: "#10B981",
                                stopOpacity: .3
                            }), E.jsx("stop", {
                                offset: "95%",
                                stopColor: "#10B981",
                                stopOpacity: 0
                            })]
                        }), E.jsxs("linearGradient", {
                            id: "colorDeposits",
                            x1: "0",
                            y1: "0",
                            x2: "0",
                            y2: "1",
                            children: [E.jsx("stop", {
                                offset: "5%",
                                stopColor: "#34D399",
                                stopOpacity: .3
                            }), E.jsx("stop", {
                                offset: "95%",
                                stopColor: "#34D399",
                                stopOpacity: 0
                            })]
                        }), E.jsxs("linearGradient", {
                            id: "colorWithdraws",
                            x1: "0",
                            y1: "0",
                            x2: "0",
                            y2: "1",
                            children: [E.jsx("stop", {
                                offset: "5%",
                                stopColor: "#F87171",
                                stopOpacity: .3
                            }), E.jsx("stop", {
                                offset: "95%",
                                stopColor: "#F87171",
                                stopOpacity: 0
                            })]
                        })]
                    }), E.jsx(m0, {
                        dataKey: "timestamp",
                        stroke: "#4B5563",
                        tick: {
                            fill: "#9CA3AF"
                        },
                        tickLine: {
                            stroke: "#4B5563"
                        },
                        tickFormatter: a,
                        interval: "preserveStartEnd",
                        minTickGap: 50
                    }), E.jsx(g0, {
                        stroke: "#4B5563",
                        tick: {
                            fill: "#9CA3AF"
                        },
                        tickLine: {
                            stroke: "#4B5563"
                        },
                        tickFormatter: l => `${n}${l.toFixed(4)}`
                    }), E.jsx(Yr, {
                        content: E.jsx(s, {})
                    }), E.jsx(ls, {
                        content: E.jsx(u, {})
                    }), E.jsx(fi, {
                        type: "monotone",
                        dataKey: "value",
                        name: "Balance",
                        stroke: "#10B981",
                        fill: "url(#colorValue)",
                        strokeWidth: 2,
                        isAnimationActive: !1
                    }), E.jsx(fi, {
                        type: "monotone",
                        dataKey: "deposits",
                        name: "Deposits",
                        stroke: "#34D399",
                        fill: "url(#colorDeposits)",
                        strokeWidth: 2,
                        isAnimationActive: !1
                    }), E.jsx(fi, {
                        type: "monotone",
                        dataKey: "withdraws",
                        name: "Withdraws",
                        stroke: "#F87171",
                        fill: "url(#colorWithdraws)",
                        strokeWidth: 2,
                        isAnimationActive: !1
                    })]
                })
            })
        })
    },
    xp = ({
        icon: e,
        title: t,
        subtitle: n,
        href: r
    }) => E.jsxs(mt, {
        to: r,
        target: r.startsWith("http") ? "_blank" : void 0,
        rel: r.startsWith("http") ? "noopener noreferrer" : void 0,
        className: "group flex-1 flex flex-col items-center p-6 rounded-2xl bg-background-light border border-gray-800 hover:border-primary/20 hover:bg-background-light/50 transition-all duration-300",
        children: [E.jsx("div", {
            className: "mb-4 p-4 rounded-xl bg-background flex items-center justify-center group-hover:scale-110 transition-transform duration-300",
            children: E.jsx(e, {
                className: "h-8 w-8 text-primary"
            })
        }), E.jsx("h3", {
            className: "text-xl font-bold mb-2 text-center bg-clip-text text-transparent bg-gradient-to-r from-white to-gray-300",
            children: t
        }), E.jsx("p", {
            className: "text-sm text-gray-400 text-center",
            children: n
        })]
    }),
    oCe = () => E.jsxs("div", {
        className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4",
        children: [E.jsx(xp, {
            icon: xS,
            title: "Documentation",
            subtitle: "Learn how it works",
            href: "/docs"
        }), E.jsx(xp, {
            icon: Gf,
            title: "Security Audit",
            subtitle: "View audit report",
            href: "/audit"
        }), E.jsx(xp, {
            icon: NL,
            title: "View on BscScan",
            subtitle: "Verify contract",
            href: "https://bscscan.com/address/0x8067b825ae7c013edacbddcb8449cabc3f07488b"
        }), E.jsx(xp, {
            icon: RL,
            title: "Join Telegram",
            subtitle: "Join community",
            href: "https://t.me/xjarprotocol"
        })]
    }),
    aCe = () => {
        const [e, t] = S.useState(""), [n, r] = S.useState("0"), [i, o] = S.useState(!1), [a, s] = S.useState(null), [u, l] = S.useState("0"), [c, f] = S.useState("0"), [d, h] = S.useState("0"), m = .01;
        S.useEffect(() => {
            (async () => {
                try {
                    const A = kg();
                    if (!A) return;
                    const w = new Kt(window.ethereum),
                        x = await w.eth.getBalance(A),
                        T = Number(w.utils.fromWei(x, "ether")) * (1 - m);
                    r(T.toFixed(4)), t(T.toFixed(4)), p(T.toString())
                } catch (A) {
                    console.error("Error fetching balance:", A)
                }
            })()
        }, []);
        const p = v => {
                const A = Number(v);
                if (isNaN(A) || A <= 0) {
                    l("0"), f("0"), h("0");
                    return
                }
                const w = A * .01,
                    x = w * 30,
                    T = w * 365;
                l(w.toFixed(4)), f(x.toFixed(4)), h(T.toFixed(4))
            },
            y = v => {
                if (v === "") {
                    t(""), p("0");
                    return
                }
                const A = Number(v);
                isNaN(A) || (t(v), p(v))
            },
            g = () => {
                t(n), p(n)
            },
            b = async () => {
                if (!e || Number(e) <= 0) {
                    s("Please enter a valid amount");
                    return
                }
                s(null), o(!0);
                try {
                    const v = Cg(),
                        A = kg();
                    if (!A) throw new Error("Please connect your wallet");
                    const x = new Kt(window.ethereum).utils.toWei(e, "ether");
                    await v.methods.deposit("0x0000000000000000000000000000000000000000").send({
                        from: A,
                        value: x
                    }), t(""), p("0")
                } catch (v) {
                    console.error("Deposit error:", v), s(v.message || "Failed to deposit")
                } finally {
                    o(!1)
                }
            };
        return E.jsxs("div", {
            className: "space-y-6",
            children: [E.jsxs("div", {
                className: "space-y-4",
                children: [E.jsxs("div", {
                    className: "flex items-center justify-between",
                    children: [E.jsx("label", {
                        className: "text-sm text-gray-400",
                        children: "Amount to Deposit"
                    }), E.jsxs("button", {
                        onClick: g,
                        className: "text-sm text-primary hover:text-primary-light transition-colors",
                        children: ["Max: ", n, " BNB"]
                    })]
                }), E.jsxs("div", {
                    className: "relative",
                    children: [E.jsx("input", {
                        type: "number",
                        value: e,
                        onChange: v => y(v.target.value),
                        placeholder: "0.0",
                        className: "w-full px-4 py-3 bg-background-light rounded-xl border border-gray-800 focus:border-primary focus:ring-1 focus:ring-primary outline-none transition-colors",
                        step: "0.01",
                        min: "0"
                    }), E.jsx("span", {
                        className: "absolute right-4 top-1/2 -translate-y-1/2 text-gray-400",
                        children: "BNB"
                    })]
                })]
            }), E.jsxs("div", {
                className: "space-y-4",
                children: [E.jsx("h3", {
                    className: "text-lg font-bold",
                    children: "ROI Calculator"
                }), E.jsxs("div", {
                    className: "grid grid-cols-3 gap-4",
                    children: [E.jsxs("div", {
                        className: "bg-background-light rounded-xl p-4 text-center",
                        children: [E.jsx("p", {
                            className: "text-sm text-gray-400 mb-2",
                            children: "Daily"
                        }), E.jsxs("p", {
                            className: "font-bold",
                            children: [u, " BNB"]
                        })]
                    }), E.jsxs("div", {
                        className: "bg-background-light rounded-xl p-4 text-center",
                        children: [E.jsx("p", {
                            className: "text-sm text-gray-400 mb-2",
                            children: "Monthly"
                        }), E.jsxs("p", {
                            className: "font-bold",
                            children: [c, " BNB"]
                        })]
                    }), E.jsxs("div", {
                        className: "bg-background-light rounded-xl p-4 text-center",
                        children: [E.jsx("p", {
                            className: "text-sm text-gray-400 mb-2",
                            children: "Yearly"
                        }), E.jsxs("p", {
                            className: "font-bold",
                            children: [d, " BNB"]
                        })]
                    })]
                })]
            }), a && E.jsx("div", {
                className: "p-4 rounded-xl bg-red-500/10 border border-red-500/20",
                children: E.jsx("p", {
                    className: "text-sm text-red-500",
                    children: a
                })
            }), E.jsx(Ve.button, {
                whileHover: {
                    scale: 1.02
                },
                whileTap: {
                    scale: .98
                },
                onClick: b,
                disabled: i,
                className: `w-full px-6 py-3 rounded-xl bg-gradient-to-r from-primary to-primary-light text-white hover:shadow-lg hover:shadow-primary/20 transition-all duration-300 ${i?"opacity-50 cursor-not-allowed":""}`,
                children: i ? E.jsxs("div", {
                    className: "flex items-center justify-center",
                    children: [E.jsx("div", {
                        className: "animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-white mr-2"
                    }), "Depositing..."]
                }) : "Deposit BNB"
            })]
        })
    },
    sCe = () => {
        const [e, t] = S.useState("0"), [n, r] = S.useState(!1), [i, o] = S.useState(null);
        S.useEffect(() => {
            const s = async () => {
                try {
                    const l = kg();
                    if (!l) return;
                    const f = await Cg().methods.userInfo(l).call(),
                        h = new Kt(window.ethereum).utils.fromWei(f.for_withdraw, "ether");
                    t(Number(h).toFixed(4))
                } catch (l) {
                    console.error("Error fetching available amount:", l)
                }
            };
            s();
            const u = setInterval(s, 3e4);
            return () => clearInterval(u)
        }, []);
        const a = async () => {
            if (Number(e) <= 0) {
                o("No funds available to withdraw");
                return
            }
            o(null), r(!0);
            try {
                const s = Cg(),
                    u = kg();
                if (!u) throw new Error("Please connect your wallet");
                await s.methods.withdraw().send({
                    from: u
                });
                const l = await s.methods.userInfo(u).call(),
                    f = new Kt(window.ethereum).utils.fromWei(l.for_withdraw, "ether");
                t(Number(f).toFixed(4))
            } catch (s) {
                console.error("Withdraw error:", s), o(s.message || "Failed to withdraw")
            } finally {
                r(!1)
            }
        };
        return E.jsxs("div", {
            className: "space-y-6",
            children: [E.jsxs("div", {
                className: "bg-background-light rounded-xl p-6 text-center",
                children: [E.jsx("h3", {
                    className: "text-lg font-bold mb-2",
                    children: "Available to Withdraw"
                }), E.jsxs("div", {
                    className: "flex items-center justify-center space-x-2",
                    children: [E.jsx("p", {
                        className: "text-2xl font-bold text-primary",
                        children: e
                    }), E.jsx("span", {
                        className: "text-gray-400",
                        children: "BNB"
                    })]
                })]
            }), i && E.jsx("div", {
                className: "p-4 rounded-xl bg-red-500/10 border border-red-500/20",
                children: E.jsx("p", {
                    className: "text-sm text-red-500",
                    children: i
                })
            }), E.jsx(Ve.button, {
                whileHover: {
                    scale: 1.02
                },
                whileTap: {
                    scale: .98
                },
                onClick: a,
                disabled: n || Number(e) <= 0,
                className: `w-full px-6 py-3 rounded-xl bg-gradient-to-r from-primary to-primary-light text-white hover:shadow-lg hover:shadow-primary/20 transition-all duration-300 ${n||Number(e)<=0?"opacity-50 cursor-not-allowed":""}`,
                children: n ? E.jsxs("div", {
                    className: "flex items-center justify-center",
                    children: [E.jsx("div", {
                        className: "animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-white mr-2"
                    }), "Withdrawing..."]
                }) : "Withdraw BNB"
            }), E.jsx("p", {
                className: "text-sm text-gray-400 text-center",
                children: "Withdraw your available rewards anytime"
            })]
        })
    },
    Ap = ({
        size: e = "md",
        className: t = ""
    }) => {
        const n = {
            sm: "h-4 w-4",
            md: "h-6 w-6",
            lg: "h-8 w-8"
        };
        return E.jsx(gG, {
            className: `animate-spin ${n[e]} ${t}`
        })
    },
    uCe = () => {
        const {
            account: e,
            isConnected: t,
            connectWithMetaMask: n
        } = Ov(), [r, i] = S.useState(!1), [o, a] = S.useState(!1), [s, u] = S.useState(!1), [l, c] = S.useState("1000"), [f, d] = S.useState(null), [h, m] = S.useState(null), [p, y] = S.useState(!0);
        S.useEffect(() => {
            const M = async () => {
                if (!e) {
                    m(null), y(!1);
                    return
                }
                try {
                    y(!0);
                    const P = await Cg().methods.userInfo(e).call();
                    m(P)
                } catch (L) {
                    console.error("Failed to fetch user info:", L)
                } finally {
                    y(!1)
                }
            };
            M();
            const B = setInterval(M, 3e4);
            return () => clearInterval(B)
        }, [e]), S.useEffect(() => {
            const M = B => {
                B.target.closest(".share-menu-container") || u(!1)
            };
            return s && document.addEventListener("click", M), () => {
                document.removeEventListener("click", M)
            }
        }, [s]);
        const g = M => M ? /^0x[a-fA-F0-9]{40}$/.test(M) : !1,
            b = () => {
                n()
            },
            A = (M => M ? IL().utils.fromWei(M, "ether") : "0")(h == null ? void 0 : h.total_match_bonus),
            w = (h == null ? void 0 : h.structure) || ["0", "0", "0", "0", "0"],
            x = t ? `${window.location.origin}/?r=${e==null?void 0:e.toLowerCase()}` : "Connect wallet to get your referral link",
            T = async () => {
                if (t) try {
                    await navigator.clipboard.writeText(x), i(!0), setTimeout(() => i(!1), 2e3)
                } catch (M) {
                    console.error("Failed to copy:", M)
                }
            },
            _ = async M => {
                if (!t) return;
                if (!g(e)) {
                    d("Invalid wallet address");
                    return
                }
                d(null);
                const B = "Join me on xJar Protocol and earn daily returns on your BNB! Use my referral link:",
                    L = encodeURIComponent(x),
                    P = encodeURIComponent(B);
                try {
                    let C = "";
                    switch (M) {
                        case "twitter":
                            C = `https://twitter.com/intent/tweet?text=${P}&url=${L}`;
                            break;
                        case "telegram":
                            C = `https://t.me/share/url?url=${L}&text=${P}`;
                            break;
                        case "whatsapp":
                            C = `https://wa.me/?text=${P}%20${L}`;
                            break
                    }
                    window.open(C, "_blank") || d("Please allow popups to share")
                } catch (C) {
                    console.error("Share error:", C), d("Failed to share. Please try again.")
                }
            },
            O = [{
                level: 1,
                bonus: "5%",
                color: "text-primary"
            }, {
                level: 2,
                bonus: "3%",
                color: "text-primary-light"
            }, {
                level: 3,
                bonus: "2%",
                color: "text-accent"
            }, {
                level: 4,
                bonus: "1%",
                color: "text-accent-light"
            }, {
                level: 5,
                bonus: "0.5%",
                color: "text-gray-400"
            }],
            I = (M => {
                const B = O.map(P => ({
                        level: P.level,
                        bonus: P.bonus,
                        earnings: parseFloat(P.bonus) / 100 * M
                    })),
                    L = B.reduce((P, C) => P + C.earnings, 0);
                return {
                    earnings: B,
                    total: L
                }
            })(parseFloat(l));
        return p ? E.jsx("div", {
            className: "card flex items-center justify-center py-12",
            children: E.jsx(Ap, {
                size: "lg",
                className: "text-primary"
            })
        }) : E.jsxs("div", {
            className: "space-y-8",
            children: [E.jsxs("div", {
                className: "card bg-gradient-to-r from-primary/10 to-background p-6",
                children: [E.jsxs("div", {
                    className: "flex items-center justify-between",
                    children: [E.jsxs("div", {
                        children: [E.jsx("h2", {
                            className: "text-2xl font-bold mb-2",
                            children: "Earn Up To 11.5% on Referrals!"
                        }), E.jsx("p", {
                            className: "text-gray-400",
                            children: "Get 5% from direct referrals and up to 11.5% total through 5 levels"
                        })]
                    }), E.jsxs("button", {
                        onClick: () => a(!o),
                        className: "btn-outline flex items-center space-x-2",
                        children: [E.jsx(AG, {
                            className: "h-5 w-5"
                        }), E.jsx("span", {
                            children: "Calculate Earnings"
                        })]
                    })]
                }), o && E.jsxs("div", {
                    className: "mt-6 p-4 bg-background rounded-lg",
                    children: [E.jsxs("div", {
                        className: "mb-4",
                        children: [E.jsx("label", {
                            className: "block text-sm text-gray-400 mb-2",
                            children: "Average Referral Deposit (BNB)"
                        }), E.jsx("input", {
                            type: "number",
                            value: l,
                            onChange: M => c(M.target.value),
                            className: "input w-full",
                            min: "0",
                            step: "0.1"
                        })]
                    }), E.jsxs("div", {
                        className: "space-y-2",
                        children: [I.earnings.map(M => E.jsxs("div", {
                            className: "flex justify-between text-sm",
                            children: [E.jsxs("span", {
                                className: "text-gray-400",
                                children: ["Level ", M.level, " (", M.bonus, ")"]
                            }), E.jsxs("span", {
                                className: "font-medium",
                                children: [M.earnings.toFixed(2), " BNB"]
                            })]
                        }, M.level)), E.jsxs("div", {
                            className: "border-t border-gray-800 pt-2 flex justify-between font-bold",
                            children: [E.jsx("span", {
                                children: "Total Potential Earnings"
                            }), E.jsxs("span", {
                                className: "text-primary",
                                children: [I.total.toFixed(2), " BNB"]
                            })]
                        })]
                    })]
                })]
            }), E.jsxs("div", {
                className: "card",
                children: [E.jsx("h2", {
                    className: "text-xl font-bold mb-6",
                    children: "Share Your Referral Link"
                }), E.jsxs("div", {
                    className: "space-y-4",
                    children: [E.jsxs("div", {
                        className: "relative share-menu-container",
                        children: [E.jsx("input", {
                            type: "text",
                            value: x,
                            readOnly: !0,
                            className: "input w-full pr-24"
                        }), t && E.jsx("button", {
                            onClick: T,
                            className: "absolute right-2 top-1/2 -translate-y-1/2 px-3 py-1 text-sm font-semibold text-primary hover:text-primary-dark transition-colors flex items-center space-x-1",
                            children: r ? E.jsxs(E.Fragment, {
                                children: [E.jsx(PG, {
                                    className: "h-4 w-4"
                                }), E.jsx("span", {
                                    children: "Copied!"
                                })]
                            }) : E.jsxs(E.Fragment, {
                                children: [E.jsx(IG, {
                                    className: "h-4 w-4"
                                }), E.jsx("span", {
                                    children: "Copy"
                                })]
                            })
                        })]
                    }), t && E.jsxs(E.Fragment, {
                        children: [f && E.jsx("div", {
                            className: "bg-red-500/10 border border-red-500/20 rounded-lg p-3 mb-4",
                            children: E.jsx("p", {
                                className: "text-red-500 text-sm",
                                children: f
                            })
                        }), E.jsxs("div", {
                            className: "relative",
                            children: [E.jsxs("button", {
                                onClick: () => u(!s),
                                className: "w-full btn-outline flex items-center justify-center space-x-2",
                                children: [E.jsx(tp, {
                                    className: "h-5 w-5"
                                }), E.jsx("span", {
                                    children: "Share Link"
                                })]
                            }), s && E.jsxs("div", {
                                className: "absolute top-full left-0 right-0 mt-2 bg-background-light rounded-lg shadow-lg border border-gray-800 overflow-hidden",
                                children: [E.jsxs("button", {
                                    onClick: () => {
                                        _("twitter"), u(!1)
                                    },
                                    className: "w-full px-4 py-3 text-left hover:bg-primary/5 flex items-center space-x-2",
                                    children: [E.jsx(tp, {
                                        className: "h-5 w-5"
                                    }), E.jsx("span", {
                                        children: "Share on Twitter"
                                    })]
                                }), E.jsxs("button", {
                                    onClick: () => {
                                        _("telegram"), u(!1)
                                    },
                                    className: "w-full px-4 py-3 text-left hover:bg-primary/5 flex items-center space-x-2",
                                    children: [E.jsx(tp, {
                                        className: "h-5 w-5"
                                    }), E.jsx("span", {
                                        children: "Share on Telegram"
                                    })]
                                }), E.jsxs("button", {
                                    onClick: () => {
                                        _("whatsapp"), u(!1)
                                    },
                                    className: "w-full px-4 py-3 text-left hover:bg-primary/5 flex items-center space-x-2",
                                    children: [E.jsx(tp, {
                                        className: "h-5 w-5"
                                    }), E.jsx("span", {
                                        children: "Share on WhatsApp"
                                    })]
                                })]
                            })]
                        })]
                    })]
                })]
            }), E.jsxs("div", {
                className: "card",
                children: [E.jsx("h2", {
                    className: "text-xl font-bold mb-6",
                    children: "Your Referral Stats"
                }), E.jsxs("div", {
                    className: "grid grid-cols-1 md:grid-cols-2 gap-6",
                    children: [E.jsxs("div", {
                        className: "bg-background rounded-lg p-4",
                        children: [E.jsx("p", {
                            className: "text-sm text-gray-400",
                            children: "Total Referral Bonus"
                        }), E.jsx("p", {
                            className: "text-2xl font-bold mt-1",
                            children: p ? E.jsx(Ap, {
                                size: "sm",
                                className: "text-gray-400"
                            }) : `${A} BNB`
                        })]
                    }), E.jsxs("div", {
                        className: "bg-background rounded-lg p-4",
                        children: [E.jsx("p", {
                            className: "text-sm text-gray-400",
                            children: "Total Referrals"
                        }), E.jsx("p", {
                            className: "text-2xl font-bold mt-1",
                            children: p ? E.jsx(Ap, {
                                size: "sm",
                                className: "text-gray-400"
                            }) : w.reduce((M, B) => Number(M) + Number(B), "0")
                        })]
                    })]
                })]
            }), E.jsxs("div", {
                className: "card",
                children: [E.jsx("h2", {
                    className: "text-xl font-bold mb-6",
                    children: "Referral Program"
                }), E.jsxs("div", {
                    className: "space-y-6",
                    children: [E.jsx("p", {
                        className: "text-gray-400",
                        children: "Earn bonus rewards when your referrals make deposits. The more people you invite, the more you earn!"
                    }), E.jsx("div", {
                        className: "grid grid-cols-1 md:grid-cols-5 gap-4",
                        children: O.map(({
                            level: M,
                            bonus: B,
                            color: L
                        }, P) => E.jsxs("div", {
                            className: "bg-background rounded-lg p-4 text-center",
                            children: [E.jsxs("p", {
                                className: "text-sm text-gray-400",
                                children: ["Level ", M]
                            }), E.jsx("p", {
                                className: `text-xl font-bold mt-1 ${L}`,
                                children: B
                            }), E.jsx("p", {
                                className: "text-sm mt-1",
                                children: p ? E.jsx(Ap, {
                                    size: "sm",
                                    className: "text-gray-400 mx-auto"
                                }) : `${Number(w[P])} referrals`
                            })]
                        }, M))
                    }), E.jsxs("div", {
                        className: "space-y-4",
                        children: [E.jsx("h3", {
                            className: "text-lg font-semibold",
                            children: "How It Works"
                        }), E.jsxs("ol", {
                            className: "list-decimal list-inside space-y-2 text-gray-400",
                            children: [E.jsx("li", {
                                children: "Share your referral link with friends"
                            }), E.jsx("li", {
                                children: "They make a deposit using your link"
                            }), E.jsx("li", {
                                children: "You earn up to 11.5% bonus rewards from their deposits"
                            }), E.jsx("li", {
                                children: "Bonuses are automatically sent to your wallet"
                            }), E.jsx("li", {
                                children: "No limit on the number of referrals"
                            })]
                        })]
                    })]
                })]
            }), !t && E.jsxs("div", {
                className: "card bg-gradient-to-r from-background-light to-background p-8 text-center",
                children: [E.jsx("h3", {
                    className: "text-2xl font-bold mb-4",
                    children: "Start Earning Referral Bonuses"
                }), E.jsx("p", {
                    className: "text-gray-400 mb-6",
                    children: "Connect your wallet to get your unique referral link and start earning bonus rewards!"
                }), E.jsx("button", {
                    onClick: b,
                    className: "btn-primary",
                    children: "Connect Wallet"
                })]
            })]
        })
    },
    lCe = {
        hidden: {
            opacity: 0
        },
        show: {
            opacity: 1,
            transition: {
                staggerChildren: .1
            }
        }
    },
    Pa = {
        hidden: {
            opacity: 0,
            y: 20
        },
        show: {
            opacity: 1,
            y: 0
        }
    },
    Ep = ({
        icon: e
    }) => E.jsx("div", {
        className: "bg-background-light p-6 rounded-xl mb-6 flex items-center justify-center w-20 h-20",
        children: E.jsx(e, {
            className: "h-14 w-14 text-primary"
        })
    }),
    cCe = ({
        onConnectClick: e
    }) => E.jsxs(Ve.div, {
        variants: lCe,
        initial: "hidden",
        animate: "show",
        className: "relative py-16 sm:py-24 overflow-hidden",
        children: [E.jsxs("div", {
            className: "absolute inset-0 z-0",
            children: [E.jsx("div", {
                className: "absolute inset-0 bg-[radial-gradient(circle_at_center,rgba(0,230,118,0.1)_0%,transparent_70%)]"
            }), E.jsx("div", {
                className: "absolute top-0 left-0 right-0 h-px bg-gradient-to-r from-transparent via-primary/20 to-transparent"
            })]
        }), E.jsxs("div", {
            className: "relative z-10 max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
            children: [E.jsxs("div", {
                className: "text-center mb-16",
                children: [E.jsxs(Ve.h1, {
                    variants: Pa,
                    className: "text-5xl sm:text-7xl font-bold mb-8 leading-tight",
                    children: [E.jsx("span", {
                        className: "text-white",
                        children: "Earn "
                    }), E.jsx("span", {
                        className: "text-primary",
                        children: "1%"
                    }), E.jsx("br", {}), E.jsx("span", {
                        className: "text-primary",
                        children: "Daily"
                    }), E.jsx("br", {}), E.jsx("span", {
                        className: "text-white",
                        children: "on Your "
                    }), E.jsx("span", {
                        className: "text-primary",
                        children: "BNB"
                    })]
                }), E.jsx(Ve.p, {
                    variants: Pa,
                    className: "text-gray-400 text-xl sm:text-2xl max-w-3xl mx-auto mb-12",
                    children: "Join the most secure and transparent DeFi protocol on BNB Chain. Start earning passive income with mathematically guaranteed returns."
                }), E.jsxs(Ve.div, {
                    variants: Pa,
                    className: "flex flex-col sm:flex-row items-center justify-center gap-6",
                    children: [E.jsx("button", {
                        onClick: e,
                        className: "px-8 py-4 text-lg rounded-xl bg-gradient-to-r from-primary to-primary-light text-white hover:shadow-lg hover:shadow-primary/20 transition-all duration-300 transform hover:scale-105",
                        children: "Connect Wallet →"
                    }), E.jsx(mt, {
                        to: "https://t.me/xjarprotocol",
                        target: "_blank",
                        rel: "noopener noreferrer",
                        className: "px-8 py-4 text-lg rounded-xl bg-primary/10 text-primary border border-primary hover:bg-primary/20 transition-all duration-300 transform hover:scale-105",
                        children: "Join Community →"
                    })]
                })]
            }), E.jsxs("div", {
                className: "grid grid-cols-2 sm:grid-cols-4 gap-8 max-w-5xl mx-auto",
                children: [E.jsx(Ve.div, {
                    variants: Pa,
                    className: "flex flex-col items-center text-center",
                    children: E.jsxs("div", {
                        className: "flex flex-col items-center",
                        children: [E.jsx(Ep, {
                            icon: Gf
                        }), E.jsxs("h3", {
                            className: "text-xl font-bold mb-2 text-center",
                            children: ["Security", E.jsx("br", {}), "First"]
                        }), E.jsx("p", {
                            className: "text-gray-400 text-sm text-center",
                            children: "Smart contract audited by leading security firms"
                        })]
                    })
                }), E.jsx(Ve.div, {
                    variants: Pa,
                    className: "flex flex-col items-center text-center",
                    children: E.jsxs("div", {
                        className: "flex flex-col items-center",
                        children: [E.jsx(Ep, {
                            icon: xS
                        }), E.jsx("h3", {
                            className: "text-xl font-bold mb-2 text-center",
                            children: "Transparent"
                        }), E.jsx("p", {
                            className: "text-gray-400 text-sm text-center",
                            children: "Fully verified and open-source code"
                        })]
                    })
                }), E.jsx(Ve.div, {
                    variants: Pa,
                    className: "flex flex-col items-center text-center",
                    children: E.jsxs("div", {
                        className: "flex flex-col items-center",
                        children: [E.jsx(Ep, {
                            icon: LG
                        }), E.jsx("h3", {
                            className: "text-xl font-bold mb-2 text-center",
                            children: "Immutable"
                        }), E.jsx("p", {
                            className: "text-gray-400 text-sm text-center",
                            children: "Contract ownership renounced"
                        })]
                    })
                }), E.jsx(Ve.div, {
                    variants: Pa,
                    className: "flex flex-col items-center text-center",
                    children: E.jsxs("div", {
                        className: "flex flex-col items-center",
                        children: [E.jsx(Ep, {
                            icon: wS
                        }), E.jsx("h3", {
                            className: "text-xl font-bold mb-2 text-center",
                            children: "Sustainable"
                        }), E.jsx("p", {
                            className: "text-gray-400 text-sm text-center",
                            children: "Mathematically proven ROI model"
                        })]
                    })
                })]
            })]
        })]
    }),
    fCe = "https://min-api.cryptocompare.com/data/price?fsym=BNB&tsyms=USD",
    Wr = {
        price: 0,
        timestamp: 0,
        CACHE_DURATION: 1e4
    };
let hN = 0;
const pN = 200,
    h8 = () => {
        const [e, t] = S.useState(0), [n, r] = S.useState(!0), [i, o] = S.useState(null);
        return S.useEffect(() => {
            const a = async () => {
                try {
                    const u = Date.now();
                    if (Wr.price && u - Wr.timestamp < Wr.CACHE_DURATION) {
                        t(Wr.price), r(!1);
                        return
                    }
                    const l = u - hN;
                    l < pN && await new Promise(d => setTimeout(d, pN - l));
                    const c = await fetch(fCe);
                    if (!c.ok) throw new Error("Failed to fetch BNB price");
                    hN = Date.now();
                    const f = await c.json();
                    f.USD ? (Wr.price = f.USD, Wr.timestamp = u, t(f.USD), o(null)) : Wr.price ? t(Wr.price) : o("Invalid price data received")
                } catch (u) {
                    console.error("Error fetching BNB price:", u), Wr.price ? t(Wr.price) : o("Failed to fetch price data")
                } finally {
                    r(!1)
                }
            };
            a();
            const s = setInterval(a, 6e4);
            return () => clearInterval(s)
        }, []), {
            price: e,
            isLoading: n,
            error: i
        }
    },
    dCe = 1e4,
    hCe = 5,
    pCe = () => {
        const [e, t] = S.useState([]), [n, r] = S.useState(!0), [i, o] = S.useState(null), {
            price: a
        } = h8(), s = async (c = !0) => {
            c && (r(!0), o(null));
            try {
                const f = new Kt,
                    d = f.utils.keccak256("NewDeposit(address,uint256)"),
                    h = f.utils.keccak256("Withdraw(address,uint256)"),
                    p = await (await fetch(`https://api.bscscan.com/api?module=proxy&action=eth_blockNumber&apikey=${pf}`)).json();
                if (p.status === "0") throw new Error(p.result || "Failed to get latest block");
                const y = parseInt(p.result, 16),
                    g = (y - 5e3).toString(),
                    b = y.toString(),
                    v = `https://api.bscscan.com/api?module=logs&action=getLogs&fromBlock=${g}&toBlock=${b}&address=${Os}&topic0=${d}&apikey=${pf}`,
                    A = `https://api.bscscan.com/api?module=logs&action=getLogs&fromBlock=${g}&toBlock=${b}&address=${Os}&topic0=${h}&apikey=${pf}`,
                    [w, x] = await Promise.all([fetch(v), fetch(A)]);
                if (!w.ok || !x.ok) throw new Error("Failed to fetch data");
                const [T, _] = await Promise.all([w.json(), x.json()]), O = [];
                T.result && Array.isArray(T.result) && T.result.forEach(I => {
                    try {
                        const M = f.utils.fromWei(f.utils.hexToNumberString(I.data), "ether");
                        O.push({
                            hash: I.transactionHash,
                            type: "deposit",
                            amount: M,
                            timestamp: parseInt(I.timeStamp) * 1e3,
                            address: "0x" + I.topics[1].slice(26).toLowerCase()
                        })
                    } catch (M) {
                        console.error("Error processing deposit:", M)
                    }
                }), _.result && Array.isArray(_.result) && _.result.forEach(I => {
                    try {
                        const M = f.utils.fromWei(f.utils.hexToNumberString(I.data), "ether");
                        O.push({
                            hash: I.transactionHash,
                            type: "withdraw",
                            amount: M,
                            timestamp: parseInt(I.timeStamp) * 1e3,
                            address: "0x" + I.topics[1].slice(26).toLowerCase()
                        })
                    } catch (M) {
                        console.error("Error processing withdrawal:", M)
                    }
                });
                const k = O.sort((I, M) => M.timestamp - I.timestamp).slice(0, hCe);
                t(k), o(null)
            } catch (f) {
                console.error("Error fetching transactions:", f), o("Failed to load recent transactions")
            } finally {
                r(!1)
            }
        };
        S.useEffect(() => {
            let c = !0,
                f;
            return (async () => {
                if (c) try {
                    if (await s(!0), !c) return;
                    f = setInterval(() => {
                        c && !i && s(!1)
                    }, dCe)
                } catch (h) {
                    console.error("Failed to load initial transactions:", h)
                }
            })(), () => {
                c = !1, f && clearInterval(f)
            }
        }, []);
        const u = c => {
                const f = Math.floor((Date.now() - c) / 1e3),
                    d = Math.floor(f / 60),
                    h = Math.floor(d / 60),
                    m = Math.floor(h / 24);
                return m > 0 ? `${m}d ago` : h > 0 ? `${h}h ago` : d > 0 ? `${d}m ago` : `${f}s ago`
            },
            l = c => `${c.slice(0,6)}...${c.slice(-4)}`;
        return n ? E.jsx("div", {
            className: "flex justify-center items-center py-8",
            children: E.jsx("div", {
                className: "animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-primary"
            })
        }) : i ? E.jsxs("div", {
            className: "space-y-4",
            children: [E.jsx("div", {
                className: "bg-red-500/10 border border-red-500/20 rounded-lg p-4",
                children: E.jsx("p", {
                    className: "text-red-500 text-center",
                    children: "Failed to load recent transactions"
                })
            }), E.jsx("button", {
                onClick: () => s(!0),
                className: "w-full px-4 py-2 rounded-lg bg-background-light hover:bg-background-light/80 border border-gray-800 text-sm text-gray-300 hover:text-white transition-all duration-300",
                disabled: n,
                children: "Refresh Transactions"
            })]
        }) : e.length === 0 ? E.jsx("div", {
            className: "text-center py-8",
            children: E.jsx("p", {
                className: "text-gray-400",
                children: "No transactions found"
            })
        }) : E.jsx("div", {
            className: "space-y-2",
            children: e.map(c => E.jsxs("div", {
                className: "flex items-center justify-between p-3 rounded-lg bg-[#0D0D0D] border border-gray-800/50 hover:border-gray-700/50 transition-colors",
                children: [E.jsxs("div", {
                    className: "flex items-center space-x-3",
                    children: [c.type === "withdraw" ? E.jsx(pG, {
                        className: "h-4 w-4 text-red-500"
                    }) : E.jsx(vG, {
                        className: "h-4 w-4 text-green-500"
                    }), E.jsx("span", {
                        className: `text-sm ${c.type==="withdraw"?"text-red-500":"text-green-500"}`,
                        children: c.type === "withdraw" ? "Withdraw" : "Deposit"
                    }), E.jsx("span", {
                        className: "text-sm text-gray-500",
                        children: u(c.timestamp)
                    }), E.jsx("span", {
                        className: "text-sm text-gray-500",
                        children: "•"
                    }), E.jsx("span", {
                        className: "text-sm text-gray-500",
                        children: l(c.address)
                    }), E.jsx("span", {
                        className: "text-sm text-gray-500",
                        children: "•"
                    }), E.jsx("span", {
                        className: "text-sm text-gray-500",
                        children: l(c.hash)
                    })]
                }), E.jsxs("div", {
                    className: "text-right",
                    children: [E.jsxs("p", {
                        className: `text-sm font-medium ${c.type==="withdraw"?"text-red-500":"text-green-500"}`,
                        children: [c.type === "withdraw" ? "-" : "+", Number(c.amount).toFixed(4), " BNB"]
                    }), E.jsxs("p", {
                        className: "text-xs text-gray-500",
                        children: ["$", (Number(c.amount) * a).toFixed(2)]
                    })]
                })]
            }, c.hash))
        })
    },
    mCe = [{
        question: "What is xJar Protocol?",
        answer: "xJar Protocol is a decentralized investment protocol on the BNB Smart Chain that offers daily ROI on deposits. Users can earn 1% daily returns on their BNB investments, along with referral bonuses through our multi-level referral system."
    }, {
        question: "How does the ROI work?",
        answer: "The protocol offers a 1% daily ROI on your deposits. This means for every BNB you deposit, you earn 0.01 BNB per day. ROI is calculated and distributed automatically based on your deposit time."
    }, {
        question: "What is the minimum deposit?",
        answer: "The minimum deposit amount is 0.001 BNB. This ensures accessibility while maintaining protocol sustainability."
    }, {
        question: "How does the referral system work?",
        answer: "Our 5-level referral system rewards you for bringing in new investors. You earn 5% from level 1 referrals, 3% from level 2, 2% from level 3, 1% from level 4, and 0.5% from level 5. These bonuses are paid from the marketing fee, not from user deposits."
    }, {
        question: "Is there a maximum deposit limit?",
        answer: "Yes, there is a limit of 100 deposits per address. This helps maintain protocol sustainability and prevents manipulation."
    }, {
        question: "Are there any fees?",
        answer: "The protocol charges a 1% marketing fee on deposits and withdrawals. This fee is used to sustain the referral system and protocol development."
    }, {
        question: "How secure is the protocol?",
        answer: "The smart contract is verified on BSCScan and follows best security practices. It has no external dependencies and uses simple, auditable code. However, as with any DeFi protocol, users should perform their own research and invest responsibly."
    }, {
        question: "When can I withdraw my earnings?",
        answer: "You can withdraw your earnings at any time, provided you have a minimum of 0.001 BNB in earnings. Withdrawals are processed instantly and sent directly to your wallet."
    }, {
        question: "What happens if I use a referral link?",
        answer: "When you deposit using a referral link, the referrer receives a bonus from your deposit through our multi-level system. This doesn't affect your ROI or deposit amount."
    }, {
        question: "Is the code open source?",
        answer: "Yes, the smart contract code is publicly verified on BSCScan and can be audited by anyone. We believe in transparency and encourage users to review the code."
    }],
    gCe = () => {
        const [e, t] = S.useState(null), n = r => {
            t(e === r ? null : r)
        };
        return E.jsxs("div", {
            className: "space-y-8",
            children: [E.jsx("h2", {
                className: "text-2xl font-bold",
                children: "Frequently Asked Questions"
            }), E.jsx("div", {
                className: "space-y-4",
                children: mCe.map((r, i) => E.jsxs("div", {
                    className: "card hover:border-primary transition-colors cursor-pointer",
                    onClick: () => n(i),
                    children: [E.jsxs("div", {
                        className: "flex justify-between items-center",
                        children: [E.jsx("h3", {
                            className: "text-lg font-semibold",
                            children: r.question
                        }), E.jsx(kG, {
                            className: `h-5 w-5 text-primary transition-transform ${e===i?"transform rotate-180":""}`
                        })]
                    }), e === i && E.jsx("p", {
                        className: "mt-4 text-gray-400",
                        children: r.answer
                    })]
                }, i))
            }), E.jsxs("div", {
                className: "card bg-gradient-to-r from-background-light to-background p-8 text-center",
                children: [E.jsx("h3", {
                    className: "text-xl font-bold mb-4",
                    children: "Still have questions?"
                }), E.jsx("p", {
                    className: "text-gray-400 mb-6",
                    children: "Join our community for more information and support"
                }), E.jsx("div", {
                    className: "flex justify-center",
                    children: E.jsx("a", {
                        href: "https://t.me/xjarprotocol",
                        target: "_blank",
                        rel: "noopener noreferrer",
                        className: "btn-outline",
                        children: "Join Telegram Community"
                    })
                })]
            })]
        })
    };
var yCe = Object.defineProperty,
    vCe = (e, t, n) => t in e ? yCe(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n,
    iw = (e, t, n) => (vCe(e, typeof t != "symbol" ? t + "" : t, n), n);
let bCe = class {
        constructor() {
            iw(this, "current", this.detect()), iw(this, "handoffState", "pending"), iw(this, "currentId", 0)
        }
        set(t) {
            this.current !== t && (this.handoffState = "pending", this.currentId = 0, this.current = t)
        }
        reset() {
            this.set(this.detect())
        }
        nextId() {
            return ++this.currentId
        }
        get isServer() {
            return this.current === "server"
        }
        get isClient() {
            return this.current === "client"
        }
        detect() {
            return typeof window > "u" || typeof document > "u" ? "server" : "client"
        }
        handoff() {
            this.handoffState === "pending" && (this.handoffState = "complete")
        }
        get isHandoffComplete() {
            return this.handoffState === "complete"
        }
    },
    Ki = new bCe,
    lo = (e, t) => {
        Ki.isServer ? S.useEffect(e, t) : S.useLayoutEffect(e, t)
    };

function b0(e) {
    let t = S.useRef(e);
    return lo(() => {
        t.current = e
    }, [e]), t
}
let an = function(e) {
    let t = b0(e);
    return R.useCallback((...n) => t.current(...n), [t])
};

function w0(e) {
    typeof queueMicrotask == "function" ? queueMicrotask(e) : Promise.resolve().then(e).catch(t => setTimeout(() => {
        throw t
    }))
}

function x0() {
    let e = [],
        t = {
            addEventListener(n, r, i, o) {
                return n.addEventListener(r, i, o), t.add(() => n.removeEventListener(r, i, o))
            },
            requestAnimationFrame(...n) {
                let r = requestAnimationFrame(...n);
                return t.add(() => cancelAnimationFrame(r))
            },
            nextFrame(...n) {
                return t.requestAnimationFrame(() => t.requestAnimationFrame(...n))
            },
            setTimeout(...n) {
                let r = setTimeout(...n);
                return t.add(() => clearTimeout(r))
            },
            microTask(...n) {
                let r = {
                    current: !0
                };
                return w0(() => {
                    r.current && n[0]()
                }), t.add(() => {
                    r.current = !1
                })
            },
            style(n, r, i) {
                let o = n.style.getPropertyValue(r);
                return Object.assign(n.style, {
                    [r]: i
                }), this.add(() => {
                    Object.assign(n.style, {
                        [r]: o
                    })
                })
            },
            group(n) {
                let r = x0();
                return n(r), this.add(() => r.dispose())
            },
            add(n) {
                return e.push(n), () => {
                    let r = e.indexOf(n);
                    if (r >= 0)
                        for (let i of e.splice(r, 1)) i()
                }
            },
            dispose() {
                for (let n of e.splice(0)) n()
            }
        };
    return t
}

function wCe() {
    let [e] = S.useState(x0);
    return S.useEffect(() => () => e.dispose(), [e]), e
}

function xCe() {
    let e = typeof document > "u";
    return "useSyncExternalStore" in wf ? (t => t.useSyncExternalStore)(wf)(() => () => {}, () => !1, () => !e) : !1
}

function A0() {
    let e = xCe(),
        [t, n] = S.useState(Ki.isHandoffComplete);
    return t && Ki.isHandoffComplete === !1 && n(!1), S.useEffect(() => {
        t !== !0 && n(!0)
    }, [t]), S.useEffect(() => Ki.handoff(), []), e ? !1 : t
}
var mN;
let lc = (mN = R.useId) != null ? mN : function() {
    let e = A0(),
        [t, n] = R.useState(e ? () => Ki.nextId() : null);
    return lo(() => {
        t === null && n(Ki.nextId())
    }, [t]), t != null ? "" + t : void 0
};

function la(e, t, ...n) {
    if (e in t) {
        let i = t[e];
        return typeof i == "function" ? i(...n) : i
    }
    let r = new Error(`Tried to handle "${e}" but there is no handler defined. Only defined handlers are: ${Object.keys(t).map(i=>`"${i}"`).join(", ")}.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, la), r
}

function p8(e) {
    return Ki.isServer ? null : e instanceof Node ? e.ownerDocument : e != null && e.hasOwnProperty("current") && e.current instanceof Node ? e.current.ownerDocument : document
}
let MA = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map(e => `${e}:not([tabindex='-1'])`).join(",");
var Ba = (e => (e[e.First = 1] = "First", e[e.Previous = 2] = "Previous", e[e.Next = 4] = "Next", e[e.Last = 8] = "Last", e[e.WrapAround = 16] = "WrapAround", e[e.NoScroll = 32] = "NoScroll", e))(Ba || {}),
    m8 = (e => (e[e.Error = 0] = "Error", e[e.Overflow = 1] = "Overflow", e[e.Success = 2] = "Success", e[e.Underflow = 3] = "Underflow", e))(m8 || {}),
    ACe = (e => (e[e.Previous = -1] = "Previous", e[e.Next = 1] = "Next", e))(ACe || {});

function ECe(e = document.body) {
    return e == null ? [] : Array.from(e.querySelectorAll(MA)).sort((t, n) => Math.sign((t.tabIndex || Number.MAX_SAFE_INTEGER) - (n.tabIndex || Number.MAX_SAFE_INTEGER)))
}
var g8 = (e => (e[e.Strict = 0] = "Strict", e[e.Loose = 1] = "Loose", e))(g8 || {});

function SCe(e, t = 0) {
    var n;
    return e === ((n = p8(e)) == null ? void 0 : n.body) ? !1 : la(t, {
        0() {
            return e.matches(MA)
        },
        1() {
            let r = e;
            for (; r !== null;) {
                if (r.matches(MA)) return !0;
                r = r.parentElement
            }
            return !1
        }
    })
}
var _Ce = (e => (e[e.Keyboard = 0] = "Keyboard", e[e.Mouse = 1] = "Mouse", e))(_Ce || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", e => {
    e.metaKey || e.altKey || e.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "")
}, !0), document.addEventListener("click", e => {
    e.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "")
}, !0));

function ds(e) {
    e == null || e.focus({
        preventScroll: !0
    })
}
let TCe = ["textarea", "input"].join(",");

function PCe(e) {
    var t, n;
    return (n = (t = e == null ? void 0 : e.matches) == null ? void 0 : t.call(e, TCe)) != null ? n : !1
}

function OCe(e, t = n => n) {
    return e.slice().sort((n, r) => {
        let i = t(n),
            o = t(r);
        if (i === null || o === null) return 0;
        let a = i.compareDocumentPosition(o);
        return a & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : a & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0
    })
}

function Jp(e, t, {
    sorted: n = !0,
    relativeTo: r = null,
    skipElements: i = []
} = {}) {
    let o = Array.isArray(e) ? e.length > 0 ? e[0].ownerDocument : document : e.ownerDocument,
        a = Array.isArray(e) ? n ? OCe(e) : e : ECe(e);
    i.length > 0 && a.length > 1 && (a = a.filter(h => !i.includes(h))), r = r ? ? o.activeElement;
    let s = (() => {
            if (t & 5) return 1;
            if (t & 10) return -1;
            throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")
        })(),
        u = (() => {
            if (t & 1) return 0;
            if (t & 2) return Math.max(0, a.indexOf(r)) - 1;
            if (t & 4) return Math.max(0, a.indexOf(r)) + 1;
            if (t & 8) return a.length - 1;
            throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")
        })(),
        l = t & 32 ? {
            preventScroll: !0
        } : {},
        c = 0,
        f = a.length,
        d;
    do {
        if (c >= f || c + f <= 0) return 0;
        let h = u + c;
        if (t & 16) h = (h + f) % f;
        else {
            if (h < 0) return 3;
            if (h >= f) return 1
        }
        d = a[h], d == null || d.focus(l), c += s
    } while (d !== o.activeElement);
    return t & 6 && PCe(d) && d.select(), 2
}

function y8() {
    return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0
}

function kCe() {
    return /Android/gi.test(window.navigator.userAgent)
}

function CCe() {
    return y8() || kCe()
}

function Sp(e, t, n) {
    let r = b0(t);
    S.useEffect(() => {
        function i(o) {
            r.current(o)
        }
        return document.addEventListener(e, i, n), () => document.removeEventListener(e, i, n)
    }, [e, n])
}

function v8(e, t, n) {
    let r = b0(t);
    S.useEffect(() => {
        function i(o) {
            r.current(o)
        }
        return window.addEventListener(e, i, n), () => window.removeEventListener(e, i, n)
    }, [e, n])
}

function ICe(e, t, n = !0) {
    let r = S.useRef(!1);
    S.useEffect(() => {
        requestAnimationFrame(() => {
            r.current = n
        })
    }, [n]);

    function i(a, s) {
        if (!r.current || a.defaultPrevented) return;
        let u = s(a);
        if (u === null || !u.getRootNode().contains(u) || !u.isConnected) return;
        let l = function c(f) {
            return typeof f == "function" ? c(f()) : Array.isArray(f) || f instanceof Set ? f : [f]
        }(e);
        for (let c of l) {
            if (c === null) continue;
            let f = c instanceof HTMLElement ? c : c.current;
            if (f != null && f.contains(u) || a.composed && a.composedPath().includes(f)) return
        }
        return !SCe(u, g8.Loose) && u.tabIndex !== -1 && a.preventDefault(), t(a, u)
    }
    let o = S.useRef(null);
    Sp("pointerdown", a => {
        var s, u;
        r.current && (o.current = ((u = (s = a.composedPath) == null ? void 0 : s.call(a)) == null ? void 0 : u[0]) || a.target)
    }, !0), Sp("mousedown", a => {
        var s, u;
        r.current && (o.current = ((u = (s = a.composedPath) == null ? void 0 : s.call(a)) == null ? void 0 : u[0]) || a.target)
    }, !0), Sp("click", a => {
        CCe() || o.current && (i(a, () => o.current), o.current = null)
    }, !0), Sp("touchend", a => i(a, () => a.target instanceof HTMLElement ? a.target : null), !0), v8("blur", a => i(a, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0)
}

function Ch(...e) {
    return S.useMemo(() => p8(...e), [...e])
}
let b8 = Symbol();

function MCe(e, t = !0) {
    return Object.assign(e, {
        [b8]: t
    })
}

function xo(...e) {
    let t = S.useRef(e);
    S.useEffect(() => {
        t.current = e
    }, [e]);
    let n = an(r => {
        for (let i of t.current) i != null && (typeof i == "function" ? i(r) : i.current = r)
    });
    return e.every(r => r == null || (r == null ? void 0 : r[b8])) ? void 0 : n
}

function OT(e, t) {
    let n = S.useRef([]),
        r = an(e);
    S.useEffect(() => {
        let i = [...n.current];
        for (let [o, a] of t.entries())
            if (n.current[o] !== a) {
                let s = r(t, i);
                return n.current = t, s
            }
    }, [r, ...t])
}

function gN(...e) {
    return Array.from(new Set(e.flatMap(t => typeof t == "string" ? t.split(" ") : []))).filter(Boolean).join(" ")
}
var NA = (e => (e[e.None = 0] = "None", e[e.RenderStrategy = 1] = "RenderStrategy", e[e.Static = 2] = "Static", e))(NA || {}),
    NCe = (e => (e[e.Unmount = 0] = "Unmount", e[e.Hidden = 1] = "Hidden", e))(NCe || {});

function wi({
    ourProps: e,
    theirProps: t,
    slot: n,
    defaultTag: r,
    features: i,
    visible: o = !0,
    name: a,
    mergeRefs: s
}) {
    s = s ? ? RCe;
    let u = w8(t, e);
    if (o) return _p(u, n, r, a, s);
    let l = i ? ? 0;
    if (l & 2) {
        let {
            static: c = !1,
            ...f
        } = u;
        if (c) return _p(f, n, r, a, s)
    }
    if (l & 1) {
        let {
            unmount: c = !0,
            ...f
        } = u;
        return la(c ? 0 : 1, {
            0() {
                return null
            },
            1() {
                return _p({ ...f,
                    hidden: !0,
                    style: {
                        display: "none"
                    }
                }, n, r, a, s)
            }
        })
    }
    return _p(u, n, r, a, s)
}

function _p(e, t = {}, n, r, i) {
    let {
        as: o = n,
        children: a,
        refName: s = "ref",
        ...u
    } = ow(e, ["unmount", "static"]), l = e.ref !== void 0 ? {
        [s]: e.ref
    } : {}, c = typeof a == "function" ? a(t) : a;
    "className" in u && u.className && typeof u.className == "function" && (u.className = u.className(t));
    let f = {};
    if (t) {
        let d = !1,
            h = [];
        for (let [m, p] of Object.entries(t)) typeof p == "boolean" && (d = !0), p === !0 && h.push(m);
        d && (f["data-headlessui-state"] = h.join(" "))
    }
    if (o === S.Fragment && Object.keys(yN(u)).length > 0) {
        if (!S.isValidElement(c) || Array.isArray(c) && c.length > 1) throw new Error(['Passing props on "Fragment"!', "", `The current component <${r} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(u).map(p => `  - ${p}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map(p => `  - ${p}`).join(`
`)].join(`
`));
        let d = c.props,
            h = typeof(d == null ? void 0 : d.className) == "function" ? (...p) => gN(d == null ? void 0 : d.className(...p), u.className) : gN(d == null ? void 0 : d.className, u.className),
            m = h ? {
                className: h
            } : {};
        return S.cloneElement(c, Object.assign({}, w8(c.props, yN(ow(u, ["ref"]))), f, l, {
            ref: i(c.ref, l.ref)
        }, m))
    }
    return S.createElement(o, Object.assign({}, ow(u, ["ref"]), o !== S.Fragment && l, o !== S.Fragment && f), c)
}

function RCe(...e) {
    return e.every(t => t == null) ? void 0 : t => {
        for (let n of e) n != null && (typeof n == "function" ? n(t) : n.current = t)
    }
}

function w8(...e) {
    if (e.length === 0) return {};
    if (e.length === 1) return e[0];
    let t = {},
        n = {};
    for (let r of e)
        for (let i in r) i.startsWith("on") && typeof r[i] == "function" ? (n[i] != null || (n[i] = []), n[i].push(r[i])) : t[i] = r[i];
    if (t.disabled || t["aria-disabled"]) return Object.assign(t, Object.fromEntries(Object.keys(n).map(r => [r, void 0])));
    for (let r in n) Object.assign(t, {
        [r](i, ...o) {
            let a = n[r];
            for (let s of a) {
                if ((i instanceof Event || (i == null ? void 0 : i.nativeEvent) instanceof Event) && i.defaultPrevented) return;
                s(i, ...o)
            }
        }
    });
    return t
}

function xi(e) {
    var t;
    return Object.assign(S.forwardRef(e), {
        displayName: (t = e.displayName) != null ? t : e.name
    })
}

function yN(e) {
    let t = Object.assign({}, e);
    for (let n in t) t[n] === void 0 && delete t[n];
    return t
}

function ow(e, t = []) {
    let n = Object.assign({}, e);
    for (let r of t) r in n && delete n[r];
    return n
}
let jCe = "div";
var Iy = (e => (e[e.None = 1] = "None", e[e.Focusable = 2] = "Focusable", e[e.Hidden = 4] = "Hidden", e))(Iy || {});

function BCe(e, t) {
    var n;
    let {
        features: r = 1,
        ...i
    } = e, o = {
        ref: t,
        "aria-hidden": (r & 2) === 2 ? !0 : (n = i["aria-hidden"]) != null ? n : void 0,
        hidden: (r & 4) === 4 ? !0 : void 0,
        style: {
            position: "fixed",
            top: 1,
            left: 1,
            width: 1,
            height: 0,
            padding: 0,
            margin: -1,
            overflow: "hidden",
            clip: "rect(0, 0, 0, 0)",
            whiteSpace: "nowrap",
            borderWidth: "0",
            ...(r & 4) === 4 && (r & 2) !== 2 && {
                display: "none"
            }
        }
    };
    return wi({
        ourProps: o,
        theirProps: i,
        slot: {},
        defaultTag: jCe,
        name: "Hidden"
    })
}
let RA = xi(BCe),
    x8 = S.createContext(null);
x8.displayName = "OpenClosedContext";
var Kc = (e => (e[e.Open = 1] = "Open", e[e.Closed = 2] = "Closed", e[e.Closing = 4] = "Closing", e[e.Opening = 8] = "Opening", e))(Kc || {});

function DCe() {
    return S.useContext(x8)
}

function $Ce(e) {
    function t() {
        document.readyState !== "loading" && (e(), document.removeEventListener("DOMContentLoaded", t))
    }
    typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", t), t())
}
let jo = [];
$Ce(() => {
    function e(t) {
        t.target instanceof HTMLElement && t.target !== document.body && jo[0] !== t.target && (jo.unshift(t.target), jo = jo.filter(n => n != null && n.isConnected), jo.splice(10))
    }
    window.addEventListener("click", e, {
        capture: !0
    }), window.addEventListener("mousedown", e, {
        capture: !0
    }), window.addEventListener("focus", e, {
        capture: !0
    }), document.body.addEventListener("click", e, {
        capture: !0
    }), document.body.addEventListener("mousedown", e, {
        capture: !0
    }), document.body.addEventListener("focus", e, {
        capture: !0
    })
});

function LCe(e) {
    let t = e.parentElement,
        n = null;
    for (; t && !(t instanceof HTMLFieldSetElement);) t instanceof HTMLLegendElement && (n = t), t = t.parentElement;
    let r = (t == null ? void 0 : t.getAttribute("disabled")) === "";
    return r && FCe(n) ? !1 : r
}

function FCe(e) {
    if (!e) return !1;
    let t = e.previousElementSibling;
    for (; t !== null;) {
        if (t instanceof HTMLLegendElement) return !1;
        t = t.previousElementSibling
    }
    return !0
}
var A8 = (e => (e.Space = " ", e.Enter = "Enter", e.Escape = "Escape", e.Backspace = "Backspace", e.Delete = "Delete", e.ArrowLeft = "ArrowLeft", e.ArrowUp = "ArrowUp", e.ArrowRight = "ArrowRight", e.ArrowDown = "ArrowDown", e.Home = "Home", e.End = "End", e.PageUp = "PageUp", e.PageDown = "PageDown", e.Tab = "Tab", e))(A8 || {});

function E8(e, t, n, r) {
    let i = b0(n);
    S.useEffect(() => {
        e = e ? ? window;

        function o(a) {
            i.current(a)
        }
        return e.addEventListener(t, o, r), () => e.removeEventListener(t, o, r)
    }, [e, t, r])
}

function S8() {
    let e = S.useRef(!1);
    return lo(() => (e.current = !0, () => {
        e.current = !1
    }), []), e
}

function _8(e) {
    let t = an(e),
        n = S.useRef(!1);
    S.useEffect(() => (n.current = !1, () => {
        n.current = !0, w0(() => {
            n.current && t()
        })
    }), [t])
}
var Qc = (e => (e[e.Forwards = 0] = "Forwards", e[e.Backwards = 1] = "Backwards", e))(Qc || {});

function UCe() {
    let e = S.useRef(0);
    return v8("keydown", t => {
        t.key === "Tab" && (e.current = t.shiftKey ? 1 : 0)
    }, !0), e
}

function T8(e) {
    if (!e) return new Set;
    if (typeof e == "function") return new Set(e());
    let t = new Set;
    for (let n of e.current) n.current instanceof HTMLElement && t.add(n.current);
    return t
}
let HCe = "div";
var P8 = (e => (e[e.None = 1] = "None", e[e.InitialFocus = 2] = "InitialFocus", e[e.TabLock = 4] = "TabLock", e[e.FocusLock = 8] = "FocusLock", e[e.RestoreFocus = 16] = "RestoreFocus", e[e.All = 30] = "All", e))(P8 || {});

function VCe(e, t) {
    let n = S.useRef(null),
        r = xo(n, t),
        {
            initialFocus: i,
            containers: o,
            features: a = 30,
            ...s
        } = e;
    A0() || (a = 1);
    let u = Ch(n);
    GCe({
        ownerDocument: u
    }, !!(a & 16));
    let l = qCe({
        ownerDocument: u,
        container: n,
        initialFocus: i
    }, !!(a & 2));
    KCe({
        ownerDocument: u,
        container: n,
        containers: o,
        previousActiveElement: l
    }, !!(a & 8));
    let c = UCe(),
        f = an(p => {
            let y = n.current;
            y && (g => g())(() => {
                la(c.current, {
                    [Qc.Forwards]: () => {
                        Jp(y, Ba.First, {
                            skipElements: [p.relatedTarget]
                        })
                    },
                    [Qc.Backwards]: () => {
                        Jp(y, Ba.Last, {
                            skipElements: [p.relatedTarget]
                        })
                    }
                })
            })
        }),
        d = wCe(),
        h = S.useRef(!1),
        m = {
            ref: r,
            onKeyDown(p) {
                p.key == "Tab" && (h.current = !0, d.requestAnimationFrame(() => {
                    h.current = !1
                }))
            },
            onBlur(p) {
                let y = T8(o);
                n.current instanceof HTMLElement && y.add(n.current);
                let g = p.relatedTarget;
                g instanceof HTMLElement && g.dataset.headlessuiFocusGuard !== "true" && (O8(y, g) || (h.current ? Jp(n.current, la(c.current, {
                    [Qc.Forwards]: () => Ba.Next,
                    [Qc.Backwards]: () => Ba.Previous
                }) | Ba.WrapAround, {
                    relativeTo: p.target
                }) : p.target instanceof HTMLElement && ds(p.target)))
            }
        };
    return R.createElement(R.Fragment, null, !!(a & 4) && R.createElement(RA, {
        as: "button",
        type: "button",
        "data-headlessui-focus-guard": !0,
        onFocus: f,
        features: Iy.Focusable
    }), wi({
        ourProps: m,
        theirProps: s,
        defaultTag: HCe,
        name: "FocusTrap"
    }), !!(a & 4) && R.createElement(RA, {
        as: "button",
        type: "button",
        "data-headlessui-focus-guard": !0,
        onFocus: f,
        features: Iy.Focusable
    }))
}
let zCe = xi(VCe),
    Dc = Object.assign(zCe, {
        features: P8
    });

function WCe(e = !0) {
    let t = S.useRef(jo.slice());
    return OT(([n], [r]) => {
        r === !0 && n === !1 && w0(() => {
            t.current.splice(0)
        }), r === !1 && n === !0 && (t.current = jo.slice())
    }, [e, jo, t]), an(() => {
        var n;
        return (n = t.current.find(r => r != null && r.isConnected)) != null ? n : null
    })
}

function GCe({
    ownerDocument: e
}, t) {
    let n = WCe(t);
    OT(() => {
        t || (e == null ? void 0 : e.activeElement) === (e == null ? void 0 : e.body) && ds(n())
    }, [t]), _8(() => {
        t && ds(n())
    })
}

function qCe({
    ownerDocument: e,
    container: t,
    initialFocus: n
}, r) {
    let i = S.useRef(null),
        o = S8();
    return OT(() => {
        if (!r) return;
        let a = t.current;
        a && w0(() => {
            if (!o.current) return;
            let s = e == null ? void 0 : e.activeElement;
            if (n != null && n.current) {
                if ((n == null ? void 0 : n.current) === s) {
                    i.current = s;
                    return
                }
            } else if (a.contains(s)) {
                i.current = s;
                return
            }
            n != null && n.current ? ds(n.current) : Jp(a, Ba.First) === m8.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), i.current = e == null ? void 0 : e.activeElement
        })
    }, [r]), i
}

function KCe({
    ownerDocument: e,
    container: t,
    containers: n,
    previousActiveElement: r
}, i) {
    let o = S8();
    E8(e == null ? void 0 : e.defaultView, "focus", a => {
        if (!i || !o.current) return;
        let s = T8(n);
        t.current instanceof HTMLElement && s.add(t.current);
        let u = r.current;
        if (!u) return;
        let l = a.target;
        l && l instanceof HTMLElement ? O8(s, l) ? (r.current = l, ds(l)) : (a.preventDefault(), a.stopPropagation(), ds(u)) : ds(r.current)
    }, !0)
}

function O8(e, t) {
    for (let n of e)
        if (n.contains(t)) return !0;
    return !1
}
let k8 = S.createContext(!1);

function QCe() {
    return S.useContext(k8)
}

function jA(e) {
    return R.createElement(k8.Provider, {
        value: e.force
    }, e.children)
}

function YCe(e) {
    let t = QCe(),
        n = S.useContext(C8),
        r = Ch(e),
        [i, o] = S.useState(() => {
            if (!t && n !== null || Ki.isServer) return null;
            let a = r == null ? void 0 : r.getElementById("headlessui-portal-root");
            if (a) return a;
            if (r === null) return null;
            let s = r.createElement("div");
            return s.setAttribute("id", "headlessui-portal-root"), r.body.appendChild(s)
        });
    return S.useEffect(() => {
        i !== null && (r != null && r.body.contains(i) || r == null || r.body.appendChild(i))
    }, [i, r]), S.useEffect(() => {
        t || n !== null && o(n.current)
    }, [n, o, t]), i
}
let XCe = S.Fragment;

function ZCe(e, t) {
    let n = e,
        r = S.useRef(null),
        i = xo(MCe(c => {
            r.current = c
        }), t),
        o = Ch(r),
        a = YCe(r),
        [s] = S.useState(() => {
            var c;
            return Ki.isServer ? null : (c = o == null ? void 0 : o.createElement("div")) != null ? c : null
        }),
        u = S.useContext(BA),
        l = A0();
    return lo(() => {
        !a || !s || a.contains(s) || (s.setAttribute("data-headlessui-portal", ""), a.appendChild(s))
    }, [a, s]), lo(() => {
        if (s && u) return u.register(s)
    }, [u, s]), _8(() => {
        var c;
        !a || !s || (s instanceof Node && a.contains(s) && a.removeChild(s), a.childNodes.length <= 0 && ((c = a.parentElement) == null || c.removeChild(a)))
    }), l ? !a || !s ? null : Nj.createPortal(wi({
        ourProps: {
            ref: i
        },
        theirProps: n,
        defaultTag: XCe,
        name: "Portal"
    }), s) : null
}
let JCe = S.Fragment,
    C8 = S.createContext(null);

function eIe(e, t) {
    let {
        target: n,
        ...r
    } = e, i = {
        ref: xo(t)
    };
    return R.createElement(C8.Provider, {
        value: n
    }, wi({
        ourProps: i,
        theirProps: r,
        defaultTag: JCe,
        name: "Popover.Group"
    }))
}
let BA = S.createContext(null);

function tIe() {
    let e = S.useContext(BA),
        t = S.useRef([]),
        n = an(o => (t.current.push(o), e && e.register(o), () => r(o))),
        r = an(o => {
            let a = t.current.indexOf(o);
            a !== -1 && t.current.splice(a, 1), e && e.unregister(o)
        }),
        i = S.useMemo(() => ({
            register: n,
            unregister: r,
            portals: t
        }), [n, r, t]);
    return [t, S.useMemo(() => function({
        children: o
    }) {
        return R.createElement(BA.Provider, {
            value: i
        }, o)
    }, [i])]
}
let nIe = xi(ZCe),
    rIe = xi(eIe),
    DA = Object.assign(nIe, {
        Group: rIe
    });

function iIe(e, t) {
    return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t
}
const oIe = typeof Object.is == "function" ? Object.is : iIe,
    {
        useState: aIe,
        useEffect: sIe,
        useLayoutEffect: uIe,
        useDebugValue: lIe
    } = wf;

function cIe(e, t, n) {
    const r = t(),
        [{
            inst: i
        }, o] = aIe({
            inst: {
                value: r,
                getSnapshot: t
            }
        });
    return uIe(() => {
        i.value = r, i.getSnapshot = t, aw(i) && o({
            inst: i
        })
    }, [e, r, t]), sIe(() => (aw(i) && o({
        inst: i
    }), e(() => {
        aw(i) && o({
            inst: i
        })
    })), [e]), lIe(r), r
}

function aw(e) {
    const t = e.getSnapshot,
        n = e.value;
    try {
        const r = t();
        return !oIe(n, r)
    } catch {
        return !0
    }
}

function fIe(e, t, n) {
    return t()
}
const dIe = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u",
    hIe = !dIe,
    pIe = hIe ? fIe : cIe,
    mIe = "useSyncExternalStore" in wf ? (e => e.useSyncExternalStore)(wf) : pIe;

function gIe(e) {
    return mIe(e.subscribe, e.getSnapshot, e.getSnapshot)
}

function yIe(e, t) {
    let n = e(),
        r = new Set;
    return {
        getSnapshot() {
            return n
        },
        subscribe(i) {
            return r.add(i), () => r.delete(i)
        },
        dispatch(i, ...o) {
            let a = t[i].call(n, ...o);
            a && (n = a, r.forEach(s => s()))
        }
    }
}

function vIe() {
    let e;
    return {
        before({
            doc: t
        }) {
            var n;
            let r = t.documentElement;
            e = ((n = t.defaultView) != null ? n : window).innerWidth - r.clientWidth
        },
        after({
            doc: t,
            d: n
        }) {
            let r = t.documentElement,
                i = r.clientWidth - r.offsetWidth,
                o = e - i;
            n.style(r, "paddingRight", `${o}px`)
        }
    }
}

function bIe() {
    return y8() ? {
        before({
            doc: e,
            d: t,
            meta: n
        }) {
            function r(i) {
                return n.containers.flatMap(o => o()).some(o => o.contains(i))
            }
            t.microTask(() => {
                var i;
                if (window.getComputedStyle(e.documentElement).scrollBehavior !== "auto") {
                    let s = x0();
                    s.style(e.documentElement, "scrollBehavior", "auto"), t.add(() => t.microTask(() => s.dispose()))
                }
                let o = (i = window.scrollY) != null ? i : window.pageYOffset,
                    a = null;
                t.addEventListener(e, "click", s => {
                    if (s.target instanceof HTMLElement) try {
                        let u = s.target.closest("a");
                        if (!u) return;
                        let {
                            hash: l
                        } = new URL(u.href), c = e.querySelector(l);
                        c && !r(c) && (a = c)
                    } catch {}
                }, !0), t.addEventListener(e, "touchstart", s => {
                    if (s.target instanceof HTMLElement)
                        if (r(s.target)) {
                            let u = s.target;
                            for (; u.parentElement && r(u.parentElement);) u = u.parentElement;
                            t.style(u, "overscrollBehavior", "contain")
                        } else t.style(s.target, "touchAction", "none")
                }), t.addEventListener(e, "touchmove", s => {
                    if (s.target instanceof HTMLElement)
                        if (r(s.target)) {
                            let u = s.target;
                            for (; u.parentElement && u.dataset.headlessuiPortal !== "" && !(u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth);) u = u.parentElement;
                            u.dataset.headlessuiPortal === "" && s.preventDefault()
                        } else s.preventDefault()
                }, {
                    passive: !1
                }), t.add(() => {
                    var s;
                    let u = (s = window.scrollY) != null ? s : window.pageYOffset;
                    o !== u && window.scrollTo(0, o), a && a.isConnected && (a.scrollIntoView({
                        block: "nearest"
                    }), a = null)
                })
            })
        }
    } : {}
}

function wIe() {
    return {
        before({
            doc: e,
            d: t
        }) {
            t.style(e.documentElement, "overflow", "hidden")
        }
    }
}

function xIe(e) {
    let t = {};
    for (let n of e) Object.assign(t, n(t));
    return t
}
let Za = yIe(() => new Map, {
    PUSH(e, t) {
        var n;
        let r = (n = this.get(e)) != null ? n : {
            doc: e,
            count: 0,
            d: x0(),
            meta: new Set
        };
        return r.count++, r.meta.add(t), this.set(e, r), this
    },
    POP(e, t) {
        let n = this.get(e);
        return n && (n.count--, n.meta.delete(t)), this
    },
    SCROLL_PREVENT({
        doc: e,
        d: t,
        meta: n
    }) {
        let r = {
                doc: e,
                d: t,
                meta: xIe(n)
            },
            i = [bIe(), vIe(), wIe()];
        i.forEach(({
            before: o
        }) => o == null ? void 0 : o(r)), i.forEach(({
            after: o
        }) => o == null ? void 0 : o(r))
    },
    SCROLL_ALLOW({
        d: e
    }) {
        e.dispose()
    },
    TEARDOWN({
        doc: e
    }) {
        this.delete(e)
    }
});
Za.subscribe(() => {
    let e = Za.getSnapshot(),
        t = new Map;
    for (let [n] of e) t.set(n, n.documentElement.style.overflow);
    for (let n of e.values()) {
        let r = t.get(n.doc) === "hidden",
            i = n.count !== 0;
        (i && !r || !i && r) && Za.dispatch(n.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", n), n.count === 0 && Za.dispatch("TEARDOWN", n)
    }
});

function AIe(e, t, n) {
    let r = gIe(Za),
        i = e ? r.get(e) : void 0,
        o = i ? i.count > 0 : !1;
    return lo(() => {
        if (!(!e || !t)) return Za.dispatch("PUSH", e, n), () => Za.dispatch("POP", e, n)
    }, [t, e]), o
}
let sw = new Map,
    $c = new Map;

function vN(e, t = !0) {
    lo(() => {
        var n;
        if (!t) return;
        let r = typeof e == "function" ? e() : e.current;
        if (!r) return;

        function i() {
            var a;
            if (!r) return;
            let s = (a = $c.get(r)) != null ? a : 1;
            if (s === 1 ? $c.delete(r) : $c.set(r, s - 1), s !== 1) return;
            let u = sw.get(r);
            u && (u["aria-hidden"] === null ? r.removeAttribute("aria-hidden") : r.setAttribute("aria-hidden", u["aria-hidden"]), r.inert = u.inert, sw.delete(r))
        }
        let o = (n = $c.get(r)) != null ? n : 0;
        return $c.set(r, o + 1), o !== 0 || (sw.set(r, {
            "aria-hidden": r.getAttribute("aria-hidden"),
            inert: r.inert
        }), r.setAttribute("aria-hidden", "true"), r.inert = !0), i
    }, [e, t])
}

function EIe({
    defaultContainers: e = [],
    portals: t,
    mainTreeNodeRef: n
} = {}) {
    var r;
    let i = S.useRef((r = n == null ? void 0 : n.current) != null ? r : null),
        o = Ch(i),
        a = an(() => {
            var s, u, l;
            let c = [];
            for (let f of e) f !== null && (f instanceof HTMLElement ? c.push(f) : "current" in f && f.current instanceof HTMLElement && c.push(f.current));
            if (t != null && t.current)
                for (let f of t.current) c.push(f);
            for (let f of (s = o == null ? void 0 : o.querySelectorAll("html > *, body > *")) != null ? s : []) f !== document.body && f !== document.head && f instanceof HTMLElement && f.id !== "headlessui-portal-root" && (f.contains(i.current) || f.contains((l = (u = i.current) == null ? void 0 : u.getRootNode()) == null ? void 0 : l.host) || c.some(d => f.contains(d)) || c.push(f));
            return c
        });
    return {
        resolveContainers: a,
        contains: an(s => a().some(u => u.contains(s))),
        mainTreeNodeRef: i,
        MainTreeNode: S.useMemo(() => function() {
            return n != null ? null : R.createElement(RA, {
                features: Iy.Hidden,
                ref: i
            })
        }, [i, n])
    }
}
let kT = S.createContext(() => {});
kT.displayName = "StackContext";
var $A = (e => (e[e.Add = 0] = "Add", e[e.Remove = 1] = "Remove", e))($A || {});

function SIe() {
    return S.useContext(kT)
}

function _Ie({
    children: e,
    onUpdate: t,
    type: n,
    element: r,
    enabled: i
}) {
    let o = SIe(),
        a = an((...s) => {
            t == null || t(...s), o(...s)
        });
    return lo(() => {
        let s = i === void 0 || i === !0;
        return s && a(0, n, r), () => {
            s && a(1, n, r)
        }
    }, [a, n, r, i]), R.createElement(kT.Provider, {
        value: a
    }, e)
}
let I8 = S.createContext(null);

function M8() {
    let e = S.useContext(I8);
    if (e === null) {
        let t = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
        throw Error.captureStackTrace && Error.captureStackTrace(t, M8), t
    }
    return e
}

function TIe() {
    let [e, t] = S.useState([]);
    return [e.length > 0 ? e.join(" ") : void 0, S.useMemo(() => function(n) {
        let r = an(o => (t(a => [...a, o]), () => t(a => {
                let s = a.slice(),
                    u = s.indexOf(o);
                return u !== -1 && s.splice(u, 1), s
            }))),
            i = S.useMemo(() => ({
                register: r,
                slot: n.slot,
                name: n.name,
                props: n.props
            }), [r, n.slot, n.name, n.props]);
        return R.createElement(I8.Provider, {
            value: i
        }, n.children)
    }, [t])]
}
let PIe = "p";

function OIe(e, t) {
    let n = lc(),
        {
            id: r = `headlessui-description-${n}`,
            ...i
        } = e,
        o = M8(),
        a = xo(t);
    lo(() => o.register(r), [r, o.register]);
    let s = {
        ref: a,
        ...o.props,
        id: r
    };
    return wi({
        ourProps: s,
        theirProps: i,
        slot: o.slot || {},
        defaultTag: PIe,
        name: o.name || "Description"
    })
}
let kIe = xi(OIe),
    CIe = Object.assign(kIe, {});
var IIe = (e => (e[e.Open = 0] = "Open", e[e.Closed = 1] = "Closed", e))(IIe || {}),
    MIe = (e => (e[e.SetTitleId = 0] = "SetTitleId", e))(MIe || {});
let NIe = {
        0(e, t) {
            return e.titleId === t.id ? e : { ...e,
                titleId: t.id
            }
        }
    },
    My = S.createContext(null);
My.displayName = "DialogContext";

function Ih(e) {
    let t = S.useContext(My);
    if (t === null) {
        let n = new Error(`<${e} /> is missing a parent <Dialog /> component.`);
        throw Error.captureStackTrace && Error.captureStackTrace(n, Ih), n
    }
    return t
}

function RIe(e, t, n = () => [document.body]) {
    AIe(e, t, r => {
        var i;
        return {
            containers: [...(i = r.containers) != null ? i : [], n]
        }
    })
}

function jIe(e, t) {
    return la(t.type, NIe, e, t)
}
let BIe = "div",
    DIe = NA.RenderStrategy | NA.Static;

function $Ie(e, t) {
    let n = lc(),
        {
            id: r = `headlessui-dialog-${n}`,
            open: i,
            onClose: o,
            initialFocus: a,
            role: s = "dialog",
            __demoMode: u = !1,
            ...l
        } = e,
        [c, f] = S.useState(0),
        d = S.useRef(!1);
    s = function() {
        return s === "dialog" || s === "alertdialog" ? s : (d.current || (d.current = !0, console.warn(`Invalid role [${s}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog")
    }();
    let h = DCe();
    i === void 0 && h !== null && (i = (h & Kc.Open) === Kc.Open);
    let m = S.useRef(null),
        p = xo(m, t),
        y = Ch(m),
        g = e.hasOwnProperty("open") || h !== null,
        b = e.hasOwnProperty("onClose");
    if (!g && !b) throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
    if (!g) throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
    if (!b) throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
    if (typeof i != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${i}`);
    if (typeof o != "function") throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${o}`);
    let v = i ? 0 : 1,
        [A, w] = S.useReducer(jIe, {
            titleId: null,
            descriptionId: null,
            panelRef: S.createRef()
        }),
        x = an(() => o(!1)),
        T = an(re => w({
            type: 0,
            id: re
        })),
        _ = A0() ? u ? !1 : v === 0 : !1,
        O = c > 1,
        k = S.useContext(My) !== null,
        [I, M] = tIe(),
        B = {
            get current() {
                var re;
                return (re = A.panelRef.current) != null ? re : m.current
            }
        },
        {
            resolveContainers: L,
            mainTreeNodeRef: P,
            MainTreeNode: C
        } = EIe({
            portals: I,
            defaultContainers: [B]
        }),
        j = O ? "parent" : "leaf",
        N = h !== null ? (h & Kc.Closing) === Kc.Closing : !1,
        D = k || N ? !1 : _,
        $ = S.useCallback(() => {
            var re, z;
            return (z = Array.from((re = y == null ? void 0 : y.querySelectorAll("body > *")) != null ? re : []).find(he => he.id === "headlessui-portal-root" ? !1 : he.contains(P.current) && he instanceof HTMLElement)) != null ? z : null
        }, [P]);
    vN($, D);
    let V = O ? !0 : _,
        H = S.useCallback(() => {
            var re, z;
            return (z = Array.from((re = y == null ? void 0 : y.querySelectorAll("[data-headlessui-portal]")) != null ? re : []).find(he => he.contains(P.current) && he instanceof HTMLElement)) != null ? z : null
        }, [P]);
    vN(H, V), ICe(L, re => {
        re.preventDefault(), x()
    }, !(!_ || O));
    let X = !(O || v !== 0);
    E8(y == null ? void 0 : y.defaultView, "keydown", re => {
        X && (re.defaultPrevented || re.key === A8.Escape && (re.preventDefault(), re.stopPropagation(), x()))
    }), RIe(y, !(N || v !== 0 || k), L), S.useEffect(() => {
        if (v !== 0 || !m.current) return;
        let re = new ResizeObserver(z => {
            for (let he of z) {
                let me = he.target.getBoundingClientRect();
                me.x === 0 && me.y === 0 && me.width === 0 && me.height === 0 && x()
            }
        });
        return re.observe(m.current), () => re.disconnect()
    }, [v, m, x]);
    let [De, ot] = TIe(), St = S.useMemo(() => [{
        dialogState: v,
        close: x,
        setTitleId: T
    }, A], [v, A, x, T]), K = S.useMemo(() => ({
        open: v === 0
    }), [v]), ae = {
        ref: p,
        id: r,
        role: s,
        "aria-modal": v === 0 ? !0 : void 0,
        "aria-labelledby": A.titleId,
        "aria-describedby": De
    };
    return R.createElement(_Ie, {
        type: "Dialog",
        enabled: v === 0,
        element: m,
        onUpdate: an((re, z) => {
            z === "Dialog" && la(re, {
                [$A.Add]: () => f(he => he + 1),
                [$A.Remove]: () => f(he => he - 1)
            })
        })
    }, R.createElement(jA, {
        force: !0
    }, R.createElement(DA, null, R.createElement(My.Provider, {
        value: St
    }, R.createElement(DA.Group, {
        target: m
    }, R.createElement(jA, {
        force: !1
    }, R.createElement(ot, {
        slot: K,
        name: "Dialog.Description"
    }, R.createElement(Dc, {
        initialFocus: a,
        containers: L,
        features: _ ? la(j, {
            parent: Dc.features.RestoreFocus,
            leaf: Dc.features.All & ~Dc.features.FocusLock
        }) : Dc.features.None
    }, R.createElement(M, null, wi({
        ourProps: ae,
        theirProps: l,
        slot: K,
        defaultTag: BIe,
        features: DIe,
        visible: v === 0,
        name: "Dialog"
    }))))))))), R.createElement(C, null))
}
let LIe = "div";

function FIe(e, t) {
    let n = lc(),
        {
            id: r = `headlessui-dialog-overlay-${n}`,
            ...i
        } = e,
        [{
            dialogState: o,
            close: a
        }] = Ih("Dialog.Overlay"),
        s = xo(t),
        u = an(c => {
            if (c.target === c.currentTarget) {
                if (LCe(c.currentTarget)) return c.preventDefault();
                c.preventDefault(), c.stopPropagation(), a()
            }
        }),
        l = S.useMemo(() => ({
            open: o === 0
        }), [o]);
    return wi({
        ourProps: {
            ref: s,
            id: r,
            "aria-hidden": !0,
            onClick: u
        },
        theirProps: i,
        slot: l,
        defaultTag: LIe,
        name: "Dialog.Overlay"
    })
}
let UIe = "div";

function HIe(e, t) {
    let n = lc(),
        {
            id: r = `headlessui-dialog-backdrop-${n}`,
            ...i
        } = e,
        [{
            dialogState: o
        }, a] = Ih("Dialog.Backdrop"),
        s = xo(t);
    S.useEffect(() => {
        if (a.panelRef.current === null) throw new Error("A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.")
    }, [a.panelRef]);
    let u = S.useMemo(() => ({
        open: o === 0
    }), [o]);
    return R.createElement(jA, {
        force: !0
    }, R.createElement(DA, null, wi({
        ourProps: {
            ref: s,
            id: r,
            "aria-hidden": !0
        },
        theirProps: i,
        slot: u,
        defaultTag: UIe,
        name: "Dialog.Backdrop"
    })))
}
let VIe = "div";

function zIe(e, t) {
    let n = lc(),
        {
            id: r = `headlessui-dialog-panel-${n}`,
            ...i
        } = e,
        [{
            dialogState: o
        }, a] = Ih("Dialog.Panel"),
        s = xo(t, a.panelRef),
        u = S.useMemo(() => ({
            open: o === 0
        }), [o]),
        l = an(c => {
            c.stopPropagation()
        });
    return wi({
        ourProps: {
            ref: s,
            id: r,
            onClick: l
        },
        theirProps: i,
        slot: u,
        defaultTag: VIe,
        name: "Dialog.Panel"
    })
}
let WIe = "h2";

function GIe(e, t) {
    let n = lc(),
        {
            id: r = `headlessui-dialog-title-${n}`,
            ...i
        } = e,
        [{
            dialogState: o,
            setTitleId: a
        }] = Ih("Dialog.Title"),
        s = xo(t);
    S.useEffect(() => (a(r), () => a(null)), [r, a]);
    let u = S.useMemo(() => ({
        open: o === 0
    }), [o]);
    return wi({
        ourProps: {
            ref: s,
            id: r
        },
        theirProps: i,
        slot: u,
        defaultTag: WIe,
        name: "Dialog.Title"
    })
}
let qIe = xi($Ie),
    KIe = xi(HIe),
    QIe = xi(zIe),
    YIe = xi(FIe),
    XIe = xi(GIe),
    uw = Object.assign(qIe, {
        Backdrop: KIe,
        Panel: QIe,
        Overlay: YIe,
        Title: XIe,
        Description: CIe
    });
const N8 = ({
        isOpen: e,
        onClose: t
    }) => {
        const {
            connectWithMetaMask: n,
            connectWithWalletConnect: r
        } = Ov(), [i, o] = S.useState(null), [a, s] = S.useState(!1), u = async () => {
            try {
                o(null), s(!0), await n(), t()
            } catch (c) {
                console.error("MetaMask connection error:", c), o(c.message || "Failed to connect with MetaMask")
            } finally {
                s(!1)
            }
        }, l = async () => {
            try {
                o(null), s(!0), await r(), t()
            } catch (c) {
                console.error("WalletConnect error:", c), o(c.message || "Failed to connect with WalletConnect")
            } finally {
                s(!1)
            }
        };
        return E.jsxs(uw, {
            open: e,
            onClose: t,
            className: "relative z-50",
            children: [E.jsx("div", {
                className: "fixed inset-0 bg-black/80",
                "aria-hidden": "true"
            }), E.jsx("div", {
                className: "fixed inset-0 flex items-center justify-center p-4",
                children: E.jsxs(uw.Panel, {
                    className: "w-full max-w-sm rounded-2xl bg-background border border-gray-800 p-6 text-left",
                    children: [E.jsxs("div", {
                        className: "flex items-center justify-between mb-6",
                        children: [E.jsx(uw.Title, {
                            className: "text-xl font-bold",
                            children: "Connect Wallet"
                        }), E.jsx("button", {
                            onClick: t,
                            className: "p-1 rounded-lg text-gray-400 hover:text-white hover:bg-white/5",
                            children: E.jsx(wx, {
                                className: "h-6 w-6"
                            })
                        })]
                    }), i && E.jsx("div", {
                        className: "mb-6 p-4 rounded-xl bg-red-500/10 border border-red-500/20",
                        children: E.jsx("p", {
                            className: "text-sm text-red-500",
                            children: i
                        })
                    }), E.jsxs("div", {
                        className: "space-y-4",
                        children: [E.jsxs(Ve.button, {
                            whileHover: {
                                scale: 1.02
                            },
                            whileTap: {
                                scale: .98
                            },
                            onClick: u,
                            disabled: a,
                            className: `w-full flex items-center space-x-4 p-4 rounded-xl bg-background-light border border-gray-800 hover:border-primary/20 transition-colors ${a?"opacity-50 cursor-not-allowed":""}`,
                            children: [E.jsx("img", {
                                src: "/images/metamask.svg",
                                alt: "MetaMask",
                                className: "h-8 w-8"
                            }), E.jsxs("div", {
                                className: "flex-1 text-left",
                                children: [E.jsx("h3", {
                                    className: "font-medium",
                                    children: "MetaMask"
                                }), E.jsx("p", {
                                    className: "text-sm text-gray-400",
                                    children: "Connect using browser wallet"
                                })]
                            }), a && E.jsx("div", {
                                className: "animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-white"
                            })]
                        }), E.jsxs(Ve.button, {
                            whileHover: {
                                scale: 1.02
                            },
                            whileTap: {
                                scale: .98
                            },
                            onClick: l,
                            disabled: a,
                            className: `w-full flex items-center space-x-4 p-4 rounded-xl bg-background-light border border-gray-800 hover:border-primary/20 transition-colors ${a?"opacity-50 cursor-not-allowed":""}`,
                            children: [E.jsx("div", {
                                className: "h-8 w-8 flex items-center justify-center",
                                children: E.jsx("svg", {
                                    width: "32",
                                    height: "32",
                                    viewBox: "0 0 32 32",
                                    fill: "none",
                                    xmlns: "http://www.w3.org/2000/svg",
                                    children: E.jsx("path", {
                                        d: "M9.58818 11.8556C13.1293 8.31442 18.8706 8.31442 22.4117 11.8556L22.8379 12.2818C23.015 12.4589 23.015 12.7459 22.8379 12.923L21.3801 14.3808C21.2915 14.4694 21.148 14.4694 21.0595 14.3808L20.473 13.7944C18.0026 11.324 13.9973 11.324 11.5269 13.7944L10.8989 14.4223C10.8104 14.5109 10.6669 14.5109 10.5783 14.4223L9.12053 12.9646C8.94339 12.7875 8.94339 12.5005 9.12053 12.3234L9.58818 11.8556ZM25.4722 14.916L26.7697 16.2135C26.9468 16.3906 26.9468 16.6776 26.7697 16.8547L20.8559 22.7685C20.6788 22.9457 20.3918 22.9457 20.2147 22.7685L16.0574 18.6113C16.0131 18.567 15.9409 18.567 15.8966 18.6113L11.7852 22.7685C11.6081 22.9457 11.3211 22.9457 11.144 22.7685L5.23026 16.8547C5.05312 16.6776 5.05312 16.3906 5.23026 16.2135L6.52774 14.916C6.70488 14.7389 6.99185 14.7389 7.16899 14.916L11.2804 19.0274C11.3247 19.0717 11.3969 19.0717 11.4412 19.0274L15.5985 14.8701C15.7756 14.693 16.0626 14.693 16.2397 14.8701L20.3971 19.0274C20.4414 19.0717 20.5135 19.0717 20.5578 19.0274L24.6692 14.916C24.8464 14.7389 25.1333 14.7389 25.3105 14.916Z",
                                        fill: "#3B99FC"
                                    })
                                })
                            }), E.jsxs("div", {
                                className: "flex-1 text-left",
                                children: [E.jsx("h3", {
                                    className: "font-medium",
                                    children: "WalletConnect"
                                }), E.jsx("p", {
                                    className: "text-sm text-gray-400",
                                    children: "Connect using mobile wallet"
                                })]
                            }), a && E.jsx("div", {
                                className: "animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-white"
                            })]
                        })]
                    }), E.jsxs("div", {
                        className: "mt-6 text-center text-sm text-gray-400",
                        children: [E.jsx("p", {
                            children: "By connecting your wallet, you agree to our"
                        }), E.jsxs("div", {
                            className: "space-x-1",
                            children: [E.jsx("button", {
                                className: "text-primary hover:text-primary-light",
                                children: "Terms of Service"
                            }), E.jsx("span", {
                                children: "and"
                            }), E.jsx("button", {
                                className: "text-primary hover:text-primary-light",
                                children: "Privacy Policy"
                            })]
                        })]
                    })]
                })
            })]
        })
    },
    bN = "46045361",
    wN = new Date("2025-01-24T00:00:00Z"),
    ZIe = {
        hidden: {
            opacity: 0
        },
        show: {
            opacity: 1,
            transition: {
                staggerChildren: .1
            }
        }
    },
    Ar = {
        hidden: {
            opacity: 0,
            y: 20
        },
        show: {
            opacity: 1,
            y: 0
        }
    },
    JIe = () => {
        const {
            isConnected: e
        } = Ov(), [t, n] = S.useState("all"), [r, i] = S.useState([]), [o, a] = S.useState(!0), [s, u] = S.useState(null), {
            price: l,
            error: c
        } = h8(), [f, d] = S.useState("0"), [h, m] = S.useState(0), [p, y] = S.useState(!1), g = Math.floor((new Date().getTime() - wN.getTime()) / (1e3 * 60 * 60 * 24));
        S.useEffect(() => {
            c && u(c)
        }, [c]);
        const b = [{
            label: "24H",
            value: "24h"
        }, {
            label: "7D",
            value: "7d"
        }, {
            label: "30D",
            value: "30d"
        }, {
            label: "ALL",
            value: "all"
        }];
        return S.useEffect(() => {
            (async () => {
                a(!0);
                try {
                    const A = new Kt,
                        w = A.utils.keccak256("NewDeposit(address,uint256)"),
                        x = A.utils.keccak256("Withdraw(address,uint256)"),
                        T = `https://api.bscscan.com/api?module=logs&action=getLogs&fromBlock=${bN}&toBlock=latest&address=${Os}&topic0=${w}&apikey=${pf}`.replace(/\s+/g, ""),
                        _ = `https://api.bscscan.com/api?module=logs&action=getLogs&fromBlock=${bN}&toBlock=latest&address=${Os}&topic0=${x}&apikey=${pf}`.replace(/\s+/g, ""),
                        [O, k] = await Promise.all([fetch(T), fetch(_)]);
                    if (!O.ok || !k.ok) throw new Error("Failed to fetch data");
                    const [I, M] = await Promise.all([O.json(), k.json()]);
                    if (I.status === "0" || M.status === "0") throw new Error(I.result || M.result || "Failed to fetch data");
                    const B = {},
                        L = {},
                        P = {};
                    let C = 0,
                        j = 0;
                    const N = new Set;
                    I.result && I.result.forEach(V => {
                        const Q = new Date(parseInt(V.timeStamp) * 1e3).toISOString().split("T")[0],
                            X = Number(A.utils.fromWei(A.utils.hexToNumberString(V.data), "ether"));
                        L[Q] = (L[Q] || 0) + X, C += X, B[Q] = C, j += X, N.add("0x" + V.topics[1].slice(26).toLowerCase())
                    }), M.result && M.result.forEach(V => {
                        const Q = new Date(parseInt(V.timeStamp) * 1e3).toISOString().split("T")[0],
                            X = Number(A.utils.fromWei(A.utils.hexToNumberString(V.data), "ether"));
                        P[Q] = (P[Q] || 0) + X, C -= X, B[Q] = C
                    }), d(j.toFixed(3)), m(N.size);
                    const D = new Set([...Object.keys(B), ...Object.keys(L), ...Object.keys(P)]),
                        $ = Array.from(D).map(V => {
                            var H, Q, X;
                            return {
                                timestamp: V,
                                value: Number(((H = B[V]) == null ? void 0 : H.toFixed(3)) || 0),
                                deposits: Number(((Q = L[V]) == null ? void 0 : Q.toFixed(3)) || 0),
                                withdraws: Number(((X = P[V]) == null ? void 0 : X.toFixed(3)) || 0),
                                usdValue: Number((B[V] * l).toFixed(2) || 0)
                            }
                        }).sort((V, H) => V.timestamp.localeCompare(H.timestamp));
                    i($), u(null), a(!1)
                } catch (A) {
                    console.error("Error fetching stats:", A), u("Failed to load stats"), a(!1)
                }
            })()
        }, [l]), E.jsxs(Ve.div, {
            variants: ZIe,
            initial: "hidden",
            animate: "show",
            className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pb-4 sm:pb-8 pt-6",
            children: [o && E.jsx(Ve.div, {
                variants: Ar,
                className: "flex justify-center items-center py-12",
                children: E.jsx("div", {
                    className: "animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary"
                })
            }), s && !o && E.jsxs(Ve.div, {
                variants: Ar,
                className: "bg-red-500/10 border border-red-500/20 rounded-lg p-4 mb-6",
                children: [E.jsx("p", {
                    className: "text-red-500",
                    children: s
                }), E.jsx("button", {
                    onClick: () => window.location.reload(),
                    className: "mt-2 text-sm text-red-500 hover:text-red-400",
                    children: "Retry"
                })]
            }), !o && !s && E.jsxs("div", {
                children: [E.jsxs("div", {
                    className: "grid grid-cols-2 sm:grid-cols-4 gap-4",
                    children: [E.jsx(Ve.div, {
                        variants: Ar,
                        className: "card bg-gradient-to-br from-background-light to-background p-4 hover:shadow-lg hover:shadow-primary/5 transition-all duration-300",
                        children: E.jsxs("div", {
                            className: "flex flex-col sm:flex-row sm:items-center sm:space-x-3",
                            children: [E.jsx(E3, {
                                className: "h-8 w-8 text-primary mb-2 sm:mb-0"
                            }), E.jsxs("div", {
                                children: [E.jsx("p", {
                                    className: "text-sm text-gray-400",
                                    children: "Total Deposits"
                                }), E.jsxs("p", {
                                    className: "text-lg sm:text-xl font-bold",
                                    children: [f, " BNB"]
                                }), E.jsxs("p", {
                                    className: "text-xs text-gray-400",
                                    children: ["$", (Number(f) * l).toFixed(2)]
                                })]
                            })]
                        })
                    }), E.jsx(Ve.div, {
                        variants: Ar,
                        className: "card bg-gradient-to-br from-background-light to-background p-4 hover:shadow-lg hover:shadow-primary/5 transition-all duration-300",
                        children: E.jsxs("div", {
                            className: "flex flex-col sm:flex-row sm:items-center sm:space-x-3",
                            children: [E.jsx(NG, {
                                className: "h-8 w-8 text-primary mb-2 sm:mb-0"
                            }), E.jsxs("div", {
                                children: [E.jsx("p", {
                                    className: "text-sm text-gray-400",
                                    children: "Days Active"
                                }), E.jsx("p", {
                                    className: "text-lg sm:text-xl font-bold",
                                    children: g
                                }), E.jsxs("p", {
                                    className: "text-xs text-gray-400",
                                    children: ["Since ", wN.toLocaleDateString()]
                                })]
                            })]
                        })
                    }), E.jsx(Ve.div, {
                        variants: Ar,
                        className: "card bg-gradient-to-br from-background-light to-background p-4 hover:shadow-lg hover:shadow-primary/5 transition-all duration-300",
                        children: E.jsxs("div", {
                            className: "flex flex-col sm:flex-row sm:items-center sm:space-x-3",
                            children: [E.jsx(WG, {
                                className: "h-8 w-8 text-primary mb-2 sm:mb-0"
                            }), E.jsxs("div", {
                                children: [E.jsx("p", {
                                    className: "text-sm text-gray-400",
                                    children: "Unique Wallets"
                                }), E.jsx("p", {
                                    className: "text-lg sm:text-xl font-bold",
                                    children: h
                                }), E.jsx("p", {
                                    className: "text-xs text-gray-400",
                                    children: "Active investors"
                                })]
                            })]
                        })
                    }), E.jsx(Ve.div, {
                        variants: Ar,
                        className: "card bg-gradient-to-br from-background-light to-background p-4 hover:shadow-lg hover:shadow-primary/5 transition-all duration-300",
                        children: E.jsxs("div", {
                            className: "flex flex-col sm:flex-row sm:items-center sm:space-x-3",
                            children: [E.jsx(wS, {
                                className: "h-8 w-8 text-primary mb-2 sm:mb-0"
                            }), E.jsxs("div", {
                                children: [E.jsx("p", {
                                    className: "text-sm text-gray-400",
                                    children: "BNB Price"
                                }), E.jsxs("p", {
                                    className: "text-lg sm:text-xl font-bold",
                                    children: ["$", l.toFixed(2)]
                                }), E.jsx("p", {
                                    className: "text-xs text-gray-400",
                                    children: "Current price"
                                })]
                            })]
                        })
                    })]
                }), !e && E.jsx("div", {
                    className: "mt-12",
                    children: E.jsx(cCe, {
                        onConnectClick: () => y(!0)
                    })
                }), e && E.jsxs("div", {
                    className: "mt-12 space-y-8",
                    children: [E.jsxs(Ve.div, {
                        variants: Ar,
                        className: "card bg-gradient-to-br from-background-light to-background p-4 sm:p-6 hover:shadow-lg hover:shadow-primary/5 transition-all duration-300 overflow-x-auto",
                        children: [E.jsxs("div", {
                            className: "flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 space-y-4 sm:space-y-0",
                            children: [E.jsx("h2", {
                                className: "text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-primary to-primary-light",
                                children: "Protocol Analytics"
                            }), E.jsx("div", {
                                className: "flex flex-wrap gap-2",
                                children: b.map(v => E.jsx("button", {
                                    onClick: () => n(v.value),
                                    className: `px-4 py-2 rounded-lg text-sm font-medium transition-all duration-300 ${t===v.value?"bg-primary text-white shadow-lg shadow-primary/20":"text-gray-400 hover:text-white hover:bg-primary/10"}`,
                                    children: v.label
                                }, v.value))
                            })]
                        }), E.jsx("div", {
                            className: "min-w-[300px]",
                            children: E.jsx(iCe, {
                                data: r,
                                title: "Total Value Locked Over Time",
                                valuePrefix: "BNB ",
                                isLoading: !1,
                                bnbPrice: l
                            })
                        })]
                    }), E.jsxs("div", {
                        className: "grid grid-cols-1 lg:grid-cols-2 gap-4 sm:gap-8",
                        children: [E.jsxs(Ve.div, {
                            variants: Ar,
                            className: "card bg-gradient-to-br from-background-light to-background p-4 sm:p-6 hover:shadow-lg hover:shadow-primary/5 transition-all duration-300",
                            children: [E.jsx("h2", {
                                className: "text-xl font-bold mb-4 bg-clip-text text-transparent bg-gradient-to-r from-primary to-primary-light",
                                children: "Deposit"
                            }), E.jsx(aCe, {})]
                        }), E.jsxs(Ve.div, {
                            variants: Ar,
                            className: "card bg-gradient-to-br from-background-light to-background p-4 sm:p-6 hover:shadow-lg hover:shadow-primary/5 transition-all duration-300",
                            children: [E.jsx("h2", {
                                className: "text-xl font-bold mb-4 bg-clip-text text-transparent bg-gradient-to-r from-primary to-primary-light",
                                children: "Withdraw"
                            }), E.jsx(sCe, {})]
                        })]
                    }), E.jsxs(Ve.div, {
                        variants: Ar,
                        className: "card bg-gradient-to-br from-background-light to-background p-4 sm:p-6 hover:shadow-lg hover:shadow-primary/5 transition-all duration-300",
                        children: [E.jsx("h2", {
                            className: "text-xl font-bold mb-4 bg-clip-text text-transparent bg-gradient-to-r from-primary to-primary-light",
                            children: "Recent Activity"
                        }), E.jsx(pCe, {})]
                    }), E.jsx(Ve.div, {
                        variants: Ar,
                        className: "card bg-gradient-to-br from-background-light to-background p-4 sm:p-6 hover:shadow-lg hover:shadow-primary/5 transition-all duration-300",
                        children: E.jsx(oCe, {})
                    })]
                })]
            }), E.jsx(N8, {
                isOpen: p,
                onClose: () => y(!1)
            })]
        })
    },
    eMe = () => {
        const e = [{
            title: "Protocol Overview",
            icon: E.jsx(wS, {
                className: "h-8 w-8"
            }),
            content: `
        xJar Protocol is a decentralized investment platform built on the BNB Chain. The protocol offers:
        • 1% daily ROI (365% APY)
        • 5-level referral system
        • Transparent and verifiable smart contract
        • No admin keys or backdoors
        • Immutable code
      `
        }, {
            title: "How It Works",
            icon: E.jsx(E3, {
                className: "h-8 w-8"
            }),
            content: `
        1. Connect your wallet and deposit BNB
        2. Earn 1% daily returns on your deposit
        3. Compound or withdraw your earnings anytime
        4. Share your referral link to earn additional rewards
        
        The protocol automatically calculates and distributes rewards every 24 hours. All transactions are processed through our verified smart contract on the BNB Chain.

        Note: Both ROI earnings and referral rewards are automatically added to your withdrawable balance. You can withdraw all your earnings (including referral bonuses) at once using the Withdraw function.
      `
        }, {
            title: "Referral System",
            icon: E.jsx(VG, {
                className: "h-8 w-8"
            }),
            content: `
        Our 5-level referral system rewards community growth:
        • Level 1: 5% of referral's deposit
        • Level 2: 3% of referral's deposit
        • Level 3: 2% of referral's deposit
        • Level 4: 1% of referral's deposit
        • Level 5: 0.5% of referral's deposit

        Referral rewards are:
        • Paid instantly in BNB
        • Added to your withdrawable balance automatically
        • Can be withdrawn together with your ROI earnings
        • Not subject to any additional fees
        • Available as soon as your referral makes a deposit
      `
        }, {
            title: "Security",
            icon: E.jsx(Gf, {
                className: "h-8 w-8"
            }),
            content: `
        Security Measures:
        • Smart contract is verified on BscScan
        • Code is immutable and cannot be modified
        • No admin functions or backdoors
        • All transactions are public and verifiable
        • Self-audited for common vulnerabilities
        
        Contract Address: 0x8067b825ae7c013edacbddcb8449cabc3f07488b
      `
        }, {
            title: "Technical Details",
            icon: E.jsx(xS, {
                className: "h-8 w-8"
            }),
            content: `
        Smart Contract Specifications:
        • Network: BNB Chain (BSC)
        • Language: Solidity
        • Compiler: v0.8.19
        • Optimization: Enabled
        • Runs: 200
        
        Key Functions:
        • deposit(address _upline) - Make a deposit
        • withdraw() - Withdraw all available earnings (ROI + referral rewards)
        • userInfo(address _addr) - View user statistics
        • contractInfo() - View protocol statistics
      `
        }];
        return E.jsxs("div", {
            className: "max-w-4xl mx-auto py-8 px-4 space-y-8",
            children: [E.jsxs("div", {
                className: "text-center mb-12",
                children: [E.jsx("h1", {
                    className: "text-4xl font-bold mb-4",
                    children: "Documentation"
                }), E.jsx("p", {
                    className: "text-gray-400",
                    children: "Learn how xJar Protocol works and how to maximize your earnings"
                })]
            }), E.jsx("div", {
                className: "space-y-8",
                children: e.map((t, n) => E.jsxs("div", {
                    className: "card",
                    children: [E.jsxs("div", {
                        className: "flex items-center space-x-4 mb-4",
                        children: [E.jsx("div", {
                            className: "text-primary",
                            children: t.icon
                        }), E.jsx("h2", {
                            className: "text-2xl font-bold",
                            children: t.title
                        })]
                    }), E.jsx("div", {
                        className: "prose prose-invert",
                        children: t.content.split(`
`).map((r, i) => E.jsx("p", {
                            className: "text-gray-300 whitespace-pre-line",
                            children: r
                        }, i))
                    })]
                }, n))
            }), E.jsxs("div", {
                className: "card mt-12",
                children: [E.jsx("h2", {
                    className: "text-2xl font-bold mb-4",
                    children: "Need Help?"
                }), E.jsx("p", {
                    className: "text-gray-400 mb-4",
                    children: "If you have any questions or need assistance, join our community:"
                }), E.jsx("div", {
                    children: E.jsx("a", {
                        href: "https://t.me/xjarprotocol",
                        target: "_blank",
                        rel: "noopener noreferrer",
                        className: "btn-outline inline-flex items-center",
                        children: "Join Telegram Community"
                    })
                })]
            })]
        })
    },
    tMe = () => {
        const e = [{
                title: "Contract Overview",
                content: `
        Contract Name: xJar Protocol
        Contract Address: 0x8067b825ae7c013edacbddcb8449cabc3f07488b
        Network: BNB Chain (BSC)
        Language: Solidity v0.8.19
        Compiler Settings: Optimized, 200 runs
        
        This self-audit report documents our security analysis and best practices implementation.
      `
            }, {
                title: "Key Security Features",
                items: [{
                    status: "pass",
                    name: "No Admin Functions",
                    description: "Contract has no owner or admin functions that could alter its behavior"
                }, {
                    status: "pass",
                    name: "Immutable Code",
                    description: "Contract cannot be upgraded or modified after deployment"
                }, {
                    status: "pass",
                    name: "Verified Source Code",
                    description: "Contract is verified on BscScan for public audit"
                }, {
                    status: "pass",
                    name: "Deterministic Rewards",
                    description: "All reward calculations are transparent and verifiable"
                }]
            }, {
                title: "Security Analysis",
                items: [{
                    status: "pass",
                    name: "Reentrancy Protection",
                    description: "Functions use checks-effects-interactions pattern"
                }, {
                    status: "pass",
                    name: "Integer Overflow/Underflow",
                    description: "Protected by Solidity 0.8.x built-in checks"
                }, {
                    status: "pass",
                    name: "Timestamp Manipulation",
                    description: "Time-based calculations are safe from minor manipulations"
                }, {
                    status: "info",
                    name: "Block Gas Limit",
                    description: "Large referral structures might require multiple transactions"
                }]
            }, {
                title: "Investment Security",
                items: [{
                    status: "pass",
                    name: "Deposit Protection",
                    description: "Minimum deposit enforced, maximum limited by contract balance"
                }, {
                    status: "pass",
                    name: "Withdrawal Security",
                    description: "Users can only withdraw their available balance"
                }, {
                    status: "info",
                    name: "ROI Sustainability",
                    description: "Returns depend on continuous contract activity"
                }, {
                    status: "warning",
                    name: "Investment Risk",
                    description: "As with any DeFi protocol, invest only what you can afford to lose"
                }]
            }],
            t = n => {
                switch (n) {
                    case "pass":
                        return E.jsx(_G, {
                            className: "h-6 w-6 text-green-500"
                        });
                    case "warning":
                        return E.jsx(DG, {
                            className: "h-6 w-6 text-yellow-500"
                        });
                    case "fail":
                        return E.jsx(qG, {
                            className: "h-6 w-6 text-red-500"
                        });
                    default:
                        return E.jsx(Gf, {
                            className: "h-6 w-6 text-blue-500"
                        })
                }
            };
        return E.jsxs("div", {
            className: "max-w-4xl mx-auto py-8 px-4 space-y-8",
            children: [E.jsxs("div", {
                className: "text-center mb-12",
                children: [E.jsx("h1", {
                    className: "text-4xl font-bold mb-4",
                    children: "Security Audit Report"
                }), E.jsx("p", {
                    className: "text-gray-400 mb-6",
                    children: "Comprehensive analysis of xJar Protocol's smart contract security"
                }), E.jsxs("div", {
                    className: "card bg-gradient-to-br from-background via-background to-green-950/30 border border-green-500/30 p-8 mb-8 relative overflow-hidden",
                    children: [E.jsx("div", {
                        className: "absolute top-0 right-0 w-64 h-64 bg-green-500/5 rounded-full blur-3xl transform translate-x-1/2 -translate-y-1/2"
                    }), E.jsxs("div", {
                        className: "relative z-10",
                        children: [E.jsxs("div", {
                            className: "flex items-start justify-between mb-6",
                            children: [E.jsxs("div", {
                                children: [E.jsx("h2", {
                                    className: "text-3xl font-bold text-green-400 mb-2",
                                    children: "Haze Crypto Security Audit"
                                }), E.jsx("p", {
                                    className: "text-gray-400 text-lg",
                                    children: "Independent Smart Contract Security Assessment"
                                })]
                            }), E.jsx("div", {
                                className: "bg-green-500/10 rounded-full p-3 backdrop-blur-sm",
                                children: E.jsx(Gf, {
                                    className: "h-10 w-10 text-green-400"
                                })
                            })]
                        }), E.jsx("p", {
                            className: "text-gray-300 text-lg mb-6 leading-relaxed max-w-3xl",
                            children: "Our smart contract has been thoroughly audited by Haze Crypto, a leading blockchain security firm. The audit confirms the security, efficiency, and reliability of our protocol's implementation."
                        }), E.jsxs("a", {
                            href: "https://hazecrypto.net/audit/xJarProtocol",
                            target: "_blank",
                            rel: "noopener noreferrer",
                            className: "inline-flex items-center space-x-3 bg-green-500/10 hover:bg-green-500/20 text-green-400 px-6 py-3 rounded-lg transition-all duration-200 backdrop-blur-sm hover:scale-105 transform",
                            children: [E.jsx("span", {
                                className: "text-lg font-semibold",
                                children: "View Full Audit Report"
                            }), E.jsx("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                className: "h-6 w-6",
                                viewBox: "0 0 20 20",
                                fill: "currentColor",
                                children: E.jsx("path", {
                                    fillRule: "evenodd",
                                    d: "M10.293 3.293a1 1 0 011.414 0l6 6a1 1 0 010 1.414l-6 6a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-4.293-4.293a1 1 0 010-1.414z",
                                    clipRule: "evenodd"
                                })
                            })]
                        })]
                    })]
                })]
            }), E.jsx("div", {
                className: "space-y-8",
                children: e.map((n, r) => E.jsxs("div", {
                    className: "card",
                    children: [E.jsx("h2", {
                        className: "text-2xl font-bold mb-4",
                        children: n.title
                    }), n.content && E.jsx("div", {
                        className: "prose prose-invert mb-4",
                        children: n.content.split(`
`).map((i, o) => E.jsx("p", {
                            className: "text-gray-300 whitespace-pre-line",
                            children: i
                        }, o))
                    }), n.items && E.jsx("div", {
                        className: "space-y-4",
                        children: n.items.map((i, o) => E.jsxs("div", {
                            className: "flex items-start space-x-4 bg-background rounded-lg p-4",
                            children: [E.jsx("div", {
                                className: "flex-shrink-0 mt-1",
                                children: t(i.status)
                            }), E.jsxs("div", {
                                children: [E.jsx("h3", {
                                    className: "font-semibold mb-1",
                                    children: i.name
                                }), E.jsx("p", {
                                    className: "text-gray-400",
                                    children: i.description
                                })]
                            })]
                        }, o))
                    })]
                }, r))
            }), E.jsxs("div", {
                className: "card mt-12",
                children: [E.jsx("h2", {
                    className: "text-2xl font-bold mb-4",
                    children: "Disclaimer"
                }), E.jsx("p", {
                    className: "text-gray-400",
                    children: "This self-audit report is provided for informational purposes only. While we strive to ensure the security of our smart contract, no code is completely risk-free. Users should conduct their own research and understand the risks involved before participating in the protocol."
                })]
            })]
        })
    },
    nMe = () => E.jsxs("div", {
        className: "max-w-4xl mx-auto py-8 px-4 space-y-8",
        children: [E.jsxs("div", {
            className: "text-center mb-12",
            children: [E.jsx("h1", {
                className: "text-4xl font-bold mb-4",
                children: "Frequently Asked Questions"
            }), E.jsx("p", {
                className: "text-gray-400 mb-6",
                children: "Common questions about xJar Protocol and how it works"
            })]
        }), E.jsxs("div", {
            className: "card bg-gradient-to-br from-background via-background to-primary-950/30 border border-primary/30 p-8 relative overflow-hidden",
            children: [E.jsx("div", {
                className: "absolute top-0 right-0 w-64 h-64 bg-primary/5 rounded-full blur-3xl transform translate-x-1/2 -translate-y-1/2"
            }), E.jsx("div", {
                className: "relative z-10",
                children: E.jsx(gCe, {})
            })]
        })]
    }),
    rMe = () => E.jsxs("div", {
        className: "max-w-4xl mx-auto py-8 px-4 space-y-8",
        children: [E.jsxs("div", {
            className: "text-center mb-12",
            children: [E.jsx("h1", {
                className: "text-4xl font-bold mb-4",
                children: "Referral Program"
            }), E.jsx("p", {
                className: "text-gray-400 mb-6",
                children: "Earn rewards by inviting others to join xJar Protocol"
            })]
        }), E.jsxs("div", {
            className: "card bg-gradient-to-br from-background via-background to-primary-950/30 border border-primary/30 p-8 relative overflow-hidden",
            children: [E.jsx("div", {
                className: "absolute top-0 right-0 w-64 h-64 bg-primary/5 rounded-full blur-3xl transform translate-x-1/2 -translate-y-1/2"
            }), E.jsx("div", {
                className: "relative z-10",
                children: E.jsx(uCe, {})
            })]
        })]
    }),
    iMe = S.createContext(void 0),
    oMe = ({
        children: e
    }) => {
        const [t, n] = S.useState("deposit");
        return E.jsx(iMe.Provider, {
            value: {
                activeTab: t,
                setActiveTab: n
            },
            children: e
        })
    };

function aMe() {
    const [e, t] = S.useState(!1);
    return E.jsx(Fie, {
        children: E.jsx(oMe, {
            children: E.jsx(k9, {
                children: E.jsxs("div", {
                    className: "flex flex-col min-h-screen bg-background text-white",
                    children: [E.jsx(Uie, {
                        onConnectClick: () => t(!0)
                    }), E.jsx(V9, {
                        mode: "wait",
                        children: E.jsx(Ve.main, {
                            initial: {
                                opacity: 0,
                                y: 20
                            },
                            animate: {
                                opacity: 1,
                                y: 0
                            },
                            exit: {
                                opacity: 0,
                                y: -20
                            },
                            transition: {
                                duration: .2
                            },
                            className: "flex-grow",
                            children: E.jsxs(o9, {
                                children: [E.jsx(Zs, {
                                    path: "/",
                                    element: E.jsx(JIe, {})
                                }), E.jsx(Zs, {
                                    path: "/docs",
                                    element: E.jsx(eMe, {})
                                }), E.jsx(Zs, {
                                    path: "/audit",
                                    element: E.jsx(tMe, {})
                                }), E.jsx(Zs, {
                                    path: "/faq",
                                    element: E.jsx(nMe, {})
                                }), E.jsx(Zs, {
                                    path: "/referral",
                                    element: E.jsx(rMe, {})
                                })]
                            })
                        })
                    }), E.jsx(Hie, {}), E.jsx(N8, {
                        isOpen: e,
                        onClose: () => t(!1)
                    })]
                })
            })
        })
    })
}
lw.createRoot(document.getElementById("root")).render(E.jsx(R.StrictMode, {
    children: E.jsx(aMe, {})
}));
export {
    XG as _, uMe as a, sMe as c, Fe as g, Aee as p
};